var relearn_searchindex = [
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "1. Introduction √† Visual Studio 2022 Qu‚Äôest-ce que Visual Studio ? Visual Studio 2022 est l‚ÄôEnvironnement de D√©veloppement Int√©gr√© (IDE) de Microsoft d√©di√© au d√©veloppement d‚Äôapplications sur les plateformes .NET. Il offre un ensemble complet d‚Äôoutils pour coder, tester, d√©boguer, d√©ployer et collaborer efficacement.\nLes √©ditions de Visual Studio 2022 √âdition Public cible Community Gratuit : √©tudiants, d√©veloppeurs open source et particuliers. Professional D√©veloppeurs professionnels et petites √©quipes. Enterprise Grandes √©quipes : outils avanc√©s de test, performance et int√©gration continue. 2. Installation et Configuration √âtapes d‚Äôinstallation T√©l√©chargement : Se rendre sur visualstudio.microsoft.com/fr pour choisir sa version. S√©lection des charges de travail : Pour le d√©veloppement C# (Windows Forms ou WPF), il est imp√©ratif de s√©lectionner .NET Desktop Development. Si vous disposez d√©j√† de Visual Studio, vous pouvez ajouter la charge de travail de d√©veloppement de bureau .NET comme suit :\nLancez Visual Studio Installer. Si vous y √™tes invit√©, autorisez le programme d‚Äôinstallation √† se mettre √† jour. Si une mise √† jour pour Visual Studio est disponible, un bouton Mettre √† jour s‚Äôaffiche. S√©lectionnez-la pour la mettre √† jour avant de modifier l‚Äôinstallation. Recherchez votre installation de Visual Studio et s√©lectionnez le bouton Modifier . S‚Äôil n‚Äôest pas d√©j√† s√©lectionn√©, s√©lectionnez la charge de travail de d√©veloppement du bureau .NET , puis s√©lectionnez le bouton Modifier . Sinon, fermez simplement la fen√™tre de dialogue. Personnalisation L‚Äôinterface est enti√®rement personnalisable : th√®mes, raccourcis clavier et extensions. Pour un environnement complet, il est recommand√© d‚Äôinstaller Git pour la gestion de versions.\nCaution Note sur l‚ÄôIA : Des outils comme GitHub Copilot sont disponibles, mais ils ne doivent pas √™tre utilis√©s dans le cadre de ce cours afin de ne pas nuire √† l‚Äôapprentissage des concepts fondamentaux.\n3. Fonctionnalit√©s principales Source : https://learn.microsoft.com/fr-fr/visualstudio/get-started/media/visual-studio-overview.png?view=vs-2022\nL‚Äô√©diteur de texte L‚Äô√©diteur de texte de Visual Studio est un puissant outil permettant de saisir le code de l‚Äôapplication.\nVoici quelques fonctionnalit√©s de l‚Äô√©diteur de texte:\nLes mots-cl√©s et les types sont color√©s pour faciliter la lecture et la compr√©hension du code. La qualit√© du document en cours de visualisation est annonc√©e gr√¢ce √† l‚Äôic√¥ne en bas du document pour indiquer s‚Äôil contient des suggestions, des avertissements ou des erreurs. L‚Äôintellisense permet d‚Äôafficher les classes et leurs membres en rapport avec le code saisi ainsi que les param√®tres et les surcharges possibles pour les m√©thodes L‚Äôintellicode vous permet d‚Äôassurer la pr√©cision et la coh√©rence de l‚Äôex√©cution du code qui peut remplir une ligne enti√®re √† la fois. L‚ÄôIA d√©tecte votre contexte de code, notamment les noms de variables, les fonctions et le type de code que vous √©crivez, pour vous donner les meilleures suggestions. Encore mieux¬†: IntelliCode s‚Äôex√©cute sur votre ordinateur, ce qui garantit que votre code priv√© reste priv√©. Autres outils de Visual Studio Code 2022 Gestion de builds : Cr√©ation de configurations adapt√©es aux environnements de d√©veloppement ou de production.\nD√©bogage et tests : D√©bogueur int√©gr√© pour l‚Äôex√©cution pas √† pas et outils de tests unitaires (NUnit, xUnit). Le mode d√©bogage peut √™tre lanc√© en allant sur D√©boguer -\u003e D√©marrer le d√©bogage ou juste F5\nCollaboration : Int√©gration native de Git/GitHub et support de Live Share pour le d√©veloppement collaboratif en temps r√©el.\n4. Exploration de l‚Äôinterface Lors du lancement, la fen√™tre de d√©marrage propose quatre options principales:\nClone a repository : R√©cup√©rer du code depuis GitHub ou Azure DevOps. Open a project or solution : Ouvrir un fichier projet local. Open a local folder : Naviguer et √©diter du code dans n‚Äôimporte quel dossier. Create a new project : Commencer √† partir d‚Äôun mod√®le pr√©d√©fini. ` 5. Projets et Solutions Cr√©er votre solution et projet D√©marrez Visual Studio et s√©lectionnez Cr√©er un projet. Dans la fen√™tre Cr√©er un projet, recherchez et s√©lectionnez un mod√®le d‚Äôapplication console C#, puis s√©lectionnez Suivant.. Configurez votre projet (nom, emplacement). √Ä cette √©tape, vous pouvez d√©cidez de placer la solution .sln et le projet .csproj. Puis s√©lectionnez Suivant. Dans la fen√™tre Informations suppl√©mentaires , v√©rifiez que .NET 8.0 appara√Æt dans le menu d√©roulant Framework, puis s√©lectionnez Cr√©er. Diff√©rences fondamentales entre projet et solution Un projet est un ensemble de fichiers qui seront compil√©s en un seul assemblage. Une solution est un ensemble d‚Äôun ou plusieurs projets. Un projet d‚Äôapplication ex√©cutable poss√®de un point d‚Äôentr√©e. C‚Äôest la m√©thode Main. Cette m√©thode doit √™tre publique et statique en utilisant les mots-cl√©s public et static, qui sp√©cifient respectivement que la m√©thode est accessible depuis l‚Äôapplication et en dehors, que la m√©thode est globale et que la classe n‚Äôa pas besoin d‚Äô√™tre instanci√©e pour pouvoir l‚Äôappeler. Une solution poss√®de aussi un projet de d√©marrage. Ce projet est identifiable dans l‚Äôexplorateur de solutions, car son nom est en gras. Pour modifier cette propri√©t√©, un clic droit sur le projet permet de s√©lectionner D√©finir en tant que projet de d√©marrage dans le menu contextuel. Le point d‚Äôentr√©e (M√©thode Main) Un projet ex√©cutable poss√®de une m√©thode Main. Elle doit √™tre d√©finie comme suit:\npublic : Accessible depuis l‚Äôapplication et l‚Äôext√©rieur. static : La m√©thode est globale et la classe n‚Äôa pas besoin d‚Äô√™tre instanci√©e pour l‚Äôappeler. Projet de d√©marrage : Dans une solution, le projet de d√©marrage appara√Æt en gras dans l‚Äôexplorateur de solutions. On peut le modifier via un clic droit -\u003e D√©finir en tant que projet de d√©marrage.\n6. Ex√©cution et D√©bogage Lancement : Cliquez sur la fl√®che verte ou appuyez sur F5. Points d‚Äôarr√™t (Breakpoints) : Permettent d‚Äôinterrompre l‚Äôex√©cution pour examiner l‚Äô√©tat des variables √† des endroits pr√©cis.\nLes diff√©rents fichiers compris dans la solution Le fichier program.cs qui contient le code qui est compil√© et ex√©cut√© Quand on fait un clic droit sur le projet, ensuite on choisit ‚ÄúOuvrir le dossier dans l‚ÄôExplorateur de fichiers‚Äù,¬†on peut voir le fichier du projet dont l‚Äôextension est csproj. Un niveau plus haut, on voit le fichier de la solution dont l‚Äôextension est sln. Plus bas, dans le dossier bin -\u003e Debug -\u003e net8.0, on peut voir le fichier ex√©cutable .exe qui est l‚Äôapplication qui vient d‚Äô√™tre cr√©√©e. Si on double-clique sur l‚Äôex√©cutable, on ouvre l‚Äôapplication. On peut aussi ouvrir la ligne de commande cmd et ex√©cuter l‚Äôapplication en¬†tapant le nom de l‚Äôex√©cutable. Ressources suppl√©mentaires Documentation Visual Studio Documentation IntelliCode",
    "description": "1. Introduction √† Visual Studio 2022 Qu‚Äôest-ce que Visual Studio ? Visual Studio 2022 est l‚ÄôEnvironnement de D√©veloppement Int√©gr√© (IDE) de Microsoft d√©di√© au d√©veloppement d‚Äôapplications sur les plateformes .NET. Il offre un ensemble complet d‚Äôoutils pour coder, tester, d√©boguer, d√©ployer et collaborer efficacement.",
    "tags": [],
    "title": "Introduction √† Visual Studio 2022",
    "uri": "/420-413/intro/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Introduction √† .NET .NET : Un √©cosyst√®me pour le d√©veloppement d ºapplications qui prend en charge plusieurs langages, dont C#, F#, et VB.NET. Il fournit des outils, des biblioth√®ques, et un environnement d ºex√©cution pour faciliter le d√©veloppement d‚Äôapplications.\nLa plateforme .NET La plateforme .NET repose sur une architecture en couches qui permet l‚Äôex√©cution de code √©crit dans diff√©rents langages (C#, F#, VB.NET) de mani√®re unifi√©e et performante.\n1. Les composants fondamentaux L‚Äôarchitecture s‚Äôappuie principalement sur deux piliers :\nCLR (Common Language Runtime) : C‚Äôest le moteur/coeur d‚Äôex√©cution. Il g√®re l‚Äôex√©cution des programmes, la m√©moire (Garbage Collector), la s√©curit√© et la compilation √† la vol√©e (JIT). Moteur d‚Äôex√©cution : Le CLR est responsable de charger et ex√©cuter des programmes .NET et assure la gestion de la m√©moire, la s√©curit√©, et la gestion des exceptions. Conversion IL -\u003e Code natif : Le code C# est d‚Äôabord compil√© en Intermediate Language (IL), puis converti en code machine natif par le CLR. Gestion de la m√©moire : Le CLR g√®re automatiquement la m√©moire via la garbage collection (collecte des objets non utilis√©s). S√©curit√© : Le CLR applique des r√®gles de s√©curit√© pour ex√©cuter les programmes de mani√®re s√©curis√©e. BCL (Base Class Library) : Une immense biblioth√®que de classes r√©utilisables qui fournit les fonctionnalit√©s de base (gestion des fichiers, r√©seau, dates, collections, etc.). 2. Le M√©canisme de Compilation du Code Source C# Code source C# : Lorsqu‚Äôun programme C# est √©crit, le code source est d‚Äôabord compil√© en IL (Intermediate Language). Le compilateur C# s‚Äôappelle Roslyn Le CIL (Common Intermediate Language) : Le compilateur ne cr√©e pas tout de suite un programme fini. Il traduit votre C# en un langage interm√©diaire (autrefois appel√© MSIL). Pourquoi ? Parce que ce langage est universel au sein de l‚Äô√©cosyst√®me .NET. Que vous √©criviez en C#, F# ou VB.NET, tout finit en CIL. Cela permet √† diff√©rents langages de fonctionner ensemble.\nEn plus du code IL, le compilateur g√©n√®re des informations cruciales :\nM√©tadonn√©es : Une description de chaque classe, m√©thode et variable d√©finie dans votre code.\nManifeste : La ‚Äúcarte d‚Äôidentit√©‚Äù du programme (nom, version, biblioth√®ques externes n√©cessaires).\nAssembly : Le code et les ressources sont stock√©s dans un fichier assembly (g√©n√©ralement avec l‚Äôextension .dll ou .exe). Un assembly contient un manifeste qui d√©crit ses types, sa version, et ses m√©tadonn√©es. Compilation Just-In-Time (JIT) : Lorsque le programme est ex√©cut√©, le CLR charge l ºassembly, et le code IL est compil√© en code natif via la compilation JIT. Particularit√© : Le JIT ne compile que les morceaux de code au fur et √† mesure qu‚Äôils sont appel√©s (‚ÄúJuste √† temps‚Äù). Si une fonction n‚Äôest jamais utilis√©e pendant une session, elle n‚Äôest jamais compil√©e en code machine, ce qui √©conomise des ressources.",
    "description": "Introduction √† .NET .NET : Un √©cosyst√®me pour le d√©veloppement d ºapplications qui prend en charge plusieurs langages, dont C#, F#, et VB.NET. Il fournit des outils, des biblioth√®ques, et un environnement d ºex√©cution pour faciliter le d√©veloppement d‚Äôapplications.\nLa plateforme .NET La plateforme .NET repose sur une architecture en couches qui permet l‚Äôex√©cution de code √©crit dans diff√©rents langages (C#, F#, VB.NET) de mani√®re unifi√©e et performante.",
    "tags": [],
    "title": "Architecture .NET",
    "uri": "/420-413/architecture/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Introduction √† C# C# (prononc√© ‚ÄúC Sharp‚Äù) est un langage de programmation moderne, orient√© objet et fortement typ√©. C# est d√©velopp√© par Microsoft en 2000 et est principalement utilis√© pour le d√©veloppement d ºapplications sous la plateforme .NET. La syntaxe de C# est influenc√©e par C, C++ et Java, mais elle pr√©sente certaines sp√©cificit√©s qui lui sont propres.\nC# est un langage sensible √† la casse.\nL‚Äôextension des fichiers C# est .cs\nCaract√©ristiques principales: Orient√© objet: tout est bas√© sur des classes et des objets Typ√© statiquement: les types de variables doivent √™tre d√©clar√©s G√©r√©: la m√©moire est g√©r√©e automatiquement par le garbage collector Polyvalent: applications desktop, web, mobile, jeux vid√©o (Unity) Moderne: syntaxe claire et √©volutive Domaines d‚Äôutilisation: Avec C#, on peut cr√©er :\nüñ•Ô∏è des applications console\nüñ•Ô∏è Applications Windows (WPF, WinForms)\nüåê des sites Web et des API\nüì± des applications mobiles\nüéÆ des jeux (Unity utilise C#)\nüëâ Bref : un langage, plusieurs carri√®res possibles.\nStructure de base d‚Äôun programme C# Un programme C# est compos√© de plusieurs √©l√©ments cl√©s : l‚Äôespace de noms (namespace), les classes, et la m√©thode Main, qui est le point d‚Äôentr√©e de l‚Äôapplication.\nusing System; // Importation des biblioth√®ques namespace MyProgram // D√©finition de l'espace de noms { class Program // D√©finition de la classe { static void Main(string[] args) // M√©thode Main, point d'entr√©e du programme { Console.WriteLine(\"Hello, World!\"); // Affichage d'un message et aller √† la prochaine ligne } } } using : Utilis√© pour importer des biblioth√®ques externes (par exemple, System contient des classes utiles comme Console). namespace : Un conteneur logique pour les classes et autres types. En d‚Äôautres termes, c‚Äôest une fa√ßon d‚Äôorganiser le code. Pense √† un namespace comme : un dossier une section ou un casier pour ranger des classes. Sans namespaces, ce serait le chaos total üò±. Imagine des milliers de classes, toutes avec des noms simples comme Console, List, Button. Sans namespace : üí• conflits de noms üí• code impossible √† lire üí• d√©veloppeurs en d√©pression class : Un mod√®le pour cr√©er des objets. Tout programme C# doit contenir au moins une classe. Main : La m√©thode Main est le point de d√©part d‚Äôune application C#. C‚Äôest ici que l‚Äôex√©cution du programme commence. Les identifiants ou les identificateurs Ce sont les noms donn√©s aux classes et √† leurs membres. Un identifiant doit √™tre compos√© d‚Äôun seul mot commen√ßant par une lettre ou un caract√®re underscore (_). Mais, il peut contenir aussi un chiffre qui ne doit pas se placer au d√©but de l‚Äôidentifiant. Ils peuvent √™tre compos√©s de lettres majuscules et minuscules, mais le langage C# √©tant sensible √† la casse, les majuscules et minuscules doivent √™tre respect√©es pour faire r√©f√©rence au bon identifiant Par exemple: les identifiants suivants ne sont pas les m√™mes monIdentifiant et MonIdentifiant. Les mots-cl√©s Les mots cl√©s sont des noms r√©serv√©s par le langage C#, qui ont des significations sp√©cifiques pour le compilateur. Ils ne peuvent pas √™tre utilis√©s comme identifiants dans votre programme, sauf s‚Äôils incluent @ comme pr√©fixe. Par exemple, @if est un identifiant valide, mais pas if, car if est un mot cl√©.\nPar d√©faut, les mots-cl√©s sont color√©s en bleu dans l‚Äô√©diteur de Visual Studio. Le caract√®re @ peut √©galement pr√©fixer des identifiants qui n‚Äôont aucun conflit avec les mots-cl√©s. Ainsi @monIdentifiant et monIdentifiant seront interpr√©t√©s de la m√™me mani√®re (la m√™me variable). Les commentaires C# prend en charge deux formes diff√©rentes de commentaires:\nLes commentaires sur une seule ligne commencent par // et se terminent √† la fin de cette ligne de code. Les commentaires multilignes commencent par /* et se terminent par */ Le commentaire sur plusieurs lignes peut √©galement √™tre utilis√© pour ins√©rer du texte dans une ligne de code. √âtant donn√© que ces commentaires ont un caract√®re de fermeture explicite, vous pouvez inclure plus de code ex√©cutable apr√®s le commentaire:\npublic static int additioner(int nombre1, int nombre2) { return nombre1 /* premi√®re op√©rande */ + nombre2 /* deuxi√®me op√©rande*/; } Le commentaire sur une seule ligne peut appara√Ætre apr√®s le code ex√©cutable sur la m√™me ligne. Le commentaire se termine √† la fin de la ligne de texte :\nfloat temperature = 34.4f; // Si nous n'ajoutons pas le f ou le F apr√®s la valeur, nous obtiendrons une erreur",
    "description": "Introduction √† C# C# (prononc√© ‚ÄúC Sharp‚Äù) est un langage de programmation moderne, orient√© objet et fortement typ√©. C# est d√©velopp√© par Microsoft en 2000 et est principalement utilis√© pour le d√©veloppement d ºapplications sous la plateforme .NET. La syntaxe de C# est influenc√©e par C, C++ et Java, mais elle pr√©sente certaines sp√©cificit√©s qui lui sont propres.",
    "tags": [],
    "title": "Introduction et syntaxe du langage C#",
    "uri": "/420-413/intro_syntaxe_c_sharp/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "1. D√©claration de variables et types de donn√©es C# est un langage fortement typ√©, ce qui signifie que chaque variable doit √™tre d√©clar√©e avec un type sp√©cifique. Voici quelques types de base :\nint age = 25; // Entier double price = 19.99; // Nombre √† virgule flottante char grade = 'A'; // Caract√®re unique string name = \"John\"; // Cha√Æne de caract√®res bool isActive = true; // Bool√©en (vrai ou faux) Une variable peut √™tre d√©clar√©e et initialis√©e avec la m√™me instruction.\nstring salutation = \"Bonjour tout le monde!\";\nIl est √©galement possible de d√©clarer et d‚Äôinitier plusieurs variables en une seule instruction, √† la condition qu‚Äôelles soient du m√™me type. Dans ce cas, les variables sont s√©par√©es par une virgule. bool joyeux = true, content = true;\nUne variable peut √©galement √™tre marqu√©e par le mot-cl√© const qui sp√©cifie que la valeur de la variable ne peut pas √™tre modifi√©e pendant l‚Äôex√©cution. C‚Äôest une variable en lecture seule. const double pi = 3.14;\nL‚Äôinf√©rence de type (var) : Le mot-cl√© var permet au compilateur de deviner le type de la variable lors de l‚Äôinitialisation. Attention : le type reste fixe apr√®s l‚Äôassignation.\nvar total = 15.5; // Le compilateur d√©duit 'double'\nüí° Voici quelques conventions de codage applicables aux variables : La r√®gle d‚Äôor : Camel Case Pour les variables locales (celles d√©finies √† l‚Äôint√©rieur d‚Äôune m√©thode), la convention universelle en C# est le camelCase. Par exemple¬†:¬†string thisIsCamelCase;. Le premier mot commence par une lettre minuscule.\nChaque mot suivant commence par une lettre majuscule.\nOn ne doit pas utiliser de chiffres au d√©but du nom.\nLe trait de soulignement (_) est proscrit pour le moment.\nint nombreEtudiants; // Correct\tstring codePermanent; // Correct double soldeBanque;\t// Correct int NombreEtudiants; // (PascalCase) Incorrect (ou non conventionnel) string code_permanent; // (snake_case) non conventionnel) double soldebanque; // (tout en minuscule) Incorrect (ou non conventionnel) S√©mantique (Donner du sens)\nUne variable doit d√©crire son contenu sans ambigu√Øt√©. En programmation professionnelle, on √©vite les noms d‚Äôune seule lettre.\n√âvitez : string s = \"Informatique\";\nPrivil√©giez : string nomProgramme = \"Informatique\";\nTableau r√©capitulatif des conventions de nommage C# √âl√©ment Convention Exemple Variable locale camelCase uniteDisponible Param√®tre de m√©thode camelCase (int quantiteItems) Constante PascalCase tauxTaxeFederale Classe PascalCase GestionnaireEtudiant M√©thode PascalCase CalculerSalaire() 2. Les types de base Les types de donn√©es permettent de stocker des valeurs dans l‚Äôapplication. Les langages .NET √©tant fortement typ√©s, il n‚Äôest pas toujours possible de convertir un type de donn√©es √† un autre. Les conversions permettent de convertir les types de donn√©es. Cela est possible, car tous les types du Framework .NET d√©rivent du type Object qui est le type de case de tous les autres types Les types num√©riques Les types num√©riques sont d√©compos√©s en deux parties: Les entiers et les d√©cimaux. Chacun dispose d‚Äôun ensemble de types pour repr√©senter les donn√©es de la mani√®re la plus judicieuse en fonction des besoins.\nLes entiers Une valeur peut √™tre assign√©e √† un entier avec une notation d√©cimale:\nint nombre = 10; //Notation d√©cimale La notation hexad√©cimale peut √™tre utilis√©e et elle doit √™tre pr√©c√©d√©e du pr√©fixe 0x:\nint nombre = 0x4B; // Notation hexad√©cimale √©quivalente √† 75 La notation binaire peut √™tre utilis√©e et elle doit √™tre pr√©c√©d√©e du pr√©fixe 0b:\nint nombre = 0b1101; // Notation binaire √©quivalente √† 13 Les d√©cimaux Les bool√©ens Un bool√©en est un type qui permet de repr√©senter une valeur qui est soit true, soit false. Le type .NET correspondant est System.Boolean et son nom C# est bool. Il est possible d‚Äôassigner √† un bool√©en le r√©sultat d‚Äôune comparaison:\nint nombre = 8; bool estPair = nombre % 2 == 0; Les cha√Ænes de caract√®res Le type System.String (string) est un type de r√©f√©rence qui repr√©sente une s√©rie de types System.Char (char)\nUne variable de type char est assign√©e avec un caract√®re plac√© entre guillemets simples:\nchar premiereLettre = 'a'; Une variable de type string est assign√©e avec une cha√Æne de caract√®re plac√©e entre des guillemets doubles\nstring salutation = \"Bonjour tout le monde!\"; La propri√©t√© Length permet de savoir quelle est la longueur d‚Äôun string\nConsole.WriteLine(\"Hello\".Length); // R√©sultat: 5 D√©claration des chaines de caract√®res // D√©clarer sans initialiser. string message1; // Initialiser √† null. string message2 = null; // Initialise comme une cha√Æne vide (empty string). // Utilise la constante Empty au lieu de \"\". string message3 = System.String.Empty; // Initialiser avec une cha√Æne de caract√®res normale. string vieuxChemin = \"c:\\\\Program Files\\\\Microsoft Visual Studio 8.0\"; // Initialiser avec un litt√©ral de cha√Æne verbatim (pratique pour les chemins). string nouveauChemin = @\"c:\\Program Files\\Microsoft Visual Studio 9.0\"; // Utilisez System.String si vous pr√©f√©rez. System.String salutation = \"Hello World!\"; // Dans les variables locales (c'est-√†-dire dans le corps d'une m√©thode), // vous pouvez utiliser le typage implicite. var temporaire = \"I'm still a strongly-typed System.String!\"; // Utilisez une cha√Æne const pour emp√™cher la variable de stocker une autre valeur. const string messagePermanent = \"Tu ne peux pas te d√©barrasser de moi!\"; // Utilisez le constructeur String uniquement lors de la cr√©ation // d'une cha√Æne √† partir d'un char*, char[] ou sbyte*. char[] lettres = { 'A', 'B', 'C' }; string alphabet = new string(lettres); Quelques propri√©t√©s et m√©thodes de la classe string Soit la variable suivante¬†: string salutation = \"Bonjour tout le monde!\";\nLa nombre de caract√®re:\nint nombreCaractere = salutation.Length; // 22 Convertir tous les caract√®res de la cha√Æne en majuscule:\nstring salutationMajuscule = salutation.ToUpper(); //¬†BONJOUR TOUT LE MONDE! Convertir tous les caract√®res de la cha√Æne en lettre minuscule\nstring¬†salutationMinuscule = salutation.ToLower(); // bonjour tout le monde! V√©rifier si le string contient une sous-cha√Æne de caract√®re ou un mot\nbool contientBonjour = salutation.Contains(\"bonjour\"); contientBonjour = salutation.Contains(\"Bonjour\");¬†//true Remplacer toutes les occurrences d‚Äôun caract√®re dans la cha√Æne par un autre\nstring salut =¬†salutation.Replace(\"Bonjour\", \"Salut\") //¬†Salut tout le monde! Retourne une partie de la chaine, le 0 est l‚Äôindex du d√©but, et le 7 est le¬†nombre de caract√®re √† consid√©rer\nstring bonjour =¬†salutation.Substring(0, 7); // Bonjour Admettons que j‚Äôajoute un autre string, pour Concat√©ner les strings\nstring question = \"Comment allez-vous?\"; String¬†nouvelleSalutation¬†=¬†string.Concat(salutation, \" \", question);¬†//Bonjour tout le monde!¬†Comment allez-vous? Formatter la chaine de caract√®re pour remplacer les expressions de type {0}, {1}, {2}, {3}, etc. Pr√©sentes dans la cha√Æne par les valeurs pass√©es en param√®tres lors de l‚Äôappel de la fonction.\nstring firstName = \"Sara\"; int count = 25; float temperature = 34.4f; Console.WriteLine(\"Bonjour, {0}! Tu as {1} messages dans ta bo√Æte. La temp√©rature est {2} celsius.\", prenom, count, temperature); L‚Äôinterpolation de string Soit les variables suivantes:\nstring nom = \"Samuel\"; int age = 28; On aimerait cr√©er le string: Je m‚Äôappelle Marc, j‚Äôai 20 ans. Si on utilise l‚Äôaddition des cha√Ænes de caract√®res, on aurait:\nstring presentation = \"Je m'appelle \" + nom + \", j'ai \" +¬†age + \" ans.\"; En utilisant la m√©thode string.format:\nstring presentation = string.Format(\"Je m'appelle {0}, j'ai {1} ans. \",¬†nom, age); En utilisant l‚Äôinterpolation:\nstring presentation = $\"Je m'appelle {nom}, j'ai {age} ans. \"; Convertir une cha√Æne de caract√®res aux autres types Utiliser la m√©thode Parse pour convertir un string vers un autre type\nint age = int.Parse(\"35\");¬†bool vrai = bool.Parse(\"true\"); Il se peut qu‚Äôon essaie de convertir une valeur incorrecte. Par exemple, si on essaie de convertir la cha√Æne de caract√®re ‚ÄúSamuel‚Äù en int. On aura une erreur lors de l‚Äôex√©cution. Pour √©viter d‚Äôavoir une erreur, on utilise TryParse pour v√©rifier si la cha√Æne de caract√®re peut se convertir¬†au type d√©sir√© Type implicite et explicite Jusqu‚Äô√† maintenant, on a vu diff√©rents types explicites qui existent, par exemple : int, double, bool, string, etc. Depuis C# 3, C# permet d‚Äôutiliser un type implicite. De ce fait, le programmeur demande √† C# de trouver le type associ√© √† la variable.\nOn utilise le mot-cl√© var pour d√©finir une variable implicite\nvar nombre = 6; // C# sait que c'est un int var content = true; // C# sait que c'est un bool√©en var¬†salutation = \"Bonjour\"; // sait que c'est un string Par contre, si on d√©clare une variable implicite sans l‚Äôinitialiser, C# donnera une erreur de compilation.\n// ‚ùå Erreur de compilation : \"Implicitly-typed variables must be initialized\" var message; // ‚úÖ Correct : Le compilateur voit \"Bonjour\" et d√©duit que 'message' est de type string var message = \"Bonjour\"; Avec string message;, vous dites explicitement au compilateur : ‚ÄúR√©serve une bo√Æte pour du texte‚Äù. Avec var message;, vous ne lui donnez aucun indice. Le compilateur refuse de deviner ou de laisser la variable ‚Äúsans type‚Äù jusqu‚Äô√† plus tard.*",
    "description": "1. D√©claration de variables et types de donn√©es C# est un langage fortement typ√©, ce qui signifie que chaque variable doit √™tre d√©clar√©e avec un type sp√©cifique. Voici quelques types de base :\nint age = 25; // Entier double price = 19.99; // Nombre √† virgule flottante char grade = 'A'; // Caract√®re unique string name = \"John\"; // Cha√Æne de caract√®res bool isActive = true; // Bool√©en (vrai ou faux) Une variable peut √™tre d√©clar√©e et initialis√©e avec la m√™me instruction.\nstring salutation = \"Bonjour tout le monde!\";",
    "tags": [],
    "title": "Variables",
    "uri": "/420-413/variables/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Les op√©rateurs Op√©rateurs Arithm√©tiques en C# Op√©rateur Nom Description Exemple R√©sultat + Addition Somme de deux valeurs int x = 10 + 5; 15 - Soustraction Diff√©rence entre deux valeurs int x = 20 - 8; 12 * Multiplication Produit de deux valeurs double x = 5.5 * 2; 11.0 / Division Quotient de la division int x = 10 / 3; 3 (Entier) % Modulo Reste de la division enti√®re int x = 10 % 3; 1 Op√©rateurs d‚Äôincr√©mentation et de d√©cr√©mentation Op√©rateur Nom Position Description Exemple R√©sultat (x) ++x Pr√©-incr√©mentation Avant Incr√©mente, puis retourne la valeur int y = ++x; Augment√© de 1 x++ Post-incr√©mentation Apr√®s Retourne la valeur, puis incr√©mente int y = x++; Augment√© de 1 --x Pr√©-d√©cr√©mentation Avant D√©cr√©mente, puis retourne la valeur int y = --x; Diminu√© de 1 x-- Post-d√©cr√©mentation Apr√®s Retourne la valeur, puis d√©cr√©mente int y = x--; Diminu√© de 1 Pourquoi la position est-elle importante ? La diff√©rence r√©side dans la valeur retourn√©e par l‚Äôexpression au moment de l‚Äôex√©cution :\nPr√© (++x) : C‚Äôest le mode ‚ÄúMise √† jour d‚Äôabord‚Äù. On change la valeur et on utilise le nouveau r√©sultat tout de suite. Post (x++) : C‚Äôest le mode ‚ÄúUtilisation d‚Äôabord‚Äù. On utilise la valeur actuelle dans le calcul, et l‚Äôajout de 1 se fait juste apr√®s. Exemple de comparaison : int a = 10; int b = 10; int resultatA = ++a; // a devient 11, puis resultatA re√ßoit 11. int resultatB = b++; // resultatB re√ßoit 10, puis b devient 11. // √Ä la fin : // a est 11, resultatA est 11 // b est 11, resultatB est 10 Op√©rateurs Logiques en C# Les op√©rateurs logiques permettent de tester plusieurs conditions √† la fois et retournent toujours une valeur bool√©enne (true ou false).\nOp√©rateur Nom Description Exemple \u0026\u0026 ET (AND) Retourne true si toutes les conditions sont vraies. (age \u003e= 18 \u0026\u0026 aPermis) || OU (OR) Retourne true si au moins une des conditions est vraie. (estSamedi || estDimanche) ! NON (NOT) Inverse l‚Äô√©tat logique (vrai devient faux et inversement). !estConnecte ^ OU exclusif (XOR) Retourne true si une seule des deux conditions est vraie. (estOptionA ^ estOptionB) Tables de v√©rit√© (R√©sum√©) A B A \u0026\u0026 B A || B A ^ B !A true true true true false false true false false true true false false true false true true true false false false false false true Le concept de ‚ÄúCourt-circuit‚Äù (Short-circuit) Les op√©rateurs \u0026\u0026 et || sont dits ‚Äúintelligents‚Äù en C# :\nAvec \u0026\u0026 : Si la premi√®re condition est fausse, C# n‚Äô√©value m√™me pas la deuxi√®me (car le r√©sultat sera forc√©ment faux). Avec || : Si la premi√®re condition est vraie, C# s‚Äôarr√™te l√† (car le r√©sultat sera forc√©ment vrai). Astuce : Placez toujours la condition la plus ‚Äúlourde‚Äù ou risqu√©e en deuxi√®me position pour profiter du court-circuit.\nOp√©rateurs logiques : Court-circuit vs √âvaluation compl√®te Il existe deux variantes pour les op√©rateurs ET et OU. La diff√©rence r√©side dans la gestion de la deuxi√®me condition.\nType ET OU Comportement Court-circuit \u0026\u0026 || √âvalue la 2e condition uniquement si n√©cessaire. √âvaluation compl√®te \u0026 | √âvalue toujours les deux conditions, sans exception. Pourquoi utiliser l‚Äô√©valuation compl√®te (\u0026 et |) ? L‚Äôutilisation de \u0026 et | sur des bool√©ens est plus rare, mais elle est n√©cessaire si la deuxi√®me condition contient un effet de bord (une action qui doit absolument se produire, comme une incr√©mentation ou l‚Äôappel d‚Äôune m√©thode).\nExemple de diff√©rence : int compteur = 0; bool conditionFausse = false; // Cas 1 : Court-circuit (\u0026\u0026) if (conditionFausse \u0026\u0026 ++compteur \u003e 0) { /* ... */ } Console.WriteLine(compteur); // Affiche 0 (le ++ n'a jamais √©t√© ex√©cut√©) // Cas 2 : √âvaluation compl√®te (\u0026) if (conditionFausse \u0026 ++compteur \u003e 0) { /* ... */ } Console.WriteLine(compteur); // Affiche 1 (le ++ a √©t√© ex√©cut√© malgr√© le faux) Op√©rateurs de comparaison en C# Les op√©rateurs de comparaison permettent de v√©rifier la relation entre deux expressions. Le r√©sultat est toujours une valeur bool√©enne (true ou false).\nOp√©rateur Nom Description Exemple R√©sultat == √âgalit√© true si les valeurs sont identiques 5 == 5 true != In√©galit√© true si les valeurs sont diff√©rentes 5 != 3 true \u003e Plus grand que true si la gauche est strictement sup√©rieure 10 \u003e 5 true \u003c Plus petit que true si la gauche est strictement inf√©rieure 2 \u003c 1 false \u003e= Plus grand ou √©gal true si la gauche est sup√©rieure ou √©gale 5 \u003e= 5 true \u003c= Plus petit ou √©gal true si la gauche est inf√©rieure ou √©gale 4 \u003c= 3 false Confusion entre = et == C‚Äôest l‚Äôerreur la plus fr√©quente chez les d√©butants :\n= est l‚Äôop√©rateur d‚Äôassignation (on donne une valeur √† une variable). == est l‚Äôop√©rateur de comparaison (on v√©rifie si deux valeurs sont √©gales). Comparaison de cha√Ænes de caract√®res (string) En C#, l‚Äôop√©rateur == fonctionne pour comparer le contenu des cha√Ænes de caract√®res. Attention : la comparaison est sensible √† la casse.\nstring nomUn = \"Bob\"; string nomDeux = \"bob\"; bool sontEgaux = (nomUn == nomDeux); // R√©sultat: false",
    "description": "Les op√©rateurs Op√©rateurs Arithm√©tiques en C# Op√©rateur Nom Description Exemple R√©sultat + Addition Somme de deux valeurs int x = 10 + 5; 15 - Soustraction Diff√©rence entre deux valeurs int x = 20 - 8; 12 * Multiplication Produit de deux valeurs double x = 5.5 * 2; 11.0 / Division Quotient de la division int x = 10 / 3; 3 (Entier) % Modulo Reste de la division enti√®re int x = 10 % 3; 1 Op√©rateurs d‚Äôincr√©mentation et de d√©cr√©mentation Op√©rateur Nom Position Description Exemple R√©sultat (x) ++x Pr√©-incr√©mentation Avant Incr√©mente, puis retourne la valeur int y = ++x; Augment√© de 1 x++ Post-incr√©mentation Apr√®s Retourne la valeur, puis incr√©mente int y = x++; Augment√© de 1 --x Pr√©-d√©cr√©mentation Avant D√©cr√©mente, puis retourne la valeur int y = --x; Diminu√© de 1 x-- Post-d√©cr√©mentation Apr√®s Retourne la valeur, puis d√©cr√©mente int y = x--; Diminu√© de 1 Pourquoi la position est-elle importante ? La diff√©rence r√©side dans la valeur retourn√©e par l‚Äôexpression au moment de l‚Äôex√©cution :",
    "tags": [],
    "title": "Op√©rateurs",
    "uri": "/420-413/operateurs/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "1. Structures Conditionnelles 1.1 If-Else Similitudes avec Java : La syntaxe de base est identique.\n// Calcul de rabais selon la quantit√© et le montant int quantite = 15; double montantTotal = 250.50; double rabais = 0.0; if (quantite \u003e= 20 \u0026\u0026 montantTotal \u003e= 500) { rabais = 0.20; // 20% pour commandes importantes } else if (quantite \u003e= 10 || montantTotal \u003e= 200) { rabais = 0.10; // 10% pour commandes moyennes } else { rabais = 0.0; // Pas de rabais } double montantFinal = montantTotal * (1 - rabais); Console.WriteLine($\"Montant final: {montantFinal} $\"); ‚úÖ Bonne pratique - Accolades obligatoires\nint stock = 5; int quantite = 10; // ‚úÖ BIEN - Toujours utiliser des accolades if (quantite \u003e stock) { Console.WriteLine(\"Stock insuffisant\"); } // ‚ùå √âVITER - M√™me si syntaxiquement valide if (quantite \u003e stock) Console.WriteLine(\"Stock insuffisant\"); 1.2 Op√©rateur Ternaire Identique √† Java, mais C# encourage son utilisation judicieuse.\n// Calcul de frais d'exp√©dition // Calcul des frais d'exp√©dition double montantCommande = 45.00; double fraisExpedition = montantCommande \u003e= 50 ? 0.0 : 5.99; Console.WriteLine($\"Frais d'exp√©dition : {fraisExpedition:C}\"); // D√©termination du statut de paiement int joursRetard = 15; string statutPaiement = joursRetard \u003e 0 ? \"En retard\" : \"√Ä jour\"; Console.WriteLine($\"Statut : {statutPaiement}\"); ‚úÖ Bonne pratique - Ternaires imbriqu√©s\nint noteExamen = 85; // ‚úÖ Acceptable pour des cas simples (Logique lin√©aire) string mention = noteExamen \u003e= 90 ? \"A\" : noteExamen \u003e= 80 ? \"B\" : noteExamen \u003e= 70 ? \"C\" : noteExamen \u003e= 60 ? \"D\" : \"F\"; Console.WriteLine($\"R√©sultat : {mention}\"); // ‚ùå √Ä √âVITER - Trop complexe, rend le d√©bogage difficile int heuresTravaillees = 45; int heuresSupplementaires = 5; bool estWeekend = true; // Cette structure imbriqu√©e est une \"dette technique\" imm√©diate double tauxHoraire = heuresTravaillees \u003e 40 ? (estWeekend ? 30.0 : 25.0) : (heuresSupplementaires \u003e 0 ? 22.0 : 20.0); // Difficile √† lire et √† maintenir ! ‚úÖ Bonne pratique - Assignation conditionnelle simple\nint articlesDansPanier = 5; double prixArticle = 19.99; // Rabais de volume (Logique d√©gressive) double prixUnitaire = articlesDansPanier \u003e= 10 ? prixArticle * 0.85 : articlesDansPanier \u003e= 5 ? prixArticle * 0.95 : prixArticle; double coutTotal = articlesDansPanier * prixUnitaire; // Utilisation du symbole $ au lieu du formatage automatique :C Console.WriteLine($\"Prix unitaire : {prixUnitaire} $, Total : {coutTotal} $\"); 1.3 Switch Statement Diff√©rence majeure avec Java : Pas de ‚Äúfall-through‚Äù implicite en C#.\nint jour = 3; switch (jour) { case 1: Console.WriteLine(\"Lundi\"); break; // break obligatoire case 2: Console.WriteLine(\"Mardi\"); break; case 3: Console.WriteLine(\"Mercredi\"); break; case 4: Console.WriteLine(\"Jeudi\"); break; case 5: Console.WriteLine(\"Vendredi\"); break; default: Console.WriteLine(\"Weekend ou invalide\"); break; } Fall-through explicite en C#\nint jour = 6; switch (jour) { case 6: case 7: Console.WriteLine(\"Weekend\"); break; // Un seul break pour les deux cas case 1: case 2: case 3: case 4: case 5: Console.WriteLine(\"Jour de semaine\"); break; default: Console.WriteLine(\"Jour invalide\"); break; } ‚úÖ Bonne pratique - Switch avec char et string\n// Switch avec char char noteLettre = 'B'; switch (noteLettre) { case 'A': Console.WriteLine(\"Excellent\"); break; case 'B': Console.WriteLine(\"Tr√®s bien\"); break; case 'C': Console.WriteLine(\"Bien\"); break; default: Console.WriteLine(\"√Ä am√©liorer\"); break; } // Switch avec string string commande = \"start\"; switch (commande) { case \"start\": Console.WriteLine(\"D√©marrage...\"); break; case \"stop\": Console.WriteLine(\"Arr√™t...\"); break; case \"pause\": Console.WriteLine(\"Pause...\"); break; default: Console.WriteLine(\"Commande inconnue\"); break; } 1.4 Switch Expression (C# 8.0+) Nouveaut√© C# - N‚Äôexiste pas en Java (avant Java 14)\n// Syntaxe concise et fonctionnelle int numeroDuJour = 3; string nomJour = numeroDuJour switch { 1 =\u003e \"Lundi\", 2 =\u003e \"Mardi\", 3 =\u003e \"Mercredi\", 4 =\u003e \"Jeudi\", 5 =\u003e \"Vendredi\", 6 =\u003e \"Weekend\", 7 =\u003e \"Weekend\", _ =\u003e \"Invalide\" }; Console.WriteLine(nomJour); ‚úÖ Bonne pratique - Switch expression pour calculer des valeurs\n// Utilisation de valeurs discr√®tes (cas pr√©cis) int numeroJour = 3; string typeJour = numeroJour switch { 1 or 2 =\u003e \"D√©but de semaine\", 3 or 4 =\u003e \"Milieu de semaine\", 5 =\u003e \"Fin de semaine\", 6 or 7 =\u003e \"Weekend\", _ =\u003e \"Invalide\" }; Console.WriteLine(typeJour); // Pour les comparaisons de ranges, utiliser if-else iint age = 25; double prixBillet; if (age \u003c 5) prixBillet = 0.0; else if (age \u003c 18) prixBillet = 8.50; else if (age \u003c 65) prixBillet = 12.00; else prixBillet = 9.00; Console.WriteLine($\"Prix du billet : {prixBillet} $\"); ‚úÖ Bonne pratique - Switch expression avec valeurs multiples\nchar lettre = 'e'; // ‚úÖ Version optimis√©e (C# 9+) : Plus lisible et moins de r√©p√©titions bool estUneVoyelle = lettre switch { 'a' or 'e' or 'i' or 'o' or 'u' or 'A' or 'E' or 'I' or 'O' or 'U' =\u003e true, _ =\u003e false }; Console.WriteLine($\"Est une voyelle : {estUneVoyelle}\"); ‚úÖ Bonne pratique - Quand utiliser switch vs if-else\nint note = 85; // La switch expression agit comme une \"table de correspondance\" string mention = note switch { \u003e= 90 =\u003e \"A\", \u003e= 80 =\u003e \"B\", \u003e= 70 =\u003e \"C\", \u003e= 60 =\u003e \"D\", _ =\u003e \"F\" // Le discard (_) est obligatoire pour couvrir tous les cas }; Console.WriteLine($\"Mention obtenue : {mention}\"); double solde = 1500.50; int nombreTransactions = 25; bool aUnDecouvert = false; double fraisMensuels = 0.0; // Logique d√©cisionnelle bas√©e sur plusieurs crit√®res if (solde \u003e= 5000 \u0026\u0026 nombreTransactions \u003e 50) { fraisMensuels = 0.0; // Compte premium gratuit } else if (solde \u003e= 1000 || nombreTransactions \u003c= 10) { fraisMensuels = 5.0; // Frais r√©duits (fid√©lit√© ou faible usage) } else if (aUnDecouvert) { fraisMensuels = 25.0; // P√©nalit√© pour d√©couvert } else { fraisMensuels = 12.0; // Frais standards } // Utilisation du format mon√©taire :C (tr√®s pratique en .NET 8) Console.WriteLine($\"Frais mensuels : {fraisMensuels:C}\"); 2. Structures It√©ratives 2.1 Boucle While Identique √† Java.\nint i = 0; while (i \u003c 5) { Console.WriteLine(i); i++; } ‚úÖ Bonne pratique - While avec condition claire\nint somme = 0; int nombre = 1; while (somme \u003c 100) { somme += number; nombre++; } Console.WriteLine($\"Somme: {somme}, Dernier nombre: {nombre}\"); ‚úÖ Bonne pratique - √âviter les boucles infinies\n// ‚ùå DANGEREUX // while (true) // { // // Sans condition de sortie claire // } // ‚úÖ MIEUX - Avec limite de s√©curit√© int maxTentatives = 10; int tentatives = 0; bool succes = false; // ‚úÖ Utilisation d'une boucle While avec deux conditions de sortie while (tentatives \u003c maxTentatives \u0026\u0026 !succes) { Console.Write(\"Entrez un nombre entre 1 et 10 : \"); string saisie = Console.ReadLine(); // ‚úÖ int.TryParse √©vite que le programme plante si l'utilisateur tape du texte // Le \"out int nombre\" d√©clare la variable uniquement si la conversion r√©ussit if (int.TryParse(saisie, out int nombre) \u0026\u0026 nombre \u003e= 1 \u0026\u0026 nombre \u003c= 10) { succes = true; Console.WriteLine(\"Valide !\"); } else { tentatives++; Console.WriteLine($\"Invalide. Tentatives restantes : {maxTentatives - tentatives}\"); } } 2.2 Boucle Do-While Identique √† Java.\nint i = 0; do { Console.WriteLine(i); i++; } while (i \u003c 5); ‚úÖ Bonne pratique - Utiliser do-while pour validation Utilisation pour la validation de saisie : Cette structure garantit que l‚Äôutilisateur verra le message au moins une fois.\nint nombre; string saisie; do { Console.Write(\"Entrez un nombre positif : \"); saisie = Console.ReadLine(); // On boucle tant que la saisie n'est pas un entier OU que le nombre est \u003c= 0 } while (!int.TryParse(saisie, out nombre) || nombre \u003c= 0); Console.WriteLine($\"Vous avez entr√© : {nombre}\"); Exemple - Menu simple\nint choix; do { Console.WriteLine(\"\\n--- MENU ---\"); Console.WriteLine(\"1. Addition\"); Console.WriteLine(\"2. Soustraction\"); Console.WriteLine(\"3. Quitter\"); Console.Write(\"Votre choix : \"); //si l'utilisateur ne tape pas un chiffre et que la conversion ne fonction pas, choix va avoir la valeur par d√©faut 0 int.TryParse(Console.ReadLine(), out choix); switch (choix) { case 1: Console.WriteLine(\"Addition s√©lectionn√©e\"); break; case 2: Console.WriteLine(\"Soustraction s√©lectionn√©e\"); break; case 3: Console.WriteLine(\"Au revoir !\"); break; default: Console.WriteLine(\"Choix invalide, veuillez recommencer.\"); break; } // La boucle continue tant que l'utilisateur n'a pas choisi de quitter (3) } while (choix != 3); 2.3 Boucle For Identique √† Java.\nfor (int i = 0; i \u003c 10; i++) { Console.WriteLine(i); } ‚úÖ Bonne pratique - D√©clarer la variable dans la boucle\n// ‚úÖ BIEN - Port√©e limit√©e for (int i = 0; i \u003c 10; i++) { Console.WriteLine(i); } // i n'existe plus ici // ‚ùå √âVITER - Port√©e trop large int j; for (j = 0; j \u003c 10; j++) { Console.WriteLine(j); } // j existe encore ici It√©rer sur un tableau\nLa boucle for est privil√©gi√©e lorsque l‚Äôindexation est n√©cessaire ou pour manipuler des structures multidimensionnelles.\nint[] nombres = { 10, 20, 30, 40, 50 }; // Calcul de la somme int somme = 0; for (int i = 0; i \u003c nombres.Length; i++) { somme += nombres[i]; } Console.WriteLine($\"Somme : {somme}\"); // Recherche d'un √©l√©ment int valeurRecherchee = 30; int indexTrouve = -1; for (int i = 0; i \u003c nombres.Length; i++) { if (nombres[i] == valeurRecherchee) { indexTrouve = i; break; // On quitte la boucle d√®s qu'on a trouv√© } } if (indexTrouve != -1) { Console.WriteLine($\"Trouv√© √† l'index {indexTrouve}\"); } ‚úÖ Bonne pratique - √âviter de modifier le compteur dans la boucle\nint[] values = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // ‚ùå MAUVAIS - Difficile √† comprendre for (int i = 0; i \u003c values.Length; i++) { Console.WriteLine(values[i]); if (values[i] % 2 == 0) i++; // Modifie le flux de contr√¥le - confus! } // ‚úÖ MIEUX - Intention claire for (int i = 0; i \u003c values.Length; i++) { Console.WriteLine(values[i]); if (values[i] % 2 == 0 \u0026\u0026 i + 1 \u003c values.Length) { i++; // Saute le prochain si pair } } Boucles imbriqu√©es - Tableaux 2D\nint[,] matrice = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; // Affichage de la matrice ligne par ligne for (int ligne = 0; ligne \u003c 3; ligne++) { for (int col = 0; col \u003c 3; col++) { Console.Write($\"{matrice[ligne, col]} \"); } Console.WriteLine(); // Saut de ligne apr√®s chaque rang√©e } 2.4 Boucle Foreach Diff√©rence avec Java : Mot-cl√© foreach au lieu de for. C‚Äôest l‚Äôoutil le plus s√ªr car il √©limine les erreurs de d√©passement d‚Äôindex (le fameux IndexOutOfRangeException).\n// Java: for (String name : names) // C#: string[] noms = { \"Alice\", \"Bob\", \"Charlie\" }; foreach (string nom in noms) { Console.WriteLine(nom); } ‚úÖ Bonne pratique - Pr√©f√©rer foreach quand appropri√©\niint[] nombres = { 1, 2, 3, 4, 5 }; // ‚úÖ BIEN - Plus lisible, id√©al pour le calcul ou l'affichage int somme = 0; foreach (int n in nombres) { somme += n; } Console.WriteLine($\"Somme : {somme}\"); // ‚ùå √Ä √âVITER - Sauf si vous avez besoin de l'index 'i' (ex: modification) int sommeAlternative = 0; for (int i = 0; i \u003c nombres.Length; i++) { sommeAlternative += nombres[i]; } Exemples pratiques avec foreach\n// Affichage de prix format√©s (Symbole $ au lieu de :C) double[] prixUnitaires = { 19.99, 29.99, 39.99, 49.99 }; foreach (double p in prixUnitaires) { Console.WriteLine($\"Prix : {p} $\"); } // Comptage avec condition (Filtrage simple) int[] scores = { 45, 78, 92, 65, 88, 54, 91 }; int reussites = 0; foreach (int s in scores) { if (s \u003e= 60) { reussites++; } } Console.WriteLine($\"{reussites} √©tudiants ont r√©ussi.\"); // Recherche du maximum int[] valeurs = { 23, 67, 12, 89, 45, 34 }; int maximum = valeurs[0]; foreach (int v in valeurs) { if (v \u003e maximum) { maximum = v; } } Console.WriteLine($\"Valeur maximale : {maximum}\"); ‚ö†Ô∏è Important - Foreach est read-only\nIl est impossible de modifier directement l‚Äô√©l√©ment de la collection √† l‚Äôint√©rieur d‚Äôun foreach. Le compilateur .NET 8 bloquera le code.\nint[] chiffres = { 1, 2, 3 }; // ‚ùå ERREUR DE COMPILATION - On ne peut pas modifier 'c' /* foreach (int c in chiffres) { c = c * 2; } */ // ‚úÖ SOLUTION - Utiliser 'for' pour modifier le contenu du tableau for (int i = 0; i \u003c chiffres.Length; i++) { chiffres[i] = chiffres[i] * 2; } // V√©rification (Lecture simple via foreach) foreach (int c in chiffres) { Console.WriteLine(c); // Affiche : 2, 4, 6 } Foreach avec tableaux multidimensionnels\nint[,] matrice = { { 1, 2, 3 }, { 4, 5, 6 } }; // Foreach parcourt automatiquement toutes les lignes et colonnes foreach (int valeur in matrice) { Console.Write($\"{valeur} \"); } // R√©sultat : 1 2 3 4 5 6 3. Instructions de Contr√¥le de Flux 3.1 Break Identique √† Java - Sort de la boucle ou du switch.\n// Recherche d'un √©l√©ment dans un tableau int[] nombres = { 5, 12, 8, 3, 19, 7 }; int cible = 19; int position = -1; for (int i = 0; i \u003c nombres.Length; i++) { if (nombres[i] == cible) { position = i; break; // ‚úÖ Succ√®s : On arr√™te de chercher pour √©conomiser des ressources } } if (position != -1) { Console.WriteLine($\"Trouv√© √† la position {position}\"); } else { Console.WriteLine(\"L'√©l√©ment n'a pas √©t√© trouv√©.\"); } Break dans switch\nint operation = 2; int nombre1 = 10; int nombre2 = 5; int resultat = 0; switch (operation) { case 1: resultat = nombre1 + nombre2; break; // Sort du switch apr√®s l'addition case 2: resultat = nombre1 - nombre2; break; // Sort du switch apr√®s la soustraction case 3: resultat = nombre1 * nombre2; break; // Sort du switch apr√®s la multiplication default: Console.WriteLine(\"Op√©ration invalide\"); break; } Console.WriteLine($\"R√©sultat : {resultat}\"); 3.2 Continue Identique √† Java - Passe √† l‚Äôit√©ration suivante.\n// Afficher seulement les nombres impairs for (int i = 0; i \u003c 10; i++) { if (i % 2 == 0) continue; // Saute les nombres pairs Console.WriteLine(i); } // Affiche: 1, 3, 5, 7, 9 Continue pour filtrage simple\nint[] notes = { 45, 78, 0, 92, -1, 65, 88 }; // ‚úÖ BIEN - Utilisation de continue pour filtrer (Style \"Guard Clause\") foreach (int note in notes) { // Si la note est hors limite, on l'ignore imm√©diatement if (note \u003c 0 || note \u003e 100) continue; // Le code principal reste ici, sans √™tre cach√© dans un bloc 'if' Console.WriteLine($\"Note valide : {note}\"); } // ‚ùå MOINS LISIBLE - L'imbrication inutile (Arrow Code) foreach (int note in notes) { if (note \u003e= 0 \u0026\u0026 note \u003c= 100) { // Imaginez si vous aviez 10 conditions... // Le code finirait par √™tre tr√®s d√©cal√© vers la droite. Console.WriteLine($\"Note valide : {note}\"); } } Exemple - Somme conditionnelle\nint[] nombres = { 5, -3, 12, 0, 8, -7, 15 }; int sommePositifs = 0; foreach (int n in nombres) { // Si le nombre est n√©gatif ou nul, on passe directement au suivant if (n \u003c= 0) continue; // On ne traite que les valeurs qui nous int√©ressent sommePositifs += n; } Console.WriteLine($\"Somme des nombres positifs : {sommePositifs}\"); 4. Gestion des Exceptions 4.1 Try-Catch-Finally Tr√®s similaire √† Java.\ntry { int result = 10 / 0; // G√©n√®re une exception } catch (DivideByZeroException ex) { Console.WriteLine($\"Erreur: {ex.Message}\"); } catch (Exception ex) { Console.WriteLine($\"Erreur g√©n√©rale: {ex.Message}\"); } finally { Console.WriteLine(\"Toujours ex√©cut√©\"); }",
    "description": "1. Structures Conditionnelles 1.1 If-Else Similitudes avec Java : La syntaxe de base est identique.\n// Calcul de rabais selon la quantit√© et le montant int quantite = 15; double montantTotal = 250.50; double rabais = 0.0; if (quantite \u003e= 20 \u0026\u0026 montantTotal \u003e= 500) { rabais = 0.20; // 20% pour commandes importantes } else if (quantite \u003e= 10 || montantTotal \u003e= 200) { rabais = 0.10; // 10% pour commandes moyennes } else { rabais = 0.0; // Pas de rabais } double montantFinal = montantTotal * (1 - rabais); Console.WriteLine($\"Montant final: {montantFinal} $\"); ‚úÖ Bonne pratique - Accolades obligatoires",
    "tags": [],
    "title": "Structures de contr√¥les",
    "uri": "/420-413/structures_de_controles/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "En C#, on distingue deux grandes familles pour stocker des groupes de donn√©es : les Tableaux (taille fixe) et les Collections (taille dynamique).\nLes tableaux (Array) Un tableau est une structure de donn√©es de taille fixe stock√©e de mani√®re contigu√´ en m√©moire.\n1. D√©claration et initialisation Syntaxe de base // D√©claration d'un tableau int[] nombres; // D√©claration avec initialisation de la taille int[] nombres = new int[5]; // D√©claration avec initialisation des valeurs int[] nombres = new int[] { 10, 20, 30, 40, 50 }; // Syntaxe courte (recommand√©e) int[] nombres = { 10, 20, 30, 40, 50 }; Le pi√®ge de l‚Äôimmuabilit√© : Si vous cr√©ez int[] tab = new int[3], vous ne pourrez jamais y mettre un 4e √©l√©ment. Pour ‚Äúagrandir‚Äù un tableau, il faut en cr√©er un nouveau, copier les donn√©es, puis ajouter le nouvel √©l√©ment. C‚Äôest pourquoi nous utilisons les Collections pour les donn√©es dynamiques.\nPoints importants √† retenir Les tableaux ont une taille fixe d√©finie √† la cr√©ation Les collections (comme List\u003cT\u003e) peuvent changer de taille dynamiquement Les propri√©t√©s en C# (comme .Length, .Count) n‚Äôont pas de parenth√®ses C# offre LINQ (Language Integrated Query) pour manipuler les collections facilement Les collections sont dans le namespace System.Collections.Generic 2. Exemples pratiques Exemple 1 : Gestion des notes d‚Äô√©tudiants using System; class GestionNotes { static void Main() { // D√©claration d'un tableau de notes double[] notesEtudiants = { 85.5, 92.0, 78.5, 88.0, 95.5 }; // Afficher toutes les notes Console.WriteLine(\"=== Notes des √©tudiants ===\"); for (int i = 0; i \u003c notesEtudiants.Length; i++) { Console.WriteLine($\"√âtudiant {i + 1}: {notesEtudiants[i]}%\"); } // Calculer la moyenne double somme = 0; foreach (double note in notesEtudiants) { somme += note; } double moyenne = somme / notesEtudiants.Length; Console.WriteLine($\"\\nMoyenne de la classe: {moyenne:F2}%\"); } } Sortie :\n=== Notes des √©tudiants ===\r√âtudiant 1: 85.5%\r√âtudiant 2: 92%\r√âtudiant 3: 78.5%\r√âtudiant 4: 88%\r√âtudiant 5: 95.5%\rMoyenne de la classe: 87.90% Exemple 2 : Tableau de cha√Ænes de caract√®res using System; class GestionPrenoms { static void Main() { // Tableau de pr√©noms string[] prenoms = { \"Alice\", \"Bernard\", \"Catherine\", \"David\", \"√âmilie\" }; // Afficher les pr√©noms avec leur longueur Console.WriteLine(\"=== Liste des pr√©noms ===\"); foreach (string prenom in prenoms) { Console.WriteLine($\"{prenom} - {prenom.Length} lettres\"); } // Trouver le pr√©nom le plus long string prenomPlusLong = prenoms[0]; foreach (string prenom in prenoms) { if (prenom.Length \u003e prenomPlusLong.Length) { prenomPlusLong = prenom; } } Console.WriteLine($\"\\nPr√©nom le plus long: {prenomPlusLong}\"); } } 3. Tableaux multidimensionnels Tableau √† deux dimensions (matrice) using System; class Matrice { static void Main() { // D√©claration d'une matrice 3x3 int[,] matrice = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; // Affichage de la matrice Console.WriteLine(\"=== Matrice 3x3 ===\"); for (int ligne = 0; ligne \u003c 3; ligne++) { for (int colonne = 0; colonne \u003c 3; colonne++) { Console.Write($\"{matrice[ligne, colonne]}\\t\"); } Console.WriteLine(); } // Calculer la somme de chaque ligne Console.WriteLine(\"\\n=== Somme par ligne ===\"); for (int ligne = 0; ligne \u003c 3; ligne++) { int somme = 0; for (int colonne = 0; colonne \u003c 3; colonne++) { somme += matrice[ligne, colonne]; } Console.WriteLine($\"Ligne {ligne + 1}: {somme}\"); } } } Tableau dentel√© (jagged array) using System; class TableauDentele { static void Main() { // Tableau o√π chaque ligne peut avoir une longueur diff√©rente int[][] notesParCours = new int[3][]; notesParCours[0] = new int[] { 85, 90, 78 }; // 3 notes notesParCours[1] = new int[] { 92, 88 }; // 2 notes notesParCours[2] = new int[] { 95, 87, 91, 89 }; // 4 notes // Affichage Console.WriteLine(\"=== Notes par cours ===\"); for (int cours = 0; cours \u003c notesParCours.Length; cours++) { Console.Write($\"Cours {cours + 1}: \"); foreach (int note in notesParCours[cours]) { Console.Write($\"{note} \"); } Console.WriteLine(); } } } 4. M√©thodes utiles pour les tableaux using System; class MethodesTableaux { static void Main() { int[] nombres = { 45, 12, 78, 34, 90, 23, 67 }; // Longueur du tableau Console.WriteLine($\"Nombre d'√©l√©ments: {nombres.Length}\"); // Trier le tableau Array.Sort(nombres); Console.WriteLine(\"\\nTableau tri√©:\"); AfficherTableau(nombres); // Inverser l'ordre Array.Reverse(nombres); Console.WriteLine(\"\\nTableau invers√©:\"); AfficherTableau(nombres); // Rechercher un √©l√©ment int valeurRecherchee = 78; int index = Array.IndexOf(nombres, valeurRecherchee); Console.WriteLine($\"\\nIndex de {valeurRecherchee}: {index}\"); // Copier un tableau int[] copie = new int[nombres.Length]; Array.Copy(nombres, copie, nombres.Length); Console.WriteLine(\"\\nCopie du tableau:\"); AfficherTableau(copie); } static void AfficherTableau(int[] tableau) { foreach (int nombre in tableau) { Console.Write($\"{nombre} \"); } Console.WriteLine(); } } Les Collections Les collections en C# offrent plus de flexibilit√© que les tableaux. Elles peuvent changer de taille dynamiquement et offrent des m√©thodes pratiques pour manipuler les donn√©es.\n1. List - La collection la plus utilis√©e Syntaxe de base using System; using System.Collections.Generic; class ExempleList { static void Main() { // Cr√©ation d'une liste vide List fruits = new List(); // Cr√©ation avec valeurs initiales List nombres = new List { 1, 2, 3, 4, 5 }; // Ajout d'√©l√©ments fruits.Add(\"Pomme\"); fruits.Add(\"Banane\"); fruits.Add(\"Orange\"); // Affichage Console.WriteLine(\"=== Liste de fruits ===\"); foreach (string fruit in fruits) { Console.WriteLine(fruit); } // Nombre d'√©l√©ments Console.WriteLine($\"\\nNombre de fruits: {fruits.Count}\"); } } Exemple 2 : Gestion d‚Äôun inventaire simple using System; using System.Collections.Generic; class GestionInventaire { static void Main() { // Cr√©ation de listes pour stocker les informations List nomsProduits = new List(); List prixProduits = new List(); List quantitesProduits = new List(); // Ajout de produits nomsProduits.Add(\"Ordinateur portable\"); prixProduits.Add(1299.99); quantitesProduits.Add(15); nomsProduits.Add(\"Souris sans fil\"); prixProduits.Add(29.99); quantitesProduits.Add(50); nomsProduits.Add(\"Clavier m√©canique\"); prixProduits.Add(149.99); quantitesProduits.Add(25); // Affichage de l'inventaire Console.WriteLine(\"=== INVENTAIRE ===\"); for (int i = 0; i \u003c nomsProduits.Count; i++) { Console.WriteLine($\"{nomsProduits[i]} - {prixProduits[i]:C} - Qt√©: {quantitesProduits[i]}\"); } // Calculer la valeur totale de l'inventaire double valeurTotale = 0; for (int i = 0; i \u003c nomsProduits.Count; i++) { valeurTotale += prixProduits[i] * quantitesProduits[i]; } Console.WriteLine($\"\\nValeur totale de l'inventaire: {valeurTotale:C}\"); } } M√©thodes importantes de List using System; using System.Collections.Generic; class MethodesList { static void Main() { List etudiants = new List { \"Alice\", \"Bernard\", \"Catherine\", \"David\" }; // Add - Ajouter un √©l√©ment √† la fin etudiants.Add(\"√âmilie\"); // Insert - Ins√©rer √† une position sp√©cifique etudiants.Insert(1, \"Fran√ßois\"); // Remove - Retirer un √©l√©ment sp√©cifique etudiants.Remove(\"Bernard\"); // RemoveAt - Retirer √† un index sp√©cifique etudiants.RemoveAt(0); // Contains - V√©rifier si un √©l√©ment existe bool existe = etudiants.Contains(\"Catherine\"); Console.WriteLine($\"Catherine est dans la liste: {existe}\"); // IndexOf - Trouver l'index d'un √©l√©ment int index = etudiants.IndexOf(\"David\"); Console.WriteLine($\"Index de David: {index}\"); // Clear - Vider la liste // etudiants.Clear(); // Sort - Trier la liste etudiants.Sort(); // Reverse - Inverser l'ordre etudiants.Reverse(); // Count - Nombre d'√©l√©ments Console.WriteLine($\"Nombre d'√©tudiants: {etudiants.Count}\"); // Affichage final Console.WriteLine(\"\\n=== Liste finale ===\"); foreach (string etudiant in etudiants) { Console.WriteLine(etudiant); } } } 2. Dictionary\u003cTKey, TValue\u003e - Paires cl√©-valeur using System; using System.Collections.Generic; class ExempleDictionnaire { static void Main() { // Cr√©ation d'un dictionnaire pour stocker des codes postaux Dictionary codesPostaux = new Dictionary(); // Ajout d'√©l√©ments codesPostaux.Add(\"Montr√©al\", \"H1A\"); codesPostaux.Add(\"Qu√©bec\", \"G1A\"); codesPostaux.Add(\"Laval\", \"H7A\"); codesPostaux.Add(\"Gatineau\", \"J8T\"); // Acc√®s √† une valeur Console.WriteLine($\"Code postal de Montr√©al: {codesPostaux[\"Montr√©al\"]}\"); // V√©rifier si une cl√© existe if (codesPostaux.ContainsKey(\"Qu√©bec\")) { Console.WriteLine($\"Code postal de Qu√©bec: {codesPostaux[\"Qu√©bec\"]}\"); } // Parcourir le dictionnaire Console.WriteLine(\"\\n=== Tous les codes postaux ===\"); foreach (KeyValuePair paire in codesPostaux) { Console.WriteLine($\"{paire.Key}: {paire.Value}\"); } // Modifier une valeur codesPostaux[\"Montr√©al\"] = \"H2X\"; // Retirer un √©l√©ment codesPostaux.Remove(\"Gatineau\"); Console.WriteLine($\"\\nNombre de villes: {codesPostaux.Count}\"); } } Exemple pratique : Syst√®me de notes using System; using System.Collections.Generic; class SystemeNotes { static void Main() { // Dictionnaire: nom de l'√©tudiant -\u003e liste de notes Dictionary\u003e notesEtudiants = new Dictionary\u003e(); // Ajout des √©tudiants et leurs notes notesEtudiants.Add(\"Alice\", new List { 85.5, 92.0, 88.5 }); notesEtudiants.Add(\"Bernard\", new List { 78.0, 82.5, 80.0 }); notesEtudiants.Add(\"Catherine\", new List { 95.0, 93.5, 97.0 }); // Afficher les notes et moyennes Console.WriteLine(\"=== NOTES ET MOYENNES ===\\n\"); foreach (KeyValuePair\u003e etudiant in notesEtudiants) { string nom = etudiant.Key; List notes = etudiant.Value; Console.WriteLine($\"√âtudiant: {nom}\"); Console.Write(\"Notes: \"); foreach (double note in notes) { Console.Write($\"{note}% \"); } // Calculer la moyenne double somme = 0; foreach (double note in notes) { somme += note; } double moyenne = somme / notes.Count; Console.WriteLine($\"\\nMoyenne: {moyenne:F2}%\\n\"); } } } 3. Queue - File d‚Äôattente (FIFO) using System; using System.Collections.Generic; class ExempleQueue { static void Main() { // Cr√©ation d'une file d'attente Queue fileAttente = new Queue(); // Enqueue - Ajouter √† la fin de la file fileAttente.Enqueue(\"Client 1\"); fileAttente.Enqueue(\"Client 2\"); fileAttente.Enqueue(\"Client 3\"); fileAttente.Enqueue(\"Client 4\"); Console.WriteLine($\"Nombre de clients: {fileAttente.Count}\"); // Peek - Voir le premier √©l√©ment sans le retirer string premier = fileAttente.Peek(); Console.WriteLine($\"Prochain client √† servir: {premier}\"); // Dequeue - Retirer et retourner le premier √©l√©ment Console.WriteLine(\"\\n=== Service des clients ===\"); while (fileAttente.Count \u003e 0) { string client = fileAttente.Dequeue(); Console.WriteLine($\"Servir: {client}\"); } Console.WriteLine($\"\\nClients restants: {fileAttente.Count}\"); } } 4. Stack - Pile (LIFO) using System; using System.Collections.Generic; class ExempleStack { static void Main() { // Cr√©ation d'une pile Stack historiqueNavigation = new Stack(); // Push - Ajouter au sommet de la pile historiqueNavigation.Push(\"Page d'accueil\"); historiqueNavigation.Push(\"Page de recherche\"); historiqueNavigation.Push(\"Page de r√©sultats\"); historiqueNavigation.Push(\"Page de d√©tails\"); Console.WriteLine($\"Nombre de pages visit√©es: {historiqueNavigation.Count}\"); // Peek - Voir le sommet sans retirer string pageActuelle = historiqueNavigation.Peek(); Console.WriteLine($\"Page actuelle: {pageActuelle}\"); // Pop - Retirer et retourner l'√©l√©ment du sommet Console.WriteLine(\"\\n=== Navigation arri√®re ===\"); while (historiqueNavigation.Count \u003e 0) { string page = historiqueNavigation.Pop(); Console.WriteLine($\"Retour √†: {page}\"); } } } 5. HashSet - Ensemble (pas de doublons) using System; using System.Collections.Generic; class ExempleHashSet { static void Main() { // Cr√©ation d'un ensemble HashSet tagsUniques = new HashSet(); // Add - Ajouter un √©l√©ment (ignore les doublons) tagsUniques.Add(\"programmation\"); tagsUniques.Add(\"csharp\"); tagsUniques.Add(\"collections\"); tagsUniques.Add(\"csharp\"); // Sera ignor√© (doublon) tagsUniques.Add(\"dotnet\"); Console.WriteLine($\"Nombre de tags uniques: {tagsUniques.Count}\"); // Affichage Console.WriteLine(\"\\n=== Tags ===\"); foreach (string tag in tagsUniques) { Console.WriteLine($\"- {tag}\"); } // Contains - V√©rifier l'existence bool existe = tagsUniques.Contains(\"csharp\"); Console.WriteLine($\"\\nLe tag 'csharp' existe: {existe}\"); // Op√©rations sur les ensembles HashSet autresTags = new HashSet { \"csharp\", \"java\", \"python\" }; // Union tagsUniques.UnionWith(autresTags); Console.WriteLine($\"\\nApr√®s union: {tagsUniques.Count} tags\"); // Intersection HashSet langages = new HashSet { \"csharp\", \"java\", \"python\" }; HashSet appris = new HashSet { \"csharp\", \"javascript\" }; langages.IntersectWith(appris); Console.WriteLine(\"\\n=== Langages en commun ===\"); foreach (string langage in langages) { Console.WriteLine(langage); } } }",
    "description": "En C#, on distingue deux grandes familles pour stocker des groupes de donn√©es : les Tableaux (taille fixe) et les Collections (taille dynamique).\nLes tableaux (Array) Un tableau est une structure de donn√©es de taille fixe stock√©e de mani√®re contigu√´ en m√©moire.\n1. D√©claration et initialisation Syntaxe de base // D√©claration d'un tableau int[] nombres; // D√©claration avec initialisation de la taille int[] nombres = new int[5]; // D√©claration avec initialisation des valeurs int[] nombres = new int[] { 10, 20, 30, 40, 50 }; // Syntaxe courte (recommand√©e) int[] nombres = { 10, 20, 30, 40, 50 }; Le pi√®ge de l‚Äôimmuabilit√© : Si vous cr√©ez int[] tab = new int[3], vous ne pourrez jamais y mettre un 4e √©l√©ment. Pour ‚Äúagrandir‚Äù un tableau, il faut en cr√©er un nouveau, copier les donn√©es, puis ajouter le nouvel √©l√©ment. C‚Äôest pourquoi nous utilisons les Collections pour les donn√©es dynamiques.",
    "tags": [],
    "title": "Tableaux et collections",
    "uri": "/420-413/tableaux_collections/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Table des mati√®res Introduction Syntaxe de base Param√®tres de m√©thodes Param√®tres par r√©f√©rence (ref) Param√®tres de sortie (out) Param√®tres optionnels Surcharge de m√©thodes Port√©e des variables Exercices Introduction Les m√©thodes (aussi appel√©es fonctions) sont des blocs de code r√©utilisables qui effectuent une t√¢che sp√©cifique. Elles permettent de :\nOrganiser le code de mani√®re logique √âviter la r√©p√©tition de code Faciliter la maintenance et la lecture du programme Diviser un probl√®me complexe en sous-probl√®mes plus simples Avantages des m√©thodes R√©utilisabilit√© : √âcrire une fois, utiliser plusieurs fois Lisibilit√© : Code plus clair et organis√© Maintenance : Plus facile de corriger ou modifier le code Tests : Plus facile de tester des petites unit√©s de code Syntaxe de base Structure d‚Äôune m√©thode modificateurAcces [static] typeRetour NomMethode(typeParam1 param1, typeParam2 param2) { // Corps de la m√©thode // Instructions √† ex√©cuter return valeur; // Si la m√©thode retourne une valeur } Composantes :\nmodificateurAcces : Contr√¥le la visibilit√© de la m√©thode (public, private, protected, internal) static : Indique que la m√©thode appartient √† la classe, pas √† une instance (obligatoire pour l‚Äôinstant) typeRetour : Le type de donn√©es que la m√©thode retourne (int, string, double, void, etc.) NomMethode : Le nom de la m√©thode (convention : commence par une majuscule en C#) Param√®tres : Les donn√©es d‚Äôentr√©e (optionnels) Corps : Le code qui s‚Äôex√©cute quand la m√©thode est appel√©e return : Retourne une valeur (sauf si void) Les modificateurs d‚Äôacc√®s Modificateur Description Utilisation public Accessible partout Pour les m√©thodes utilis√©es par d‚Äôautres classes private Accessible seulement dans la classe actuelle Pour les m√©thodes internes (par d√©faut) protected Accessible dans la classe et ses classes d√©riv√©es Pour l‚Äôh√©ritage (POO) internal Accessible dans le m√™me assembly Pour les m√©thodes partag√©es dans un projet Note : Pour l‚Äôinstant, nous utilisons principalement static avec nos m√©thodes car nous ne travaillons pas encore avec la programmation orient√©e objet. Les m√©thodes static peuvent √™tre appel√©es directement sans cr√©er d‚Äôobjet.\nExemples de d√©clarations de m√©thodes // M√©thode publique statique qui retourne un entier public static int CalculerSomme(int a, int b) { return a + b; } // M√©thode priv√©e statique qui ne retourne rien (void) private static void AfficherMessage() { Console.WriteLine(\"Message priv√©\"); } // M√©thode publique statique avec plusieurs param√®tres public static double CalculerMoyenne(double note1, double note2, double note3) { return (note1 + note2 + note3) / 3; } // M√©thode publique statique sans param√®tres public static void AfficherBienvenue() { Console.WriteLine(\"Bienvenue!\"); } Exemple simple : M√©thode sans param√®tres using System; class Programme { public static void AfficherMessage() { Console.WriteLine(\"Bonjour du C√âGEP!\"); Console.WriteLine(\"Bienvenue dans le cours de C#\"); } static void Main() { AfficherMessage(); // Appel de la m√©thode AfficherMessage(); // On peut l'appeler plusieurs fois } } Sortie :\nBonjour du C√âGEP!\rBienvenue dans le cours de C#\rBonjour du C√âGEP!\rBienvenue dans le cours de C# Exemple : M√©thode avec retour using System; class Programme { public static int ObtenirAnneeActuelle() { return 2024; } static void Main() { int annee = ObtenirAnneeActuelle(); Console.WriteLine($\"Nous sommes en {annee}\"); } } Param√®tres de m√©thodes Les param√®tres permettent de passer des donn√©es √† une m√©thode.\nPassage par valeur (comportement par d√©faut) Quand vous passez une variable √† une m√©thode, C# cr√©e une copie de la valeur. Les modifications dans la m√©thode n‚Äôaffectent pas la variable originale.\nusing System; class Programme { public static void AugmenterNombre(int nombre) { nombre = nombre + 10; Console.WriteLine($\"Dans la m√©thode: {nombre}\"); } static void Main() { int valeur = 5; Console.WriteLine($\"Avant l'appel: {valeur}\"); AugmenterNombre(valeur); Console.WriteLine($\"Apr√®s l'appel: {valeur}\"); } } Sortie :\nAvant l'appel: 5\rDans la m√©thode: 15\rApr√®s l'appel: 5 Explication : La variable valeur n‚Äôa pas chang√© car la m√©thode a travaill√© avec une copie.\nExemple : Calculer l‚Äôaire d‚Äôun rectangle using System; class Programme { public static double CalculerAireRectangle(double longueur, double largeur) { double aire = longueur * largeur; return aire; } static void Main() { double resultat = CalculerAireRectangle(5.5, 3.2); Console.WriteLine($\"L'aire du rectangle est: {resultat:F2} m¬≤\"); // Appel avec d'autres valeurs resultat = CalculerAireRectangle(10.0, 7.5); Console.WriteLine($\"L'aire du rectangle est: {resultat:F2} m¬≤\"); } } Exemple : M√©thode avec plusieurs param√®tres using System; class Programme { public static void AfficherInfoEtudiant(string nom, string prenom, int age, double moyenne) { Console.WriteLine(\"=== FICHE √âTUDIANT ===\"); Console.WriteLine($\"Nom: {nom}\"); Console.WriteLine($\"Pr√©nom: {prenom}\"); Console.WriteLine($\"√Çge: {age} ans\"); Console.WriteLine($\"Moyenne: {moyenne:F1}%\"); Console.WriteLine(\"=====================\"); } static void Main() { AfficherInfoEtudiant(\"Tremblay\", \"Alice\", 19, 87.5); AfficherInfoEtudiant(\"Lavoie\", \"Bernard\", 20, 82.3); } } Param√®tres par r√©f√©rence (ref) Le mot-cl√© ref permet de passer une variable par r√©f√©rence plut√¥t que par valeur. Cela signifie que la m√©thode travaille directement avec la variable originale, pas avec une copie.\nCaract√©ristiques de ref La variable DOIT √™tre initialis√©e avant l‚Äôappel Les modifications dans la m√©thode affectent la variable originale Le mot-cl√© ref doit appara√Ætre √† la d√©finition ET √† l‚Äôappel de la m√©thode Syntaxe public static void NomMethode(ref int parametre) { parametre = parametre * 2; } // Appel int nombre = 10; NomMethode(ref nombre); // Utiliser 'ref' lors de l'appel Exemple : √âchanger deux valeurs using System; class Programme { public static void EchangerValeurs(ref int a, ref int b) { int temporaire = a; a = b; b = temporaire; Console.WriteLine($\"Dans la m√©thode - a: {a}, b: {b}\"); } static void Main() { int x = 10; int y = 20; Console.WriteLine($\"Avant l'√©change - x: {x}, y: {y}\"); EchangerValeurs(ref x, ref y); Console.WriteLine($\"Apr√®s l'√©change - x: {x}, y: {y}\"); } } Sortie :\nAvant l'√©change - x: 10, y: 20\rDans la m√©thode - a: 20, b: 10\rApr√®s l'√©change - x: 20, y: 10 Exemple : Doubler une valeur using System; class Programme { public static void DoublerValeur(ref int nombre) { nombre = nombre * 2; } static void Main() { int valeur = 15; Console.WriteLine($\"Valeur initiale: {valeur}\"); DoublerValeur(ref valeur); Console.WriteLine($\"Valeur apr√®s doublement: {valeur}\"); } } Sortie :\nValeur initiale: 15\rValeur apr√®s doublement: 30 Exemple : Modifier plusieurs valeurs using System; class Programme { public static void AppliquerTaxes(ref double prix, double tauxTPS, double tauxTVQ) { double tps = prix * tauxTPS; double tvq = prix * tauxTVQ; prix = prix + tps + tvq; } static void Main() { double prixProduit = 100.00; Console.WriteLine($\"Prix avant taxes: {prixProduit:C}\"); AppliquerTaxes(ref prixProduit, 0.05, 0.09975); Console.WriteLine($\"Prix apr√®s taxes: {prixProduit:C}\"); } } Param√®tres de sortie (out) Le mot-cl√© out est similaire √† ref, mais avec des diff√©rences importantes :\nDiff√©rences entre ref et out Caract√©ristique ref out Initialisation avant appel REQUISE Pas n√©cessaire Assignation dans la m√©thode Optionnelle OBLIGATOIRE Utilisation principale Modifier une valeur existante Retourner plusieurs valeurs Caract√©ristiques de out La variable N‚ÄôA PAS BESOIN d‚Äô√™tre initialis√©e avant l‚Äôappel La m√©thode DOIT assigner une valeur au param√®tre out Utilis√© principalement pour retourner plusieurs valeurs d‚Äôune m√©thode Le mot-cl√© out doit appara√Ætre √† la d√©finition ET √† l‚Äôappel Syntaxe public static void CalculerStatistiques(int[] nombres, out double moyenne, out int maximum) { // La m√©thode DOIT assigner des valeurs √† moyenne et maximum moyenne = ...; maximum = ...; } // Appel double moy; int max; CalculerStatistiques(tableau, out moy, out max); Exemple : Retourner plusieurs valeurs using System; class Programme { public static void CalculerRectangle(double longueur, double largeur, out double aire, out double perimetre) { aire = longueur * largeur; perimetre = 2 * (longueur + largeur); } static void Main() { double surfaceResultat; double perimetreResultat; CalculerRectangle(5.0, 3.0, out surfaceResultat, out perimetreResultat); Console.WriteLine($\"Aire: {surfaceResultat} m¬≤\"); Console.WriteLine($\"P√©rim√®tre: {perimetreResultat} m\"); } } Sortie :\nAire: 15 m¬≤\rP√©rim√®tre: 16 m D√©claration inline (C# 7.0+) Depuis C# 7.0, vous pouvez d√©clarer les variables out directement dans l‚Äôappel :\nusing System; class Programme { public static void DiviserAvecReste(int dividende, int diviseur, out int quotient, out int reste) { quotient = dividende / diviseur; reste = dividende % diviseur; } static void Main() { // D√©claration inline - plus concis! DiviserAvecReste(17, 5, out int q, out int r); Console.WriteLine($\"17 √∑ 5 = {q} reste {r}\"); } } Exemple : Statistiques d‚Äôun tableau using System; class Programme { public static void CalculerStatistiques(int[] nombres, out double moyenne, out int minimum, out int maximum) { // Calcul de la somme et moyenne int somme = 0; foreach (int nombre in nombres) { somme += nombre; } moyenne = (double)somme / nombres.Length; // Trouver min et max minimum = nombres[0]; maximum = nombres[0]; foreach (int nombre in nombres) { if (nombre \u003c minimum) minimum = nombre; if (nombre \u003e maximum) maximum = nombre; } } static void Main() { int[] notes = { 85, 92, 78, 95, 88, 76, 90 }; CalculerStatistiques(notes, out double moy, out int min, out int max); Console.WriteLine(\"=== STATISTIQUES DES NOTES ===\"); Console.WriteLine($\"Moyenne: {moy:F2}%\"); Console.WriteLine($\"Note minimale: {min}%\"); Console.WriteLine($\"Note maximale: {max}%\"); } } Exemple : Validation d‚Äôentr√©e avec TryParse La m√©thode TryParse utilise out pour retourner le r√©sultat de la conversion :\nusing System; class Programme { static void Main() { Console.Write(\"Entrez votre √¢ge: \"); string entree = Console.ReadLine(); // TryParse retourne true si la conversion r√©ussit // et met le r√©sultat dans la variable 'age' if (int.TryParse(entree, out int age)) { Console.WriteLine($\"Votre √¢ge est: {age} ans\"); if (age \u003e= 18) Console.WriteLine(\"Vous √™tes majeur\"); else Console.WriteLine(\"Vous √™tes mineur\"); } else { Console.WriteLine(\"Entr√©e invalide!\"); } } } Exemple : Analyse de cha√Æne using System; class Programme { public static bool ExtraireNomPrenom(string nomComplet, out string nom, out string prenom) { string[] parties = nomComplet.Split(' '); if (parties.Length \u003e= 2) { prenom = parties[0]; nom = parties[1]; return true; } else { nom = \"\"; prenom = \"\"; return false; } } static void Main() { string nomComplet = \"Alice Tremblay\"; if (ExtraireNomPrenom(nomComplet, out string n, out string p)) { Console.WriteLine($\"Pr√©nom: {p}\"); Console.WriteLine($\"Nom: {n}\"); } else { Console.WriteLine(\"Format invalide\"); } } } Param√®tres optionnels Les param√®tres optionnels ont des valeurs par d√©faut et peuvent √™tre omis lors de l‚Äôappel.\nR√®gles Les param√®tres optionnels doivent √™tre √† la fin de la liste de param√®tres Vous devez fournir une valeur par d√©faut Si omis lors de l‚Äôappel, la valeur par d√©faut est utilis√©e Syntaxe public static void NomMethode(int obligatoire, int optionnel = 10) { // Corps de la m√©thode } // Appels possibles NomMethode(5); // optionnel = 10 (valeur par d√©faut) NomMethode(5, 20); // optionnel = 20 Exemple : Afficher un message personnalis√© using System; class Programme { public static void AfficherBienvenue(string nom, string titre = \"√âtudiant\") { Console.WriteLine($\"Bonjour {titre} {nom}!\"); } static void Main() { AfficherBienvenue(\"Alice\"); // Utilise \"√âtudiant\" par d√©faut AfficherBienvenue(\"Bernard\", \"Professeur\"); // Utilise \"Professeur\" AfficherBienvenue(\"Catherine\", \"Directrice\"); } } Sortie :\nBonjour √âtudiant Alice!\rBonjour Professeur Bernard!\rBonjour Directrice Catherine! Exemple : Calcul avec taux par d√©faut using System; class Programme { public static double CalculerPrixTotal(double prixBase, double tauxTaxe = 0.15) { return prixBase * (1 + tauxTaxe); } static void Main() { // Utilise le taux par d√©faut (15%) double total1 = CalculerPrixTotal(100.00); Console.WriteLine($\"Prix avec taxe par d√©faut: {total1:C}\"); // Sp√©cifie un taux diff√©rent double total2 = CalculerPrixTotal(100.00, 0.20); Console.WriteLine($\"Prix avec 20% de taxe: {total2:C}\"); } } Exemple : Affichage format√© using System; class Programme { public static void AfficherLigne(string texte, char caractere = '-', int longueur = 40) { Console.WriteLine(texte); Console.WriteLine(new string(caractere, longueur)); } static void Main() { AfficherLigne(\"Titre 1\"); // - et 40 par d√©faut AfficherLigne(\"Titre 2\", '='); // = et 40 AfficherLigne(\"Titre 3\", '*', 30); // * et 30 } } Sortie :\nTitre 1\r----------------------------------------\rTitre 2\r========================================\rTitre 3\r****************************** Surcharge de m√©thodes La surcharge (overloading) permet d‚Äôavoir plusieurs m√©thodes avec le m√™me nom mais des signatures diff√©rentes.\nQu‚Äôest-ce qu‚Äôune signature? La signature d‚Äôune m√©thode inclut :\nLe nom de la m√©thode Le nombre de param√®tres Le type des param√®tres L‚Äôordre des param√®tres Note : Le type de retour ne fait PAS partie de la signature.\nExemple : Calculer l‚Äôaire de diff√©rentes formes using System; class Programme { // Aire d'un carr√© public static double CalculerAire(double cote) { return cote * cote; } // Aire d'un rectangle public static double CalculerAire(double longueur, double largeur) { return longueur * largeur; } // Aire d'un cercle public static double CalculerAire(double rayon, bool estCercle) { return Math.PI * rayon * rayon; } static void Main() { double aireCarre = CalculerAire(5.0); Console.WriteLine($\"Aire du carr√©: {aireCarre:F2} m¬≤\"); double aireRectangle = CalculerAire(5.0, 3.0); Console.WriteLine($\"Aire du rectangle: {aireRectangle:F2} m¬≤\"); double aireCercle = CalculerAire(4.0, true); Console.WriteLine($\"Aire du cercle: {aireCercle:F2} m¬≤\"); } } Exemple : Afficher diff√©rents types using System; class Programme { public static void Afficher(int nombre) { Console.WriteLine($\"Nombre entier: {nombre}\"); } public static void Afficher(double nombre) { Console.WriteLine($\"Nombre d√©cimal: {nombre:F2}\"); } public static void Afficher(string texte) { Console.WriteLine($\"Texte: {texte}\"); } public static void Afficher(int[] tableau) { Console.Write(\"Tableau: \"); foreach (int n in tableau) { Console.Write($\"{n} \"); } Console.WriteLine(); } static void Main() { Afficher(42); Afficher(3.14159); Afficher(\"Bonjour!\"); Afficher(new int[] { 1, 2, 3, 4, 5 }); } } Exemple : Cr√©er un message de bienvenue using System; class Programme { // Version simple public static string CreerBienvenue(string nom) { return $\"Bienvenue {nom}!\"; } // Version avec pr√©nom et nom public static string CreerBienvenue(string prenom, string nom) { return $\"Bienvenue {prenom} {nom}!\"; } // Version avec titre public static string CreerBienvenue(string prenom, string nom, string titre) { return $\"Bienvenue {titre} {prenom} {nom}!\"; } static void Main() { Console.WriteLine(CreerBienvenue(\"Alice\")); Console.WriteLine(CreerBienvenue(\"Alice\", \"Tremblay\")); Console.WriteLine(CreerBienvenue(\"Alice\", \"Tremblay\", \"Dr.\")); } } Port√©e des variables La port√©e (scope) d‚Äôune variable d√©termine o√π elle peut √™tre utilis√©e dans le code.\nVariables locales Les variables d√©clar√©es √† l‚Äôint√©rieur d‚Äôune m√©thode sont locales √† cette m√©thode.\nusing System; class Programme { public static void Methode1() { int x = 10; // Variable locale √† Methode1 Console.WriteLine($\"Dans Methode1: x = {x}\"); } public static void Methode2() { int x = 20; // Variable diff√©rente, locale √† Methode2 Console.WriteLine($\"Dans Methode2: x = {x}\"); } static void Main() { Methode1(); Methode2(); // Console.WriteLine(x); // ERREUR: x n'existe pas ici } } Port√©e de bloc Les variables d√©clar√©es dans un bloc { } ne sont visibles que dans ce bloc.\nusing System; class Programme { static void Main() { int nombre = 10; if (nombre \u003e 5) { int resultat = nombre * 2; // Variable locale au bloc if Console.WriteLine($\"R√©sultat: {resultat}\"); } // Console.WriteLine(resultat); // ERREUR: resultat n'existe plus for (int i = 0; i \u003c 3; i++) // i existe seulement dans le for { Console.WriteLine($\"i = {i}\"); } // Console.WriteLine(i); // ERREUR: i n'existe plus } } Exemple : Port√©e et m√©thodes using System; class Programme { public static int CalculerCarre(int nombre) { int resultat = nombre * nombre; // Variable locale return resultat; } static void Main() { int valeur = 5; int carre = CalculerCarre(valeur); Console.WriteLine($\"Le carr√© de {valeur} est {carre}\"); // Console.WriteLine(resultat); // ERREUR: resultat est local √† CalculerCarre } } Bonnes pratiques 1. Nommage des m√©thodes Utilisez des verbes qui d√©crivent l‚Äôaction Commencez par une majuscule (convention C#) Soyez descriptif // Bon public static void CalculerMoyenne() public static bool VerifierAge() public static string ObtenirNomComplet() // √Ä √©viter public static void calc() public static bool check() public static string get() 2. Une m√©thode = une t√¢che Chaque m√©thode devrait faire une seule chose et la faire bien.\n// Bon - une m√©thode par t√¢che public static double CalculerMoyenne(int[] notes) { // Calcule seulement la moyenne } public static void AfficherResultats(double moyenne) { // Affiche seulement les r√©sultats } // Moins bon - fait trop de choses public static void CalculerEtAfficher(int[] notes) { // Calcule ET affiche } 3. Limiter le nombre de param√®tres Si une m√©thode a trop de param√®tres (plus de 4-5), consid√©rez regrouper les donn√©es.\n// Peut devenir difficile √† g√©rer public static void CreerEtudiant(string nom, string prenom, int age, string adresse, string telephone, string courriel) { // Beaucoup de param√®tres! } 4. Utiliser des noms de param√®tres significatifs // Bon public static double CalculerPrixTotal(double prixBase, double tauxTaxe) { return prixBase * (1 + tauxTaxe); } // Moins clair public static double Calculer(double p, double t) { return p * (1 + t); } R√©capitulatif : ref vs out Utilisez ref quand : Vous voulez modifier une valeur existante La variable doit √™tre initialis√©e avant l‚Äôappel Vous voulez que les changements affectent la variable originale Utilisez out quand : Vous voulez retourner plusieurs valeurs d‚Äôune m√©thode La variable n‚Äôa pas besoin d‚Äô√™tre initialis√©e avant l‚Äôappel La m√©thode va cr√©er/calculer une nouvelle valeur Tableau comparatif Aspect Passage par valeur ref out Initialisation requise Non Oui Non Modifie l‚Äôoriginal Non Oui Oui Doit assigner dans m√©thode Non Non Oui Usage principal Donner des donn√©es Modifier des donn√©es Retourner plusieurs valeurs Exercices Exercice 1 : M√©thode simple Difficult√© : Facile\nCr√©ez une m√©thode AfficherTableMultiplication qui prend un nombre en param√®tre et affiche sa table de multiplication de 1 √† 10.\nExemple de sortie pour le nombre 5 :\n5 x 1 = 5\r5 x 2 = 10\r5 x 3 = 15\r...\r5 x 10 = 50 Exercice 2 : M√©thode avec retour Difficult√© : Facile\nCr√©ez une m√©thode EstPair qui prend un nombre entier en param√®tre et retourne true s‚Äôil est pair, false sinon.\nIndice : Un nombre est pair si nombre % 2 == 0\nExercice 3 : M√©thode avec plusieurs param√®tres Difficult√© : Facile\nCr√©ez une m√©thode CalculerMoyenne qui prend trois notes (double) en param√®tres et retourne leur moyenne.\nExercice 4 : Utilisation de ref Difficult√© : Moyenne\nCr√©ez une m√©thode AugmenterDe10Pourcent qui prend un prix en param√®tre (ref double) et l‚Äôaugmente de 10%.\nTestez avec un prix initial de 100.00$ et v√©rifiez que la variable originale est bien modifi√©e.\nExercice 5 : Utilisation de out - Division Difficult√© : Moyenne\nCr√©ez une m√©thode DiviserEntiers qui prend deux entiers (dividende et diviseur) et retourne le quotient ET le reste en utilisant des param√®tres out.\nExemple : 17 divis√© par 5 donne quotient = 3 et reste = 2\nIndice : Utilisez les op√©rateurs / pour le quotient et % pour le reste.\nExercice 6 : Utilisation de out - Statistiques Difficult√© : Moyenne\nCr√©ez une m√©thode AnalyserTableau qui prend un tableau d‚Äôentiers et retourne (via out) :\nLa somme de tous les √©l√©ments La moyenne Le nombre d‚Äô√©l√©ments Testez avec le tableau : {10, 20, 30, 40, 50}\nExercice 7 : Param√®tres optionnels Difficult√© : Moyenne\nCr√©ez une m√©thode AfficherFacture qui prend :\nLe montant (obligatoire) Le taux de TPS (optionnel, d√©faut = 0.05) Le taux de TVQ (optionnel, d√©faut = 0.09975) La m√©thode calcule et affiche le montant avant taxes, les taxes, et le total.\nExercice 8 : Surcharge de m√©thodes Difficult√© : Moyenne\nCr√©ez trois versions surcharg√©es d‚Äôune m√©thode CalculerVolume :\nVolume d‚Äôun cube : CalculerVolume(double cote) Volume d‚Äôun parall√©l√©pip√®de : CalculerVolume(double longueur, double largeur, double hauteur) Volume d‚Äôun cylindre : CalculerVolume(double rayon, double hauteur, bool estCylindre) Formules :\nCube : c√¥t√©¬≥ Parall√©l√©pip√®de : longueur √ó largeur √ó hauteur Cylindre : œÄ √ó rayon¬≤ √ó hauteur Exercice 9 : Validation avec TryParse Difficult√© : Moyenne\nCr√©ez un programme qui demande √† l‚Äôutilisateur d‚Äôentrer un nombre. Utilisez int.TryParse avec un param√®tre out pour valider l‚Äôentr√©e. Si l‚Äôentr√©e est valide, affichez le carr√© du nombre. Sinon, affichez un message d‚Äôerreur.\nExercice 10 : Calculatrice simple Difficult√© : Difficile\nCr√©ez les m√©thodes suivantes pour une calculatrice :\nAdditionner(double a, double b) - retourne a + b Soustraire(double a, double b) - retourne a - b Multiplier(double a, double b) - retourne a √ó b Diviser(double a, double b, out bool succes) - retourne a √∑ b et indique si la division a r√©ussi (pas de division par z√©ro) Cr√©ez un menu qui permet √† l‚Äôutilisateur de choisir une op√©ration et d‚Äôentrer deux nombres.\nExercice 11 : Analyse de texte Difficult√© : Difficile\nCr√©ez une m√©thode AnalyserTexte qui prend une cha√Æne de caract√®res et retourne (via out) :\nLe nombre de caract√®res Le nombre de mots Le nombre de voyelles Indice : Utilisez .Split(' ') pour s√©parer les mots, et une boucle pour compter les voyelles (a, e, i, o, u).\nExercice 12 : Conversion de temp√©rature Difficult√© : Difficile\nCr√©ez les m√©thodes suivantes avec surcharge :\nConvertirTemperature(double celsius) - convertit Celsius ‚Üí Fahrenheit ConvertirTemperature(double fahrenheit, bool versCelsius) - convertit Fahrenheit ‚Üí Celsius Puis cr√©ez une m√©thode ConvertirAvecValidation qui utilise un param√®tre out bool pour indiquer si la temp√©rature est physiquement possible (au-dessus du z√©ro absolu : -273.15¬∞C ou -459.67¬∞F).\nFormules :\nC ‚Üí F : (C √ó 9/5) + 32 F ‚Üí C : (F - 32) √ó 5/9 Conclusion Les m√©thodes sont un outil fondamental en programmation. Vous avez appris :\n‚úÖ Syntaxe de base : Comment cr√©er et appeler des m√©thodes\n‚úÖ Param√®tres : Passage par valeur vs passage par r√©f√©rence\n‚úÖ ref : Modifier des variables existantes\n‚úÖ out : Retourner plusieurs valeurs\n‚úÖ Param√®tres optionnels : Valeurs par d√©faut\n‚úÖ Surcharge : Plusieurs m√©thodes avec le m√™me nom\n‚úÖ Port√©e : O√π les variables sont accessibles\nConcepts cl√©s √† retenir Une m√©thode = une t√¢che : Gardez vos m√©thodes simples et cibl√©es Nommage clair : Le nom doit d√©crire ce que fait la m√©thode ref pour modifier, out pour retourner : Choisissez selon votre besoin R√©utilisabilit√© : √âcrivez une fois, utilisez plusieurs fois",
    "description": "Table des mati√®res Introduction Syntaxe de base Param√®tres de m√©thodes Param√®tres par r√©f√©rence (ref) Param√®tres de sortie (out) Param√®tres optionnels Surcharge de m√©thodes Port√©e des variables Exercices Introduction Les m√©thodes (aussi appel√©es fonctions) sont des blocs de code r√©utilisables qui effectuent une t√¢che sp√©cifique. Elles permettent de :",
    "tags": [],
    "title": "Les m√©thodes en c#",
    "uri": "/420-413/methodes/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Premi√®re partie 1 : Calculatrice Simple Concepts pratiqu√©s : Variables, op√©rateurs arithm√©tiques, types num√©riques\nDescription : Cr√©ez un programme qui demande √† l‚Äôutilisateur deux nombres et une op√©ration (+, -, *, /), puis affiche le r√©sultat.\nFonctionnalit√©s requises :\nDemander deux nombres d√©cimaux √† l‚Äôutilisateur Demander l‚Äôop√©ration souhait√©e Effectuer le calcul appropri√© Afficher le r√©sultat avec 2 d√©cimales G√©rer la division par z√©ro Exemple d‚Äôex√©cution :\nEntrez le premier nombre : 15.5\rEntrez le deuxi√®me nombre : 3.2\rChoisissez l'op√©ration (+, -, *, /) : *\rR√©sultat : 15.5 * 3.2 = 49.60 2 : Convertisseur de Temp√©rature Concepts pratiqu√©s : Variables, op√©rateurs, formules math√©matiques, casting\nDescription : D√©veloppez un convertisseur qui transforme une temp√©rature de Celsius vers Fahrenheit et Kelvin.\nFonctionnalit√©s requises :\nDemander une temp√©rature en Celsius Calculer l‚Äô√©quivalent en Fahrenheit : F = (C √ó 9/5) + 32 Calculer l‚Äô√©quivalent en Kelvin : K = C + 273.15 Afficher les trois temp√©ratures avec 2 d√©cimales Exemple d‚Äôex√©cution :\nEntrez la temp√©rature en Celsius : 25\r25.00¬∞C = 77.00¬∞F = 298.15K 3 : V√©rificateur de Nombre Pair ou Impair Concepts pratiqu√©s : Variables, op√©rateur modulo, structure if/else\nDescription : Cr√©ez un programme qui d√©termine si un nombre entier est pair ou impair.\nFonctionnalit√©s requises :\nDemander un nombre entier √† l‚Äôutilisateur Utiliser l‚Äôop√©rateur modulo (%) pour v√©rifier la parit√© Afficher si le nombre est pair ou impair Bonus : indiquer si le nombre est positif, n√©gatif ou z√©ro Exemple d‚Äôex√©cution :\nEntrez un nombre entier : 42\rLe nombre 42 est pair et positif. 4 : Calculateur d‚ÄôIMC (Indice de Masse Corporelle) Concepts pratiqu√©s : Variables, op√©rateurs, structures de contr√¥le if/else if\nDescription : D√©veloppez un calculateur d‚ÄôIMC qui cat√©gorise le r√©sultat selon les normes de sant√©.\nFonctionnalit√©s requises :\nDemander le poids en kg et la taille en m√®tres Calculer l‚ÄôIMC : IMC = poids / (taille √ó taille) Cat√©goriser le r√©sultat : Moins de 18.5 : Insuffisance pond√©rale 18.5 √† 24.9 : Poids normal 25 √† 29.9 : Surpoids 30 ou plus : Ob√©sit√© Afficher l‚ÄôIMC et la cat√©gorie Exemple d‚Äôex√©cution :\nEntrez votre poids (kg) : 70\rEntrez votre taille (m) : 1.75\rVotre IMC est de 22.86 - Poids normal 5 : Jeu du Plus ou Moins Concepts pratiqu√©s : Variables, Random, boucles while, structures if/else\nDescription : Cr√©ez un jeu o√π l‚Äôordinateur choisit un nombre al√©atoire entre 1 et 100, et l‚Äôutilisateur doit le deviner.\nFonctionnalit√©s requises :\nG√©n√©rer un nombre al√©atoire entre 1 et 100 Utiliser une boucle pour permettre plusieurs tentatives Indiquer si la proposition est trop haute ou trop basse Compter le nombre de tentatives Afficher un message de victoire avec le nombre de coups Exemple d‚Äôex√©cution :\nJ'ai choisi un nombre entre 1 et 100. Devinez !\rVotre proposition : 50\rTrop bas !\rVotre proposition : 75\rTrop haut !\rVotre proposition : 63\rBravo ! Vous avez trouv√© en 3 coups ! 6 : Calculateur de Facture avec Pourboire Concepts pratiqu√©s : Variables, op√©rateurs, types d√©cimaux, formatage\nDescription : D√©veloppez un programme qui calcule le montant total d‚Äôune facture incluant taxes et pourboire.\nFonctionnalit√©s requises :\nDemander le montant de base de la facture Demander le pourcentage de taxes (ex: 15%) Demander le pourcentage de pourboire (ex: 18%) Calculer le montant des taxes Calculer le montant du pourboire (sur le sous-total avec taxes) Afficher le d√©tail complet de la facture Exemple d‚Äôex√©cution :\nMontant de base : 50.00$\rPourcentage de taxes : 15\rPourcentage de pourboire : 18\r--- Facture d√©taill√©e ---\rMontant de base : 50.00$\rTaxes (15%) : 7.50$\rSous-total : 57.50$\rPourboire (18%) : 10.35$\rTOTAL √Ä PAYER : 67.85$ 7 : Validateur de Mot de Passe Concepts pratiqu√©s : Variables string, op√©rateurs logiques, structures if/else, m√©thodes de string\nDescription : Cr√©ez un validateur qui v√©rifie si un mot de passe respecte certains crit√®res de s√©curit√©.\nFonctionnalit√©s requises :\nDemander un mot de passe √† l‚Äôutilisateur V√©rifier que le mot de passe : Contient au moins 8 caract√®res Contient au moins une majuscule Contient au moins une minuscule Contient au moins un chiffre Afficher si le mot de passe est valide ou non Lister les crit√®res non respect√©s Exemple d‚Äôex√©cution :\nEntrez un mot de passe : Hello123\r‚úì Au moins 8 caract√®res\r‚úì Contient une majuscule\r‚úì Contient une minuscule\r‚úì Contient un chiffre\rMot de passe valide ! 8 : Chronom√©treur de Temps de R√©action Concepts pratiqu√©s : Variables, Random, DateTime, boucles, op√©rateurs de comparaison\nDescription : D√©veloppez un mini-jeu qui teste le temps de r√©action de l‚Äôutilisateur.\nFonctionnalit√©s requises :\nAfficher ‚ÄúPr√©parez-vous‚Ä¶‚Äù Attendre un d√©lai al√©atoire (2 √† 5 secondes) Afficher ‚ÄúMAINTENANT !‚Äù et enregistrer l‚Äôheure Attendre que l‚Äôutilisateur appuie sur Entr√©e Calculer et afficher le temps de r√©action en millisecondes Proposer de rejouer Exemple d‚Äôex√©cution :\nPr√©parez-vous...\rMAINTENANT !\r[utilisateur appuie sur Entr√©e]\rVotre temps de r√©action : 342 ms\rExcellent !\rVoulez-vous rejouer ? (o/n) 9 : Convertisseur de Devises Concepts pratiqu√©s : Variables, op√©rateurs, switch/case, types d√©cimaux\nDescription : Cr√©ez un convertisseur qui transforme un montant en dollars canadiens vers diff√©rentes devises.\nFonctionnalit√©s requises :\nDemander un montant en CAD Proposer plusieurs devises (USD, EUR, GBP, JPY) Utiliser un switch pour s√©lectionner le taux de change appropri√© Calculer et afficher la conversion Utiliser des taux de change r√©alistes Exemple d‚Äôex√©cution :\nMontant en CAD : 100\rChoisissez la devise :\r1. USD (Dollar am√©ricain)\r2. EUR (Euro)\r3. GBP (Livre sterling)\r4. JPY (Yen japonais)\rVotre choix : 1\r100.00 CAD = 72.50 USD 10 : Calculateur de Note Finale Concepts pratiqu√©s : Variables, op√©rateurs, structures if/else, moyenne pond√©r√©e\nDescription : D√©veloppez un programme qui calcule la note finale d‚Äôun √©tudiant selon diff√©rents crit√®res pond√©r√©s.\nFonctionnalit√©s requises :\nDemander les notes pour : Examens (40% de la note finale) Devoirs (30% de la note finale) Participation (10% de la note finale) final (20% de la note finale) Calculer la note finale pond√©r√©e D√©terminer la cote (A+, A, B+, B, C+, C, D, E) Indiquer si l‚Äô√©tudiant a r√©ussi (60% et plus) Exemple d‚Äôex√©cution :\nNote des examens (sur 100) : 85\rNote des devoirs (sur 100) : 78\rNote de participation (sur 100) : 92\rNote du final (sur 100) : 88\r--- R√©sultat final ---\rNote finale : 84.2 / 100\rCote : A\rStatut : R√©ussite 11 : Simulateur de D√©s Concepts pratiqu√©s : Variables, Random, boucles for, op√©rateurs\nDescription : Cr√©ez un simulateur qui lance plusieurs d√©s et calcule des statistiques.\nFonctionnalit√©s requises :\nDemander le nombre de d√©s √† lancer (1-10) Demander le nombre de faces par d√© (4, 6, 8, 12, 20) Lancer tous les d√©s Afficher le r√©sultat de chaque d√© Calculer et afficher la somme totale Afficher le r√©sultat minimum et maximum obtenu Exemple d‚Äôex√©cution :\nNombre de d√©s : 3\rNombre de faces : 6\rLancer des d√©s...\rD√© 1 : 4\rD√© 2 : 6\rD√© 3 : 2\rSomme totale : 12\rMinimum : 2\rMaximum : 6 12 : Compteur de Voyelles et Consonnes Concepts pratiqu√©s : Variables string, boucles foreach, switch/case, op√©rateurs\nDescription : D√©veloppez un programme qui analyse une phrase et compte les voyelles et consonnes.\nFonctionnalit√©s requises :\nDemander une phrase √† l‚Äôutilisateur Parcourir chaque caract√®re de la phrase Compter les voyelles (a, e, i, o, u, y - majuscules et minuscules) Compter les consonnes Compter les espaces et caract√®res sp√©ciaux Afficher les statistiques compl√®tes Exemple d‚Äôex√©cution :\nEntrez une phrase : Bonjour le monde!\r--- Analyse ---\rVoyelles : 6\rConsonnes : 8\rEspaces : 2\rAutres caract√®res : 1\rTotal de caract√®res : 17 13 : G√©n√©rateur de Tables de Multiplication Concepts pratiqu√©s : Variables, boucles for imbriqu√©es, op√©rateurs, formatage\nDescription : Cr√©ez un programme qui g√©n√®re et affiche des tables de multiplication.\nFonctionnalit√©s requises :\nDemander quel nombre de table l‚Äôutilisateur veut voir (1-12) Demander jusqu‚Äô√† quel multiplicateur (g√©n√©ralement 10 ou 12) Utiliser une boucle pour g√©n√©rer la table Afficher la table de mani√®re format√©e et lisible Bonus : afficher plusieurs tables c√¥te √† c√¥te Exemple d‚Äôex√©cution :\nTable de multiplication de : 7\rJusqu'√† : 10\r7 x 1 = 7\r7 x 2 = 14\r7 x 3 = 21\r7 x 4 = 28\r7 x 5 = 35\r7 x 6 = 42\r7 x 7 = 49\r7 x 8 = 56\r7 x 9 = 63\r7 x 10 = 70 14 : Calculateur d‚Äô√Çge Pr√©cis Concepts pratiqu√©s : Variables, DateTime, op√©rateurs, structures if/else\nDescription : D√©veloppez un programme qui calcule l‚Äô√¢ge pr√©cis d‚Äôune personne en ann√©es, mois et jours.\nFonctionnalit√©s requises :\nDemander la date de naissance (jour, mois, ann√©e) Utiliser DateTime pour les calculs Calculer l‚Äô√¢ge en ann√©es, mois et jours Calculer le nombre total de jours v√©cus Calculer le jour de la semaine de la naissance Afficher le prochain anniversaire Exemple d‚Äôex√©cution :\nDate de naissance\rJour : 15\rMois : 3\rAnn√©e : 2005\rVous avez 20 ans, 10 mois et 15 jours\rTotal de jours v√©cus : 7625 jours\rVous √™tes n√©(e) un mardi\rProchain anniversaire : dans 136 jours 15 : D√©tecteur de Nombre Premier Concepts pratiqu√©s : Variables, boucles for, op√©rateurs, structures if/else\nDescription : Cr√©ez un programme qui d√©termine si un nombre est premier et trouve tous les nombres premiers dans une plage.\nFonctionnalit√©s requises :\nDemander un nombre √† l‚Äôutilisateur V√©rifier s‚Äôil est premier (divisible seulement par 1 et lui-m√™me) Afficher tous les diviseurs du nombre Option : afficher tous les nombres premiers jusqu‚Äô√† ce nombre Optimiser l‚Äôalgorithme (v√©rifier jusqu‚Äô√† la racine carr√©e) Exemple d‚Äôex√©cution :\nEntrez un nombre : 17\rLe nombre 17 est PREMIER\rDiviseurs : 1, 17\rVoulez-vous voir tous les nombres premiers jusqu'√† 17 ? (o/n) : o\r2, 3, 5, 7, 11, 13, 17\rTotal : 7 nombres premiers 16 : Simulateur de Distributeur Bancaire Concepts pratiqu√©s : Variables, switch/case, boucles while, op√©rateurs\nDescription : D√©veloppez un simulateur de guichet automatique avec un menu et des op√©rations bancaires de base.\nFonctionnalit√©s requises :\nD√©finir un solde initial (ex: 1000$) Cr√©er un menu avec options : Consulter le solde D√©poser de l‚Äôargent Retirer de l‚Äôargent Quitter V√©rifier que les retraits n‚Äôexc√®dent pas le solde Utiliser une boucle pour r√©p√©ter le menu Afficher l‚Äôhistorique des transactions Exemple d‚Äôex√©cution :\n=== Guichet Automatique ===\r1. Consulter le solde\r2. D√©poser\r3. Retirer\r4. Quitter\rVotre choix : 3\rMontant √† retirer : 50\rRetrait effectu√©. Nouveau solde : 950.00$ 17 : Convertisseur Binaire/D√©cimal Concepts pratiqu√©s : Variables, boucles while, op√©rateurs, types num√©riques\nDescription : Cr√©ez un convertisseur bidirectionnel entre nombres d√©cimaux et binaires.\nFonctionnalit√©s requises :\nProposer deux options : D√©cimal vers binaire Binaire vers d√©cimal Pour d√©cimal vers binaire : utiliser la division successive par 2 Pour binaire vers d√©cimal : utiliser les puissances de 2 Afficher les √©tapes de conversion Valider que l‚Äôentr√©e binaire contient seulement 0 et 1 Exemple d‚Äôex√©cution :\n1. D√©cimal vers Binaire\r2. Binaire vers D√©cimal\rVotre choix : 1\rEntrez un nombre d√©cimal : 42\rConversion de 42 en binaire :\r42 √∑ 2 = 21 reste 0\r21 √∑ 2 = 10 reste 1\r10 √∑ 2 = 5 reste 0\r5 √∑ 2 = 2 reste 1\r2 √∑ 2 = 1 reste 0\r1 √∑ 2 = 0 reste 1\rR√©sultat : 42 (d√©cimal) = 101010 (binaire) 18 : Jeu de Pierre-Papier-Ciseaux Concepts pratiqu√©s : Variables, Random, switch/case, structures de contr√¥le, boucles\nDescription : D√©veloppez le jeu classique Pierre-Papier-Ciseaux contre l‚Äôordinateur avec score.\nFonctionnalit√©s requises :\nCr√©er un menu avec les 3 choix possibles G√©n√©rer un choix al√©atoire pour l‚Äôordinateur D√©terminer le gagnant selon les r√®gles : Pierre bat Ciseaux Ciseaux bat Papier Papier bat Pierre Tenir un score (victoires, d√©faites, √©galit√©s) Permettre de jouer plusieurs parties Afficher le score final Exemple d‚Äôex√©cution :\n=== Pierre-Papier-Ciseaux ===\r1. Pierre\r2. Papier\r3. Ciseaux\rVotre choix : 1\rVous : Pierre\rOrdinateur : Ciseaux\rVous gagnez !\rScore - Vous: 1 | Ordi: 0 | √âgalit√©s: 0\rRejouer ? (o/n) 19 : Calculateur de Moyenne Mobile Concepts pratiqu√©s : Variables, boucles for, op√©rateurs, types num√©riques\nDescription : Cr√©ez un programme qui calcule la moyenne d‚Äôune s√©rie de nombres entr√©s par l‚Äôutilisateur.\nFonctionnalit√©s requises :\nDemander combien de nombres l‚Äôutilisateur veut entrer Utiliser une boucle pour saisir chaque nombre Calculer la moyenne, le minimum et le maximum Calculer l‚Äô√©cart-type (bonus) Afficher tous les nombres au-dessus et en-dessous de la moyenne Exemple d‚Äôex√©cution :\nCombien de nombres : 5\rNombre 1 : 12\rNombre 2 : 15\rNombre 3 : 8\rNombre 4 : 20\rNombre 5 : 10\r--- Statistiques ---\rMoyenne : 13.00\rMinimum : 8\rMaximum : 20\rNombres au-dessus de la moyenne : 15, 20\rNombres en-dessous de la moyenne : 12, 8, 10 20 : G√©n√©rateur de Calendrier Mensuel Concepts pratiqu√©s : Variables, DateTime, boucles, structures if/else, formatage\nDescription : D√©veloppez un programme qui affiche le calendrier d‚Äôun mois donn√©.\nFonctionnalit√©s requises :\nDemander le mois et l‚Äôann√©e D√©terminer le premier jour du mois (lundi, mardi, etc.) Calculer le nombre de jours dans le mois Afficher le calendrier format√© avec les jours de la semaine Mettre en √©vidence le jour actuel si c‚Äôest le mois en cours Bonus : marquer les fins de semaine diff√©remment Exemple d‚Äôex√©cution :\nMois (1-12) : 2\rAnn√©e : 2026\rF√©vrier 2026\rDim Lun Mar Mer Jeu Ven Sam\r1 2 3 4 5 6 7\r8 9 10 11 12 13 14\r15 16 17 18 19 20 21\r22 23 24 25 26 27 28 s Avanc√©s Ces s int√®grent tableaux, collections (List, Dictionary), m√©thodes et tous les concepts pr√©c√©dents.\n21 : Gestionnaire de Liste de Courses Concepts pratiqu√©s : List, m√©thodes, boucles, switch/case\nDescription : Cr√©ez une application compl√®te pour g√©rer une liste de courses avec ajout, suppression et affichage.\nFonctionnalit√©s requises :\nCr√©er une List pour stocker les articles Menu avec options : Ajouter un article Supprimer un article Afficher la liste Rechercher un article Vider la liste Compter les articles Quitter Cr√©er des m√©thodes pour chaque fonctionnalit√© √âviter les doublons Trier la liste alphab√©tiquement (option) Structure sugg√©r√©e :\nstatic List\u003cstring\u003e listeDesCourses = new List\u003cstring\u003e(); static void AjouterArticle() static void SupprimerArticle() static void AfficherListe() static void RechercherArticle() Exemple d‚Äôex√©cution :\n=== Liste de Courses ===\r1. Ajouter un article\r2. Supprimer un article\r3. Afficher la liste\r4. Rechercher un article\r5. Vider la liste\r6. Quitter\rChoix : 1\rArticle √† ajouter : Lait\rArticle ajout√© ! Total : 1 article(s) 22 : Carnet d‚ÄôAdresses Concepts pratiqu√©s : Dictionary, m√©thodes, structures (ou classes), collections\nDescription : D√©veloppez un carnet d‚Äôadresses qui stocke nom, t√©l√©phone et courriel de plusieurs contacts.\nFonctionnalit√©s requises :\nUtiliser un Dictionary\u003cstring, Contact\u003e (nom comme cl√©) Cr√©er une structure Contact avec propri√©t√©s : Nom T√©l√©phone Courriel M√©thodes pour : Ajouter un contact Modifier un contact Supprimer un contact Rechercher un contact Afficher tous les contacts Afficher les contacts par ordre alphab√©tique Structure sugg√©r√©e :\nstruct Contact { public string Nom; public string Telephone; public string Courriel; } static Dictionary\u003cstring, Contact\u003e carnet = new Dictionary\u003cstring, Contact\u003e(); static void AjouterContact() static Contact RechercherContact(string nom) Exemple d‚Äôex√©cution :\n=== Carnet d'Adresses ===\r1. Ajouter un contact\r2. Rechercher\r3. Afficher tous\r4. Quitter\rChoix : 1\rNom : Jean Tremblay\rT√©l√©phone : 514-555-1234\rCourriel : jean@email.com\rContact ajout√© ! 23 : Analyseur de Texte Avanc√© Concepts pratiqu√©s : Tableaux, string methods, Dictionary, m√©thodes, LINQ\nDescription : Cr√©ez un analyseur qui effectue des statistiques d√©taill√©es sur un texte.\nFonctionnalit√©s requises :\nDemander un texte √† l‚Äôutilisateur (plusieurs phrases) Cr√©er des m√©thodes pour : Compter les mots Compter les phrases Calculer la longueur moyenne des mots Trouver le mot le plus long Compter la fr√©quence de chaque mot (Dictionary) Afficher les 5 mots les plus fr√©quents Ignorer la ponctuation et la casse pour le comptage M√©thodes sugg√©r√©es :\nstatic int CompterMots(string texte) static int CompterPhrases(string texte) static double LongueurMoyenneMots(string texte) static string TrouverMotLePlusLong(string texte) static Dictionary\u003cstring, int\u003e CompterFrequenceMots(string texte) static void AfficherTopMots(Dictionary\u003cstring, int\u003e frequences, int top) Exemple d‚Äôex√©cution :\nEntrez votre texte :\rLe chat est sur le tapis. Le chat dort.\r--- Analyse ---\rNombre de mots : 9\rNombre de phrases : 2\rLongueur moyenne des mots : 3.33 lettres\rMot le plus long : tapis (5 lettres)\rMots les plus fr√©quents :\r1. le (3 fois)\r2. chat (2 fois)\r3. est (1 fois)\r4. sur (1 fois)\r5. tapis (1 fois) 24 : Jeu du Pendu Concepts pratiqu√©s : Tableaux char, List, m√©thodes, string manipulation, Random\nDescription : D√©veloppez le jeu classique du pendu avec une banque de mots et gestion des vies.\nFonctionnalit√©s requises :\nCr√©er un tableau de mots √† deviner Choisir un mot al√©atoirement Utiliser un tableau de char pour le mot masqu√© G√©rer une List pour les lettres d√©j√† propos√©es Compter les erreurs (maximum 6) Cr√©er des m√©thodes pour : Afficher le mot masqu√© V√©rifier si une lettre est dans le mot Afficher le dessin du pendu selon les erreurs V√©rifier si le jeu est gagn√©/perdu M√©thodes sugg√©r√©es :\nstatic string[] banqueDeMots = { \"programmation\", \"ordinateur\", \"clavier\" }; static List\u003cchar\u003e lettresProposees = new List\u003cchar\u003e(); static string ChoisirMotAleatoire() static void AfficherMotMasque(string mot) static bool VerifierLettre(string mot, char lettre) static void DessinerPendu(int erreurs) static bool EstMotTrouve(string mot) Exemple d‚Äôex√©cution :\n=== Jeu du Pendu ===\rMot √† deviner : _ _ _ _ _ _ _ _ _ _ _ (11 lettres)\rErreurs : 0/6\rProposez une lettre : e\rBien jou√© !\rMot : _ _ _ _ _ _ _ _ _ _ e 25 : Gestionnaire de Notes d‚Äô√âtudiants Concepts pratiqu√©s : Dictionary, List, m√©thodes, structures/classes, calculs statistiques\nDescription : Cr√©ez un syst√®me complet pour g√©rer les notes de plusieurs √©tudiants dans plusieurs mati√®res.\nFonctionnalit√©s requises :\nUtiliser un Dictionary\u003cstring, Etudiant\u003e Cr√©er une classe/struct Etudiant avec : Nom Dictionary\u003cstring, double\u003e pour les notes par mati√®re M√©thodes pour : Ajouter un √©tudiant Ajouter une note pour une mati√®re Calculer la moyenne d‚Äôun √©tudiant Calculer la moyenne de classe pour une mati√®re Afficher le bulletin d‚Äôun √©tudiant Trouver le meilleur √©tudiant Afficher les statistiques g√©n√©rales Structure sugg√©r√©e :\nclass Etudiant { public string Nom { get; set; } public Dictionary\u003cstring, double\u003e Notes { get; set; } public double CalculerMoyenne() public void AfficherBulletin() } static Dictionary\u003cstring, Etudiant\u003e etudiants = new Dictionary\u003cstring, Etudiant\u003e(); static void AjouterEtudiant() static void AjouterNote() static double CalculerMoyenneClasse(string matiere) Exemple d‚Äôex√©cution :\n=== Gestionnaire de Notes ===\r1. Ajouter √©tudiant\r2. Ajouter note\r3. Bulletin √©tudiant\r4. Statistiques classe\r5. Quitter\rChoix : 3\rNom de l'√©tudiant : Marie Dubois\r--- Bulletin de Marie Dubois ---\rMath√©matiques : 85\rFran√ßais : 92\rSciences : 78\rMoyenne g√©n√©rale : 85.0 26 : Syst√®me de Playlist Musicale Concepts pratiqu√©s : List, m√©thodes, Random, manipulation de listes\nDescription : D√©veloppez un gestionnaire de playlist musicale avec lecture al√©atoire et r√©p√©tition.\nFonctionnalit√©s requises :\nCr√©er une List pour stocker les chansons M√©thodes pour : Ajouter une chanson Supprimer une chanson Afficher toute la playlist Lire la playlist en ordre Lire en mode al√©atoire (shuffle) Rechercher une chanson D√©placer une chanson (changer l‚Äôordre) Afficher le nombre total de chansons Vider la playlist Simuler la lecture avec un compteur de chansons jou√©es M√©thodes sugg√©r√©es :\nstatic List\u003cstring\u003e playlist = new List\u003cstring\u003e(); static Random rand = new Random(); static void AjouterChanson() static void SupprimerChanson() static void AfficherPlaylist() static void LireEnOrdre() static void LireAleatoire() static void DeplacerChanson(int indexDepart, int indexArrivee) Exemple d‚Äôex√©cution :\n=== Gestionnaire de Playlist ===\r1. Ajouter chanson\r2. Supprimer chanson\r3. Afficher playlist\r4. Lire en ordre\r5. Lire al√©atoire\r6. Quitter\rChoix : 3\r--- Ma Playlist (4 chansons) ---\r1. Bohemian Rhapsody - Queen\r2. Imagine - John Lennon\r3. Hotel California - Eagles\r4. Stairway to Heaven - Led Zeppelin\rChoix : 5\rMode lecture al√©atoire activ√©...\r‚ô™ Lecture : Hotel California - Eagles\r‚ô™ Lecture : Bohemian Rhapsody - Queen\r‚ô™ Lecture : Stairway to Heaven - Led Zeppelin\r‚ô™ Lecture : Imagine - John Lennon\rPlaylist termin√©e ! 27 : G√©n√©rateur et Analyseur de Statistiques Concepts pratiqu√©s : Tableaux, m√©thodes math√©matiques, Random, tri, calculs statistiques\nDescription : Cr√©ez un programme qui g√©n√®re des donn√©es al√©atoires et effectue des analyses statistiques compl√®tes.\nFonctionnalit√©s requises :\nG√©n√©rer un tableau de N nombres al√©atoires (10-100) Cr√©er des m√©thodes pour calculer : Moyenne M√©diane (valeur centrale apr√®s tri) Mode (valeur la plus fr√©quente) √âcart-type Minimum et maximum Premier et troisi√®me quartile Afficher un histogramme simple en console Cr√©er une m√©thode pour trier le tableau M√©thodes sugg√©r√©es :\nstatic double[] GenererDonnees(int taille, int min, int max) static double CalculerMoyenne(double[] donnees) static double CalculerMediane(double[] donnees) static double CalculerMode(double[] donnees) static double CalculerEcartType(double[] donnees) static void AfficherHistogramme(double[] donnees) static double[] TrierTableau(double[] donnees) Exemple d‚Äôex√©cution :\nG√©n√©ration de 20 nombres entre 1 et 100...\rDonn√©es g√©n√©r√©es : 45, 23, 78, 45, 12, ...\r--- Statistiques ---\rMoyenne : 48.5\rM√©diane : 46.0\rMode : 45 (appara√Æt 3 fois)\r√âcart-type : 24.3\rMin : 12\rMax : 98\rPremier quartile : 28.5\rTroisi√®me quartile : 71.0\r--- Histogramme ---\r0-20: *** (3)\r21-40: ***** (5)\r41-60: ******* (7)\r61-80: **** (4)\r81-100: * (1) 28 : Simulateur de Loto et Statistiques Concepts pratiqu√©s : Tableaux, List, Random, m√©thodes, comparaison\nDescription : Cr√©ez un simulateur de loterie qui g√©n√®re des num√©ros et v√©rifie les gains.\nFonctionnalit√©s requises :\nDemander √† l‚Äôutilisateur de choisir 6 num√©ros entre 1 et 49 G√©n√©rer un tirage al√©atoire de 6 num√©ros (sans r√©p√©tition) Comparer les num√©ros du joueur avec le tirage Calculer le gain selon le nombre de num√©ros correspondants : 6 num√©ros : Jackpot (1 000 000$) 5 num√©ros : 10 000$ 4 num√©ros : 500$ 3 num√©ros : 20$ 2 num√©ros : 5$ M√©thodes pour : G√©n√©rer des num√©ros al√©atoires uniques Valider les choix de l‚Äôutilisateur (pas de doublons, dans la plage) Comparer deux listes de num√©ros Calculer le gain Afficher les statistiques apr√®s plusieurs parties M√©thodes sugg√©r√©es :\nstatic int[] numeros_joueur = new int[6]; static int[] numeros_gagnants = new int[6]; static void ChoisirNumeros() static int[] GenererTirage() static int CompterNumerosCorrespondants() static double CalculerGain(int correspondants) static bool ContiendreNumero(int[] tableau, int numero) static void TrierTableau(int[] tableau) Exemple d‚Äôex√©cution :\n=== Simulateur de Loto 6/49 ===\rChoisissez 6 num√©ros entre 1 et 49 :\rNum√©ro 1 : 7\rNum√©ro 2 : 14\rNum√©ro 3 : 21\rNum√©ro 4 : 28\rNum√©ro 5 : 35\rNum√©ro 6 : 42\rVos num√©ros : 7, 14, 21, 28, 35, 42\rTirage en cours...\rNum√©ros gagnants : 12, 14, 23, 28, 35, 41\rNum√©ros correspondants : 14, 28, 35\rTotal : 3 num√©ros\rVous gagnez : 20.00$ !\rRejouer ? (o/n) 29 : Gestion d‚ÄôInventaire de Magasin Concepts pratiqu√©s : Tableaux parall√®les, m√©thodes, recherche, tri\nDescription : Cr√©ez un syst√®me de gestion d‚Äôinventaire avec produits, quantit√©s et prix en utilisant des tableaux parall√®les.\nFonctionnalit√©s requises :\nUtiliser 4 tableaux parall√®les pour stocker : string[] codes (codes produits) string[] noms (noms des produits) int[] quantites (quantit√©s en stock) double[] prix (prix unitaires) M√©thodes pour : Ajouter un produit Modifier un produit Supprimer un produit Rechercher par code ou nom Afficher tous les produits Afficher les produits en rupture de stock (quantit√© = 0) Calculer la valeur totale de l‚Äôinventaire Vendre un produit (diminuer quantit√©) Trier les produits par prix M√©thodes sugg√©r√©es :\nstatic string[] codes = new string[100]; static string[] noms = new string[100]; static int[] quantites = new int[100]; static double[] prix = new double[100]; static int nombreProduits = 0; static void AjouterProduit() static int RechercherParCode(string code) static void AfficherInventaire() static void ProduitsEnRupture() static double ValeurTotaleInventaire() static void VendreProduit(string code, int quantite) Exemple d‚Äôex√©cution :\n=== Gestion d'Inventaire ===\r1. Ajouter produit\r2. Vendre\r3. Rechercher\r4. Afficher inventaire\r5. Ruptures de stock\r6. Valeur totale\r7. Quitter\rChoix : 4\r--- Inventaire (3 produits) ---\rCode Nom Qt√© Prix Valeur\rP001 Clavier USB 25 29.99 749.75\rP002 Souris sans fil 12 19.99 239.88\rP003 √âcran 24\" 0 299.99 0.00\rTotal produits : 3\rValeur totale : 989.63$ 30 : Convertisseur d‚ÄôUnit√©s Universel Concepts pratiqu√©s : Dictionary, m√©thodes, conversions, switch/case\nDescription : D√©veloppez un convertisseur complet pour diff√©rentes cat√©gories d‚Äôunit√©s.\nFonctionnalit√©s requises :\nCat√©gories de conversion : Longueur (m, km, cm, mm, miles, yards, pieds, pouces) Poids (kg, g, mg, livres, onces) Temp√©rature (Celsius, Fahrenheit, Kelvin) Volume (L, mL, gallons, pintes) Utiliser des Dictionary pour les facteurs de conversion M√©thodes pour chaque cat√©gorie de conversion Menu pour s√©lectionner la cat√©gorie Afficher toutes les conversions possibles depuis l‚Äôunit√© saisie M√©thodes sugg√©r√©es :\nstatic Dictionary\u003cstring, double\u003e facteursLongueur = new Dictionary\u003cstring, double\u003e { { \"m\", 1 }, { \"km\", 1000 }, { \"cm\", 0.01 }, // etc. }; static double ConvertirLongueur(double valeur, string deUnite, string versUnite) static double ConvertirTemperature(double valeur, string deUnite, string versUnite) static void AfficherToutesConversions(double valeur, string unite, string categorie) Exemple d‚Äôex√©cution :\n=== Convertisseur d'Unit√©s ===\r1. Longueur\r2. Poids\r3. Temp√©rature\r4. Volume\r5. Quitter\rChoix : 1\rValeur : 5\rUnit√© de d√©part : m\r5 m√®tres =\r- 5000 millim√®tres\r- 500 centim√®tres\r- 0.005 kilom√®tres\r- 5.468 yards\r- 16.404 pieds\r- 196.850 pouces\r- 0.003 miles 31 : G√©n√©rateur de Mots de Passe S√©curis√©s Concepts pratiqu√©s : Tableaux, Random, m√©thodes, string manipulation, validation\nDescription : Cr√©ez un g√©n√©rateur de mots de passe avec options de personnalisation et v√©rification de force.\nFonctionnalit√©s requises :\nOptions configurables : Longueur du mot de passe (8-50 caract√®res) Inclure majuscules (A-Z) Inclure minuscules (a-z) Inclure chiffres (0-9) Inclure symboles (!@#$%^\u0026*) G√©n√©rer plusieurs mots de passe √† la fois Cr√©er une m√©thode pour √©valuer la force du mot de passe (faible/moyen/fort) √âviter les caract√®res ambigus (0/O, 1/l/I) Permettre de sauvegarder les mots de passe g√©n√©r√©s dans une List M√©thodes sugg√©r√©es :\nstatic char[] majuscules = \"ABCDEFGHJKLMNPQRSTUVWXYZ\".ToCharArray(); static char[] minuscules = \"abcdefghijkmnopqrstuvwxyz\".ToCharArray(); static char[] chiffres = \"23456789\".ToCharArray(); static char[] symboles = \"!@#$%^\u0026*\".ToCharArray(); static string GenererMotDePasse(int longueur, bool maj, bool min, bool chif, bool sym) static string EvaluerForce(string motDePasse) static List\u003cchar\u003e CreerPoolDeCaracteres(bool maj, bool min, bool chif, bool sym) Exemple d‚Äôex√©cution :\n=== G√©n√©rateur de Mots de Passe ===\rLongueur (8-50) : 16\rInclure majuscules ? (o/n) : o\rInclure minuscules ? (o/n) : o\rInclure chiffres ? (o/n) : o\rInclure symboles ? (o/n) : o\rMots de passe g√©n√©r√©s :\r1. kT8#mPq2nL9@wXz5 (Force: Fort)\r2. Vy3$bNr7hK4\u0026qWm2 (Force: Fort)\r3. Jp6%dGt8sM3!xZn9 (Force: Fort)\rG√©n√©rer d'autres mots de passe ? (o/n) 32 : Calculatrice de Pr√™t Hypoth√©caire Concepts pratiqu√©s : M√©thodes, calculs financiers, tableaux, formatage, boucles\nDescription : D√©veloppez une calculatrice qui calcule les paiements mensuels et g√©n√®re un tableau d‚Äôamortissement.\nFonctionnalit√©s requises :\nDemander : Montant du pr√™t Taux d‚Äôint√©r√™t annuel Dur√©e en ann√©es Calculer le paiement mensuel avec la formule : M = P[r(1+r)^n]/[(1+r)^n-1] M = paiement mensuel P = montant principal r = taux mensuel n = nombre de paiements Utiliser des tableaux pour stocker : double[] paiements double[] interets double[] capital double[] soldes Afficher les premiers et derniers mois Calculer le total des int√©r√™ts pay√©s Option : comparer diff√©rents sc√©narios M√©thodes sugg√©r√©es :\nstatic double CalculerPaiementMensuel(double montant, double tauxAnnuel, int annees) static void GenererTableauAmortissement(double montant, double tauxAnnuel, int annees, out double[] paiements, out double[] interets, out double[] capital, out double[] soldes) static void AfficherLigneTableau(int mois, double paiement, double interet, double cap, double solde) static double CalculerTotalInterets(double[] interets) Exemple d‚Äôex√©cution :\n=== Calculatrice Hypoth√©caire ===\rMontant du pr√™t : 300000\rTaux d'int√©r√™t annuel (%) : 3.5\rDur√©e (ann√©es) : 25\rPaiement mensuel : 1498.88$\rTotal des int√©r√™ts : 149664.00$\rTotal √† rembourser : 449664.00$\r--- Tableau d'amortissement (premiers mois) ---\rMois Paiement Int√©r√™ts Capital Solde\r1 1498.88 875.00 623.88 299376.12\r2 1498.88 873.18 625.70 298750.42\r3 1498.88 871.36 627.52 298122.90\r4 1498.88 869.53 629.35 297493.55\r5 1498.88 867.69 631.19 296862.36\r...\rAfficher tous les mois ? (o/n) 33 : Syst√®me de Quiz avec Banque de Questions Concepts pratiqu√©s : Tableaux parall√®les, m√©thodes, Random, score, validation\nDescription : Cr√©ez un syst√®me de quiz interactif avec diff√©rentes cat√©gories et suivi des r√©sultats.\nFonctionnalit√©s requises :\nUtiliser des tableaux parall√®les pour stocker les questions : string[] questions string[] choixA, choixB, choixC, choixD int[] bonnesReponses (1-4) string[] categories Cr√©er une banque d‚Äôau moins 15 questions M√©thodes pour : S√©lectionner des questions al√©atoires Afficher une question avec ses choix Valider la r√©ponse de l‚Äôutilisateur Calculer le score Afficher les statistiques finales Filtrer par cat√©gorie M√©langer l‚Äôordre des questions Emp√™cher les doublons dans un m√™me quiz M√©thodes sugg√©r√©es :\nstatic string[] questions = new string[50]; static string[] choixA = new string[50]; static string[] choixB = new string[50]; static string[] choixC = new string[50]; static string[] choixD = new string[50]; static int[] bonnesReponses = new int[50]; static string[] categories = new string[50]; static int nombreQuestions = 0; static void InitialiserQuestions() static int[] SelectionnerQuestionsAleatoires(int nombre) static void AfficherQuestion(int index) static bool VerifierReponse(int index, int reponseUtilisateur) static void AfficherResultats(int bonnes, int totales) Exemple d‚Äôex√©cution :\n=== Quiz C# ===\rCat√©gories disponibles :\r1. Programmation C#\r2. Math√©matiques\r3. Culture g√©n√©rale\r4. Toutes cat√©gories\rChoix : 1\rNombre de questions : 5\r--- Question 1/5 ---\rCat√©gorie : Programmation C#\rQuel est le r√©sultat de 5 % 2 en C# ?\r1. 2.5\r2. 1\r3. 2\r4. 0\rVotre r√©ponse : 2\r‚úì Correct !\rScore actuel : 1/1\r--- Question 2/5 ---\r...\r=== R√©sultats finaux ===\rBonnes r√©ponses : 4/5 (80%)\rMauvaises r√©ponses : 1/5 (20%)\rNote : B+ 34 : Simulateur de Compte Bancaire avec Historique Concepts pratiqu√©s : List, m√©thodes, DateTime, formatage, validation\nDescription : D√©veloppez un simulateur de compte bancaire complet avec transactions et historique d√©taill√©.\nFonctionnalit√©s requises :\nVariables globales pour le compte : string numeroCompte string titulaire double solde Utiliser des List pour l‚Äôhistorique : List typesTransactions (Depot, Retrait, etc.) List montants List dates List soldesApres List descriptions M√©thodes pour : D√©poser (ajouter √† l‚Äôhistorique) Retirer (avec v√©rification solde, ajouter √† l‚Äôhistorique) Afficher l‚Äôhistorique complet Afficher les d√©p√¥ts seulement Afficher les retraits seulement Calculer solde moyen sur une p√©riode Afficher les transactions d‚Äôun mois sp√©cifique Calculer des int√©r√™ts mensuels (bonus) M√©thodes sugg√©r√©es :\nstatic string numeroCompte = \"12345-67890\"; static string titulaire = \"Jean Tremblay\"; static double solde = 1000.00; static List\u003cstring\u003e typesTransactions = new List\u003cstring\u003e(); static List\u003cdouble\u003e montants = new List\u003cdouble\u003e(); static List\u003cDateTime\u003e dates = new List\u003cDateTime\u003e(); static List\u003cdouble\u003e soldesApres = new List\u003cdouble\u003e(); static List\u003cstring\u003e descriptions = new List\u003cstring\u003e(); static bool Deposer(double montant, string description) static bool Retirer(double montant, string description) static void AfficherHistorique() static void FiltrerParType(string type) static void FiltrerParMois(int mois, int annee) static double CalculerSoldeMoyen() Exemple d‚Äôex√©cution :\n=== Compte Bancaire - Jean Tremblay ===\rNum√©ro : 12345-67890\rSolde actuel : 1500.00$\r1. D√©poser\r2. Retirer\r3. Historique complet\r4. Voir d√©p√¥ts uniquement\r5. Voir retraits uniquement\r6. Statistiques\r7. Quitter\rChoix : 3\r--- Historique des transactions ---\rDate Type Montant Solde Description\r2026-01-15 10:30 D√©p√¥t +500.00 1500.00 Paie janvier\r2026-01-16 14:20 Retrait -50.00 1450.00 √âpicerie\r2026-01-18 09:15 D√©p√¥t +200.00 1650.00 Remboursement\r2026-01-20 16:45 Retrait -150.00 1500.00 Facture t√©l√©phone\rTotal transactions : 4\rSolde moyen : 1537.50$ 35 : Simulateur de Machine √† Sous (Slot Machine) Concepts pratiqu√©s : Random, tableaux, m√©thodes, boucles, calculs\nDescription : Cr√©ez un jeu de machine √† sous avec 3 rouleaux et diff√©rentes combinaisons gagnantes.\nFonctionnalit√©s requises :\nD√©finir les symboles possibles : üçí (Cerise), üçã (Citron), üçä (Orange), üçá (Raisin), üíé (Diamant), 7Ô∏è‚É£ (Sept) Utiliser un tableau de string pour les symboles Variables pour : Solde du joueur Mise actuelle M√©thodes pour : Tourner les 3 rouleaux (g√©n√©rer 3 symboles al√©atoires) Afficher les rouleaux V√©rifier les combinaisons gagnantes : 3 identiques : Jackpot (mise √ó 50) 3 Sept : Super Jackpot (mise √ó 100) 2 identiques : Petit gain (mise √ó 5) 3 Diamants : Gros gain (mise √ó 25) Calculer les gains G√©rer le solde du joueur Historique des gains et pertes M√©thodes sugg√©r√©es :\nstatic string[] symboles = { \"üçí\", \"üçã\", \"üçä\", \"üçá\", \"üíé\", \"7Ô∏è‚É£\" }; static Random rand = new Random(); static double solde = 100.00; static string[] TournerRouleaux() static void AfficherRouleaux(string[] rouleaux) static double CalculerGain(string[] rouleaux, double mise) static bool VerifierTroisIdentiques(string[] rouleaux) static bool VerifierDeuxIdentiques(string[] rouleaux) Exemple d‚Äôex√©cution :\n=== Machine √† Sous üé∞ ===\rSolde : 100.00$\rSymboles :\rüçí Cerise üçã Citron üçä Orange\rüçá Raisin üíé Diamant 7Ô∏è‚É£ Sept\rEntrez votre mise (min 1$, max 10$) : 5\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ üçí ‚îÇ üçí ‚îÇ üçã ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\rDeux cerises ! Vous gagnez 25.00$ !\rSolde : 120.00$\rRejouer ? (o/n) : o\rEntrez votre mise : 10\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ üíé ‚îÇ üíé ‚îÇ üíé ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\rJACKPOT ! Trois diamants !\rVous gagnez 250.00$ !\rSolde : 360.00$ 36 : Planificateur de T√¢ches avec Priorit√©s Concepts pratiqu√©s : List, tableaux parall√®les, m√©thodes, tri, DateTime\nDescription : D√©veloppez une application de gestion de t√¢ches avec cat√©gories, priorit√©s et √©ch√©ances.\nFonctionnalit√©s requises :\nUtiliser des List pour stocker les t√¢ches : List titres List descriptions List priorites (1=Basse, 2=Moyenne, 3=Haute, 4=Urgente) List categories List datesEcheance List statuts (1=√Ä faire, 2=En cours, 3=Termin√©e) M√©thodes pour : Ajouter une t√¢che Modifier une t√¢che Marquer comme termin√©e Supprimer une t√¢che Afficher toutes les t√¢ches Filtrer par priorit√©, cat√©gorie ou statut Trier par date d‚Äô√©ch√©ance ou priorit√© Afficher les t√¢ches en retard Statistiques (nombre par statut, taux de compl√©tion) M√©thodes sugg√©r√©es :\nstatic List\u003cstring\u003e titres = new List\u003cstring\u003e(); static List\u003cstring\u003e descriptions = new List\u003cstring\u003e(); static List\u003cint\u003e priorites = new List\u003cint\u003e(); static List\u003cstring\u003e categories = new List\u003cstring\u003e(); static List\u003cDateTime\u003e datesEcheance = new List\u003cDateTime\u003e(); static List\u003cint\u003e statuts = new List\u003cint\u003e(); static void AjouterTache() static void AfficherTaches() static void FiltrerParPriorite(int priorite) static void AfficherTachesEnRetard() static void AfficherStatistiques() static string ObtenirNomPriorite(int priorite) static string ObtenirNomStatut(int statut) static int CalculerJoursRestants(DateTime dateEcheance) Exemple d‚Äôex√©cution :\n=== Planificateur de T√¢ches ===\r1. Ajouter t√¢che\r2. Voir toutes les t√¢ches\r3. Filtrer\r4. Marquer termin√©e\r5. T√¢ches en retard\r6. Statistiques\r7. Quitter\rChoix : 2\r--- Toutes les t√¢ches ---\r[1] [URGENTE] Terminer C# - Cat√©gorie: √âcole\r√âch√©ance: 2026-02-05 (6 jours) - Statut: En cours\rDescription: Compl√©ter les 40 mini-s\r[2] [HAUTE] R√©viser pour examen - Cat√©gorie: √âcole\r√âch√©ance: 2026-02-10 (11 jours) - Statut: √Ä faire\rDescription: R√©viser chapitres 1 √† 5\r[3] [MOYENNE] Faire l'√©picerie - Cat√©gorie: Personnel\r√âch√©ance: 2026-02-01 (2 jours) - Statut: √Ä faire\rDescription: Acheter fruits et l√©gumes 37 : Syst√®me de Sondage et Analyse Concepts pratiqu√©s : List, Dictionary, m√©thodes, statistiques, pourcentages\nDescription : Cr√©ez un syst√®me pour cr√©er des sondages, collecter des r√©ponses et analyser les r√©sultats.\nFonctionnalit√©s requises :\nUtiliser des List pour stocker les questions : List questions List option1, option2, option3, option4 Utiliser Dictionary\u003cstring, int\u003e pour compter les r√©ponses Cl√© : ‚ÄúQuestion1_Option1‚Äù, ‚ÄúQuestion1_Option2‚Äù, etc. M√©thodes pour : Cr√©er un sondage (ajouter questions et options) R√©pondre au sondage (un participant √† la fois) Afficher les r√©sultats : Calculer les pourcentages pour chaque option Afficher un graphique en mode texte (barres ASCII) Trouver l‚Äôoption la plus populaire Calculer le nombre total de participants R√©initialiser les r√©sultats M√©thodes sugg√©r√©es :\nstatic List\u003cstring\u003e questions = new List\u003cstring\u003e(); static List\u003cstring\u003e option1 = new List\u003cstring\u003e(); static List\u003cstring\u003e option2 = new List\u003cstring\u003e(); static List\u003cstring\u003e option3 = new List\u003cstring\u003e(); static List\u003cstring\u003e option4 = new List\u003cstring\u003e(); static Dictionary\u003cstring, int\u003e reponses = new Dictionary\u003cstring, int\u003e(); static int nombreParticipants = 0; static void CreerSondage() static void RemplirSondage() static void AnalyserResultats() static void AfficherGraphique(int questionIndex) static double CalculerPourcentage(int nbReponses, int total) static string GenererBarre(double pourcentage) Exemple d‚Äôex√©cution :\n=== Syst√®me de Sondage ===\r1. Cr√©er sondage\r2. R√©pondre √† un sondage\r3. Voir r√©sultats\r4. Quitter\rChoix : 3\rSondage : Satisfaction des √©tudiants\rParticipants : 20\rQuestion 1: Comment √©valuez-vous la qualit√© du cours ?\rExcellent : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 45% (9 r√©ponses)\rBon : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 30% (6 r√©ponses)\rMoyen : ‚ñà‚ñà‚ñà‚ñà 15% (3 r√©ponses)\rFaible : ‚ñà‚ñà 10% (2 r√©ponses)\rQuestion 2: Recommanderiez-vous ce cours ?\rOui, certainement : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 60% (12 r√©ponses)\rProbablement oui : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 25% (5 r√©ponses)\rProbablement non : ‚ñà‚ñà‚ñà‚ñà 10% (2 r√©ponses)\rNon, certainement pas : ‚ñà‚ñà 5% (1 r√©ponse)\rOption la plus populaire : \"Oui, certainement\" 38 : Jeu de M√©moire avec Cartes Concepts pratiqu√©s : Tableaux, List, m√©thodes, Random, logique de jeu, temps\nDescription : D√©veloppez un jeu de m√©moire simplifi√© o√π il faut retrouver les paires de nombres identiques.\nFonctionnalit√©s requises :\nCr√©er un tableau de 16 cartes (8 paires de nombres de 1 √† 8) Utiliser des tableaux pour g√©rer l‚Äô√©tat : int[] valeurs (contient les nombres 1-8 en double) bool[] estVisible (true si carte retourn√©e) bool[] estTrouvee (true si paire trouv√©e) M√©langer les cartes au d√©but M√©thodes pour : Initialiser et m√©langer les cartes Afficher toutes les cartes (cach√©es sauf visibles et trouv√©es) Retourner une carte (par sa position 0-15) V√©rifier si deux cartes forment une paire Compter le nombre de coups V√©rifier si toutes les paires sont trouv√©es Emp√™cher de retourner plus de 2 cartes √† la fois Afficher le temps √©coul√© M√©thodes sugg√©r√©es :\nstatic int[] valeurs = new int[16]; static bool[] estVisible = new bool[16]; static bool[] estTrouvee = new bool[16]; static Random rand = new Random(); static int nombreCoups = 0; static void InitialiserJeu() static void MelangerCartes() static void AfficherCartes() static void RetournerCarte(int position) static bool VerifierPaire(int pos1, int pos2) static bool JeuTermine() Exemple d‚Äôex√©cution :\n=== Jeu de M√©moire üé¥ ===\rPositions : 0 √† 15\r0 1 2 3 4 5 6 7\r[?] [?] [?] [?] [?] [?] [?] [?]\r8 9 10 11 12 13 14 15\r[?] [?] [?] [?] [?] [?] [?] [?]\rPaires trouv√©es : 0/8\rCoups : 0\rPremi√®re carte (0-15) : 3\r0 1 2 3 4 5 6 7\r[?] [?] [?] [5] [?] [?] [?] [?]\rDeuxi√®me carte (0-15) : 11\r0 1 2 3 4 5 6 7\r[?] [?] [?] [5] [?] [?] [?] [?]\r8 9 10 11 12 13 14 15\r[?] [?] [?] [3] [?] [?] [?] [?]\rPas de paire ! Cartes cach√©es...\rPaires trouv√©es : 0/8\rCoups : 1 39 : Calculatrice de Budget Personnel Concepts pratiqu√©s : List, Dictionary, m√©thodes, calculs financiers, DateTime\nDescription : Cr√©ez une application compl√®te pour g√©rer un budget personnel avec revenus, d√©penses et analyse.\nFonctionnalit√©s requises :\nUtiliser des List pour stocker les transactions : List types (‚ÄúRevenu‚Äù ou ‚ÄúDepense‚Äù) List montants List categories (Salaire, √âpicerie, Transport, Loisirs, etc.) List dates List descriptions Utiliser un Dictionary\u003cstring, double\u003e pour les budgets pr√©vus par cat√©gorie M√©thodes pour : Ajouter revenu/d√©pense Afficher le r√©sum√© mensuel Calculer solde actuel Afficher d√©penses par cat√©gorie (avec pourcentages) Comparer budget pr√©vu vs r√©el Afficher graphique en barres des d√©penses Identifier les plus grosses d√©penses Filtrer par mois M√©thodes sugg√©r√©es :\nstatic List\u003cstring\u003e types = new List\u003cstring\u003e(); static List\u003cdouble\u003e montants = new List\u003cdouble\u003e(); static List\u003cstring\u003e categories = new List\u003cstring\u003e(); static List\u003cDateTime\u003e dates = new List\u003cDateTime\u003e(); static List\u003cstring\u003e descriptions = new List\u003cstring\u003e(); static Dictionary\u003cstring, double\u003e budgetsPrevus = new Dictionary\u003cstring, double\u003e(); static void AjouterTransaction() static double CalculerRevenusMois(int mois, int annee) static double CalculerDepensesMois(int mois, int annee) static Dictionary\u003cstring, double\u003e DepensesParCategorie(int mois, int annee) static void AfficherResumeMensuel(int mois, int annee) static void AfficherGraphiqueDepenses(Dictionary\u003cstring, double\u003e depenses, double total) static string GenererBarre(double pourcentage) Exemple d‚Äôex√©cution :\n=== Budget Personnel - Janvier 2026 ===\rRevenus totaux : 3200.00$\rD√©penses totales : 2450.00$\rSolde : +750.00$\r--- D√©penses par cat√©gorie ---\rLoyer : 1200.00$ (49%) ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\r√âpicerie : 450.00$ (18%) ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\rTransport : 200.00$ (8%) ‚ñà‚ñà‚ñà\rLoisirs : 300.00$ (12%) ‚ñà‚ñà‚ñà‚ñà‚ñà\rT√©l√©phone : 80.00$ (3%) ‚ñà\rAutres : 220.00$ (9%) ‚ñà‚ñà‚ñà‚ñà\r--- Budget pr√©vu vs r√©el ---\r√âpicerie : 450$ / 500$ (sous budget de 50$)\rTransport : 200$ / 150$ (d√©passement de 50$)\rLoisirs : 300$ / 250$ (d√©passement de 50$)\rPlus grosses d√©penses du mois :\r1. Loyer - 1200.00$ (2026-01-01)\r2. √âpicerie Costco - 180.00$ (2026-01-15)\r3. Restaurant - 120.00$ (2026-01-20) 40 : Simulateur de Tournoi Sportif (Round-Robin) Concepts pratiqu√©s : List, tableaux parall√®les, m√©thodes, algorithmes, tri\nDescription : D√©veloppez un syst√®me pour g√©rer un tournoi sportif o√π chaque √©quipe affronte toutes les autres.\nFonctionnalit√©s requises :\nUtiliser des tableaux/listes parall√®les pour stocker les √©quipes : List nomsEquipes List victoires List defaites List nulles List pointsMarques List pointsEncaisses Cr√©er des List pour les matches : List equipe1 List equipe2 List score1 List score2 List rondes M√©thodes pour : Ajouter des √©quipes G√©n√©rer le calendrier complet (round-robin) Simuler un match (al√©atoire ou saisie manuelle) Enregistrer les r√©sultats Mettre √† jour les classements Afficher le classement actuel Afficher les matches √† venir Calculer les statistiques (diff√©rentiel de points, taux de victoire) M√©thodes sugg√©r√©es :\nstatic List\u003cstring\u003e nomsEquipes = new List\u003cstring\u003e(); static List\u003cint\u003e victoires = new List\u003cint\u003e(); static List\u003cint\u003e defaites = new List\u003cint\u003e(); static List\u003cint\u003e nulles = new List\u003cint\u003e(); static List\u003cint\u003e pointsMarques = new List\u003cint\u003e(); static List\u003cint\u003e pointsEncaisses = new List\u003cint\u003e(); static List\u003cstring\u003e matchEquipe1 = new List\u003cstring\u003e(); static List\u003cstring\u003e matchEquipe2 = new List\u003cstring\u003e(); static List\u003cint\u003e matchScore1 = new List\u003cint\u003e(); static List\u003cint\u003e matchScore2 = new List\u003cint\u003e(); static void AjouterEquipe(string nom) static void GenererCalendrier() static void SimulerMatch(int indexMatch) static void EnregistrerResultat(string equipe1, string equipe2, int score1, int score2) static void AfficherClassement() static int TrouverIndexEquipe(string nom) static double CalculerTauxVictoire(int index) static int CalculerPoints(int index) // Victoire = 3pts, Nulle = 1pt Exemple d‚Äôex√©cution :\n=== Tournoi de Hockey Round-Robin ===\rParticipants : 6 √©quipes\rNombre total de matches : 15\r--- Classement apr√®s ronde 3 ---\rPos √âquipe Pts V N D PM PE Diff\r1 Canadiens MTL 9 3 0 0 15 8 +7\r2 Maple Leafs TOR 6 2 0 1 12 10 +2\r3 Bruins BOS 6 2 0 1 10 9 +1\r4 Senators OTT 3 1 0 2 9 11 -2\r5 Sabres BUF 3 1 0 2 7 10 -3\r6 Red Wings DET 0 0 0 3 5 10 -5\r--- Prochaine ronde (Ronde 4) ---\rCanadiens MTL vs Senators OTT\rMaple Leafs TOR vs Red Wings DET\rBruins BOS vs Sabres BUF\r1. Simuler ronde suivante\r2. Entrer r√©sultats manuellement\r3. Afficher statistiques\r4. Quitter Bonnes Pratiques Nommage : Utilisez des noms descriptifs (camelCase pour variables, PascalCase pour m√©thodes) Commentaires : Expliquez les parties complexes de votre code Validation : V√©rifiez toujours les entr√©es utilisateur Gestion d‚Äôerreurs : Utilisez try-catch pour les op√©rations risqu√©es Modularit√© : Divisez votre code en m√©thodes r√©utilisables Tests : Testez tous les sc√©narios possibles Deuxi√®me partie 1. Le Distributeur de Breuvages Intelligent Sc√©nario : Vous g√©rez une machine qui vend du Caf√© (2.50$), du Th√© (2.00$) et du Chocolat (3.00$). Exigences : Cr√©er une m√©thode AfficherMenu() qui montre les choix et les prix. L‚Äôutilisateur entre un montant. Si le montant est insuffisant, redemander de l‚Äôargent ou annuler. Calculer la monnaie √† rendre en utilisant le moins de pi√®ces possible (pi√®ces de 2$, 1$, 0.25$, 0.10$). Notions : while, switch, op√©rateurs modulo %. 2. Analyseur de Donn√©es M√©t√©o (Statistiques) Sc√©nario : Un centre m√©t√©o a besoin d‚Äôanalyser les temp√©ratures d‚Äôune semaine. Exigences : Stocker 7 valeurs double dans un tableau. M√©thode CalculerMoyenne(double[] temp) : retourne la moyenne. M√©thode TrouverExtremes(double[] temp) : affiche la plus haute et la plus basse sans Max() ou Min(). Afficher un histogramme simple dans la console (ex: 22¬∞C = **********). Notions : Boucles for, algorithme de recherche de minimum/maximum. 3. Gestionnaire de Contacts avec Recherche Floue Sc√©nario : Une liste de noms simple mais interactive. Exigences : Utiliser une List\u003cstring\u003e pour stocker les noms. Menu : 1. Ajouter, 2. Supprimer par nom, 3. Rechercher, 4. Quitter. La recherche doit afficher tous les noms qui contiennent la lettre ou la syllabe saisie (ex: ‚Äúan‚Äù trouve ‚ÄúAndr√©‚Äù et ‚ÄúChantal‚Äù). Notions : List\u003cT\u003e, m√©thode string.Contains(), foreach. 4. Syst√®me de Facturation de Magasin Sc√©nario : Calculer le total d‚Äôun panier d‚Äôachat avec taxes. Exigences : L‚Äôutilisateur saisit des prix jusqu‚Äô√† ce qu‚Äôil entre -1. G√©rer un tableau de ‚Äúrabais‚Äù : si le prix \u003e 100$, appliquer 10% de r√©duction avant taxes. M√©thode CalculerTaxes(double total) : retourne le montant des taxes (TPS 5%, TVQ 9.975%). Notions : Accumulateurs, constantes, m√©thodes de calcul. 5. Jeu du Pendu : Le D√©fi des Caract√®res Sc√©nario : Deviner un mot cach√© lettre par lettre. Exigences : Le mot secret est un char[]. Cr√©er un second char[] rempli de _. L‚Äô√©tudiant doit comparer la lettre saisie avec chaque caract√®re du mot secret. G√©rer un maximum de 6 erreurs. Notions : Tableaux de caract√®res, manipulation d‚Äôindex. 6. Bureau de Scrutin Virtuel Sc√©nario : Compter les votes pour une √©lection √† 3 candidats. Exigences : Utiliser un Dictionary\u003cstring, int\u003e o√π la cl√© est le nom du candidat. Boucle de vote : l‚Äôutilisateur tape le nom ou le num√©ro du candidat. M√©thode AfficherGagnant() : parcourt le dictionnaire pour trouver la valeur la plus √©lev√©e. Notions : Dictionnaires, it√©ration sur paires Cl√©/Valeur. 7. Validateur de Complexit√© de Mot de Passe Sc√©nario : S√©curiser la cr√©ation de compte. Exigences : Cr√©er une m√©thode VerifierForce(string mdp) qui retourne un score de 1 √† 5. Crit√®res : +1 si \u003e 8 car., +1 si majuscule, +1 si chiffre, +1 si symbole (#, !, $), +1 si \u003e 12 car. Utiliser des boucles pour inspecter chaque caract√®re. Notions : char.IsUpper, char.IsDigit, char.IsPunctuation. 8. Convertisseur de Devises avec Historique Sc√©nario : Changer de l‚Äôargent et garder une trace des transactions. Exigences : Utiliser un tableau double[] fixe pour les taux (USD, EUR, GBP). Chaque conversion effectu√©e est ajout√©e sous forme de cha√Æne (ex: ‚Äú10 CAD -\u003e 7 USD‚Äù) dans une List\u003cstring\u003e. Option pour afficher l‚Äôhistorique complet √† la fin. Notions : Tableaux, listes, formatage de texte. 9. Bataille Navale : Tactique 1D Sc√©nario : D√©truire des navires cach√©s dans une ligne de 10 cases. Exigences : Un tableau bool[10] o√π 3 cases al√©atoires sont true. L‚Äôutilisateur choisit un index. Afficher ‚ÄúTouch√©‚Äù ou ‚Äú√Ä l‚Äôeau‚Äù. Le jeu s‚Äôarr√™te quand les 3 bateaux sont coul√©s. Notions : Random, do-while, tableaux de bool√©ens. 10. Calculateur de Moyennes Multidimensionnel Sc√©nario : G√©rer les notes d‚Äôune classe de 3 √©tudiants ayant chacun 4 examens. Exigences : D√©clarer un double[3, 4]. Remplir le tableau via des saisies utilisateur. M√©thode MoyenneEtudiant(int index) : calcule la moyenne d‚Äôune ligne. M√©thode MoyenneExamen(int index) : calcule la moyenne d‚Äôune colonne. Notions : Tableaux 2D, boucles imbriqu√©es. 11. Simulateur de File d‚ÄôAttente (Banque) Sc√©nario : G√©rer l‚Äôordre de passage des clients. Exigences : Une List\u003cstring\u003e simulant une file d‚Äôattente. Options : ‚ÄúNouveau client‚Äù, ‚ÄúServir prochain‚Äù, ‚ÄúAfficher file‚Äù. ‚ÄúServir prochain‚Äù doit afficher le nom et retirer le premier √©l√©ment (index 0). Notions : List.Add(), List.RemoveAt(). 12. Cr√©ateur de Deck de Cartes et M√©langeur Sc√©nario : G√©n√©rer et m√©langer un jeu de 52 cartes. Exigences : Deux tableaux : couleurs (Pique, Coeur‚Ä¶) et valeurs (As, 2, 3‚Ä¶). G√©n√©rer les 52 combinaisons dans une List\u003cstring\u003e. Algorithme de m√©lange : √©changer chaque carte avec une autre √† un index al√©atoire. Notions : Boucles imbriqu√©es, algorithme de permutation (Swap). 13. D√©tecteur de Palindromes et de ‚ÄúMirroring‚Äù Sc√©nario : Analyser si un mot est identique √† l‚Äôenvers. Exigences : Saisir un mot. Cr√©er une m√©thode EstPalindrome(string mot). Inverser la cha√Æne manuellement dans un tableau de caract√®res pour comparer. Ne pas utiliser Array.Reverse(). Notions : Boucle for d√©croissante, manipulation de cha√Ænes. 14. Inventaire de Magasin (Tableaux Dentel√©s) Sc√©nario : G√©rer des rayons de diff√©rentes tailles. Exigences : Un tableau dentel√© string[][] rayons = new string[3][]. Rayon 1 : 2 produits, Rayon 2 : 5 produits, Rayon 3 : 3 produits. L‚Äôutilisateur peut modifier un produit en sp√©cifiant [rayon, index]. Notions : Jagged Arrays, gestion des limites de tableaux. 15. Le Juste Prix (Multi-joueurs) Sc√©nario : Deviner un prix secret g√©n√©r√© al√©atoirement. Exigences : Le programme g√©n√®re un nombre entre 1 et 1000. Plusieurs joueurs entrent leur nom. Chacun joue √† tour de r√¥le. Le programme indique ‚ÄúC‚Äôest plus !‚Äù ou ‚ÄúC‚Äôest moins !‚Äù. Notions : Random, listes de noms, boucle de jeu. 16. Syst√®me de Login avec Blocage Sc√©nario : S√©curiser l‚Äôacc√®s √† une console. Exigences : Stocker les utilisateurs/mots de passe dans deux tableaux parall√®les ou un dictionnaire. L‚Äôutilisateur a 3 tentatives. Apr√®s 3 erreurs, le programme se verrouille (utilise Thread.Sleep pour simuler une attente). Notions : Compteurs, conditions logiques, s√©curit√© de base. 17. Analyseur de Texte : Compteur de Mots Sc√©nario : Analyser la structure d‚Äôun paragraphe. Exigences : L‚Äôutilisateur entre un long texte. Compter le nombre de mots (d√©limit√©s par des espaces). Compter l‚Äôoccurrence d‚Äôune lettre sp√©cifique demand√©e √† l‚Äôutilisateur. Notions : string.Split(), foreach, compteurs. 18. Calculateur d‚ÄôIMC Professionnel Sc√©nario : Sant√© et nutrition. Exigences : Saisir le nom, le poids et la taille de plusieurs patients. Calculer l‚ÄôIMC ($poids / taille^2$). M√©thode InterpreterIMC(double imc) : retourne une cha√Æne (Maigreur, Normal, Ob√®se). Notions : M√©thodes de retour, formules math√©matiques. 19. Gestionnaire de T√¢ches avec Priorit√© Sc√©nario : Une To-Do List intelligente. Exigences : Stocker les t√¢ches dans une liste. L‚Äôutilisateur peut ajouter une t√¢che avec un niveau d‚Äôimportance (Haute, Moyenne, Basse). Afficher les t√¢ches filtr√©es manuellement : d‚Äôabord toutes les ‚ÄúHaute‚Äù, ensuite les autres. Notions : Filtrage par boucles, comparaisons de cha√Ænes. 20. Le Carr√© Magique (Validation de Grille) Sc√©nario : V√©rifier si une grille 3x3 est un carr√© magique. Exigences : L‚Äôutilisateur entre 9 nombres dans un tableau int[3, 3]. Le programme doit calculer la somme de chaque ligne, chaque colonne et des deux diagonales. Si toutes les sommes sont √©gales, c‚Äôest un carr√© magique ! Notions : Algorithmique avanc√©e sur tableaux 2D.",
    "description": "Premi√®re partie 1 : Calculatrice Simple Concepts pratiqu√©s : Variables, op√©rateurs arithm√©tiques, types num√©riques\nDescription : Cr√©ez un programme qui demande √† l‚Äôutilisateur deux nombres et une op√©ration (+, -, *, /), puis affiche le r√©sultat.\nFonctionnalit√©s requises :\nDemander deux nombres d√©cimaux √† l‚Äôutilisateur Demander l‚Äôop√©ration souhait√©e Effectuer le calcul appropri√© Afficher le r√©sultat avec 2 d√©cimales G√©rer la division par z√©ro Exemple d‚Äôex√©cution :",
    "tags": [],
    "title": "S√©rie d'exercices 1",
    "uri": "/420-413/serie_exos_1/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise¬†\u003e¬†Poos",
    "content": "Table des mati√®res Introduction √† la POO Les Classes et les Objets Les Attributs (Champs) Les Propri√©t√©s (Properties) L‚ÄôEncapsulation Les M√©thodes Les Constructeurs L‚ÄôH√©ritage Le Polymorphisme Le mot-cl√© Virtual Le mot-cl√© Abstract Le mot-cl√© Sealed Les Classes Abstraites Les Interfaces Membres Statiques Cours POO C# - Partie 2 : Concepts Avanc√©s 10. Le mot-cl√© Virtual 10.1 D√©finition Le mot-cl√© virtual permet de d√©clarer une m√©thode qui peut √™tre red√©finie (override) dans les classes d√©riv√©es. C‚Äôest la base du polymorphisme d‚Äôex√©cution en C#.\nConcepts cl√©s :\nUne m√©thode virtual a une impl√©mentation dans la classe de base Les classes d√©riv√©es peuvent (mais ne sont pas oblig√©es) la red√©finir Si elles ne la red√©finissent pas, elles utilisent l‚Äôimpl√©mentation de base Analogie : C‚Äôest comme une recette de base que vous pouvez personnaliser. La recette originale existe et fonctionne, mais vous pouvez l‚Äôadapter √† votre go√ªt.\n10.2 Syntaxe et Utilisation // ========================================== // CLASSE DE BASE avec m√©thode virtual // ========================================== public class Animal { protected string _nom; public Animal(string nom) { _nom = nom; } // ========================================== // M√âTHODE VIRTUAL - Peut √™tre red√©finie // ========================================== public virtual void EmettreS on() { Console.WriteLine($\"{_nom} √©met un son g√©n√©rique.\"); } // ========================================== // M√âTHODE NORMALE (non-virtual) - Ne peut PAS √™tre red√©finie polymorphiquement // ========================================== public void Dormir() { Console.WriteLine($\"{_nom} dort.\"); } } // ========================================== // CLASSE D√âRIV√âE - Red√©finit la m√©thode virtual // ========================================== public class Chien : Animal { public Chien(string nom) : base(nom) { } // ========================================== // OVERRIDE - Red√©finition de la m√©thode virtual // ========================================== public override void EmettreSound() { Console.WriteLine($\"{_nom} aboie: Wouf wouf!\"); } } public class Chat : Animal { public Chat(string nom) : base(nom) { } public override void EmettreSound() { Console.WriteLine($\"{_nom} miaule: Miaou!\"); } } public class Vache : Animal { public Vache(string nom) : base(nom) { } public override void EmettreSound() { Console.WriteLine($\"{_nom} meugle: Meuh!\"); } } // ========================================== // D√âMONSTRATION DU POLYMORPHISME // ========================================== class Program { static void Main() { // Cr√©ation d'objets de types diff√©rents Animal animal1 = new Chien(\"Rex\"); Animal animal2 = new Chat(\"F√©lix\"); Animal animal3 = new Vache(\"Marguerite\"); Animal animal4 = new Animal(\"Cr√©ature\"); // ========================================== // POLYMORPHISME EN ACTION // M√™me appel de m√©thode, comportements diff√©rents // ========================================== animal1.EmettreSound(); // Rex aboie: Wouf wouf! animal2.EmettreSound(); // F√©lix miaule: Miaou! animal3.EmettreSound(); // Marguerite meugle: Meuh! animal4.EmettreSound(); // Cr√©ature √©met un son g√©n√©rique. // ========================================== // UTILISATION PRATIQUE : Tableau polymorphe // ========================================== Animal[] animaux = new Animal[] { new Chien(\"Max\"), new Chat(\"Minou\"), new Vache(\"Bella\"), new Chien(\"Rocky\") }; Console.WriteLine(\"\\n=== Concert animalier ===\"); foreach (Animal animal in animaux) { animal.EmettreSound(); // Appelle la bonne version automatiquement } } } Affichage :\nRex aboie: Wouf wouf!\rF√©lix miaule: Miaou!\rMarguerite meugle: Meuh!\rCr√©ature √©met un son g√©n√©rique.\r=== Concert animalier ===\rMax aboie: Wouf wouf!\rMinou miaule: Miaou!\rBella meugle: Meuh!\rRocky aboie: Wouf wouf! 10.3 Exemple Complet : Syst√®me de Calcul de Salaire public class Employe { public string Nom { get; set; } public decimal SalaireBase { get; set; } public Employe(string nom, decimal salaireBase) { Nom = nom; SalaireBase = salaireBase; } // ========================================== // M√âTHODE VIRTUAL - Calcul de base // ========================================== public virtual decimal CalculerSalaire() { Console.WriteLine($\"[Employe] Calcul standard pour {Nom}\"); return SalaireBase; } public virtual void AfficherDetails() { Console.WriteLine($\"\\n=== {Nom} ===\"); Console.WriteLine($\"Type: Employ√©\"); Console.WriteLine($\"Salaire de base: {SalaireBase:C}\"); Console.WriteLine($\"Salaire total: {CalculerSalaire():C}\"); } } public class Manager : Employe { public decimal Prime { get; set; } public Manager(string nom, decimal salaireBase, decimal prime) : base(nom, salaireBase) { Prime = prime; } // ========================================== // OVERRIDE - Red√©finition pour Manager // ========================================== public override decimal CalculerSalaire() { Console.WriteLine($\"[Manager] Calcul avec prime pour {Nom}\"); return SalaireBase + Prime; } public override void AfficherDetails() { base.AfficherDetails(); // Appelle la version de base Console.WriteLine($\"Prime: {Prime:C}\"); } } public class Vendeur : Employe { public decimal CommissionPourcentage { get; set; } public decimal VentesTotales { get; set; } public Vendeur(string nom, decimal salaireBase, decimal commission) : base(nom, salaireBase) { CommissionPourcentage = commission; } public override decimal CalculerSalaire() { Console.WriteLine($\"[Vendeur] Calcul avec commission pour {Nom}\"); decimal commission = VentesTotales * (CommissionPourcentage / 100); return SalaireBase + commission; } public override void AfficherDetails() { base.AfficherDetails(); Console.WriteLine($\"Commission: {CommissionPourcentage}%\"); Console.WriteLine($\"Ventes: {VentesTotales:C}\"); } } public class Stagiaire : Employe { public int HeuresTravaillees { get; set; } public decimal TauxHoraire { get; set; } public Stagiaire(string nom, decimal tauxHoraire) : base(nom, 0) // Pas de salaire de base { TauxHoraire = tauxHoraire; } public override decimal CalculerSalaire() { Console.WriteLine($\"[Stagiaire] Calcul horaire pour {Nom}\"); return HeuresTravaillees * TauxHoraire; } public override void AfficherDetails() { Console.WriteLine($\"\\n=== {Nom} ===\"); Console.WriteLine($\"Type: Stagiaire\"); Console.WriteLine($\"Taux horaire: {TauxHoraire:C}\"); Console.WriteLine($\"Heures travaill√©es: {HeuresTravaillees}h\"); Console.WriteLine($\"Salaire total: {CalculerSalaire():C}\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // ========================================== // Cr√©ation d'employ√©s de diff√©rents types // ========================================== Employe e1 = new Employe(\"Alice\", 3000); Manager m1 = new Manager(\"Bob\", 4000, 1000); Vendeur v1 = new Vendeur(\"Charlie\", 2500, 5) { VentesTotales = 50000 }; Stagiaire s1 = new Stagiaire(\"David\", 15) { HeuresTravaillees = 120 }; // ========================================== // POLYMORPHISME : Liste h√©t√©rog√®ne // ========================================== List\u003cEmploye\u003e employes = new List\u003cEmploye\u003e { e1, m1, v1, s1 }; Console.WriteLine(\"=== CALCUL DES SALAIRES ===\\n\"); decimal masseSalariale = 0; foreach (Employe employe in employes) { // Appelle la bonne version de CalculerSalaire() // automatiquement selon le type r√©el decimal salaire = employe.CalculerSalaire(); masseSalariale += salaire; employe.AfficherDetails(); } Console.WriteLine($\"\\n=== TOTAL ===\"); Console.WriteLine($\"Masse salariale totale: {masseSalariale:C}\"); } } 10.4 R√®gles Importantes de virtual et override public class ClasseBase { // ‚úÖ M√©thode virtual - Peut √™tre red√©finie public virtual void Methode1() { } // ‚úÖ M√©thode normale - Ne peut pas √™tre red√©finie polymorphiquement public void Methode2() { } // ‚úÖ Propri√©t√© virtual public virtual string Propriete { get; set; } } public class ClasseDerivee : ClasseBase { // ‚úÖ OK - Override d'une m√©thode virtual public override void Methode1() { } // ‚ùå ERREUR - Ne peut pas override une m√©thode non-virtual // public override void Methode2() { } // ‚úÖ OK - Override d'une propri√©t√© virtual public override string Propriete { get; set; } // ‚ö†Ô∏è ATTENTION - Masquage avec 'new' (pas polymorphique) public new void Methode2() { // Ceci n'est PAS du polymorphisme // C'est du \"masquage\" (hiding) } } Diff√©rence entre override et new :\npublic class Base { public virtual void Afficher() { Console.WriteLine(\"Base.Afficher()\"); } } public class Derivee1 : Base { public override void Afficher() // OVERRIDE { Console.WriteLine(\"Derivee1.Afficher()\"); } } public class Derivee2 : Base { public new void Afficher() // NEW (masquage) { Console.WriteLine(\"Derivee2.Afficher()\"); } } // Test Base b1 = new Derivee1(); b1.Afficher(); // \"Derivee1.Afficher()\" - POLYMORPHISME ‚úÖ Base b2 = new Derivee2(); b2.Afficher(); // \"Base.Afficher()\" - PAS de polymorphisme ‚ö†Ô∏è Derivee2 d2 = new Derivee2(); d2.Afficher(); // \"Derivee2.Afficher()\" - Appelle la version masqu√©e 11. Le mot-cl√© Abstract 11.1 D√©finition Le mot-cl√© abstract permet de d√©clarer :\nDes classes abstraites : Classes incompl√®tes qui ne peuvent pas √™tre instanci√©es Des m√©thodes abstraites : M√©thodes sans impl√©mentation qui DOIVENT √™tre red√©finies dans les classes d√©riv√©es Diff√©rence avec virtual :\nvirtual : M√©thode avec impl√©mentation, red√©finition optionnelle abstract : M√©thode sans impl√©mentation, red√©finition obligatoire Analogie :\nUne classe abstraite est comme un plan architectural incomplet Elle d√©finit la structure mais certaines parties doivent √™tre compl√©t√©es Vous ne pouvez pas habiter dans un plan, vous devez construire la maison compl√®te 11.2 M√©thodes Abstraites public abstract class Forme { protected string _nom; protected string _couleur; public Forme(string nom, string couleur) { _nom = nom; _couleur = couleur; } // ========================================== // M√âTHODE ABSTRAITE - Pas d'impl√©mentation // DOIT √™tre red√©finie dans les classes d√©riv√©es // ========================================== public abstract double CalculerAire(); public abstract double CalculerPerimetre(); // ========================================== // M√âTHODE CONCR√àTE - A une impl√©mentation // ========================================== public void AfficherInfos() { Console.WriteLine($\"\\n{_nom} ({_couleur})\"); Console.WriteLine($\"Aire: {CalculerAire():F2}\"); Console.WriteLine($\"P√©rim√®tre: {CalculerPerimetre():F2}\"); } } // ========================================== // CLASSE D√âRIV√âE - DOIT impl√©menter les m√©thodes abstraites // ========================================== public class Cercle : Forme { private double _rayon; public Cercle(double rayon, string couleur) : base(\"Cercle\", couleur) { _rayon = rayon; } // ========================================== // IMPL√âMENTATION OBLIGATOIRE // ========================================== public override double CalculerAire() { return Math.PI * _rayon * _rayon; } public override double CalculerPerimetre() { return 2 * Math.PI * _rayon; } } public class Rectangle : Forme { private double _longueur; private double _largeur; public Rectangle(double longueur, double largeur, string couleur) : base(\"Rectangle\", couleur) { _longueur = longueur; _largeur = largeur; } public override double CalculerAire() { return _longueur * _largeur; } public override double CalculerPerimetre() { return 2 * (_longueur + _largeur); } } // ========================================== // SI on oublie d'impl√©menter une m√©thode abstraite ‚Üí ERREUR // ========================================== /* public class Triangle : Forme // ‚ùå ERREUR DE COMPILATION { // Erreur: Triangle ne red√©finit pas les m√©thodes abstraites } */ // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // ‚ùå ERREUR - Impossible d'instancier une classe abstraite // Forme f = new Forme(\"Test\", \"Rouge\"); // ‚úÖ OK - Instanciation des classes concr√®tes Forme cercle = new Cercle(5, \"Rouge\"); Forme rectangle = new Rectangle(4, 6, \"Bleu\"); // Polymorphisme cercle.AfficherInfos(); rectangle.AfficherInfos(); // Liste polymorphe List\u003cForme\u003e formes = new List\u003cForme\u003e { new Cercle(3, \"Vert\"), new Rectangle(5, 2, \"Jaune\"), new Cercle(7, \"Orange\") }; double aireTotal e = 0; foreach (Forme forme in formes) { aireTotal += forme.CalculerAire(); } Console.WriteLine($\"\\nAire totale: {aireTotal:F2}\"); } } 11.3 Propri√©t√©s Abstraites Les propri√©t√©s peuvent aussi √™tre abstraites.\npublic abstract class Vehicule { // ========================================== // PROPRI√âT√â ABSTRAITE // ========================================== public abstract int NombreRoues { get; } public abstract string TypeCarburant { get; set; } public void AfficherInfos() { Console.WriteLine($\"V√©hicule √† {NombreRoues} roues\"); Console.WriteLine($\"Carburant: {TypeCarburant}\"); } } public class Voiture : Vehicule { public override int NombreRoues { get { return 4; } } private string _typeCarburant; public override string TypeCarburant { get { return _typeCarburant; } set { _typeCarburant = value; } } public Voiture() { _typeCarburant = \"Essence\"; } } public class Moto : Vehicule { public override int NombreRoues { get { return 2; } } public override string TypeCarburant { get; set; } = \"Essence\"; } 11.4 Combinaison de Virtual et Abstract Une classe abstraite peut contenir un m√©lange de m√©thodes abstraites, virtuelles et concr√®tes.\npublic abstract class Animal { protected string _nom; public Animal(string nom) { _nom = nom; } // ========================================== // M√âTHODE ABSTRAITE - Impl√©mentation obligatoire // ========================================== public abstract void EmettreSound(); // ========================================== // M√âTHODE VIRTUELLE - Red√©finition optionnelle // ========================================== public virtual void Manger() { Console.WriteLine($\"{_nom} mange.\"); } // ========================================== // M√âTHODE CONCR√àTE - Impl√©mentation finale // ========================================== public void Dormir() { Console.WriteLine($\"{_nom} dort.\"); } } public class Chien : Animal { public Chien(string nom) : base(nom) { } // OBLIGATOIRE - M√©thode abstraite public override void EmettreSound() { Console.WriteLine($\"{_nom} aboie!\"); } // OPTIONNEL - M√©thode virtuelle public override void Manger() { Console.WriteLine($\"{_nom} d√©vore ses croquettes!\"); } // Dormir() est h√©rit√© tel quel } 12. Le mot-cl√© Sealed 12.1 D√©finition Le mot-cl√© sealed emp√™che l‚Äôh√©ritage ou la red√©finition :\nClasse sealed : Aucune classe ne peut en h√©riter M√©thode sealed : Aucune classe d√©riv√©e ne peut la red√©finir Pourquoi utiliser sealed ?\nS√©curit√© : Emp√™cher les modifications non d√©sir√©es Performance : Optimisations possibles par le compilateur Design : Indiquer qu‚Äôune classe est ‚Äúcompl√®te‚Äù et finale Analogie : C‚Äôest comme sceller un document avec de la cire. Une fois scell√©, il ne peut plus √™tre modifi√©.\n12.2 Classe Sealed // ========================================== // CLASSE SEALED - Ne peut pas √™tre h√©rit√©e // ========================================== public sealed class MathUtils { public static double CalculerMoyenne(params double[] nombres) { return nombres.Average(); } public static int Max(int a, int b) { return a \u003e b ? a : b; } } // ‚ùå ERREUR DE COMPILATION - Impossible d'h√©riter d'une classe sealed /* public class MesUtils : MathUtils { // Erreur: cannot derive from sealed type 'MathUtils' } */ Exemples de classes sealed dans .NET :\nString : sealed (impossible d‚Äôh√©riter de string) Int32, Double, etc. : sealed DateTime : sealed // ‚ùå Impossible // public class MaChaine : String { } // ‚úÖ Utilisation normale string texte = \"Bonjour\"; 12.3 M√©thode Sealed Une m√©thode sealed emp√™che sa red√©finition dans les classes d√©riv√©es ult√©rieures.\nImportant : Une m√©thode ne peut √™tre sealed que si elle override d√©j√† une m√©thode.\npublic class Animal { public virtual void EmettreSound() { Console.WriteLine(\"Son animal\"); } } public class Mammifere : Animal { // ========================================== // OVERRIDE + SEALED // Cette version est finale, ne peut plus √™tre red√©finie // ========================================== public sealed override void EmettreSound() { Console.WriteLine(\"Son de mammif√®re\"); } } public class Chien : Mammifere { // ‚ùå ERREUR - Ne peut pas override une m√©thode sealed /* public override void EmettreSound() { Console.WriteLine(\"Wouf!\"); } */ // ‚úÖ OK - M√©thode diff√©rente (pas un override) public void Aboyer() { Console.WriteLine(\"Wouf!\"); } } 12.4 Cas d‚ÄôUsage de Sealed Exemple 1 : Classe Utilitaire Compl√®te // Classe utilitaire qui ne devrait jamais √™tre modifi√©e public sealed class ConfigurationManager { private static ConfigurationManager _instance; private Dictionary\u003cstring, string\u003e _settings; private ConfigurationManager() { _settings = new Dictionary\u003cstring, string\u003e(); ChargerConfiguration(); } public static ConfigurationManager Instance { get { if (_instance == null) _instance = new ConfigurationManager(); return _instance; } } private void ChargerConfiguration() { // Chargement de la configuration } public string ObtenirValeur(string cle) { return _settings.ContainsKey(cle) ? _settings[cle] : null; } } // Impossible d'h√©riter pour modifier le comportement Exemple 2 : M√©thode Sealed pour la S√©curit√© public class SystemeS√©curit√© { public virtual bool VerifierAcces(string utilisateur) { Console.WriteLine(\"V√©rification de base\"); return true; } } public class SystemeAvance : SystemeS√©curit√© { // Version finale de la v√©rification - ne doit plus √™tre modifi√©e public sealed override bool VerifierAcces(string utilisateur) { Console.WriteLine(\"V√©rification avanc√©e (FINALE)\"); // Logique critique de s√©curit√© bool accesBase = base.VerifierAcces(utilisateur); bool verification2FA = Verifier2FA(utilisateur); bool verificationBiometrique = VerifierBiometrie(utilisateur); return accesBase \u0026\u0026 verification2FA \u0026\u0026 verificationBiometrique; } private bool Verifier2FA(string utilisateur) { return true; } private bool VerifierBiometrie(string utilisateur) { return true; } } // Aucune classe d√©riv√©e ne peut affaiblir la s√©curit√© public class SystemeTresAvance : SystemeAvance { // ‚ùå Ne peut pas override VerifierAcces // La s√©curit√© est garantie } 13. Les Classes Abstraites 13.1 D√©finition Compl√®te Une classe abstraite est une classe d√©clar√©e avec le mot-cl√© abstract qui :\nNe peut pas √™tre instanci√©e directement Peut contenir des m√©thodes abstraites (sans impl√©mentation) ET des m√©thodes concr√®tes (avec impl√©mentation) Peut avoir des constructeurs (appel√©s par les classes d√©riv√©es) Peut avoir des attributs, propri√©t√©s, etc. Sert de mod√®le ou de base pour d‚Äôautres classes Quand utiliser une classe abstraite ?\nQuand vous voulez d√©finir un comportement commun pour un groupe de classes Quand certaines m√©thodes doivent √™tre impl√©ment√©es diff√©remment par chaque classe d√©riv√©e Quand vous voulez partager du code entre classes similaires Quand la classe repr√©sente un concept abstrait qui ne devrait pas exister seul 13.2 Anatomie Compl√®te d‚Äôune Classe Abstraite public abstract class Vehicule { // ========================================== // 1. ATTRIBUTS (comme une classe normale) // ========================================== protected string _marque; protected string _modele; private int _annee; protected double _kilometrage; // ========================================== // 2. PROPRI√âT√âS // ========================================== public string Marque { get { return _marque; } } public string Modele { get { return _modele; } } public int Annee { get { return _annee; } } public double Kilometrage { get { return _kilometrage; } } // ========================================== // 3. CONSTRUCTEUR (Oui, les classes abstraites peuvent en avoir!) // ========================================== protected Vehicule(string marque, string modele, int annee) { _marque = marque; _modele = modele; _annee = annee; _kilometrage = 0; Console.WriteLine($\"Constructeur de Vehicule appel√© pour {marque} {modele}\"); } // ========================================== // 4. M√âTHODES ABSTRAITES - Impl√©mentation obligatoire // ========================================== public abstract void Demarrer(); public abstract double CalculerConsommation(double distance); public abstract string ObtenirTypeCarburant(); // ========================================== // 5. M√âTHODES VIRTUELLES - Red√©finition optionnelle // ========================================== public virtual void Accelerer(int vitesse) { Console.WriteLine($\"Le v√©hicule acc√©l√®re √† {vitesse} km/h\"); } public virtual void Klaxonner() { Console.WriteLine(\"Beep beep!\"); } // ========================================== // 6. M√âTHODES CONCR√àTES - H√©rit√©es telles quelles // ========================================== public void Rouler(double distance) { _kilometrage += distance; double consommation = CalculerConsommation(distance); // Appelle la m√©thode abstraite Console.WriteLine($\"Parcouru {distance} km. Consommation: {consommation:F2}L\"); Console.WriteLine($\"Kilom√©trage total: {_kilometrage} km\"); } public void AfficherInfos() { Console.WriteLine($\"\\n=== {_marque} {_modele} ({_annee}) ===\"); Console.WriteLine($\"Type de carburant: {ObtenirTypeCarburant()}\"); Console.WriteLine($\"Kilom√©trage: {_kilometrage} km\"); } // ========================================== // 7. PROPRI√âT√âS ABSTRAITES // ========================================== public abstract int NombreRoues { get; } } 13.3 Impl√©mentation de la Classe Abstraite // ========================================== // CLASSE CONCR√àTE 1 : Voiture // ========================================== public class Voiture : Vehicule { private string _typeCarburant; private double _consommationAu100; private int _nombrePortes; public Voiture(string marque, string modele, int annee, int portes, string carburant, double consommation) : base(marque, modele, annee) // Appelle le constructeur abstrait { _nombrePortes = portes; _typeCarburant = carburant; _consommationAu100 = consommation; } // Impl√©mentation obligatoire des m√©thodes abstraites public override void Demarrer() { Console.WriteLine($\"La voiture {_marque} {_modele} d√©marre avec la cl√©.\"); } public override double CalculerConsommation(double distance) { return (distance / 100) * _consommationAu100; } public override string ObtenirTypeCarburant() { return _typeCarburant; } // Impl√©mentation de la propri√©t√© abstraite public override int NombreRoues { get { return 4; } } // Red√©finition optionnelle d'une m√©thode virtuelle public override void Klaxonner() { Console.WriteLine(\"La voiture klaxonne: BEEP BEEP!\"); } // Nouvelle m√©thode sp√©cifique public void OuvrirCoffre() { Console.WriteLine(\"Coffre ouvert\"); } } // ========================================== // CLASSE CONCR√àTE 2 : Moto // ========================================== public class Moto : Vehicule { private bool _aSidecar; private double _consommationAu100; public Moto(string marque, string modele, int annee, bool sidecar, double consommation) : base(marque, modele, annee) { _aSidecar = sidecar; _consommationAu100 = consommation; } public override void Demarrer() { Console.WriteLine($\"La moto {_marque} {_modele} d√©marre avec le bouton start.\"); } public override double CalculerConsommation(double distance) { double consommation = (distance / 100) * _consommationAu100; if (_aSidecar) consommation *= 1.2; // 20% de plus avec sidecar return consommation; } public override string ObtenirTypeCarburant() { return \"Essence\"; } public override int NombreRoues { get { return _aSidecar ? 3 : 2; } } // Utilise la m√©thode virtuelle h√©rit√©e (pas de red√©finition) // Donc Klaxonner() sera \"Beep beep!\" de la classe de base } // ========================================== // CLASSE CONCR√àTE 3 : Camion // ========================================== public class Camion : Vehicule { private double _capaciteChargeTonnes; private double _consommationAu100; private double _chargeActuelle; public Camion(string marque, string modele, int annee, double capacite, double consommation) : base(marque, modele, annee) { _capaciteChargeTonnes = capacite; _consommationAu100 = consommation; _chargeActuelle = 0; } public override void Demarrer() { Console.WriteLine($\"Le camion {_marque} {_modele} d√©marre avec un vrombissement.\"); } public override double CalculerConsommation(double distance) { double baseConsommation = (distance / 100) * _consommationAu100; // Consommation augmente avec la charge double facteurCharge = 1 + (_chargeActuelle / _capaciteChargeTonnes) * 0.5; return baseConsommation * facteurCharge; } public override string ObtenirTypeCarburant() { return \"Diesel\"; } public override int NombreRoues { get { return 18; } } public void Charger(double poids) { if (_chargeActuelle + poids \u003c= _capaciteChargeTonnes) { _chargeActuelle += poids; Console.WriteLine($\"Chargement de {poids}t. Charge totale: {_chargeActuelle}t\"); } else { Console.WriteLine($\"Impossible! Capacit√© d√©pass√©e.\"); } } } 13.4 Utilisation Polymorphe class Program { static void Main() { // ‚ùå IMPOSSIBLE - Classe abstraite // Vehicule v = new Vehicule(\"Test\", \"Test\", 2020); // ‚úÖ OK - Classes concr√®tes Vehicule voiture = new Voiture(\"Toyota\", \"Camry\", 2023, 4, \"Essence\", 7.5); Vehicule moto = new Moto(\"Harley\", \"Davidson\", 2022, false, 4.5); Vehicule camion = new Camion(\"Volvo\", \"FH16\", 2021, 25, 30); // ========================================== // POLYMORPHISME EN ACTION // ========================================== List\u003cVehicule\u003e parc = new List\u003cVehicule\u003e { voiture, moto, camion }; Console.WriteLine(\"=== D√âMARRAGE DE TOUS LES V√âHICULES ===\\n\"); foreach (Vehicule vehicule in parc) { vehicule.Demarrer(); // Appelle la bonne version } Console.WriteLine(\"\\n=== TRAJET DE 100 KM ===\\n\"); foreach (Vehicule vehicule in parc) { vehicule.Rouler(100); vehicule.AfficherInfos(); } // ========================================== // UTILISATION SP√âCIFIQUE // ========================================== if (camion is Camion c) { c.Charger(10); c.Rouler(50); // Consommation affect√©e par la charge } } } 13.5 Exemple Complet : Syst√®me de Paiement // ========================================== // CLASSE ABSTRAITE : Moyen de Paiement // ========================================== public abstract class MoyenPaiement { protected string _titulaire; protected DateTime _dateTransaction; public string Titulaire { get { return _titulaire; } } public DateTime DateTransaction { get { return _dateTransaction; } } protected MoyenPaiement(string titulaire) { _titulaire = titulaire; } // M√©thodes abstraites public abstract bool Payer(decimal montant); public abstract bool Verifier(); public abstract string ObtenirType(); // M√©thode virtuelle public virtual void AfficherRecu(decimal montant) { Console.WriteLine($\"\\n====== RE√áU DE PAIEMENT ======\"); Console.WriteLine($\"Titulaire: {_titulaire}\"); Console.WriteLine($\"Type: {ObtenirType()}\"); Console.WriteLine($\"Montant: {montant:C}\"); Console.WriteLine($\"Date: {_dateTransaction:F}\"); Console.WriteLine($\"==============================\\n\"); } // M√©thode concr√®te protected void EnregistrerTransaction() { _dateTransaction = DateTime.Now; Console.WriteLine($\"[LOG] Transaction enregistr√©e pour {_titulaire}\"); } } // Classes concr√®tes... // (voir continuation dans le message suivant) public class CarteCredit : MoyenPaiement { private string _numero; private DateTime _dateExpiration; private decimal _limiteCredit; private decimal _soldeUtilise; public CarteCredit(string titulaire, string numero, DateTime expiration, decimal limite) : base(titulaire) { _numero = numero; _dateExpiration = expiration; _limiteCredit = limite; _soldeUtilise = 0; } public override bool Verifier() { if (_dateExpiration \u003c DateTime.Now) { Console.WriteLine(\"‚ùå Carte expir√©e\"); return false; } return true; } public override bool Payer(decimal montant) { if (!Verifier()) return false; if (_soldeUtilise + montant \u003e _limiteCredit) { Console.WriteLine($\"‚ùå Limite de cr√©dit d√©pass√©e ({_limiteCredit:C})\"); return false; } _soldeUtilise += montant; EnregistrerTransaction(); Console.WriteLine($\"‚úÖ Paiement de {montant:C} effectu√© par carte de cr√©dit\"); Console.WriteLine($\" Solde disponible: {_limiteCredit - _soldeUtilise:C}\"); return true; } public override string ObtenirType() { return \"Carte de Cr√©dit\"; } } public class CompteBancaire : MoyenPaiement { private string _numeroCompte; private decimal _solde; public CompteBancaire(string titulaire, string numero, decimal soldeInitial) : base(titulaire) { _numeroCompte = numero; _solde = soldeInitial; } public override bool Verifier() { return true; // Toujours valide } public override bool Payer(decimal montant) { if (_solde \u003c montant) { Console.WriteLine($\"‚ùå Solde insuffisant (Disponible: {_solde:C})\"); return false; } _solde -= montant; EnregistrerTransaction(); Console.WriteLine($\"‚úÖ Paiement de {montant:C} effectu√© par compte bancaire\"); Console.WriteLine($\" Nouveau solde: {_solde:C}\"); return true; } public override string ObtenirType() { return \"Compte Bancaire\"; } } // Utilisation List\u003cMoyenPaiement\u003e moyensPaiement = new List\u003cMoyenPaiement\u003e { new CarteCredit(\"Alice Martin\", \"1234-5678-9012-3456\", DateTime.Now.AddYears(2), 5000), new CompteBancaire(\"Bob Gagnon\", \"CA123456\", 2000) }; foreach (var moyen in moyensPaiement) { if (moyen.Payer(150)) { moyen.AfficherRecu(150); } } 14. Les Interfaces 14.1 D√©finition Approfondie Une interface est un contrat qui d√©finit un ensemble de membres (m√©thodes, propri√©t√©s, √©v√©nements) que les classes doivent impl√©menter, sans fournir d‚Äôimpl√©mentation.\nDiff√©rences cl√©s : Interface vs Classe Abstraite\nAspect Interface Classe Abstraite Impl√©mentation Aucune (contrat pur) Peut contenir du code H√©ritage multiple ‚úÖ Oui ‚ùå Non Constructeurs ‚ùå Non ‚úÖ Oui Champs ‚ùå Non ‚úÖ Oui Modificateurs d‚Äôacc√®s Tous public Vari√©s (private, protected, etc.) But D√©finir un comportement Partager du code commun Quand utiliser une interface ?\nD√©finir un comportement commun √† des classes sans relation hi√©rarchique Permettre l‚Äôh√©ritage multiple de comportements Cr√©er des contrats que diff√©rentes classes doivent respecter Favoriser le couplage faible dans votre architecture Analogie : Une interface est comme un certificat de comp√©tence :\nUn pilote peut avoir : certificat voiture, certificat moto, certificat avion Chaque certificat garantit certaines comp√©tences Diff√©rentes personnes peuvent avoir diff√©rentes combinaisons de certificats 14.2 D√©claration d‚Äôune Interface // ========================================== // CONVENTION : Pr√©fixe 'I' pour les interfaces // ========================================== public interface IVolant { // ========================================== // M√âTHODES (pas d'impl√©mentation) // ========================================== void Voler(); void Atterrir(); // ========================================== // PROPRI√âT√âS (seulement les signatures) // ========================================== double AltitudeMaximale { get; } double Vitesse { get; set; } // ========================================== // TOUS les membres sont PUBLIC par d√©faut // Pas besoin de sp√©cifier 'public' // ========================================== } public interface INageant { void Nager(); void Plonger(double profondeur); double ProfondeurMaximale { get; } } public interface IMarchant { void Marcher(); void Courir(); int VitesseMarche { get; } } 14.3 Impl√©mentation d‚ÄôInterfaces // ========================================== // Une classe peut impl√©menter PLUSIEURS interfaces // ========================================== public class Canard : IVolant, INageant, IMarchant { private double _altitudeActuelle; private double _profondeurActuelle; // ========================================== // Impl√©mentation de IVolant // ========================================== public double AltitudeMaximale { get { return 1000; } } public double Vitesse { get; set; } public void Voler() { _altitudeActuelle = 100; Console.WriteLine($\"Le canard vole √† {_altitudeActuelle}m\"); } public void Atterrir() { _altitudeActuelle = 0; Console.WriteLine(\"Le canard atterrit\"); } // ========================================== // Impl√©mentation de INageant // ========================================== public double ProfondeurMaximale { get { return 5; } } public void Nager() { Console.WriteLine(\"Le canard nage √† la surface\"); } public void Plonger(double profondeur) { if (profondeur \u003c= ProfondeurMaximale) { _profondeurActuelle = profondeur; Console.WriteLine($\"Le canard plonge √† {profondeur}m\"); } else { Console.WriteLine(\"Trop profond!\"); } } // ========================================== // Impl√©mentation de IMarchant // ========================================== public int VitesseMarche { get { return 5; } } public void Marcher() { Console.WriteLine(\"Le canard se dandine\"); } public void Courir() { Console.WriteLine(\"Le canard court maladroitement\"); } } // ========================================== // Autre classe avec un sous-ensemble d'interfaces // ========================================== public class Avion : IVolant { public double AltitudeMaximale { get { return 12000; } } public double Vitesse { get; set; } public void Voler() { Console.WriteLine($\"L'avion vole √† {Vitesse} km/h\"); } public void Atterrir() { Console.WriteLine(\"L'avion atterrit sur la piste\"); } } public class Poisson : INageant { public double ProfondeurMaximale { get { return 500; } } public void Nager() { Console.WriteLine(\"Le poisson nage gracieusement\"); } public void Plonger(double profondeur) { Console.WriteLine($\"Le poisson plonge √† {profondeur}m\"); } } 14.4 Polymorphisme avec Interfaces class Program { static void Main() { // ========================================== // Collections polymorphes bas√©es sur les interfaces // ========================================== // Tous les √™tres volants List\u003cIVolant\u003e volants = new List\u003cIVolant\u003e { new Canard(), new Avion { Vitesse = 800 }, new Canard() }; Console.WriteLine(\"=== D√âCOLLAGE ===\"); foreach (IVolant volant in volants) { volant.Voler(); // Polymorphisme! } // Tous les √™tres nageants List\u003cINageant\u003e nageants = new List\u003cINageant\u003e { new Canard(), new Poisson() }; Console.WriteLine(\"\\n=== PLONG√âE ===\"); foreach (INageant nageant in nageants) { nageant.Nager(); nageant.Plonger(3); } // ========================================== // Le canard peut √™tre utilis√© comme 3 types diff√©rents // ========================================== Canard donald = new Canard(); IVolant v = donald; // R√©f√©rence comme IVolant INageant n = donald; // R√©f√©rence comme INageant IMarchant m = donald; // R√©f√©rence comme IMarchant v.Voler(); n.Nager(); m.Marcher(); } } 14.5 V√©rification de Type avec Interfaces public void TraiterAnimal(object animal) { // ========================================== // Test avec 'is' // ========================================== if (animal is IVolant) { Console.WriteLine(\"Cet animal peut voler!\"); } if (animal is INageant) { Console.WriteLine(\"Cet animal peut nager!\"); } // ========================================== // Cast avec 'as' // ========================================== IVolant volant = animal as IVolant; if (volant != null) { volant.Voler(); } // ========================================== // Pattern matching (C# 7+) // ========================================== if (animal is IVolant v) { Console.WriteLine($\"Altitude max: {v.AltitudeMaximale}m\"); v.Voler(); } } 14.6 Impl√©mentation Explicite d‚ÄôInterface Utilis√©e pour r√©soudre les conflits quand deux interfaces ont des membres avec le m√™me nom.\npublic interface IAnimal { void Manger(); string Nom { get; } } public interface IRobot { void Manger(); // M√™me nom! string Nom { get; } } public class CyberChien : IAnimal, IRobot { private string _nom; public CyberChien(string nom) { _nom = nom; } // ========================================== // IMPL√âMENTATION EXPLICITE pour IAnimal // ========================================== void IAnimal.Manger() { Console.WriteLine($\"{_nom} mange de la nourriture organique\"); } string IAnimal.Nom { get { return $\"{_nom} (animal)\"; } } // ========================================== // IMPL√âMENTATION EXPLICITE pour IRobot // ========================================== void IRobot.Manger() { Console.WriteLine($\"{_nom} recharge ses batteries\"); } string IRobot.Nom { get { return $\"{_nom} (robot)\"; } } // ========================================== // M√©thode publique normale // ========================================== public void SeReposer() { Console.WriteLine($\"{_nom} se met en veille\"); } } // Utilisation CyberChien cyber = new CyberChien(\"RoboDog\"); // ‚ùå ERREUR - Ambigu√Øt√© // cyber.Manger(); // ‚úÖ OK - Cast explicite IAnimal animal = cyber; animal.Manger(); // Nourriture organique Console.WriteLine(animal.Nom); IRobot robot = cyber; robot.Manger(); // Recharge batteries Console.WriteLine(robot.Nom); cyber.SeReposer(); // ‚úÖ OK - M√©thode publique 14.7 Exemple Complet : Syst√®me de Notifications // ========================================== // INTERFACES // ========================================== public interface INotifiable { void EnvoyerNotification(string message); bool EstActif { get; set; } } public interface IConfigurable { void Configurer(Dictionary\u003cstring, string\u003e parametres); Dictionary\u003cstring, string\u003e ObtenirConfiguration(); } public interface IPrioritaire { int Priorite { get; set; } } // ========================================== // CLASSES D'IMPL√âMENTATION // ========================================== public class NotificationEmail : INotifiable, IConfigurable { public bool EstActif { get; set; } = true; public string AdresseEmail { get; private set; } public string ServeurSMTP { get; private set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"üìß [EMAIL] √Ä: {AdresseEmail}\"); Console.WriteLine($\" Message: {message}\"); Console.WriteLine($\" Via: {ServeurSMTP}\\n\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"email\")) AdresseEmail = parametres[\"email\"]; if (parametres.ContainsKey(\"smtp\")) ServeurSMTP = parametres[\"smtp\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"email\", AdresseEmail }, { \"smtp\", ServeurSMTP } }; } } public class NotificationSMS : INotifiable, IConfigurable, IPrioritaire { public bool EstActif { get; set; } = true; public int Priorite { get; set; } = 1; public string NumeroTelephone { get; private set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"üì± [SMS] Au: {NumeroTelephone}\"); Console.WriteLine($\" Message: {message}\"); Console.WriteLine($\" Priorit√©: {Priorite}\\n\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"telephone\")) NumeroTelephone = parametres[\"telephone\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"telephone\", NumeroTelephone } }; } } public class NotificationPush : INotifiable, IPrioritaire { public bool EstActif { get; set; } = true; public int Priorite { get; set; } = 2; public string DeviceId { get; set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"üîî [PUSH] Device: {DeviceId}\"); Console.WriteLine($\" Message: {message}\"); Console.WriteLine($\" Priorit√©: {Priorite}\\n\"); } } } // ========================================== // GESTIONNAIRE // ========================================== public class GestionnaireNotifications { private List\u003cINotifiable\u003e _canaux = new List\u003cINotifiable\u003e(); public void AjouterCanal(INotifiable canal) { _canaux.Add(canal); Console.WriteLine($\"‚úÖ Canal ajout√©: {canal.GetType().Name}\"); } public void EnvoyerATous(string message) { Console.WriteLine($\"\\n{'='.ToString().PadLeft(50, '=')}\"); Console.WriteLine($\"ENVOI √Ä TOUS LES CANAUX\"); Console.WriteLine($\"{'='.ToString().PadLeft(50, '=')}\\n\"); foreach (INotifiable canal in _canaux) { canal.EnvoyerNotification(message); } } public void EnvoyerParPriorite(string message, int prioriteMin) { Console.WriteLine($\"\\n{'='.ToString().PadLeft(50, '=')}\"); Console.WriteLine($\"ENVOI PRIORITAIRE (\u003e= {prioriteMin})\"); Console.WriteLine($\"{'='.ToString().PadLeft(50, '=')}\\n\"); foreach (INotifiable canal in _canaux) { // V√©rifie si le canal supporte IPrioritaire if (canal is IPrioritaire prioritaire) { if (prioritaire.Priorite \u003e= prioriteMin) { canal.EnvoyerNotification(message); } } } } public void ConfigurerCanaux() { foreach (INotifiable canal in _canaux) { if (canal is IConfigurable configurable) { Console.WriteLine($\"\\nConfiguration de {canal.GetType().Name}:\"); var config = configurable.ObtenirConfiguration(); foreach (var param in config) { Console.WriteLine($\" {param.Key}: {param.Value}\"); } } } } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { GestionnaireNotifications gestionnaire = new GestionnaireNotifications(); // Cr√©ation et configuration des canaux var email = new NotificationEmail(); email.Configurer(new Dictionary\u003cstring, string\u003e { { \"email\", \"user@example.com\" }, { \"smtp\", \"smtp.example.com\" } }); var sms = new NotificationSMS { Priorite = 3 }; sms.Configurer(new Dictionary\u003cstring, string\u003e { { \"telephone\", \"+1-514-555-0123\" } }); var push = new NotificationPush { DeviceId = \"ABC123\", Priorite = 2 }; // Ajout des canaux gestionnaire.AjouterCanal(email); gestionnaire.AjouterCanal(sms); gestionnaire.AjouterCanal(push); // Envoi de notifications gestionnaire.EnvoyerATous(\"Bienvenue dans le syst√®me!\"); gestionnaire.EnvoyerParPriorite(\"ALERTE: Activit√© suspecte d√©tect√©e!\", 2); // Affichage de la configuration gestionnaire.ConfigurerCanaux(); } } 14.8 Interfaces vs Classes Abstraites : Quand Utiliser Quoi ? Utilisez une INTERFACE quand :\nVous d√©finissez un comportement que des classes sans relation peuvent partager Vous voulez permettre l‚Äôh√©ritage multiple de comportements Vous cr√©ez un plugin system ou une architecture d√©coupl√©e Les impl√©mentations seront tr√®s diff√©rentes Exemples d‚Äôinterfaces : IComparable, IDisposable, IEnumerable\nUtilisez une CLASSE ABSTRAITE quand :\nVous voulez partager du code entre classes li√©es Vous avez une hi√©rarchie ‚Äúest-un‚Äù claire Vous voulez fournir une impl√©mentation par d√©faut Les classes d√©riv√©es ont beaucoup en commun Exemples : Stream, DbConnection, Control (UI)\nExemple combin√© :\n// Interface pour le comportement public interface IPayable { bool EffectuerPaiement(decimal montant); } // Classe abstraite pour le code commun public abstract class MoyenPaiement : IPayable { protected string _titulaire; protected MoyenPaiement(string titulaire) { _titulaire = titulaire; } // Impl√©mentation commune public void AfficherTitulaire() { Console.WriteLine($\"Titulaire: {_titulaire}\"); } // Impl√©mentation de l'interface (peut √™tre virtual ou abstract) public abstract bool EffectuerPaiement(decimal montant); } public class CarteCredit : MoyenPaiement { public CarteCredit(string titulaire) : base(titulaire) { } public override bool EffectuerPaiement(decimal montant) { Console.WriteLine($\"Paiement de {montant:C} par carte\"); return true; } } 15. Membres Statiques 15.1 D√©finition Les membres statiques (attributs, m√©thodes, propri√©t√©s) appartiennent √† la classe elle-m√™me plut√¥t qu‚Äôaux instances individuelles de la classe.\nAnalogie :\nMembres d‚Äôinstance = Caract√©ristiques personnelles (votre √¢ge, votre nom) Membres statiques = Caract√©ristiques partag√©es (le nombre total d‚Äô√™tres humains sur Terre) Caract√©ristiques :\nUn seul exemplaire existe pour toute la classe Partag√© entre toutes les instances Accessible via le nom de la classe (pas via une instance) Existe m√™me sans aucune instance cr√©√©e 15.2 Attributs Statiques public class Compteur { // ========================================== // ATTRIBUT STATIQUE - Partag√© par toutes les instances // ========================================== private static int _nombreInstances = 0; // ========================================== // ATTRIBUT D'INSTANCE - Unique pour chaque objet // ========================================== private int _id; public int Id { get { return _id; } } // ========================================== // PROPRI√âT√â STATIQUE // ========================================== public static int NombreInstances { get { return _nombreInstances; } } // ========================================== // CONSTRUCTEUR // ========================================== public Compteur() { _nombreInstances++; // Modifie la variable STATIQUE _id = _nombreInstances; // Assigne un ID unique bas√© sur le compteur Console.WriteLine($\"Instance #{_id} cr√©√©e. Total: {_nombreInstances}\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { Console.WriteLine($\"Instances au d√©part: {Compteur.NombreInstances}\"); // 0 Compteur c1 = new Compteur(); // Instance #1 cr√©√©e. Total: 1 Compteur c2 = new Compteur(); // Instance #2 cr√©√©e. Total: 2 Compteur c3 = new Compteur(); // Instance #3 cr√©√©e. Total: 3 Console.WriteLine($\"\\nTotal d'instances: {Compteur.NombreInstances}\"); // 3 Console.WriteLine($\"ID de c1: {c1.Id}\"); // 1 Console.WriteLine($\"ID de c2: {c2.Id}\"); // 2 Console.WriteLine($\"ID de c3: {c3.Id}\"); // 3 // ========================================== // Le compteur est PARTAG√â // ========================================== Compteur c4 = new Compteur(); // Instance #4 cr√©√©e. Total: 4 Console.WriteLine($\"\\nTotal apr√®s c4: {Compteur.NombreInstances}\"); // 4 } } 15.3 M√©thodes Statiques public class CalculatriceMath { // ========================================== // M√âTHODES STATIQUES - Pas besoin d'instance // ========================================== public static double CalculerAireRectangle(double longueur, double largeur) { return longueur * largeur; } public static double CalculerAireCercle(double rayon) { return Math.PI * rayon * rayon; } public static int CalculerFactorielle(int n) { if (n \u003c= 1) return 1; return n * CalculerFactorielle(n - 1); } public static bool EstPremier(int nombre) { if (nombre \u003c 2) return false; for (int i = 2; i \u003c= Math.Sqrt(nombre); i++) { if (nombre % i == 0) return false; } return true; } } // Utilisation - SANS cr√©er d'objet double aire = CalculatriceMath.CalculerAireRectangle(5, 3); // 15 double cercle = CalculatriceMath.CalculerAireCercle(4); // ~50.27 int fact = CalculatriceMath.CalculerFactorielle(5); // 120 bool premier = CalculatriceMath.EstPremier(17); // true 15.4 Classes Statiques Une classe enti√®rement statique ne peut contenir que des membres statiques et ne peut pas √™tre instanci√©e.\n// ========================================== // CLASSE STATIQUE - Ne peut pas √™tre instanci√©e // ========================================== public static class Convertisseur { // Toutes les m√©thodes doivent √™tre statiques public static double CelsiusVersFahrenheit(double celsius) { return (celsius * 9 / 5) + 32; } public static double FahrenheitVersCelsius(double fahrenheit) { return (fahrenheit - 32) * 5 / 9; } public static double KilometresVersMiles(double km) { return km * 0.621371; } public static double MilesVersKilometres(double miles) { return miles / 0.621371; } } // Utilisation double fahrenheit = Convertisseur.CelsiusVersFahrenheit(25); // 77 double miles = Convertisseur.KilometresVersMiles(100); // 62.14 // ‚ùå ERREUR - Impossible d'instancier // Convertisseur conv = new Convertisseur(); Exemples de classes statiques dans .NET :\nConsole Math File Directory Environment 15.5 Constructeur Statique Un constructeur statique est ex√©cut√© une seule fois, avant la premi√®re utilisation de la classe.\npublic class Configuration { public static string CheminFichier { get; private set; } public static DateTime DateInitialisation { get; private set; } public static Dictionary\u003cstring, string\u003e Parametres { get; private set; } // ========================================== // CONSTRUCTEUR STATIQUE // Appel√© automatiquement avant la premi√®re utilisation // ========================================== static Configuration() { Console.WriteLine(\"Initialisation de la configuration...\"); CheminFichier = \"config.json\"; DateInitialisation = DateTime.Now; Parametres = new Dictionary\u003cstring, string\u003e { { \"version\", \"1.0\" }, { \"langue\", \"fr\" } }; Console.WriteLine($\"Configuration initialis√©e √† {DateInitialisation}\"); } public static void AfficherConfiguration() { Console.WriteLine($\"\\nConfiguration:\"); Console.WriteLine($\" Fichier: {CheminFichier}\"); Console.WriteLine($\" Initialis√©e: {DateInitialisation}\"); foreach (var param in Parametres) { Console.WriteLine($\" {param.Key}: {param.Value}\"); } } } // Utilisation class Program { static void Main() { Console.WriteLine(\"D√©but du programme\\n\"); // Le constructeur statique est appel√© ici (premi√®re utilisation) Configuration.AfficherConfiguration(); // Deuxi√®me utilisation - constructeur statique PAS rappel√© Configuration.AfficherConfiguration(); } } Affichage :\nD√©but du programme\rInitialisation de la configuration...\rConfiguration initialis√©e √† 01/02/2026 10:30:00\rConfiguration:\rFichier: config.json\rInitialis√©e: 01/02/2026 10:30:00\rversion: 1.0\rlangue: fr\rConfiguration:\rFichier: config.json\rInitialis√©e: 01/02/2026 10:30:00\rversion: 1.0\rlangue: fr 15.6 Exemple Complet : Gestionnaire de Base de Donn√©es public class GestionnaireDB { // ========================================== // MEMBRES STATIQUES - Partag√©s // ========================================== private static string _chaine Connexion; private static int _nombreConnexionsActives = 0; private static int _nombreConnexionsTotales = 0; public static int NombreConnexionsActives { get { return _nombreConnexionsActives; } } public static int NombreConnexionsTotales { get { return _nombreConnexionsTotales; } } // ========================================== // MEMBRES D'INSTANCE - Uniques √† chaque connexion // ========================================== private int _id; private bool _estConnecte; private DateTime _dateConnexion; public int Id { get { return _id; } } public bool EstConnecte { get { return _estConnecte; } } // ========================================== // CONSTRUCTEUR STATIQUE // ========================================== static GestionnaireDB() { Console.WriteLine(\"[STATIC] Initialisation du gestionnaire DB\"); _chaineConnexion = \"Server=localhost;Database=test;\"; } // ========================================== // CONSTRUCTEUR D'INSTANCE // ========================================== public GestionnaireDB() { _nombreConnexionsTotales++; _id = _nombreConnexionsTotales; Console.WriteLine($\"[INSTANCE #{_id}] Cr√©√©e\"); } // ========================================== // M√âTHODE D'INSTANCE // ========================================== public void Connecter() { if (!_estConnecte) { _estConnecte = true; _dateConnexion = DateTime.Now; _nombreConnexionsActives++; Console.WriteLine($\"[INSTANCE #{_id}] Connect√©e. Actives: {_nombreConnexionsActives}\"); } } public void Deconnecter() { if (_estConnecte) { _estConnecte = false; _nombreConnexionsActives--; Console.WriteLine($\"[INSTANCE #{_id}] D√©connect√©e. Actives: {_nombreConnexionsActives}\"); } } // ========================================== // M√âTHODE STATIQUE // ========================================== public static void AfficherStatistiques() { Console.WriteLine($\"\\n=== STATISTIQUES DB ===\"); Console.WriteLine($\"Cha√Æne de connexion: {_chaineConnexion}\"); Console.WriteLine($\"Connexions actives: {_nombreConnexionsActives}\"); Console.WriteLine($\"Total cr√©√©es: {_nombreConnexionsTotales}\"); Console.WriteLine($\"=======================\\n\"); } } // Utilisation class Program { static void Main() { GestionnaireDB.AfficherStatistiques(); // D√©clenche le constructeur statique GestionnaireDB db1 = new GestionnaireDB(); GestionnaireDB db2 = new GestionnaireDB(); GestionnaireDB db3 = new GestionnaireDB(); db1.Connecter(); db2.Connecter(); db3.Connecter(); GestionnaireDB.AfficherStatistiques(); db1.Deconnecter(); db2.Deconnecter(); GestionnaireDB.AfficherStatistiques(); } } 15.7 R√®gles Importantes public class Exemple { private static int _compteurStatique = 0; private int _compteurInstance = 0; // ========================================== // M√âTHODE STATIQUE // ========================================== public static void MethodeStatique() { // ‚úÖ OK - Acc√®s √† membre statique _compteurStatique++; // ‚ùå ERREUR - Pas d'acc√®s aux membres d'instance // _compteurInstance++; // ERREUR! // this._compteurInstance++; // ERREUR! // ‚úÖ OK - Appel d'autre m√©thode statique AutreMethodeStatique(); // ‚ùå ERREUR - Pas d'appel de m√©thode d'instance // MethodeInstance(); // ERREUR! } // ========================================== // M√âTHODE D'INSTANCE // ========================================== public void MethodeInstance() { // ‚úÖ OK - Acc√®s aux membres d'instance _compteurInstance++; // ‚úÖ OK - Acc√®s aux membres statiques aussi _compteurStatique++; // ‚úÖ OK - Appel de m√©thodes statiques MethodeStatique(); AutreMethodeStatique(); } private static void AutreMethodeStatique() { } } R√©sum√© Final Tableau R√©capitulatif des Concepts Concept D√©finition Exemple d‚ÄôUsage virtual M√©thode avec impl√©mentation, red√©finition optionnelle Comportement par d√©faut modifiable abstract M√©thode sans impl√©mentation, red√©finition obligatoire Forcer les d√©riv√©es √† impl√©menter sealed Emp√™che l‚Äôh√©ritage ou la red√©finition Classe/m√©thode finale override Red√©finit une m√©thode virtual ou abstract Polymorphisme new Masque un membre de la classe de base √âviter, pr√©f√©rer override base Acc√®de aux membres de la classe parent Appeler la version parente this R√©f√©rence √† l‚Äôinstance actuelle Distinguer attributs/param√®tres static Membre appartenant √† la classe Utilitaires, compteurs partag√©s interface Contrat sans impl√©mentation D√©finir comportements multiples abstract class Classe incompl√®te avec code partag√© Base commune avec impl√©mentation Hi√©rarchie Compl√®te d‚ÄôExemple // Interface public interface IVolant { void Voler(); } // Classe abstraite public abstract class Animal { protected string _nom; public Animal(string nom) { _nom = nom; } // M√©thode abstraite public abstract void EmettreSound(); // M√©thode virtuelle public virtual void Dormir() { Console.WriteLine($\"{_nom} dort\"); } // M√©thode concr√®te public void Respirer() { Console.WriteLine($\"{_nom} respire\"); } } // Classe concr√®te public class Oiseau : Animal, IVolant { public Oiseau(string nom) : base(nom) { } // Impl√©mentation obligatoire (abstract) public override void EmettreSound() { Console.WriteLine($\"{_nom} chante\"); } // Red√©finition optionnelle (virtual) public override void Dormir() { Console.WriteLine($\"{_nom} dort dans un nid\"); } // Impl√©mentation d'interface public void Voler() { Console.WriteLine($\"{_nom} vole\"); } } // Classe sealed public sealed class Pingouin : Oiseau { public Pingouin(string nom) : base(nom) { } // Sealed override public sealed override void Dormir() { Console.WriteLine($\"{_nom} dort en groupe\"); } // Les pingouins ne volent pas, mais impl√©mentent quand m√™me IVolant public new void Voler() { Console.WriteLine($\"{_nom} ne peut pas voler!\"); } } // ‚ùå Impossible d'h√©riter de Pingouin (sealed) // public class SuperPingouin : Pingouin { }",
    "description": "Table des mati√®res Introduction √† la POO Les Classes et les Objets Les Attributs (Champs) Les Propri√©t√©s (Properties) L‚ÄôEncapsulation Les M√©thodes Les Constructeurs L‚ÄôH√©ritage Le Polymorphisme Le mot-cl√© Virtual Le mot-cl√© Abstract Le mot-cl√© Sealed Les Classes Abstraites Les Interfaces Membres Statiques Cours POO C# - Partie 2 : Concepts Avanc√©s 10. Le mot-cl√© Virtual 10.1 D√©finition Le mot-cl√© virtual permet de d√©clarer une m√©thode qui peut √™tre red√©finie (override) dans les classes d√©riv√©es. C‚Äôest la base du polymorphisme d‚Äôex√©cution en C#.",
    "tags": [],
    "title": "Programmation orient√©e objet - partie 2",
    "uri": "/420-413/poo/index_1/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Table des mati√®res Le mot-cl√© Virtual Le mot-cl√© Abstract Le mot-cl√© Sealed Les Classes Abstraites Les Interfaces Membres Statiques 1. Introduction √† la POO 1.1 Qu‚Äôest-ce que la Programmation Orient√©e Objet ? La Programmation Orient√©e Objet (POO) est un paradigme de programmation qui organise le code autour du concept d‚Äôobjets plut√¥t que de fonctions et de logique. Un objet combine des donn√©es (ce qu‚Äôil poss√®de) et des comportements (ce qu‚Äôil peut faire).\nüåç Analogie du monde r√©el Pensez √† une voiture dans le monde r√©el :\nDonn√©es : couleur, marque, mod√®le, vitesse actuelle, niveau d‚Äôessence Comportements : d√©marrer, acc√©l√©rer, freiner, tourner, klaxonner En POO, nous mod√©lisons ces concepts du monde r√©el dans notre code.\n1.2 Pourquoi utiliser la POO ? Avant la POO (Programmation proc√©durale) :\n// Variables dispers√©es string voitureMarque = \"Toyota\"; string voitureModele = \"Camry\"; int voitureVitesse = 0; // Fonctions s√©par√©es void DemarrerVoiture() { /* ... */ } void AccelererVoiture(int vitesse) { /* ... */ } Avec la POO :\n// Tout est regroup√© logiquement class Voiture { string marque; string modele; int vitesse; void Demarrer() { /* ... */ } void Accelerer(int increment) { /* ... */ } } Avantages de la POO :\nOrganisation : Le code est structur√© et logique R√©utilisabilit√© : Les classes peuvent √™tre r√©utilis√©es Maintenabilit√© : Plus facile √† maintenir et modifier Modularit√© : Chaque classe a une responsabilit√© claire Abstraction : Cache la complexit√© interne 1.3 Les 4 Piliers Fondamentaux de la POO 1Ô∏è‚É£ Encapsulation Regrouper les donn√©es et les m√©thodes ensemble, et contr√¥ler l‚Äôacc√®s aux donn√©es.\nExemple concret : Un compte bancaire\nVous ne pouvez pas modifier directement le solde Vous devez passer par des m√©thodes (d√©poser, retirer) Cela prot√®ge l‚Äôint√©grit√© des donn√©es 2Ô∏è‚É£ H√©ritage Cr√©er de nouvelles classes bas√©es sur des classes existantes.\nExemple concret : V√©hicules\nClasse de base : Vehicule (propri√©t√©s communes : marque, mod√®le) Classes d√©riv√©es : Voiture, Moto, Camion (ajoutent leurs sp√©cificit√©s) 3Ô∏è‚É£ Polymorphisme Utiliser une m√™me interface pour des types diff√©rents.\nExemple concret : Animaux\nTous peuvent ‚Äú√©mettre un son‚Äù Le chien aboie, le chat miaule, l‚Äôoiseau chante M√™me m√©thode, comportements diff√©rents 4Ô∏è‚É£ Abstraction Montrer seulement l‚Äôessentiel, cacher les d√©tails complexes.\nExemple concret : Conduire une voiture\nVous utilisez le volant, les p√©dales Vous n‚Äôavez pas besoin de comprendre le moteur interne 2. Les Classes et les Objets 2.1 Qu‚Äôest-ce qu‚Äôune Classe ? Une classe est un plan ou un mod√®le qui d√©finit la structure et le comportement d‚Äôobjets. C‚Äôest comme un plan d‚Äôarchitecte pour construire une maison.\nM√©taphore :\nUne classe est comme un moule √† biscuits üç™ Les objets sont les biscuits cr√©√©s avec ce moule Tous les biscuits ont la m√™me forme (structure), mais peuvent avoir des diff√©rences (valeurs) 2.2 Qu‚Äôest-ce qu‚Äôun Objet ? Un objet est une instance d‚Äôune classe. C‚Äôest une entit√© concr√®te cr√©√©e √† partir du mod√®le d√©fini par la classe.\n2.3 Anatomie d‚Äôune Classe // D√©claration d'une classe public class Personne { // ========================================== // ATTRIBUTS (CHAMPS) - Ce que l'objet poss√®de // ========================================== private string nom; private string prenom; private int age; // ========================================== // PROPRI√âT√âS - Interface contr√¥l√©e pour les attributs // ========================================== public string Nom { get { return nom; } set { nom = value; } } // ========================================== // CONSTRUCTEUR - Comment cr√©er l'objet // ========================================== public Personne(string nom, string prenom, int age) { this.nom = nom; this.prenom = prenom; this.age = age; } // ========================================== // M√âTHODES - Ce que l'objet peut faire // ========================================== public void SePresenter() { Console.WriteLine($\"Bonjour, je suis {prenom} {nom}, {age} ans.\"); } } 2.4 Cr√©ation et Utilisation d‚ÄôObjets class Program { static void Main() { // ========================================== // CR√âATION D'OBJETS (INSTANCIATION) // ========================================== // Syntaxe : Type nomVariable = new Constructeur(); Personne personne1 = new Personne(\"Tremblay\", \"Marie\", 25); Personne personne2 = new Personne(\"Gagnon\", \"Jean\", 30); Personne personne3 = new Personne(\"Roy\", \"Sophie\", 28); // Chaque objet est UNIQUE et IND√âPENDANT // personne1, personne2, personne3 sont 3 objets diff√©rents // ========================================== // UTILISATION DES OBJETS // ========================================== personne1.SePresenter(); // Affiche: Bonjour, je suis Marie Tremblay, 25 ans. personne2.SePresenter(); // Affiche: Bonjour, je suis Jean Gagnon, 30 ans. // Acc√®s aux propri√©t√©s Console.WriteLine(personne1.Nom); // Affiche: Tremblay } } 2.5 Comprendre la M√©moire : R√©f√©rence vs Valeur // Les CLASSES sont des types R√âF√âRENCE Personne p1 = new Personne(\"Dubois\", \"Luc\", 35); Personne p2 = p1; // p2 pointe vers le M√äME objet que p1 p2.Nom = \"Martin\"; // Modifie l'objet Console.WriteLine(p1.Nom); // Affiche: Martin Console.WriteLine(p2.Nom); // Affiche: Martin // p1 et p2 pointent vers le m√™me objet en m√©moire ! Illustration :\nM√©moire:\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ Objet Personne ‚îÇ\r‚îÇ Nom: \"Martin\" ‚îÇ ‚Üê‚îÄ‚îÄ p1 pointe ici\r‚îÇ Prenom: \"Luc\" ‚îÇ ‚Üê‚îÄ‚îÄ p2 pointe ici aussi\r‚îÇ Age: 35 ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 3. Les Attributs (Champs) 3.1 D√©finition Les attributs (ou champs ou fields) sont des variables d√©clar√©es directement dans une classe. Ils repr√©sentent l‚Äô√©tat ou les donn√©es de l‚Äôobjet.\n3.2 D√©claration des Attributs public class CompteBancaire { // ========================================== // ATTRIBUTS PRIV√âS (convention : pr√©fixe _) // ========================================== private string _numeroCompte; private string _titulaire; private decimal _solde; private DateTime _dateOuverture; private bool _estActif; // ========================================== // ATTRIBUTS PUBLICS (√† √©viter g√©n√©ralement) // ========================================== public int nombreTransactions; // Moins s√©curis√© } 3.3 Pourquoi des Attributs Priv√©s ? ‚ùå Probl√®me avec des attributs publics :\npublic class CompteBancaire { public decimal solde; // PUBLIC = DANGER ! } // Dans le code utilisateur CompteBancaire compte = new CompteBancaire(); compte.solde = -5000; // ‚ùå On peut mettre n'importe quoi ! compte.solde = 999999999; // ‚ùå Aucune validation ! ‚úÖ Solution avec des attributs priv√©s :\npublic class CompteBancaire { private decimal _solde; // PRIV√â = PROT√âG√â public void Deposer(decimal montant) { if (montant \u003e 0) // ‚úÖ Validation { _solde += montant; } } } 3.4 Initialisation des Attributs public class Voiture { // Initialisation lors de la d√©claration private string _marque = \"Inconnue\"; private int _annee = 2020; private double _kilometrage = 0.0; private bool _estDemarree = false; // Sans initialisation (valeurs par d√©faut) private int _nombrePortes; // 0 par d√©faut private string _couleur; // null par d√©faut } Valeurs par d√©faut en C# :\nint, double, float : 0 bool : false string, objets : null DateTime : 01/01/0001 00:00:00 4. Les Propri√©t√©s (Properties) 4.1 Qu‚Äôest-ce qu‚Äôune Propri√©t√© ? Une propri√©t√© est un membre de classe qui fournit un m√©canisme flexible pour lire et √©crire les valeurs des attributs priv√©s. C‚Äôest l‚Äôinterface publique pour acc√©der aux donn√©es priv√©es.\nAnalogie :\nL‚Äôattribut priv√© = Le coffre-fort üîí La propri√©t√© = La porte avec code d‚Äôacc√®s üö™ Le getter = Ouvrir pour voir le contenu üëÄ Le setter = Ouvrir pour modifier le contenu ‚úçÔ∏è 4.2 Syntaxe Compl√®te d‚Äôune Propri√©t√© public class Personne { // ========================================== // ATTRIBUT PRIV√â // ========================================== private int _age; // ========================================== // PROPRI√âT√â AVEC GET ET SET COMPLETS // ========================================== public int Age { // GETTER - Lit la valeur get { Console.WriteLine(\"Lecture de l'√¢ge\"); return _age; } // SETTER - Modifie la valeur set { Console.WriteLine($\"Modification de l'√¢ge: {value}\"); // VALIDATION avant d'assigner if (value \u003e= 0 \u0026\u0026 value \u003c= 150) { _age = value; } else { Console.WriteLine(\"√Çge invalide!\"); } } } } // Utilisation Personne p = new Personne(); p.Age = 25; // Appelle le SETTER avec value = 25 int monAge = p.Age; // Appelle le GETTER 4.3 Types de Propri√©t√©s A) Propri√©t√© Lecture/√âcriture (Get/Set) public class Produit { private string _nom; public string Nom { get { return _nom; } set { _nom = value; } } } B) Propri√©t√© en Lecture Seule (Get seulement) public class Personne { private DateTime _dateNaissance; // On peut LIRE mais pas MODIFIER de l'ext√©rieur public DateTime DateNaissance { get { return _dateNaissance; } // Pas de SET = lecture seule } public Personne(DateTime dateNaissance) { _dateNaissance = dateNaissance; // D√©fini dans le constructeur } } // Utilisation Personne p = new Personne(new DateTime(1990, 5, 15)); Console.WriteLine(p.DateNaissance); // ‚úÖ OK - Lecture // p.DateNaissance = DateTime.Now; // ‚ùå ERREUR - Pas de setter! C) Propri√©t√© en √âcriture Seule (Set seulement) - RARE public class CompteSecurise { private string _motDePasse; // On peut √âCRIRE mais pas LIRE (pour la s√©curit√©) public string MotDePasse { set { _motDePasse = HashPassword(value); } // Pas de GET pour des raisons de s√©curit√© } private string HashPassword(string password) { // Logique de hachage return password; // Simplifi√© } } D) Propri√©t√© Auto-Impl√©ment√©e (Raccourci) public class Livre { // ========================================== // PROPRI√âT√â AUTO-IMPL√âMENT√âE // Le compilateur cr√©e automatiquement un attribut priv√© cach√© // ========================================== public string Titre { get; set; } public string Auteur { get; set; } public int NombrePages { get; set; } // √âquivalent √† : // private string _titre; // public string Titre { get { return _titre; } set { _titre = value; } } } // Utilisation Livre livre = new Livre(); livre.Titre = \"Le Petit Prince\"; livre.Auteur = \"Antoine de Saint-Exup√©ry\"; livre.NombrePages = 96; E) Propri√©t√© avec Logique M√©tier public class Rectangle { private double _longueur; private double _largeur; public double Longueur { get { return _longueur; } set { if (value \u003e 0) _longueur = value; else throw new ArgumentException(\"La longueur doit √™tre positive\"); } } public double Largeur { get { return _largeur; } set { if (value \u003e 0) _largeur = value; else throw new ArgumentException(\"La largeur doit √™tre positive\"); } } // ========================================== // PROPRI√âT√â CALCUL√âE (pas d'attribut associ√©) // ========================================== public double Aire { get { return _longueur * _largeur; } // Pas de SET - calcul√©e √† chaque fois } public double Perimetre { get { return 2 * (_longueur + _largeur); } } } // Utilisation Rectangle rect = new Rectangle(); rect.Longueur = 5; rect.Largeur = 3; Console.WriteLine($\"Aire: {rect.Aire}\"); // 15 Console.WriteLine($\"P√©rim√®tre: {rect.Perimetre}\"); // 16 F) Propri√©t√© avec Accessibilit√© Diff√©rente public class CompteBancaire { private decimal _solde; // ========================================== // GET public, SET priv√© // Tout le monde peut LIRE, seule la classe peut MODIFIER // ========================================== public decimal Solde { get { return _solde; } private set { _solde = value; } // SET PRIV√â } // M√©thodes publiques pour modifier le solde de mani√®re contr√¥l√©e public void Deposer(decimal montant) { if (montant \u003e 0) Solde += montant; // Utilise le setter priv√© } public bool Retirer(decimal montant) { if (montant \u003e 0 \u0026\u0026 montant \u003c= Solde) { Solde -= montant; // Utilise le setter priv√© return true; } return false; } } // Utilisation CompteBancaire compte = new CompteBancaire(); Console.WriteLine(compte.Solde); // ‚úÖ OK - Lecture publique // compte.Solde = 1000; // ‚ùå ERREUR - Set est priv√© compte.Deposer(1000); // ‚úÖ OK - M√©thode publique 4.4 Le Mot-Cl√© value Dans un setter, le mot-cl√© value repr√©sente la valeur qu‚Äôon essaie d‚Äôassigner.\npublic class Exemple { private int _nombre; public int Nombre { get { return _nombre; } set { // 'value' contient la valeur assign√©e Console.WriteLine($\"Valeur re√ßue: {value}\"); _nombre = value; } } } // Utilisation Exemple ex = new Exemple(); ex.Nombre = 42; // 'value' vaut 42 dans le setter 4.5 Propri√©t√©s: Quand Utiliser Quoi ? Situation Type de Propri√©t√© Donn√©es simples sans validation Auto-impl√©ment√©e { get; set; } Donn√©es n√©cessitant validation Propri√©t√© compl√®te avec logique Donn√©es calcul√©es Get seulement (calcul√©e) Donn√©es d√©finies √† la cr√©ation Get seulement + constructeur Donn√©es sensibles Get public, Set priv√© Mot de passe Set seulement (√©criture seule) 5. L‚ÄôEncapsulation 5.1 D√©finition Approfondie L‚Äôencapsulation est le principe qui consiste √† :\nRegrouper les donn√©es (attributs) et les comportements (m√©thodes) dans une classe Cacher les d√©tails d‚Äôimpl√©mentation internes Contr√¥ler l‚Äôacc√®s aux donn√©es via une interface publique M√©taphore de la voiture :\nVous n‚Äôavez pas besoin de comprendre comment fonctionne le moteur (d√©tails cach√©s) Vous utilisez le volant, les p√©dales, le levier de vitesse (interface publique) Le moteur est prot√©g√© sous le capot (encapsulation) 5.2 Modificateurs d‚ÄôAcc√®s Les modificateurs d‚Äôacc√®s contr√¥lent QUI peut acc√©der √† quoi.\nTableau Complet des Modificateurs Modificateur Acc√®s Usage Typique private Classe uniquement Attributs, m√©thodes internes protected Classe + classes d√©riv√©es M√©thodes partag√©es avec enfants internal M√™me assembly (projet) Classes utilitaires internes protected internal Assembly OU d√©riv√©es Cas sp√©cifiques public Partout Interface publique, API Exemples D√©taill√©s public class Voiture { // ========================================== // PRIVATE - Accessible UNIQUEMENT dans cette classe // ========================================== private string _numeroSerie; // Donn√©e sensible private int _temperatureMoteur; // D√©tail interne private void DemarrerMoteur() // M√©thode interne { Console.WriteLine(\"Moteur d√©marr√©\"); } // ========================================== // PROTECTED - Accessible dans cette classe ET ses d√©riv√©es // ========================================== protected double _consommationBase; // Les classes enfants peuvent y acc√©der protected void CalculerConsommation() // M√©thode pour les d√©riv√©es { Console.WriteLine(\"Calcul de la consommation\"); } // ========================================== // PUBLIC - Accessible PARTOUT // ========================================== public string Marque { get; set; } // Propri√©t√© publique public string Modele { get; set; } public void Demarrer() // M√©thode publique (interface) { DemarrerMoteur(); // Appelle la m√©thode priv√©e Console.WriteLine(\"Voiture d√©marr√©e\"); } public void Accelerer(int vitesse) { // Interface publique qui utilise des d√©tails priv√©s _temperatureMoteur += 10; Console.WriteLine($\"Acc√©l√©ration √† {vitesse} km/h\"); } } // Classe d√©riv√©e public class VoitureElectrique : Voiture { public void ChargerBatterie() { // ‚úÖ OK - Acc√®s √† protected _consommationBase = 0.15; CalculerConsommation(); // ‚ùå ERREUR - Pas d'acc√®s √† private // _numeroSerie = \"123\"; // ERREUR DE COMPILATION // DemarrerMoteur(); // ERREUR DE COMPILATION // ‚úÖ OK - Acc√®s √† public Marque = \"Tesla\"; Demarrer(); } } // Utilisation externe class Program { static void Main() { Voiture maVoiture = new Voiture(); // ‚úÖ OK - Acc√®s aux membres publics maVoiture.Marque = \"Toyota\"; maVoiture.Demarrer(); maVoiture.Accelerer(50); // ‚ùå ERREUR - Pas d'acc√®s aux membres priv√©s // maVoiture._numeroSerie = \"ABC123\"; // ERREUR // maVoiture.DemarrerMoteur(); // ERREUR // ‚ùå ERREUR - Pas d'acc√®s aux membres protected // maVoiture._consommationBase = 0.10; // ERREUR // maVoiture.CalculerConsommation(); // ERREUR } } 5.3 Exemple Complet : Compte Bancaire Bien Encapsul√© public class CompteBancaire { // ========================================== // ATTRIBUTS PRIV√âS - √âtat interne prot√©g√© // ========================================== private string _numeroCompte; private string _titulaire; private decimal _solde; private List\u003cstring\u003e _historiqueTransactions; private DateTime _dateOuverture; private const decimal FRAIS_RETRAIT = 1.50m; // Constante priv√©e // ========================================== // PROPRI√âT√âS PUBLIQUES - Interface contr√¥l√©e // ========================================== // Lecture seule de l'ext√©rieur public string NumeroCompte { get { return _numeroCompte; } private set { _numeroCompte = value; } } public string Titulaire { get { return _titulaire; } set { if (!string.IsNullOrWhiteSpace(value)) _titulaire = value; } } // Lecture seule - impossible de modifier directement public decimal Solde { get { return _solde; } private set { _solde = value; } } public DateTime DateOuverture { get { return _dateOuverture; } } // ========================================== // CONSTRUCTEUR // ========================================== public CompteBancaire(string titulaire, string numeroCompte) { _titulaire = titulaire; _numeroCompte = numeroCompte; _solde = 0; _dateOuverture = DateTime.Now; _historiqueTransactions = new List\u003cstring\u003e(); AjouterTransaction(\"Ouverture du compte\"); } // ========================================== // M√âTHODES PUBLIQUES - Actions autoris√©es // ========================================== public bool Deposer(decimal montant) { if (montant \u003c= 0) { Console.WriteLine(\"Le montant doit √™tre positif\"); return false; } _solde += montant; AjouterTransaction($\"D√©p√¥t de {montant:C}\"); Console.WriteLine($\"D√©p√¥t r√©ussi. Nouveau solde: {_solde:C}\"); return true; } public bool Retirer(decimal montant) { if (montant \u003c= 0) { Console.WriteLine(\"Le montant doit √™tre positif\"); return false; } decimal montantTotal = montant + FRAIS_RETRAIT; if (montantTotal \u003e _solde) { Console.WriteLine(\"Solde insuffisant\"); return false; } _solde -= montantTotal; AjouterTransaction($\"Retrait de {montant:C} (frais: {FRAIS_RETRAIT:C})\"); Console.WriteLine($\"Retrait r√©ussi. Nouveau solde: {_solde:C}\"); return true; } public void AfficherHistorique() { Console.WriteLine($\"\\n=== Historique du compte {_numeroCompte} ===\"); foreach (string transaction in _historiqueTransactions) { Console.WriteLine(transaction); } } // ========================================== // M√âTHODES PRIV√âES - D√©tails d'impl√©mentation // ========================================== private void AjouterTransaction(string description) { string transaction = $\"{DateTime.Now:dd/MM/yyyy HH:mm:ss} - {description}\"; _historiqueTransactions.Add(transaction); } private bool VerifierFrauude() { // Logique complexe de v√©rification return true; } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { CompteBancaire compte = new CompteBancaire(\"Jean Dupont\", \"12345\"); // ‚úÖ Interface publique propre et s√©curis√©e compte.Deposer(1000); compte.Retirer(50); compte.AfficherHistorique(); // ‚úÖ Lecture s√©curis√©e Console.WriteLine($\"Solde actuel: {compte.Solde:C}\"); // ‚ùå Impossible de tricher! // compte.Solde = 9999999; // ERREUR - Setter priv√© // compte._solde += 1000; // ERREUR - Attribut priv√© } } 5.4 Avantages de l‚ÄôEncapsulation S√©curit√© : Protection des donn√©es contre les modifications non autoris√©es Validation : Contr√¥le des valeurs assign√©es Flexibilit√© : Modification de l‚Äôimpl√©mentation interne sans casser le code externe Maintenance : Code plus facile √† comprendre et modifier D√©bogage : Points de contr√¥le clairs pour tracer les probl√®mes 6. Les M√©thodes 6.1 D√©finition Les m√©thodes sont des fonctions d√©finies √† l‚Äôint√©rieur d‚Äôune classe. Elles repr√©sentent les comportements ou actions que les objets peuvent effectuer.\n6.2 Syntaxe Compl√®te [modificateur d'acc√®s] [modificateurs] [type de retour] NomMethode([param√®tres]) { // Corps de la m√©thode return valeur; // Si type de retour n'est pas void } 6.3 Types de M√©thodes A) M√©thode Sans Retour (void) public class Robot { public void Avancer() { Console.WriteLine(\"Le robot avance\"); // Pas de return - void signifie \"ne retourne rien\" } public void Saluer(string nom) { Console.WriteLine($\"Bonjour {nom}!\"); } } B) M√©thode Avec Retour public class Calculatrice { public int Additionner(int a, int b) { int resultat = a + b; return resultat; // DOIT retourner un int } public double CalculerMoyenne(double[] nombres) { double somme = 0; foreach (double nombre in nombres) { somme += nombre; } return somme / nombres.Length; } public bool EstPair(int nombre) { return nombre % 2 == 0; // Retourne true ou false } } C) M√©thode Avec Param√®tres public class GestionnaireEmail { // Param√®tres obligatoires public void EnvoyerEmail(string destinataire, string sujet, string message) { Console.WriteLine($\"√Ä: {destinataire}\"); Console.WriteLine($\"Sujet: {sujet}\"); Console.WriteLine($\"Message: {message}\"); } // Param√®tres avec valeurs par d√©faut public void EnvoyerNotification(string message, string niveau = \"INFO\") { Console.WriteLine($\"[{niveau}] {message}\"); } } // Utilisation GestionnaireEmail gestionnaire = new GestionnaireEmail(); gestionnaire.EnvoyerEmail(\"jean@example.com\", \"Bienvenue\", \"Bonjour!\"); gestionnaire.EnvoyerNotification(\"Syst√®me d√©marr√©\"); // Utilise niveau par d√©faut gestionnaire.EnvoyerNotification(\"Erreur d√©tect√©e\", \"ERREUR\"); // Sp√©cifie le niveau D) Surcharge de M√©thodes (Overloading) Plusieurs m√©thodes avec le m√™me nom mais des param√®tres diff√©rents.\npublic class Calculatrice { // M√™me nom, param√®tres diff√©rents public int Additionner(int a, int b) { return a + b; } public int Additionner(int a, int b, int c) { return a + b + c; } public double Additionner(double a, double b) { return a + b; } public int Additionner(params int[] nombres) // Nombre variable de param√®tres { int somme = 0; foreach (int nombre in nombres) { somme += nombre; } return somme; } } // Utilisation Calculatrice calc = new Calculatrice(); calc.Additionner(5, 3); // Appelle la version √† 2 int calc.Additionner(5, 3, 2); // Appelle la version √† 3 int calc.Additionner(5.5, 3.2); // Appelle la version √† 2 double calc.Additionner(1, 2, 3, 4, 5, 6); // Appelle la version avec params 6.4 Le Mot-Cl√© this this fait r√©f√©rence √† l‚Äôinstance actuelle de la classe.\npublic class Personne { private string nom; private int age; public Personne(string nom, int age) { // 'this.nom' = attribut de la classe // 'nom' = param√®tre du constructeur this.nom = nom; // Distingue l'attribut du param√®tre this.age = age; } public void Comparer(Personne autre) { if (this.age \u003e autre.age) { Console.WriteLine($\"{this.nom} est plus √¢g√© que {autre.nom}\"); } } public Personne ObtenirR√©f√©rence() { return this; // Retourne l'objet lui-m√™me } } 6.5 M√©thodes d‚ÄôInstance vs M√©thodes Statiques public class Utilitaires { // Attribut d'instance private int compteur = 0; // ========================================== // M√âTHODE D'INSTANCE - N√©cessite un objet // ========================================== public void Incrementer() { compteur++; // Acc√®de √† l'attribut d'instance Console.WriteLine($\"Compteur: {compteur}\"); } // ========================================== // M√âTHODE STATIQUE - Pas besoin d'objet // ========================================== public static int Additionner(int a, int b) { // Ne peut PAS acc√©der aux membres d'instance // compteur++; // ‚ùå ERREUR! return a + b; } public static double CalculerAire(double rayon) { return Math.PI * rayon * rayon; } } // Utilisation // M√©thode d'instance Utilitaires util = new Utilitaires(); util.Incrementer(); // Besoin d'un objet // M√©thode statique int somme = Utilitaires.Additionner(5, 3); // Pas besoin d'objet double aire = Utilitaires.CalculerAire(5); 7. Les Constructeurs 7.1 D√©finition Approfondie Un constructeur est une m√©thode sp√©ciale qui est automatiquement appel√©e lors de la cr√©ation d‚Äôun objet. Son r√¥le principal est d‚Äôinitialiser l‚Äôobjet dans un √©tat valide.\nCaract√©ristiques d‚Äôun constructeur :\nM√™me nom que la classe Pas de type de retour (m√™me pas void) Peut avoir des param√®tres Peut √™tre surcharg√© (plusieurs constructeurs diff√©rents) Appel√© automatiquement avec new M√©taphore : Le constructeur est comme le mode d‚Äôemploi d‚Äôassemblage d‚Äôun meuble IKEA. Il d√©finit comment cr√©er et pr√©parer l‚Äôobjet pour qu‚Äôil soit utilisable.\n7.2 Constructeur Par D√©faut public class Voiture { public string Marque; public string Modele; public int Annee; // ========================================== // CONSTRUCTEUR PAR D√âFAUT (sans param√®tres) // ========================================== public Voiture() { Console.WriteLine(\"Construction d'une voiture...\"); Marque = \"Inconnue\"; Modele = \"Standard\"; Annee = 2020; } } // Utilisation Voiture v = new Voiture(); // Appelle le constructeur par d√©faut Console.WriteLine($\"{v.Marque} {v.Modele}\"); // Inconnue Standard Important : Si vous ne d√©finissez AUCUN constructeur, C# cr√©e automatiquement un constructeur par d√©faut vide. Mais si vous d√©finissez au moins un constructeur, le constructeur par d√©faut automatique dispara√Æt.\npublic class Exemple1 { // Pas de constructeur d√©fini // C# cr√©e automatiquement : public Exemple1() { } } public class Exemple2 { public Exemple2(int valeur) { } // Le constructeur par d√©faut automatique N'EXISTE PLUS } // Utilisation Exemple1 e1 = new Exemple1(); // ‚úÖ OK Exemple2 e2 = new Exemple2(); // ‚ùå ERREUR - Pas de constructeur sans param√®tre Exemple2 e3 = new Exemple2(5); // ‚úÖ OK 7.3 Constructeur Avec Param√®tres public class Personne { public string Nom { get; set; } public string Prenom { get; set; } public int Age { get; set; } // ========================================== // CONSTRUCTEUR AVEC PARAM√àTRES // ========================================== public Personne(string nom, string prenom, int age) { Console.WriteLine(\"Cr√©ation d'une personne...\"); // Validation avant assignation if (string.IsNullOrWhiteSpace(nom)) throw new ArgumentException(\"Le nom ne peut pas √™tre vide\"); if (age \u003c 0 || age \u003e 150) throw new ArgumentException(\"√Çge invalide\"); Nom = nom; Prenom = prenom; Age = age; } } // Utilisation Personne p1 = new Personne(\"Tremblay\", \"Marie\", 25); // Personne p2 = new Personne(\"\", \"Jean\", 30); // ‚ùå Exception lev√©e 7.4 Surcharge de Constructeurs Une classe peut avoir plusieurs constructeurs avec diff√©rents param√®tres.\npublic class Livre { public string Titre { get; set; } public string Auteur { get; set; } public int Annee { get; set; } public int Pages { get; set; } // ========================================== // CONSTRUCTEUR 1 : Sans param√®tres // ========================================== public Livre() { Titre = \"Sans titre\"; Auteur = \"Anonyme\"; Annee = DateTime.Now.Year; Pages = 0; Console.WriteLine(\"Livre cr√©√© avec valeurs par d√©faut\"); } // ========================================== // CONSTRUCTEUR 2 : Titre seulement // ========================================== public Livre(string titre) { Titre = titre; Auteur = \"Anonyme\"; Annee = DateTime.Now.Year; Pages = 0; Console.WriteLine($\"Livre '{titre}' cr√©√©\"); } // ========================================== // CONSTRUCTEUR 3 : Titre et Auteur // ========================================== public Livre(string titre, string auteur) { Titre = titre; Auteur = auteur; Annee = DateTime.Now.Year; Pages = 0; Console.WriteLine($\"Livre '{titre}' de {auteur} cr√©√©\"); } // ========================================== // CONSTRUCTEUR 4 : Tous les param√®tres // ========================================== public Livre(string titre, string auteur, int annee, int pages) { Titre = titre; Auteur = auteur; Annee = annee; Pages = pages; Console.WriteLine($\"Livre complet cr√©√©\"); } } // Utilisation - Le compilateur choisit le bon constructeur Livre l1 = new Livre(); // Constructeur 1 Livre l2 = new Livre(\"1984\"); // Constructeur 2 Livre l3 = new Livre(\"Le Petit Prince\", \"Saint-Exup√©ry\"); // Constructeur 3 Livre l4 = new Livre(\"Dune\", \"Frank Herbert\", 1965, 412); // Constructeur 4 7.5 Cha√Ænage de Constructeurs avec this Pour √©viter la duplication de code, un constructeur peut appeler un autre constructeur de la m√™me classe avec : this().\npublic class Rectangle { public double Longueur { get; set; } public double Largeur { get; set; } public string Couleur { get; set; } // ========================================== // CONSTRUCTEUR PRINCIPAL (le plus complet) // ========================================== public Rectangle(double longueur, double largeur, string couleur) { Console.WriteLine(\"Constructeur principal appel√©\"); Longueur = longueur; Largeur = largeur; Couleur = couleur; } // ========================================== // CONSTRUCTEUR qui appelle le principal // ========================================== public Rectangle(double longueur, double largeur) : this(longueur, largeur, \"Blanc\") // Appelle le constructeur principal { Console.WriteLine(\"Constructeur sans couleur\"); // Pas besoin de r√©p√©ter l'assignation de longueur et largeur } // ========================================== // CONSTRUCTEUR pour un carr√© // ========================================== public Rectangle(double cote) : this(cote, cote, \"Blanc\") // Appelle le constructeur principal { Console.WriteLine(\"Constructeur pour carr√©\"); } // ========================================== // CONSTRUCTEUR par d√©faut // ========================================== public Rectangle() : this(1, 1, \"Blanc\") // Appelle le constructeur principal { Console.WriteLine(\"Constructeur par d√©faut\"); } } // Utilisation Rectangle r1 = new Rectangle(5, 3, \"Rouge\"); // Affiche: \"Constructeur principal appel√©\" Rectangle r2 = new Rectangle(5, 3); // Affiche: \"Constructeur principal appel√©\" // \"Constructeur sans couleur\" Rectangle r3 = new Rectangle(4); // Affiche: \"Constructeur principal appel√©\" // \"Constructeur pour carr√©\" Ordre d‚Äôex√©cution :\nLe constructeur appel√© avec : this() s‚Äôex√©cute en PREMIER Puis le constructeur actuel s‚Äôex√©cute 7.6 Constructeurs Priv√©s Un constructeur peut √™tre priv√© pour contr√¥ler la cr√©ation d‚Äôinstances.\n// ========================================== // PATTERN SINGLETON - Une seule instance possible // ========================================== public class Configuration { private static Configuration _instance = null; public string CheminFichier { get; set; } public string Langue { get; set; } // ========================================== // CONSTRUCTEUR PRIV√â - Impossible de faire 'new Configuration()' // ========================================== private Configuration() { CheminFichier = \"config.json\"; Langue = \"fr\"; Console.WriteLine(\"Configuration cr√©√©e\"); } // ========================================== // M√âTHODE PUBLIQUE pour obtenir l'instance unique // ========================================== public static Configuration ObtenirInstance() { if (_instance == null) { _instance = new Configuration(); } return _instance; } } // Utilisation // Configuration c1 = new Configuration(); // ‚ùå ERREUR - Constructeur priv√© Configuration c1 = Configuration.ObtenirInstance(); // ‚úÖ OK Configuration c2 = Configuration.ObtenirInstance(); // Retourne la m√™me instance Console.WriteLine(c1 == c2); // True - M√™me objet 7.7 Initialisation d‚ÄôObjets En plus des constructeurs, C# offre des syntaxes modernes pour initialiser les objets.\npublic class Produit { public string Nom { get; set; } public decimal Prix { get; set; } public string Categorie { get; set; } public Produit() { } public Produit(string nom, decimal prix) { Nom = nom; Prix = prix; } } // ========================================== // SYNTAXE 1 : Constructeur traditionnel // ========================================== Produit p1 = new Produit(\"Laptop\", 999.99m); p1.Categorie = \"√âlectronique\"; // ========================================== // SYNTAXE 2 : Initialiseur d'objet (Object Initializer) // ========================================== Produit p2 = new Produit { Nom = \"Souris\", Prix = 29.99m, Categorie = \"Accessoires\" }; // ========================================== // SYNTAXE 3 : Combinaison constructeur + initialiseur // ========================================== Produit p3 = new Produit(\"Clavier\", 79.99m) { Categorie = \"Accessoires\" // Ajoute la cat√©gorie apr√®s la construction }; // ========================================== // SYNTAXE 4 : C# 9+ (sans r√©p√©ter le type) // ========================================== Produit p4 = new(\"√âcran\", 299.99m) { Categorie = \"P√©riph√©riques\" }; 7.8 Exemple Complet : Classe CompteBancaire public class CompteBancaire { // ========================================== // ATTRIBUTS PRIV√âS // ========================================== private string _numeroCompte; private string _titulaire; private decimal _solde; private DateTime _dateOuverture; private static int _compteurComptes = 0; // Pour g√©n√©rer des num√©ros uniques // ========================================== // PROPRI√âT√âS // ========================================== public string NumeroCompte { get { return _numeroCompte; } } public string Titulaire { get { return _titulaire; } } public decimal Solde { get { return _solde; } } public DateTime DateOuverture { get { return _dateOuverture; } } // ========================================== // CONSTRUCTEUR 1 : Complet // ========================================== public CompteBancaire(string titulaire, decimal soldeInitial, string numeroCompte) { if (string.IsNullOrWhiteSpace(titulaire)) throw new ArgumentException(\"Le titulaire ne peut pas √™tre vide\"); if (soldeInitial \u003c 0) throw new ArgumentException(\"Le solde initial ne peut pas √™tre n√©gatif\"); _titulaire = titulaire; _solde = soldeInitial; _numeroCompte = numeroCompte; _dateOuverture = DateTime.Now; _compteurComptes++; Console.WriteLine($\"Compte {_numeroCompte} cr√©√© pour {_titulaire}\"); } // ========================================== // CONSTRUCTEUR 2 : G√©n√®re automatiquement le num√©ro // ========================================== public CompteBancaire(string titulaire, decimal soldeInitial) : this(titulaire, soldeInitial, GenererNumeroCompte()) { Console.WriteLine(\"Num√©ro de compte g√©n√©r√© automatiquement\"); } // ========================================== // CONSTRUCTEUR 3 : Solde initial de 0$ // ========================================== public CompteBancaire(string titulaire) : this(titulaire, 0) { Console.WriteLine(\"Compte cr√©√© avec solde initial de 0$\"); } // ========================================== // M√âTHODE PRIV√âE pour g√©n√©rer un num√©ro // ========================================== private static string GenererNumeroCompte() { return $\"CA{DateTime.Now.Year}{_compteurComptes + 1:D6}\"; } // ========================================== // M√âTHODES // ========================================== public void Deposer(decimal montant) { if (montant \u003e 0) { _solde += montant; Console.WriteLine($\"D√©p√¥t de {montant:C}. Nouveau solde: {_solde:C}\"); } } public void AfficherInfos() { Console.WriteLine($\"\\n=== Compte {_numeroCompte} ===\"); Console.WriteLine($\"Titulaire: {_titulaire}\"); Console.WriteLine($\"Solde: {_solde:C}\"); Console.WriteLine($\"Date d'ouverture: {_dateOuverture:d}\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // 3 fa√ßons de cr√©er un compte CompteBancaire c1 = new CompteBancaire(\"Marie Tremblay\", 1000, \"CA2024001\"); CompteBancaire c2 = new CompteBancaire(\"Jean Gagnon\", 500); CompteBancaire c3 = new CompteBancaire(\"Sophie Roy\"); c1.AfficherInfos(); c2.AfficherInfos(); c3.AfficherInfos(); c3.Deposer(250); c3.AfficherInfos(); } } 8. L‚ÄôH√©ritage 8.1 Concept Fondamental L‚Äôh√©ritage est un m√©canisme qui permet √† une classe (appel√©e classe d√©riv√©e, classe enfant ou sous-classe) d‚Äôh√©riter des membres (attributs et m√©thodes) d‚Äôune autre classe (appel√©e classe de base, classe parent ou super-classe).\nM√©taphore biologique :\nVous h√©ritez des caract√©ristiques de vos parents (couleur des yeux, groupe sanguin) Mais vous avez aussi vos propres caract√©ristiques uniques C‚Äôest la m√™me chose en programmation Pourquoi l‚Äôh√©ritage ?\nR√©utilisation du code : Ne pas r√©√©crire ce qui existe d√©j√† Organisation hi√©rarchique : Mod√©liser des relations ‚Äúest un‚Äù Extensibilit√© : Ajouter des fonctionnalit√©s sans modifier l‚Äôexistant Polymorphisme : Traiter diff√©rents objets de mani√®re uniforme 8.2 Syntaxe de l‚ÄôH√©ritage // Syntaxe : class ClasseDerivee : ClasseDeBase public class Animal { // Classe de base } public class Chien : Animal { // Chien h√©rite de Animal } 8.3 Exemple D√©taill√© : Hi√©rarchie de V√©hicules // ========================================== // CLASSE DE BASE (PARENT) // ========================================== public class Vehicule { // ========================================== // MEMBRES PROT√âG√âS - Accessibles aux d√©riv√©es // ========================================== protected string _marque; protected string _modele; protected int _annee; protected double _kilometrage; // ========================================== // PROPRI√âT√âS PUBLIQUES // ========================================== public string Marque { get { return _marque; } set { _marque = value; } } public string Modele { get { return _modele; } set { _modele = value; } } public int Annee { get; set; } public double Kilometrage { get { return _kilometrage; } protected set // Set prot√©g√© { if (value \u003e= _kilometrage) // Ne peut qu'augmenter _kilometrage = value; } } // ========================================== // CONSTRUCTEUR // ========================================== public Vehicule(string marque, string modele, int annee) { Console.WriteLine(\"Constructeur de Vehicule appel√©\"); _marque = marque; _modele = modele; _annee = annee; _kilometrage = 0; } // ========================================== // M√âTHODES // ========================================== public void Demarrer() { Console.WriteLine($\"Le v√©hicule {_marque} {_modele} d√©marre.\"); } public void Rouler(double km) { _kilometrage += km; Console.WriteLine($\"Parcouru {km} km. Total: {_kilometrage} km\"); } public void AfficherInfos() { Console.WriteLine($\"\\n=== {_marque} {_modele} ===\"); Console.WriteLine($\"Ann√©e: {_annee}\"); Console.WriteLine($\"Kilom√©trage: {_kilometrage} km\"); } } // ========================================== // CLASSE D√âRIV√âE 1 (ENFANT) // ========================================== public class Voiture : Vehicule // H√©rite de Vehicule { // ========================================== // MEMBRES SP√âCIFIQUES √† Voiture // ========================================== private int _nombrePortes; private string _typeCar burant; public int NombrePortes { get { return _nombrePortes; } set { _nombrePortes = value; } } // ========================================== // CONSTRUCTEUR - Doit appeler le constructeur du parent // ========================================== public Voiture(string marque, string modele, int annee, int portes, string carburant) : base(marque, modele, annee) // Appelle le constructeur de Vehicule { Console.WriteLine(\"Constructeur de Voiture appel√©\"); _nombrePortes = portes; _typeCarburant = carburant; } // ========================================== // NOUVELLE M√âTHODE sp√©cifique √† Voiture // ========================================== public void OuvrirCoffre() { Console.WriteLine(\"Coffre ouvert\"); } // ========================================== // ACC√àS AUX MEMBRES H√âRIT√âS // ========================================== public void AfficherToutesInfos() { // Peut acc√©der aux membres protected et public du parent AfficherInfos(); // M√©thode h√©rit√©e Console.WriteLine($\"Nombre de portes: {_nombrePortes}\"); Console.WriteLine($\"Carburant: {_typeCarburant}\"); // Peut acc√©der aux attributs protected Console.WriteLine($\"Marque (attribut protected): {_marque}\"); } } // ========================================== // CLASSE D√âRIV√âE 2 // ========================================== public class Moto : Vehicule { private bool _aCompartiment; public bool ACompartiment { get; set; } public Moto(string marque, string modele, int annee, bool compartiment) : base(marque, modele, annee) { Console.WriteLine(\"Constructeur de Moto appel√©\"); _aCompartiment = compartiment; } public void FaireWheeling() { Console.WriteLine($\"La moto {Marque} fait un wheeling!\"); } } // ========================================== // CLASSE D√âRIV√âE 3 // ========================================== public class Camion : Vehicule { private double _capaciteCharge; // En tonnes public double CapaciteCharge { get; set; } public Camion(string marque, string modele, int annee, double capacite) : base(marque, modele, annee) { _capaciteCharge = capacite; } public void Charger(double poids) { if (poids \u003c= _capaciteCharge) Console.WriteLine($\"Chargement de {poids} tonnes\"); else Console.WriteLine($\"D√©passement de capacit√©!\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // Cr√©ation d'objets d√©riv√©s Voiture voiture = new Voiture(\"Toyota\", \"Camry\", 2023, 4, \"Essence\"); Moto moto = new Moto(\"Harley-Davidson\", \"Street 750\", 2022, true); Camion camion = new Camion(\"Volvo\", \"FH16\", 2021, 20); // ========================================== // La voiture h√©rite de TOUT ce que Vehicule poss√®de // ========================================== voiture.Demarrer(); // ‚úÖ M√©thode h√©rit√©e voiture.Rouler(150); // ‚úÖ M√©thode h√©rit√©e voiture.AfficherInfos(); // ‚úÖ M√©thode h√©rit√©e voiture.OuvrirCoffre(); // ‚úÖ M√©thode sp√©cifique √† Voiture // ========================================== // M√™me chose pour la moto // ========================================== moto.Demarrer(); // ‚úÖ M√©thode h√©rit√©e moto.FaireWheeling(); // ‚úÖ M√©thode sp√©cifique √† Moto // ========================================== // Et le camion // ========================================== camion.Demarrer(); // ‚úÖ M√©thode h√©rit√©e camion.Charger(15); // ‚úÖ M√©thode sp√©cifique √† Camion } } Affichage :\nConstructeur de Vehicule appel√©\rConstructeur de Voiture appel√©\rConstructeur de Vehicule appel√©\rConstructeur de Moto appel√©\rConstructeur de Vehicule appel√©\rLe v√©hicule Toyota Camry d√©marre.\rParcouru 150 km. Total: 150 km\r=== Toyota Camry ===\rAnn√©e: 2023\rKilom√©trage: 150 km\rCoffre ouvert\r... 8.4 Le Mot-Cl√© base Le mot-cl√© base permet d‚Äôacc√©der aux membres de la classe parent.\npublic class Animal { protected string _nom; protected int _age; public Animal(string nom, int age) { _nom = nom; _age = age; Console.WriteLine($\"Animal {nom} cr√©√©\"); } public void Manger() { Console.WriteLine($\"{_nom} mange.\"); } public virtual void Dormir() { Console.WriteLine($\"{_nom} dort paisiblement.\"); } } public class Chien : Animal { private string _race; // ========================================== // UTILISATION 1 de 'base' : Appeler le constructeur parent // ========================================== public Chien(string nom, int age, string race) : base(nom, age) // Appelle Animal(nom, age) { _race = race; Console.WriteLine($\"Chien de race {race} cr√©√©\"); } // ========================================== // UTILISATION 2 de 'base' : Appeler une m√©thode du parent // ========================================== public override void Dormir() { Console.WriteLine($\"{_nom} le chien cherche un endroit confortable\"); base.Dormir(); // Appelle la m√©thode Dormir() de Animal Console.WriteLine(\"...et ronfle un peu\"); } public void AfficherTout() { // ========================================== // UTILISATION 3 de 'base' : Acc√©der √† un membre parent // ========================================== Console.WriteLine($\"Nom: {_nom}\"); // Attribut h√©rit√© Console.WriteLine($\"√Çge: {_age}\"); // Attribut h√©rit√© Console.WriteLine($\"Race: {_race}\"); // Attribut propre base.Manger(); // Appelle explicitement la m√©thode du parent } } // Utilisation Chien chien = new Chien(\"Rex\", 5, \"Labrador\"); chien.Dormir(); Affichage :\nAnimal Rex cr√©√©\rChien de race Labrador cr√©√©\rRex le chien cherche un endroit confortable\rRex dort paisiblement.\r...et ronfle un peu 8.5 Hi√©rarchie Multi-Niveaux L‚Äôh√©ritage peut avoir plusieurs niveaux.\n// ========================================== // NIVEAU 1 : Classe de base // ========================================== public class EtreVivant { public bool EstVivant { get; set; } = true; public void Respirer() { Console.WriteLine(\"Respire...\"); } } // ========================================== // NIVEAU 2 : D√©rive de EtreVivant // ========================================== public class Animal : EtreVivant { public void SeDeplacer() { Console.WriteLine(\"Se d√©place\"); } } // ========================================== // NIVEAU 3 : D√©rive de Animal // ========================================== public class Mammifere : Animal { public void Allaiter() { Console.WriteLine(\"Allaite ses petits\"); } } // ========================================== // NIVEAU 4 : D√©rive de Mammifere // ========================================== public class Chien : Mammifere { public void Aboyer() { Console.WriteLine(\"Wouf wouf!\"); } } // Utilisation Chien chien = new Chien(); // Le chien h√©rite de TOUS ses anc√™tres chien.Respirer(); // ‚úÖ De EtreVivant (arri√®re-arri√®re-grand-parent) chien.SeDeplacer(); // ‚úÖ De Animal (arri√®re-grand-parent) chien.Allaiter(); // ‚úÖ De Mammifere (grand-parent) chien.Aboyer(); // ‚úÖ De Chien (lui-m√™me) Hi√©rarchie :\nEtreVivant\r‚Üì h√©rite\rAnimal\r‚Üì h√©rite\rMammifere\r‚Üì h√©rite\rChien 8.6 Relations ‚ÄúEst-Un‚Äù (Is-A) L‚Äôh√©ritage mod√©lise une relation ‚Äúest un‚Äù.\npublic class Vehicule { } public class Voiture : Vehicule { } // Une Voiture \"est un\" Vehicule ‚úÖ // Un Vehicule \"est une\" Voiture ‚ùå (faux) Voiture v = new Voiture(); // v est une Voiture ‚úÖ // v est aussi un Vehicule ‚úÖ (par h√©ritage) Test mental : Si vous pouvez dire ‚ÄúX est un Y‚Äù, alors X peut h√©riter de Y.\nUn chien est un animal ‚úÖ Une voiture est un v√©hicule ‚úÖ Un √©tudiant est une personne ‚úÖ Une maison est un b√¢timent ‚úÖ Contre-exemples (mauvais h√©ritage) :\nUne maison est un toit ‚ùå (une maison a un toit ‚Üí composition, pas h√©ritage) Un √©tudiant est un cours ‚ùå Une voiture est un moteur ‚ùå (une voiture a un moteur) 8.7 Restrictions de l‚ÄôH√©ritage en C# Important : En C#, une classe ne peut h√©riter que d‚ÄôUNE SEULE classe (pas d‚Äôh√©ritage multiple de classes).\npublic class A { } public class B { } // ‚ùå ERREUR - Pas d'h√©ritage multiple en C# public class C : A, B { } // ‚úÖ OK - H√©ritage simple public class C : A { } Cependant : Une classe peut impl√©menter plusieurs interfaces (voir section sur les interfaces).\n9. Le Polymorphisme 9.1 D√©finition Approfondie Le polymorphisme (du grec ‚Äúpoly‚Äù = plusieurs, ‚Äúmorphe‚Äù = forme) est la capacit√© pour des objets de types diff√©rents de r√©pondre √† la m√™me interface ou au m√™me appel de m√©thode, mais avec des comportements diff√©rents.\nAnalogie du monde r√©el : Imaginez un bouton ‚ÄúD√©marrer‚Äù :\nSur une voiture : D√©marre le moteur Sur un ordinateur : Lance le syst√®me d‚Äôexploitation Sur une cafeti√®re : Commence √† infuser le caf√© M√™me action (‚ÄúD√©marrer‚Äù), comportements diff√©rents Pourquoi le polymorphisme ?\nFlexibilit√© : √âcrire du code qui fonctionne avec diff√©rents types Extensibilit√© : Ajouter de nouveaux types sans modifier le code existant Abstraction : Manipuler des objets sans conna√Ætre leur type exact Code r√©utilisable : Une m√™me fonction pour plusieurs types 9.2 Types de Polymorphisme Il existe deux types principaux :\nPolymorphisme de compilation (surcharge de m√©thodes) Polymorphisme d‚Äôex√©cution (red√©finition de m√©thodes) La Programmation Orient√©e Objet (POO) est un paradigme de programmation bas√© sur le concept d‚Äôobjets qui contiennent des donn√©es (attributs) et du code (m√©thodes).\nLes 4 piliers de la POO : Encapsulation : Regrouper les donn√©es et m√©thodes, cacher les d√©tails internes H√©ritage : Cr√©er de nouvelles classes √† partir de classes existantes Polymorphisme : Utiliser une interface commune pour des types diff√©rents Abstraction : Simplifier la complexit√© en cachant les d√©tails d‚Äôimpl√©mentation 2. Les Classes et les Objets Qu‚Äôest-ce qu‚Äôune classe ? Une classe est un mod√®le ou un plan qui d√©finit la structure et le comportement d‚Äôobjets.\nQu‚Äôest-ce qu‚Äôun objet ? Un objet est une instance d‚Äôune classe, c‚Äôest une entit√© concr√®te cr√©√©e √† partir du mod√®le.\nSyntaxe de base // D√©finition d'une classe public class Personne { // Attributs (champs) public string Nom; public string Prenom; public int Age; // M√©thode public void SePresenter() { Console.WriteLine($\"Bonjour, je m'appelle {Prenom} {Nom} et j'ai {Age} ans.\"); } } // Utilisation class Program { static void Main() { // Cr√©ation d'un objet (instance) Personne personne1 = new Personne(); personne1.Nom = \"Tremblay\"; personne1.Prenom = \"Marie\"; personne1.Age = 25; personne1.SePresenter(); // Affiche: Bonjour, je m'appelle Marie Tremblay et j'ai 25 ans. } } 3. L‚ÄôEncapsulation L‚Äôencapsulation consiste √† prot√©ger les donn√©es d‚Äôune classe et √† contr√¥ler l‚Äôacc√®s via des propri√©t√©s.\nModificateurs d‚Äôacc√®s Modificateur Description public Accessible partout private Accessible uniquement dans la classe protected Accessible dans la classe et ses d√©riv√©es internal Accessible dans le m√™me assembly protected internal Combinaison de protected et internal Propri√©t√©s (Properties) public class Compte { // Champs priv√©s private string _numeroCompte; private decimal _solde; // Propri√©t√© avec get et set public string NumeroCompte { get { return _numeroCompte; } set { _numeroCompte = value; } } // Propri√©t√© avec logique de validation public decimal Solde { get { return _solde; } private set // set priv√© : lecture publique, √©criture priv√©e { if (value \u003e= 0) _solde = value; } } // Propri√©t√© auto-impl√©ment√©e (C# 3.0+) public string Titulaire { get; set; } // Propri√©t√© en lecture seule (C# 6.0+) public DateTime DateCreation { get; } = DateTime.Now; public void Deposer(decimal montant) { if (montant \u003e 0) Solde += montant; } public bool Retirer(decimal montant) { if (montant \u003e 0 \u0026\u0026 montant \u003c= Solde) { Solde -= montant; return true; } return false; } } 4. Les Constructeurs Un constructeur est une m√©thode sp√©ciale appel√©e lors de la cr√©ation d‚Äôun objet.\nTypes de constructeurs public class Voiture { public string Marque { get; set; } public string Modele { get; set; } public int Annee { get; set; } // Constructeur par d√©faut (sans param√®tres) public Voiture() { Marque = \"Inconnue\"; Modele = \"Inconnu\"; Annee = 2020; } // Constructeur avec param√®tres public Voiture(string marque, string modele) { Marque = marque; Modele = modele; Annee = DateTime.Now.Year; } // Constructeur complet public Voiture(string marque, string modele, int annee) { Marque = marque; Modele = modele; Annee = annee; } // Cha√Ænage de constructeurs avec 'this' public Voiture(string marque) : this(marque, \"Standard\", DateTime.Now.Year) { } } // Utilisation var voiture1 = new Voiture(); var voiture2 = new Voiture(\"Toyota\", \"Camry\"); var voiture3 = new Voiture(\"Honda\", \"Civic\", 2023); var voiture4 = new Voiture(\"Ford\"); 5. L‚ÄôH√©ritage L‚Äôh√©ritage permet √† une classe (classe d√©riv√©e) d‚Äôh√©riter des membres d‚Äôune autre classe (classe de base).\nSyntaxe de base // Classe de base (parent) public class Animal { public string Nom { get; set; } public int Age { get; set; } public virtual void Manger() { Console.WriteLine($\"{Nom} est en train de manger.\"); } public virtual void Dormir() { Console.WriteLine($\"{Nom} dort.\"); } } // Classe d√©riv√©e (enfant) public class Chien : Animal { public string Race { get; set; } // Nouvelle m√©thode sp√©cifique au chien public void Aboyer() { Console.WriteLine($\"{Nom} aboie: Wouf wouf!\"); } // Red√©finition (override) d'une m√©thode public override void Manger() { Console.WriteLine($\"{Nom} le chien mange des croquettes.\"); } } // Autre classe d√©riv√©e public class Chat : Animal { public bool EstDomestique { get; set; } public void Miauler() { Console.WriteLine($\"{Nom} miaule: Miaou!\"); } public override void Manger() { Console.WriteLine($\"{Nom} le chat mange du poisson.\"); } } // Utilisation var chien = new Chien { Nom = \"Rex\", Age = 5, Race = \"Labrador\" }; chien.Manger(); // Affiche: Rex le chien mange des croquettes. chien.Aboyer(); // Affiche: Rex aboie: Wouf wouf! chien.Dormir(); // Affiche: Rex dort. Le mot-cl√© base public class Employe { public string Nom { get; set; } public decimal SalaireBase { get; set; } public Employe(string nom, decimal salaire) { Nom = nom; SalaireBase = salaire; } public virtual decimal CalculerSalaire() { return SalaireBase; } } public class Manager : Employe { public decimal Prime { get; set; } // Appel du constructeur de base avec 'base' public Manager(string nom, decimal salaire, decimal prime) : base(nom, salaire) { Prime = prime; } // Utilisation de la m√©thode de base avec 'base' public override decimal CalculerSalaire() { return base.CalculerSalaire() + Prime; } } Modificateur sealed Le mot-cl√© sealed emp√™che l‚Äôh√©ritage d‚Äôune classe ou la red√©finition d‚Äôune m√©thode.\n// Classe scell√©e - ne peut pas √™tre h√©rit√©e public sealed class ClasseFinale { public void Methode() { } } // ERREUR: Impossible d'h√©riter d'une classe sealed // public class Derivee : ClasseFinale { } public class ClasseAvecMethodeScelle : Animal { // M√©thode scell√©e - ne peut plus √™tre red√©finie dans les classes d√©riv√©es public sealed override void Manger() { Console.WriteLine(\"Impl√©mentation finale\"); } } 6. Le Polymorphisme Le polymorphisme permet √† des objets de diff√©rentes classes d‚Äô√™tre trait√©s de mani√®re uniforme via une interface commune.\nPolymorphisme par h√©ritage public class Forme { public virtual double CalculerAire() { return 0; } public virtual void Dessiner() { Console.WriteLine(\"Dessiner une forme g√©n√©rique\"); } } public class Cercle : Forme { public double Rayon { get; set; } public Cercle(double rayon) { Rayon = rayon; } public override double CalculerAire() { return Math.PI * Rayon * Rayon; } public override void Dessiner() { Console.WriteLine($\"Dessiner un cercle de rayon {Rayon}\"); } } public class Rectangle : Forme { public double Longueur { get; set; } public double Largeur { get; set; } public Rectangle(double longueur, double largeur) { Longueur = longueur; Largeur = largeur; } public override double CalculerAire() { return Longueur * Largeur; } public override void Dessiner() { Console.WriteLine($\"Dessiner un rectangle {Longueur}x{Largeur}\"); } } // Utilisation du polymorphisme class Program { static void Main() { // Tableau polymorphe Forme[] formes = new Forme[] { new Cercle(5), new Rectangle(4, 6), new Cercle(3) }; // M√™me code, comportements diff√©rents foreach (Forme forme in formes) { forme.Dessiner(); Console.WriteLine($\"Aire: {forme.CalculerAire():F2}\"); Console.WriteLine(); } } } Mots-cl√©s virtual, override, new public class ClasseBase { public virtual void MethodeVirtuelle() { Console.WriteLine(\"M√©thode virtuelle de base\"); } public void MethodeNormale() { Console.WriteLine(\"M√©thode normale de base\"); } } public class ClasseDerivee : ClasseBase { // Override: red√©finition polymorphique public override void MethodeVirtuelle() { Console.WriteLine(\"M√©thode red√©finie\"); } // New: masquage (non polymorphique) public new void MethodeNormale() { Console.WriteLine(\"M√©thode masqu√©e\"); } } // Test ClasseBase obj1 = new ClasseDerivee(); obj1.MethodeVirtuelle(); // Affiche: M√©thode red√©finie (polymorphisme) obj1.MethodeNormale(); // Affiche: M√©thode normale de base (pas de polymorphisme) ClasseDerivee obj2 = new ClasseDerivee(); obj2.MethodeVirtuelle(); // Affiche: M√©thode red√©finie obj2.MethodeNormale(); // Affiche: M√©thode masqu√©e 7. Les Classes Abstraites Une classe abstraite est une classe incompl√®te qui ne peut pas √™tre instanci√©e directement. Elle sert de mod√®le pour d‚Äôautres classes.\nCaract√©ristiques D√©clar√©e avec le mot-cl√© abstract Peut contenir des m√©thodes abstraites (sans impl√©mentation) et concr√®tes (avec impl√©mentation) Ne peut pas √™tre instanci√©e Les classes d√©riv√©es doivent impl√©menter toutes les m√©thodes abstraites // Classe abstraite public abstract class Vehicule { public string Marque { get; set; } public string Modele { get; set; } // Constructeur (oui, les classes abstraites peuvent avoir des constructeurs) public Vehicule(string marque, string modele) { Marque = marque; Modele = modele; } // M√©thode abstraite (sans impl√©mentation) public abstract void Demarrer(); // M√©thode abstraite public abstract double CalculerConsommation(double distance); // M√©thode concr√®te (avec impl√©mentation) public void AfficherInfo() { Console.WriteLine($\"V√©hicule: {Marque} {Modele}\"); } // M√©thode virtuelle (peut √™tre red√©finie) public virtual void Klaxonner() { Console.WriteLine(\"Beep beep!\"); } } // Classe d√©riv√©e - doit impl√©menter toutes les m√©thodes abstraites public class Voiture : Vehicule { public int NombrePortes { get; set; } public Voiture(string marque, string modele, int portes) : base(marque, modele) { NombrePortes = portes; } // Impl√©mentation obligatoire public override void Demarrer() { Console.WriteLine($\"La voiture {Marque} {Modele} d√©marre avec la cl√©.\"); } // Impl√©mentation obligatoire public override double CalculerConsommation(double distance) { return distance * 0.07; // 7L/100km } } public class Moto : Vehicule { public bool ASidecar { get; set; } public Moto(string marque, string modele) : base(marque, modele) { } public override void Demarrer() { Console.WriteLine($\"La moto {Marque} {Modele} d√©marre avec le kick.\"); } public override double CalculerConsommation(double distance) { return distance * 0.04; // 4L/100km } public override void Klaxonner() { Console.WriteLine(\"Beep beep! (son de moto)\"); } } // Utilisation // var v = new Vehicule(\"Test\", \"Test\"); // ERREUR: impossible d'instancier une classe abstraite var voiture = new Voiture(\"Toyota\", \"Corolla\", 4); voiture.AfficherInfo(); voiture.Demarrer(); Console.WriteLine($\"Consommation sur 100km: {voiture.CalculerConsommation(100)}L\"); var moto = new Moto(\"Harley\", \"Davidson\"); moto.Demarrer(); Exemple avanc√© : Syst√®me de paiement public abstract class MoyenPaiement { public string Titulaire { get; set; } public DateTime DateTransaction { get; protected set; } public abstract bool Payer(decimal montant); public abstract bool Verifier(); public virtual void AfficherRecu(decimal montant) { Console.WriteLine($\"Re√ßu - {Titulaire}\"); Console.WriteLine($\"Montant: {montant:C}\"); Console.WriteLine($\"Date: {DateTransaction}\"); } } public class CarteCredit : MoyenPaiement { public string Numero { get; set; } public DateTime DateExpiration { get; set; } public decimal LimiteCredit { get; set; } private decimal _soldeUtilise; public override bool Verifier() { return DateExpiration \u003e DateTime.Now; } public override bool Payer(decimal montant) { if (!Verifier()) { Console.WriteLine(\"Carte expir√©e\"); return false; } if (_soldeUtilise + montant \u003e LimiteCredit) { Console.WriteLine(\"Limite de cr√©dit d√©pass√©e\"); return false; } _soldeUtilise += montant; DateTransaction = DateTime.Now; Console.WriteLine($\"Paiement de {montant:C} effectu√© par carte de cr√©dit\"); return true; } } public class Paypal : MoyenPaiement { public string Email { get; set; } public decimal Solde { get; private set; } public void Recharger(decimal montant) { Solde += montant; } public override bool Verifier() { return !string.IsNullOrEmpty(Email) \u0026\u0026 Email.Contains(\"@\"); } public override bool Payer(decimal montant) { if (!Verifier()) { Console.WriteLine(\"Email invalide\"); return false; } if (Solde \u003c montant) { Console.WriteLine(\"Solde insuffisant\"); return false; } Solde -= montant; DateTransaction = DateTime.Now; Console.WriteLine($\"Paiement de {montant:C} effectu√© via PayPal\"); return true; } } 8. Les Interfaces Une interface d√©finit un contrat que les classes doivent respecter. Elle ne contient que des signatures de m√©thodes, propri√©t√©s, √©v√©nements ou indexeurs (pas d‚Äôimpl√©mentation).\nCaract√©ristiques D√©clar√©e avec le mot-cl√© interface Tous les membres sont publics par d√©faut Une classe peut impl√©menter plusieurs interfaces (contrairement √† l‚Äôh√©ritage) Pas de champs, pas de constructeurs Convention de nommage : pr√©fixe I (ex: IComparable) // D√©finition d'interfaces public interface IVolant { void Voler(); double AltitudeMax { get; } } public interface INageant { void Nager(); double ProfondeurMax { get; } } public interface IMarchant { void Marcher(); } // Classe impl√©mentant une interface public class Oiseau : IVolant, IMarchant { public string Nom { get; set; } // Impl√©mentation de IVolant public double AltitudeMax { get; set; } = 1000; public void Voler() { Console.WriteLine($\"{Nom} vole dans le ciel.\"); } // Impl√©mentation de IMarchant public void Marcher() { Console.WriteLine($\"{Nom} marche sur le sol.\"); } } public class Canard : IVolant, INageant, IMarchant { public string Nom { get; set; } public double AltitudeMax { get; set; } = 500; public double ProfondeurMax { get; set; } = 10; public void Voler() { Console.WriteLine($\"{Nom} le canard vole.\"); } public void Nager() { Console.WriteLine($\"{Nom} le canard nage.\"); } public void Marcher() { Console.WriteLine($\"{Nom} le canard marche.\"); } } public class Poisson : INageant { public string Nom { get; set; } public double ProfondeurMax { get; set; } = 100; public void Nager() { Console.WriteLine($\"{Nom} le poisson nage sous l'eau.\"); } } // Utilisation polymorphe des interfaces class Program { static void FaireVoler(IVolant volant) { volant.Voler(); Console.WriteLine($\"Altitude maximale: {volant.AltitudeMax}m\"); } static void FaireNager(INageant nageant) { nageant.Nager(); Console.WriteLine($\"Profondeur maximale: {nageant.ProfondeurMax}m\"); } static void Main() { var oiseau = new Oiseau { Nom = \"Aigle\" }; var canard = new Canard { Nom = \"Donald\" }; var poisson = new Poisson { Nom = \"Nemo\" }; FaireVoler(oiseau); FaireVoler(canard); FaireNager(canard); FaireNager(poisson); // Collection polymorphe List\u003cINageant\u003e animauxAquatiques = new List\u003cINageant\u003e { canard, poisson }; foreach (var animal in animauxAquatiques) { animal.Nager(); } } } Interfaces vs Classes Abstraites Aspect Interface Classe Abstraite H√©ritage multiple ‚úÖ Oui (une classe peut impl√©menter plusieurs interfaces) ‚ùå Non (une classe ne peut h√©riter que d‚Äôune seule classe) Impl√©mentation ‚ùå Aucune (sauf depuis C# 8.0 avec impl√©mentation par d√©faut) ‚úÖ Peut contenir des m√©thodes impl√©ment√©es Champs ‚ùå Non ‚úÖ Oui Constructeurs ‚ùå Non ‚úÖ Oui Modificateurs d‚Äôacc√®s Tous publics Peut varier Utilisation D√©finir un contrat/comportement D√©finir une base commune avec du code partag√© Exemple pratique : Syst√®me de notification public interface INotifiable { void EnvoyerNotification(string message); bool EstActif { get; set; } } public interface IConfigurable { void Configurer(Dictionary\u003cstring, string\u003e parametres); Dictionary\u003cstring, string\u003e ObtenirConfiguration(); } public class NotificationEmail : INotifiable, IConfigurable { public bool EstActif { get; set; } = true; public string AdresseEmail { get; set; } public string ServeurSMTP { get; set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"üìß Email envoy√© √† {AdresseEmail}: {message}\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"email\")) AdresseEmail = parametres[\"email\"]; if (parametres.ContainsKey(\"smtp\")) ServeurSMTP = parametres[\"smtp\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"email\", AdresseEmail }, { \"smtp\", ServeurSMTP } }; } } public class NotificationSMS : INotifiable, IConfigurable { public bool EstActif { get; set; } = true; public string NumeroTelephone { get; set; } public string FournisseurSMS { get; set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"üì± SMS envoy√© au {NumeroTelephone}: {message}\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"telephone\")) NumeroTelephone = parametres[\"telephone\"]; if (parametres.ContainsKey(\"fournisseur\")) FournisseurSMS = parametres[\"fournisseur\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"telephone\", NumeroTelephone }, { \"fournisseur\", FournisseurSMS } }; } } public class GestionnaireNotifications { private List\u003cINotifiable\u003e _canaux = new List\u003cINotifiable\u003e(); public void AjouterCanal(INotifiable canal) { _canaux.Add(canal); } public void EnvoyerATous(string message) { foreach (var canal in _canaux) { canal.EnvoyerNotification(message); } } } Impl√©mentation explicite d‚Äôinterface Utilis√©e pour √©viter les conflits de noms entre plusieurs interfaces.\npublic interface IAnimal { void Manger(); } public interface IRobot { void Manger(); // M√™me nom de m√©thode } public class CyberChien : IAnimal, IRobot { // Impl√©mentation explicite de IAnimal.Manger void IAnimal.Manger() { Console.WriteLine(\"Le cyber-chien mange de la vraie nourriture\"); } // Impl√©mentation explicite de IRobot.Manger void IRobot.Manger() { Console.WriteLine(\"Le cyber-chien recharge ses batteries\"); } // M√©thode publique normale public void SeReposer() { Console.WriteLine(\"Le cyber-chien se met en veille\"); } } // Utilisation var cyberChien = new CyberChien(); // cyberChien.Manger(); // ERREUR: ambigu√Øt√© IAnimal animal = cyberChien; animal.Manger(); // Appelle IAnimal.Manger IRobot robot = cyberChien; robot.Manger(); // Appelle IRobot.Manger cyberChien.SeReposer(); // OK 9. Concepts Avanc√©s 9.1 Membres statiques Les membres statiques appartiennent √† la classe plut√¥t qu‚Äô√† une instance.\npublic class Compteur { // Champ statique (partag√© par toutes les instances) private static int _nombreInstances = 0; // Propri√©t√© statique public static int NombreInstances { get { return _nombreInstances; } } // Champ d'instance public int Id { get; private set; } // Constructeur public Compteur() { _nombreInstances++; Id = _nombreInstances; } // M√©thode statique public static void Reinitialiser() { _nombreInstances = 0; } // M√©thode d'instance public void AfficherInfo() { Console.WriteLine($\"Instance #{Id} - Total: {NombreInstances}\"); } } // Constructeur statique (appel√© une seule fois avant la premi√®re utilisation) public class Configuration { public static string CheminFichier { get; private set; } static Configuration() { Console.WriteLine(\"Initialisation de la configuration...\"); CheminFichier = \"config.json\"; } } // Utilisation var c1 = new Compteur(); // NombreInstances = 1 var c2 = new Compteur(); // NombreInstances = 2 var c3 = new Compteur(); // NombreInstances = 3 Console.WriteLine(Compteur.NombreInstances); // 3 c2.AfficherInfo(); // Instance #2 - Total: 3 9.2 Classes statiques Une classe statique ne peut contenir que des membres statiques et ne peut pas √™tre instanci√©e.\npublic static class Utilitaires { public static double CalculerMoyenne(params double[] nombres) { if (nombres.Length == 0) return 0; return nombres.Average(); } public static string FormaterMonnaie(decimal montant) { return $\"{montant:C}\"; } public static T Max\u003cT\u003e(T a, T b) where T : IComparable\u003cT\u003e { return a.CompareTo(b) \u003e 0 ? a : b; } } // Utilisation double moyenne = Utilitaires.CalculerMoyenne(10, 20, 30, 40); string prix = Utilitaires.FormaterMonnaie(99.99m); int maximum = Utilitaires.Max(5, 10); 9.3 Classes partielles (Partial Classes) Permettent de diviser la d√©finition d‚Äôune classe en plusieurs fichiers.\n// Fichier: Personne.cs public partial class Personne { public string Nom { get; set; } public string Prenom { get; set; } partial void OnNomChanged(); } // Fichier: Personne.Methodes.cs public partial class Personne { public void SePresenter() { Console.WriteLine($\"Je suis {Prenom} {Nom}\"); } partial void OnNomChanged() { Console.WriteLine(\"Le nom a √©t√© modifi√©\"); } } 9.4 D√©l√©gu√©s et √âv√©nements (aper√ßu) // D√©l√©gu√© (type pointeur de fonction) public delegate void NotificationHandler(string message); public class Compte { // √âv√©nement public event NotificationHandler SoldeModifie; private decimal _solde; public decimal Solde { get { return _solde; } set { _solde = value; // D√©clencher l'√©v√©nement SoldeModifie?.Invoke($\"Nouveau solde: {_solde:C}\"); } } } // Utilisation var compte = new Compte(); compte.SoldeModifie += (msg) =\u003e Console.WriteLine($\"Notification: {msg}\"); compte.Solde = 100; // D√©clenche l'√©v√©nement 9.5 G√©n√©riques (Generics) // Classe g√©n√©rique public class Boite\u003cT\u003e { private T _contenu; public void Ranger(T item) { _contenu = item; } public T Recuperer() { return _contenu; } } // Utilisation var boiteEntiers = new Boite\u003cint\u003e(); boiteEntiers.Ranger(42); int nombre = boiteEntiers.Recuperer(); var boiteTexte = new Boite\u003cstring\u003e(); boiteTexte.Ranger(\"Bonjour\"); string texte = boiteTexte.Recuperer(); // Classe g√©n√©rique avec contraintes public class Repository\u003cT\u003e where T : class, new() { private List\u003cT\u003e _items = new List\u003cT\u003e(); public void Ajouter(T item) { _items.Add(item); } public T Creer() { return new T(); // Possible gr√¢ce √† la contrainte 'new()' } } 9.6 Extension Methods // Classe statique pour les m√©thodes d'extension public static class StringExtensions { // M√©thode d'extension (noter le 'this' devant le premier param√®tre) public static bool EstEmail(this string texte) { return texte.Contains(\"@\") \u0026\u0026 texte.Contains(\".\"); } public static string Inverser(this string texte) { char[] chars = texte.ToCharArray(); Array.Reverse(chars); return new string(chars); } public static int CompterMots(this string texte) { return texte.Split(new[] { ' ', '\\t', '\\n' }, StringSplitOptions.RemoveEmptyEntries).Length; } } // Utilisation string email = \"test@example.com\"; bool valide = email.EstEmail(); // true string mot = \"Bonjour\"; string inverse = mot.Inverser(); // \"ruojnoB\" string phrase = \"Ceci est une phrase\"; int mots = phrase.CompterMots(); // 4 9.7 Records (C# 9.0+) Les records sont des types de r√©f√©rence immuables optimis√©s pour stocker des donn√©es.\n// Record simple public record Personne(string Nom, string Prenom, int Age); // Utilisation var p1 = new Personne(\"Tremblay\", \"Marie\", 25); var p2 = new Personne(\"Tremblay\", \"Marie\", 25); Console.WriteLine(p1 == p2); // true (√©galit√© par valeur) // Expression 'with' pour cr√©er une copie modifi√©e var p3 = p1 with { Age = 26 }; // Record avec propri√©t√©s additionnelles public record Employe(string Nom, string Prenom, decimal Salaire) { public string Departement { get; init; } = \"Non assign√©\"; public decimal CalculerSalaireAnnuel() =\u003e Salaire * 12; } R√©sum√© des concepts cl√©s Quand utiliser quoi ? Concept Utilisation Classe normale Objets avec √©tat et comportement Classe abstraite Base commune avec impl√©mentation partielle Interface Contrat sans impl√©mentation, h√©ritage multiple Classe statique M√©thodes utilitaires sans √©tat Record Donn√©es immuables Sealed class Emp√™cher l‚Äôh√©ritage Partial class Diviser une classe en plusieurs fichiers Modificateurs d‚Äôacc√®s (du plus au moins restrictif) private - Classe uniquement protected - Classe et d√©riv√©es internal - Assembly actuel protected internal - Assembly ou d√©riv√©es public - Partout Principes SOLID Single Responsibility: Une classe = une responsabilit√© Open/Closed: Ouvert √† l‚Äôextension, ferm√© √† la modification Liskov Substitution: Les sous-classes doivent pouvoir remplacer leurs classes de base Interface Segregation: Interfaces petites et sp√©cifiques Dependency Inversion: D√©pendre des abstractions, pas des impl√©mentations concr√®tes Exercices pratiques Exercice 1 : Cr√©er une hi√©rarchie de comptes bancaires Cr√©ez une classe de base CompteBancaire et des classes d√©riv√©es CompteEpargne et CompteCourant avec des comportements diff√©rents.\nExercice 2 : Syst√®me de formes g√©om√©triques Cr√©ez une classe abstraite Forme avec des m√©thodes pour calculer l‚Äôaire et le p√©rim√®tre. Impl√©mentez des classes concr√®tes comme Cercle, Carre, Triangle.\nExercice 3 : Gestion d‚Äôune biblioth√®que Utilisez des interfaces IEmpruntable, IReservable pour cr√©er un syst√®me de gestion de livres, DVD, magazines.\nExercice 4 : Simulateur de zoo Cr√©ez une hi√©rarchie d‚Äôanimaux avec des interfaces pour diff√©rents comportements (voler, nager, grimper).",
    "description": "Table des mati√®res Le mot-cl√© Virtual Le mot-cl√© Abstract Le mot-cl√© Sealed Les Classes Abstraites Les Interfaces Membres Statiques 1. Introduction √† la POO 1.1 Qu‚Äôest-ce que la Programmation Orient√©e Objet ? La Programmation Orient√©e Objet (POO) est un paradigme de programmation qui organise le code autour du concept d‚Äôobjets plut√¥t que de fonctions et de logique. Un objet combine des donn√©es (ce qu‚Äôil poss√®de) et des comportements (ce qu‚Äôil peut faire).",
    "tags": [],
    "title": "Programmation orient√©e objet - partie 1",
    "uri": "/420-413/poo_2/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-413/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Plans de cours üìã Samuel Fostin√© : Plan de cours\nHoraire et disponibilit√©s des enseignants ‚úîÔ∏è Samuel Fostin√© : Lien vers mon horaire et mes disponibilit√©s\nSamuel Fostin√© Nom de l‚Äô√©valuation Pond√©ration Semaine de l‚Äô√©valuation 10 quiz (8 meilleures notes) 15 % Semaine 2 √† 14 Examen 1 20% Semaine 4 Examen 2 25 % Semaine 12 Projet remise 1 5 % Semaine 6 Projet remise 2 5 % Semaine 8 Projet remise 3 5 % Semaine 10 Projet remise 4 5 % Semaine 13 Projet remise final 20 % Semaine 15",
    "description": "Plans de cours üìã Samuel Fostin√© : Plan de cours\nHoraire et disponibilit√©s des enseignants ‚úîÔ∏è Samuel Fostin√© : Lien vers mon horaire et mes disponibilit√©s\nSamuel Fostin√© Nom de l‚Äô√©valuation Pond√©ration Semaine de l‚Äô√©valuation 10 quiz (8 meilleures notes) 15 % Semaine 2 √† 14 Examen 1 20% Semaine 4 Examen 2 25 % Semaine 12 Projet remise 1 5 % Semaine 6 Projet remise 2 5 % Semaine 8 Projet remise 3 5 % Semaine 10 Projet remise 4 5 % Semaine 13 Projet remise final 20 % Semaine 15",
    "tags": [],
    "title": "D√©veloppement d'applications pour entreprise",
    "uri": "/420-413/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Poos",
    "uri": "/420-413/poo/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-413/tags/index.html"
  }
]
