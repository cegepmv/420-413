var relearn_searchindex = [
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "ğŸ§¹ Rubrique Clean Code - Semaine 1 Noms Significatifs et Fonctions Claires ğŸ“‹ Objectifs de cette semaine Apprendre Ã  :\nIdentifier et corriger les noms non significatifs ReconnaÃ®tre et rÃ©soudre les fonctions trop longues Ã‰liminer les commentaires inutiles en Ã©crivant du code auto-explicatif ğŸ’¡ Citation de la semaine â€œLe code est lu beaucoup plus souvent quâ€™il nâ€™est Ã©crit. Facilitez la lecture, pas lâ€™Ã©criture.â€\nâ€” Robert C. Martin (Uncle Bob), Clean Code\nğŸ”´ Code Smell #1 : Noms Non Significatifs Quâ€™est-ce quâ€™un nom non significatif ? Un nom non significatif est un nom de variable, mÃ©thode ou classe qui ne rÃ©vÃ¨le pas clairement son intention ou son rÃ´le. Il force le lecteur Ã  deviner ou Ã  chercher dans le contexte pour comprendre.\nâŒ Exemple de Code ProblÃ©matique public class Program { static void Main() { // Que reprÃ©sentent ces variables ??? var d = 30; var temp = new List\u003cint[]\u003e(); for (int i = 0; i \u003c 100; i++) { var x = new int[3]; x[0] = i; x[1] = i * 2; x[2] = i % d; if (x[2] == 0) { temp.Add(x); } } // Afficher les rÃ©sultats foreach (var t in temp) { Console.WriteLine($\"{t[0]} - {t[1]} - {t[2]}\"); } } } ğŸ¤” ProblÃ¨mes identifiÃ©s d : Que signifie â€œdâ€ ? Jour ? Distance ? Diviseur ? temp : Temporaire de quoi ? Quelle est sa vraie signification ? x : Quâ€™est-ce que ce tableau reprÃ©sente ? t : MÃªme problÃ¨me dans la boucle i : Dans ce contexte, que reprÃ©sente-t-il vraiment ? Indices magiques : Que signifient [0], [1], [2] ? âœ… Code CorrigÃ© (Version Clean Code) public class Program { static void Main() { // VERSION CLEAN CODE const int nombreDeJoursDansUnMois = 30; List\u003cCommande\u003e commandesDivisiblesParTrente = new List\u003cCommande\u003e(); for (int numeroCommande = 0; numeroCommande \u003c 100; numeroCommande++) { var commande = new Commande { Numero = numeroCommande, MontantDouble = numeroCommande * 2, ResteModulo = numeroCommande % nombreDeJoursDansUnMois }; if (commande.EstDivisibleParTrente()) { commandesDivisiblesParTrente.Add(commande); } } AfficherCommandes(commandesDivisiblesParTrente); } private static void AfficherCommandes(List\u003cCommande\u003e commandes) { foreach (var commande in commandes) { Console.WriteLine(commande.ObtenirDescription()); } } } public class Commande { public int Numero { get; set; } public int MontantDouble { get; set; } public int ResteModulo { get; set; } public bool EstDivisibleParTrente() { return ResteModulo == 0; } public string ObtenirDescription() { return $\"Commande #{Numero} - Montant: {MontantDouble} - Reste: {ResteModulo}\"; } } ğŸ“Š Comparaison Avant/AprÃ¨s Avant (ğŸ˜ Mauvais) AprÃ¨s (âœ… Bon) AmÃ©lioration d nombreDeJoursDansUnMois Intention claire temp commandesDivisiblesParTrente But explicite x commande (objet Commande) Type et rÃ´le clairs x[0], x[1], x[2] commande.Numero, commande.MontantDouble PropriÃ©tÃ©s nommÃ©es i numeroCommande Contexte prÃ©cis t commande Nom significatif ğŸ¯ RÃ¨gles pour les Noms Significatifs âœ… FAIRE : // 1. Utiliser des noms qui rÃ©vÃ¨lent l'intention int nombreJoursEcoules; decimal prixTotalAvecTaxes; bool utilisateurEstConnecte; // 2. Utiliser des noms prononÃ§ables DateTime dateCreationClient; // âœ… Bon // vs DateTime dtCrCl; // âŒ ImprononÃ§able // 3. Utiliser des noms cherchables const int NOMBRE_HEURES_TRAVAIL_PAR_SEMAINE = 40; // âœ… Facile Ã  trouver // vs int n = 40; // âŒ Impossible Ã  chercher // 4. Ã‰viter les abrÃ©viations ambiguÃ«s List\u003cClient\u003e listeClients; // âœ… Clair // vs List\u003cClient\u003e lc; // âŒ Qu'est-ce que \"lc\" ? // 5. Utiliser des noms de domaine mÃ©tier decimal montantFacture; string numeroCompteBancaire; DateTime dateEcheancePaiement; âŒ NE PAS FAIRE : // 1. Noms d'une seule lettre (sauf compteurs de boucle simples) int d; // âŒ Que reprÃ©sente \"d\" ? string s; // âŒ Trop vague // 2. Noms trompeurs List\u003cClient\u003e clientsList; // âŒ Notation hongroise inutile en C# int compteur1, compteur2; // âŒ NumÃ©rotation sans signification // 3. Noms trop gÃ©nÃ©riques var data = ObtenirDonnees(); // âŒ Quelles donnÃ©es ? var info = CalculerInfo(); // âŒ Quelle info ? var temp = Process(); // âŒ Temp de quoi ? // 4. PrÃ©fixes/suffixes redondants class ClientClass { } // âŒ \"Class\" est redondant int intAge; // âŒ Notation hongroise dÃ©passÃ©e ğŸ” Exercice Pratique #1 Corrigez ce code :\npublic void Process(int a, int b) { var r = 0; for (int i = a; i \u003c= b; i++) { if (i % 2 == 0) { r += i; } } Console.WriteLine(r); } Solution :\npublic void AfficherSommeNombresPairs(int nombreDebut, int nombreFin) { int sommePairs = 0; for (int nombre = nombreDebut; nombre \u003c= nombreFin; nombre++) { if (NombreEstPair(nombre)) { sommePairs += nombre; } } Console.WriteLine($\"Somme des nombres pairs : {sommePairs}\"); } private bool NombreEstPair(int nombre) { return nombre % 2 == 0; } ğŸ”´ Code Smell #2 : Fonctions Trop Longues Quâ€™est-ce quâ€™une fonction trop longue ? Une fonction qui fait trop de choses, contient trop de lignes de code, ou a trop de niveaux dâ€™indentation. RÃ¨gle gÃ©nÃ©rale : une fonction devrait tenir sur un Ã©cran sans dÃ©filement.\nRÃ¨gle dâ€™or : Une fonction = Une responsabilitÃ©\nâŒ Exemple de Code ProblÃ©matique public class GestionnaireCommandes { public void TraiterCommande(int idCommande) { // Cette fonction fait BEAUCOUP TROP de choses ! // 1. RÃ©cupÃ©ration des donnÃ©es var commande = new Commande(); using (var connection = new SqlConnection(\"connectionString\")) { connection.Open(); var cmd = new SqlCommand($\"SELECT * FROM Commandes WHERE Id = {idCommande}\", connection); var reader = cmd.ExecuteReader(); if (reader.Read()) { commande.Id = (int)reader[\"Id\"]; commande.ClientId = (int)reader[\"ClientId\"]; commande.MontantTotal = (decimal)reader[\"MontantTotal\"]; commande.DateCommande = (DateTime)reader[\"DateCommande\"]; } } // 2. Validation if (commande.MontantTotal \u003c= 0) { Console.WriteLine(\"Erreur: Montant invalide\"); return; } if (commande.DateCommande \u003e DateTime.Now) { Console.WriteLine(\"Erreur: Date future\"); return; } // 3. Calcul des taxes decimal tps = commande.MontantTotal * 0.05m; decimal tvq = commande.MontantTotal * 0.09975m; decimal total = commande.MontantTotal + tps + tvq; // 4. VÃ©rification du client var client = new Client(); using (var connection = new SqlConnection(\"connectionString\")) { connection.Open(); var cmd = new SqlCommand($\"SELECT * FROM Clients WHERE Id = {commande.ClientId}\", connection); var reader = cmd.ExecuteReader(); if (reader.Read()) { client.Nom = (string)reader[\"Nom\"]; client.Email = (string)reader[\"Email\"]; client.Actif = (bool)reader[\"Actif\"]; } } if (!client.Actif) { Console.WriteLine(\"Erreur: Client inactif\"); return; } // 5. Application de rabais decimal rabais = 0; if (commande.MontantTotal \u003e 1000) { rabais = total * 0.10m; } else if (commande.MontantTotal \u003e 500) { rabais = total * 0.05m; } total -= rabais; // 6. Enregistrement de la facture using (var connection = new SqlConnection(\"connectionString\")) { connection.Open(); var cmd = new SqlCommand( $\"INSERT INTO Factures (CommandeId, MontantHT, TPS, TVQ, Rabais, Total) \" + $\"VALUES ({commande.Id}, {commande.MontantTotal}, {tps}, {tvq}, {rabais}, {total})\", connection); cmd.ExecuteNonQuery(); } // 7. Envoi d'email var smtp = new SmtpClient(\"smtp.server.com\"); var message = new MailMessage(); message.To.Add(client.Email); message.Subject = \"Facture\"; message.Body = $\"Votre facture de {total:C} est prÃªte\"; smtp.Send(message); // 8. Logging Console.WriteLine($\"Commande {idCommande} traitÃ©e avec succÃ¨s\"); File.AppendAllText(\"log.txt\", $\"{DateTime.Now}: Commande {idCommande} OK\\n\"); } } ğŸ¤” ProblÃ¨mes identifiÃ©s 91 lignes dans une seule mÃ©thode ! 8 responsabilitÃ©s diffÃ©rentes dans une fonction Violation du principe SRP (Single Responsibility Principle) Difficile Ã  tester : comment tester juste une partie ? Difficile Ã  maintenir : modifier une partie risque de casser le reste Code dupliquÃ© : connexion DB rÃ©pÃ©tÃ©e 3 fois MÃ©lange de niveaux dâ€™abstraction : dÃ©tails DB + logique mÃ©tier âœ… Code CorrigÃ© (Version Clean Code) public class GestionnaireCommandes { private readonly ICommandeRepository _commandeRepository; private readonly IClientRepository _clientRepository; private readonly IFactureRepository _factureRepository; private readonly ICalculateurTaxes _calculateurTaxes; private readonly ICalculateurRabais _calculateurRabais; private readonly IServiceEmail _serviceEmail; private readonly ILogger _logger; public GestionnaireCommandes( ICommandeRepository commandeRepository, IClientRepository clientRepository, IFactureRepository factureRepository, ICalculateurTaxes calculateurTaxes, ICalculateurRabais calculateurRabais, IServiceEmail serviceEmail, ILogger logger) { _commandeRepository = commandeRepository; _clientRepository = clientRepository; _factureRepository = factureRepository; _calculateurTaxes = calculateurTaxes; _calculateurRabais = calculateurRabais; _serviceEmail = serviceEmail; _logger = logger; } // ========================================== // MÃ‰THODE PRINCIPALE - Claire et concise // ========================================== public void TraiterCommande(int idCommande) { var commande = RecupererCommande(idCommande); ValiderCommande(commande); var client = RecupererClient(commande.ClientId); ValiderClient(client); var facture = CreerFacture(commande); EnregistrerFacture(facture); EnvoyerEmailConfirmation(client, facture); LoggerTraitement(idCommande); } // ========================================== // MÃ‰THODES PRIVÃ‰ES - Une responsabilitÃ© chacune // ========================================== private Commande RecupererCommande(int idCommande) { var commande = _commandeRepository.ObtenirParId(idCommande); if (commande == null) { throw new CommandeIntrouvableException($\"Commande {idCommande} introuvable\"); } return commande; } private void ValiderCommande(Commande commande) { if (commande.MontantTotal \u003c= 0) { throw new CommandeInvalideException(\"Le montant doit Ãªtre positif\"); } if (commande.DateCommande \u003e DateTime.Now) { throw new CommandeInvalideException(\"La date ne peut Ãªtre future\"); } } private Client RecupererClient(int clientId) { var client = _clientRepository.ObtenirParId(clientId); if (client == null) { throw new ClientIntrouvableException($\"Client {clientId} introuvable\"); } return client; } private void ValiderClient(Client client) { if (!client.Actif) { throw new ClientInactifException($\"Le client {client.Nom} est inactif\"); } } private Facture CreerFacture(Commande commande) { var montantHT = commande.MontantTotal; var taxes = _calculateurTaxes.CalculerTaxes(montantHT); var montantAvecTaxes = montantHT + taxes.TPS + taxes.TVQ; var rabais = _calculateurRabais.CalculerRabais(montantAvecTaxes); var montantFinal = montantAvecTaxes - rabais; return new Facture { CommandeId = commande.Id, MontantHorsTaxes = montantHT, TPS = taxes.TPS, TVQ = taxes.TVQ, Rabais = rabais, MontantTotal = montantFinal }; } private void EnregistrerFacture(Facture facture) { _factureRepository.Enregistrer(facture); } private void EnvoyerEmailConfirmation(Client client, Facture facture) { var contenuEmail = new EmailFacture { Destinataire = client.Email, NomClient = client.Nom, MontantTotal = facture.MontantTotal }; _serviceEmail.EnvoyerEmailFacture(contenuEmail); } private void LoggerTraitement(int idCommande) { _logger.LogInformation($\"Commande {idCommande} traitÃ©e avec succÃ¨s\"); } } // ========================================== // CLASSES DE SUPPORT (extraites) // ========================================== public class CalculateurTaxes : ICalculateurTaxes { private const decimal TAUX_TPS = 0.05m; private const decimal TAUX_TVQ = 0.09975m; public TaxesCalculees CalculerTaxes(decimal montantHorsTaxes) { return new TaxesCalculees { TPS = montantHorsTaxes * TAUX_TPS, TVQ = montantHorsTaxes * TAUX_TVQ }; } } public class CalculateurRabais : ICalculateurRabais { private const decimal SEUIL_RABAIS_ELEVE = 1000m; private const decimal SEUIL_RABAIS_MOYEN = 500m; private const decimal TAUX_RABAIS_ELEVE = 0.10m; private const decimal TAUX_RABAIS_MOYEN = 0.05m; public decimal CalculerRabais(decimal montant) { if (montant \u003e SEUIL_RABAIS_ELEVE) { return montant * TAUX_RABAIS_ELEVE; } if (montant \u003e SEUIL_RABAIS_MOYEN) { return montant * TAUX_RABAIS_MOYEN; } return 0; } } ğŸ“Š Comparaison Avant/AprÃ¨s Aspect Avant (ğŸ˜) AprÃ¨s (âœ…) Lignes par mÃ©thode 91 lignes 5-15 lignes max ResponsabilitÃ©s 8 dans une mÃ©thode 1 par mÃ©thode TestabilitÃ© TrÃ¨s difficile Facile (chaque partie) LisibilitÃ© NÃ©cessite dÃ©filement Chaque mÃ©thode visible dâ€™un coup Maintenance RisquÃ© SÃ»r et ciblÃ© RÃ©utilisabilitÃ© Aucune Chaque mÃ©thode rÃ©utilisable ğŸ¯ RÃ¨gles pour les Fonctions Propres âœ… Principes Ã  suivre : Une fonction = Une responsabilitÃ© // âœ… BON - Fait une seule chose public decimal CalculerPrixAvecTaxes(decimal prixHT) { return prixHT * 1.14975m; // TPS + TVQ du QuÃ©bec } // âŒ MAUVAIS - Fait plusieurs choses public decimal CalculerEtEnregistrerPrixAvecTaxes(decimal prixHT) { var prixTTC = prixHT * 1.14975m; // Enregistrement en DB // Envoi d'email // Logging return prixTTC; } Petite taille : 5-20 lignes idÃ©alement // âœ… BON - Court et clair public bool UtilisateurEstEligibleAuRabais(Utilisateur user) { return user.EstMembre \u0026\u0026 user.AncienneteEnMois \u003e= 6 \u0026\u0026 user.MontantAchatsTotal \u003e 1000; } Un seul niveau dâ€™abstraction // âœ… BON - MÃªme niveau d'abstraction public void TraiterInscription(Utilisateur user) { ValiderDonneesUtilisateur(user); EnregistrerUtilisateur(user); EnvoyerEmailBienvenue(user); } // âŒ MAUVAIS - Niveaux d'abstraction mÃ©langÃ©s public void TraiterInscription(Utilisateur user) { // Haut niveau ValiderDonneesUtilisateur(user); // Bas niveau (dÃ©tails d'implÃ©mentation) using (var connection = new SqlConnection(\"...\")) { connection.Open(); var cmd = new SqlCommand(\"INSERT...\", connection); cmd.ExecuteNonQuery(); } // Haut niveau EnvoyerEmailBienvenue(user); } Peu de paramÃ¨tres : 0-3 idÃ©alement // âœ… BON - 2 paramÃ¨tres public decimal CalculerRemise(decimal montant, TypeClient typeClient) { // ... } // âš ï¸ ACCEPTABLE - 3 paramÃ¨tres public void CreerCommande(int clientId, List\u003cProduit\u003e produits, AdresseLivraison adresse) { // ... } // âŒ MAUVAIS - Trop de paramÃ¨tres public void CreerCommande(int clientId, string nom, string prenom, string email, string telephone, string rue, string ville, string codePostal, List\u003cProduit\u003e produits) { // Utilisez plutÃ´t un objet } // âœ… MIEUX - Objet de paramÃ¨tres public void CreerCommande(InformationsCommande infos) { // ... } Pas dâ€™effets de bord // âŒ MAUVAIS - Effet de bord cachÃ© private int compteur = 0; // Variable de classe public bool ValiderUtilisateur(Utilisateur user) { compteur++; // âš ï¸ Effet de bord : modifie l'Ã©tat return user.Email != null \u0026\u0026 user.Age \u003e= 18; } // âœ… BON - Fonction pure public bool ValiderUtilisateur(Utilisateur user) { return user.Email != null \u0026\u0026 user.Age \u003e= 18; } ğŸ” Exercice Pratique #2 DÃ©composez cette fonction :\npublic void ProcessOrder(int orderId) { var order = db.Orders.Find(orderId); if (order == null) return; var customer = db.Customers.Find(order.CustomerId); if (customer == null) return; var total = 0m; foreach (var item in order.Items) { total += item.Price * item.Quantity; } var tax = total * 0.15m; var finalTotal = total + tax; if (finalTotal \u003e 1000) { finalTotal *= 0.9m; } order.Total = finalTotal; db.SaveChanges(); SendEmail(customer.Email, $\"Your order total: {finalTotal:C}\"); } Solution :\npublic void TraiterCommande(int idCommande) { var commande = RecupererCommande(idCommande); var client = RecupererClient(commande.ClientId); var montantTotal = CalculerMontantTotal(commande); EnregistrerMontantCommande(commande, montantTotal); EnvoyerEmailConfirmation(client, montantTotal); } private Commande RecupererCommande(int idCommande) { var commande = db.Orders.Find(idCommande); if (commande == null) { throw new CommandeIntrouvableException($\"Commande {idCommande} introuvable\"); } return commande; } private Client RecupererClient(int clientId) { var client = db.Customers.Find(clientId); if (client == null) { throw new ClientIntrouvableException($\"Client {clientId} introuvable\"); } return client; } private decimal CalculerMontantTotal(Commande commande) { var sousTotal = CalculerSousTotal(commande.Items); var montantAvecTaxes = AjouterTaxes(sousTotal); var montantFinal = AppliquerRabaisSiEligible(montantAvecTaxes); return montantFinal; } private decimal CalculerSousTotal(List\u003cItem\u003e items) { return items.Sum(item =\u003e item.Price * item.Quantity); } private decimal AjouterTaxes(decimal montant) { const decimal TAUX_TAXE = 0.15m; return montant * (1 + TAUX_TAXE); } private decimal AppliquerRabaisSiEligible(decimal montant) { const decimal SEUIL_RABAIS = 1000m; const decimal TAUX_RABAIS = 0.10m; if (montant \u003e SEUIL_RABAIS) { return montant * (1 - TAUX_RABAIS); } return montant; } private void EnregistrerMontantCommande(Commande commande, decimal montant) { commande.Total = montant; db.SaveChanges(); } private void EnvoyerEmailConfirmation(Client client, decimal montant) { var message = $\"Votre commande : {montant:C}\"; SendEmail(client.Email, message); } ğŸ”´ Code Smell #3 : Commentaires Inutiles ou Mensongers Quâ€™est-ce quâ€™un commentaire inutile ? Un commentaire qui :\nDÃ©crit ce que le code fait dÃ©jÃ  clairement Est obsolÃ¨te ou faux Compense un code mal Ã©crit Pourrait Ãªtre remplacÃ© par un bon nom de variable/mÃ©thode RÃ¨gle dâ€™or : Le meilleur commentaire est celui que vous nâ€™avez pas besoin dâ€™Ã©crire\nâŒ Exemple de Code ProblÃ©matique public class GestionnaireUtilisateurs { // Cette mÃ©thode calcule l'Ã¢ge de l'utilisateur public int CalculerAge(DateTime dateNaissance) { // Obtenir la date d'aujourd'hui DateTime aujourd'hui = DateTime.Today; // Calculer l'Ã¢ge int age = aujourd'hui.Year - dateNaissance.Year; // VÃ©rifier si l'anniversaire est passÃ© cette annÃ©e if (dateNaissance.Date \u003e aujourd'hui.AddYears(-age)) { age--; // Soustraire 1 si anniversaire pas encore passÃ© } // Retourner l'Ã¢ge return age; } // TODO: Corriger ce bug (Ã©crit il y a 2 ans...) // HACK: Solution temporaire en attendant le refactoring // NOTE: Ne fonctionne pas pour les clients VIP public decimal CalculerPrix(Produit p, Client c) { decimal prix = p.PrixBase; // Appliquer le rabais if (c.Type == \"VIP\") { prix = prix * 0.8m; // 20% de rabais } else if (c.Type == \"Premium\") { prix = prix * 0.9m; // 10% de rabais } // Sinon, pas de rabais return prix; } // ========================================== // SECTION: Validation // ========================================== // Valide l'email public bool ValiderEmail(string email) { // VÃ©rifier si email est null if (email == null) { return false; // Retourner faux } // VÃ©rifier si email contient @ if (!email.Contains(\"@\")) { return false; // Retourner faux } // L'email est valide return true; // Retourner vrai } /** * Cette mÃ©thode envoie un email Ã  l'utilisateur * ParamÃ¨tres: * - destinataire: l'adresse email du destinataire * - sujet: le sujet de l'email * - corps: le corps du message * Retour: * - bool: true si envoyÃ©, false sinon * Auteur: Jean Dupont * Date: 15/01/2022 * ModifiÃ© par: Marie Martin * Date: 03/05/2023 */ public bool EnvoyerEmail(string destinataire, string sujet, string corps) { // Code d'envoi d'email return true; } // MÃ©thode obsolÃ¨te - NE PLUS UTILISER // Utiliser NouvelleMethode() Ã  la place public void AncienneMethode() { // Cette mÃ©thode ne devrait plus Ãªtre utilisÃ©e // mais on la garde pour compatibilitÃ© } } ğŸ¤” ProblÃ¨mes identifiÃ©s Commentaires redondants : â€œCette mÃ©thode calcule lâ€™Ã¢geâ€ â†’ Le nom le dit dÃ©jÃ  ! Commentaires Ã©vidents : â€œObtenir la date dâ€™aujourdâ€™huiâ€ â†’ Le code est clair TODO/HACK vieux : Jamais rÃ©solus, induisent en erreur Commentaires qui mentent : â€œNe fonctionne pas pour VIPâ€ mais le code le gÃ¨re ! Commentaires de sÃ©paration : Headers inutiles Documentation excessive : Javadoc inutile pour mÃ©thode simple Code commentÃ© : MÃ©thode obsolÃ¨te devrait Ãªtre supprimÃ©e Explications du â€œcommentâ€ : Au lieu du â€œpourquoiâ€ âœ… Code CorrigÃ© (Version Clean Code) public class GestionnaireUtilisateurs { // ========================================== // MÃ‰THODE 1 : Calcul d'Ã¢ge // Aucun commentaire nÃ©cessaire - le code parle de lui-mÃªme // ========================================== public int CalculerAge(DateTime dateNaissance) { var aujourdHui = DateTime.Today; var age = aujourdHui.Year - dateNaissance.Year; if (AnniversairePasEncorePasseCetteAnnee(dateNaissance, aujourdHui, age)) { age--; } return age; } private bool AnniversairePasEncorePasseCetteAnnee(DateTime dateNaissance, DateTime aujourdHui, int age) { return dateNaissance.Date \u003e aujourdHui.AddYears(-age); } // ========================================== // MÃ‰THODE 2 : Calcul de prix // Code auto-documentÃ© avec extraction de mÃ©thodes // ========================================== public decimal CalculerPrix(Produit produit, Client client) { var prixBase = produit.PrixBase; var tauxRabais = ObtenirTauxRabais(client.Type); return AppliquerRabais(prixBase, tauxRabais); } private decimal ObtenirTauxRabais(TypeClient typeClient) { return typeClient switch { TypeClient.VIP =\u003e 0.20m, // 20% pour VIP TypeClient.Premium =\u003e 0.10m, // 10% pour Premium _ =\u003e 0m // Pas de rabais par dÃ©faut }; } private decimal AppliquerRabais(decimal prixBase, decimal tauxRabais) { return prixBase * (1 - tauxRabais); } // ========================================== // MÃ‰THODE 3 : Validation email // Nom de mÃ©thode explicite + extraction de conditions // ========================================== public bool EmailEstValide(string email) { return email != null \u0026\u0026 email.Contains(\"@\"); } // OU version plus robuste public bool EmailEstValide_Version2(string email) { if (EstVideOuNull(email)) { return false; } return ContientArobase(email) \u0026\u0026 ContientPoint(email); } private bool EstVideOuNull(string texte) =\u003e string.IsNullOrWhiteSpace(texte); private bool ContientArobase(string email) =\u003e email.Contains(\"@\"); private bool ContientPoint(string email) =\u003e email.Contains(\".\"); // ========================================== // MÃ‰THODE 4 : Envoi email // Signature claire = documentation suffisante // ========================================== public bool EnvoyerEmail(string destinataire, string sujet, string corps) { // Code d'envoi return true; } // ========================================== // MÃ‰THODE OBSOLÃˆTE : MarquÃ©e avec attribut, pas commentaire // ========================================== [Obsolete(\"Utilisez NouvelleMethode() Ã  la place\", error: true)] public void AncienneMethode() { throw new NotSupportedException(\"Cette mÃ©thode est obsolÃ¨te\"); } public void NouvelleMethode() { // Nouvelle implÃ©mentation } } ğŸ¯ Quand les Commentaires SONT Utiles Certains commentaires sont prÃ©cieux et doivent Ãªtre gardÃ©s :\nâœ… 1. Explication du â€œPOURQUOIâ€ (pas du â€œQUOIâ€) // âœ… BON - Explique une dÃ©cision non-Ã©vidente public decimal CalculerFraisLivraison(decimal montantCommande) { // Nous offrons la livraison gratuite au-dessus de 50$ pour encourager // les achats plus importants et amÃ©liorer la satisfaction client // (dÃ©cision marketing du 15/01/2024) if (montantCommande \u003e= 50) { return 0; } return 5.99m; } // âŒ MAUVAIS - DÃ©crit ce que le code fait dÃ©jÃ  public decimal CalculerFraisLivraison(decimal montantCommande) { // VÃ©rifier si le montant est supÃ©rieur ou Ã©gal Ã  50 if (montantCommande \u003e= 50) { return 0; // Retourner 0 } return 5.99m; // Sinon retourner 5.99 } âœ… 2. Avertissements sur les ConsÃ©quences // âœ… BON - Avertit d'un comportement important public void SupprimerToutesLesDonnees() { // ATTENTION: Cette opÃ©ration est IRRÃ‰VERSIBLE et supprime // toutes les donnÃ©es de production. Ã€ utiliser uniquement // dans le cadre de la procÃ©dure de rÃ©initialisation annuelle. database.DeleteAll(); } âœ… 3. TODO LÃ©gitimes (avec date et contexte) // âœ… BON - TODO avec contexte et Ã©chÃ©ance public class ServicePaiement { // TODO (2024-02-15): Migrer vers la nouvelle API Stripe v3 // DÃ©pendance: Attente de la mise Ã  jour du SDK // Responsable: Ã©quipe-backend@example.com public bool ProcesserPaiement(CarteBancaire carte) { // Utilisation de l'ancienne API (v2) return StripeV2.Charge(carte); } } // âŒ MAUVAIS - TODO vague et sans contexte public bool ProcesserPaiement(CarteBancaire carte) { // TODO: amÃ©liorer return StripeV2.Charge(carte); } âœ… 4. Explication dâ€™un Algorithme Complexe // âœ… BON - Explique un algorithme non-trivial public int CalculerJourPaques(int annee) { // Algorithme de Gauss pour calculer la date de PÃ¢ques // Formule mathÃ©matique complexe basÃ©e sur les cycles lunaires // RÃ©fÃ©rence: https://fr.wikipedia.org/wiki/Calcul_de_la_date_de_PÃ¢ques int a = annee % 19; int b = annee / 100; int c = annee % 100; // ... suite de l'algorithme complexe } âœ… 5. Exigences LÃ©gales ou MÃ©tier // âœ… BON - RÃ©fÃ©rence lÃ©gale importante public decimal CalculerTaxes(decimal montant) { // ConformÃ©ment Ã  la loi C-45 (QuÃ©bec), les taux de taxes sont: // TPS fÃ©dÃ©rale: 5% (depuis 01/01/2008) // TVQ provinciale: 9.975% (depuis 01/01/2013) // Ces taux peuvent changer - voir: revenuquebec.ca const decimal TPS = 0.05m; const decimal TVQ = 0.09975m; return montant * (1 + TPS + TVQ); } ğŸ“Š Guide de DÃ©cision : Commentaire ou Refactoring ? Vous voulez Ã©crire un commentaire ?\râ”‚\râ”œâ”€ DÃ©crit-il ce que le code fait ?\râ”‚ â””â”€ OUI â†’ âŒ Ne commentez pas, amÃ©liorez le code\râ”‚ â””â”€ Renommez variables/mÃ©thodes pour Ãªtre auto-documentÃ©\râ”‚\râ”œâ”€ Explique-t-il POURQUOI (dÃ©cision mÃ©tier, contrainte) ?\râ”‚ â””â”€ OUI â†’ âœ… Commentaire utile, gardez-le\râ”‚\râ”œâ”€ Compense-t-il un code mal Ã©crit ?\râ”‚ â””â”€ OUI â†’ âŒ Ne commentez pas, refactorez\râ”‚\râ”œâ”€ Contient-il un TODO/FIXME ?\râ”‚ â”œâ”€ Avec date, contexte et responsable â†’ âœ… OK\râ”‚ â””â”€ Vague ou ancien â†’ âŒ Supprimez ou corrigez\râ”‚\râ””â”€ Explique-t-il un algorithme complexe ?\râ””â”€ OUI â†’ âœ… Commentaire utile avec rÃ©fÃ©rence ğŸ” Exercice Pratique #3 Nettoyez ce code :\n// Classe pour gÃ©rer les utilisateurs public class UserManager { // Constructeur public UserManager() { // Initialiser } // Cette mÃ©thode vÃ©rifie si l'utilisateur peut se connecter public bool CanLogin(User u) { // VÃ©rifier si l'utilisateur n'est pas null if (u == null) { return false; // Retourner faux } // VÃ©rifier si l'utilisateur est actif if (!u.IsActive) { return false; // Retourner faux } // VÃ©rifier le mot de passe // TODO: ajouter vÃ©rification 2FA if (u.Password == null || u.Password.Length \u003c 8) { return false; // Mot de passe trop court } // Tout est OK return true; // Retourner vrai } // HACK: Temporaire jusqu'Ã  refonte // Ne fonctionne pas pour admin public void DeleteUser(int id) { // Code de suppression } } Solution :\npublic class GestionnaireUtilisateurs { private const int LONGUEUR_MINIMALE_MOT_DE_PASSE = 8; public bool UtilisateurPeutSeConnecter(Utilisateur utilisateur) { return UtilisateurExiste(utilisateur) \u0026\u0026 UtilisateurEstActif(utilisateur) \u0026\u0026 MotDePasseEstValide(utilisateur.MotDePasse); } private bool UtilisateurExiste(Utilisateur utilisateur) { return utilisateur != null; } private bool UtilisateurEstActif(Utilisateur utilisateur) { return utilisateur.EstActif; } private bool MotDePasseEstValide(string motDePasse) { return !string.IsNullOrEmpty(motDePasse) \u0026\u0026 motDePasse.Length \u003e= LONGUEUR_MINIMALE_MOT_DE_PASSE; } // TODO (2024-02-15): Ajouter authentification Ã  deux facteurs (2FA) // Ticket: SECURITY-123 // Responsable: Ã©quipe-sÃ©curitÃ©@example.com public void SupprimerUtilisateur(int idUtilisateur) { // ImplÃ©mentation } } ğŸ“ RÃ©sumÃ© de la Semaine Les 3 Code Smells Ã‰tudiÃ©s Noms Non Significatifs\nâŒ Variables dâ€™une lettre, abrÃ©viations obscures âœ… Noms rÃ©vÃ©lant lâ€™intention, prononÃ§ables, cherchables Fonctions Trop Longues\nâŒ Fonction qui fait tout, 100+ lignes âœ… Petites fonctions (5-20 lignes), une responsabilitÃ©, un niveau dâ€™abstraction Commentaires Inutiles\nâŒ Commentaires redondants, obsolÃ¨tes, compensant du mauvais code âœ… Code auto-documentÃ©, commentaires expliquant le POURQUOI Citations Ã  Retenir â€œLe code propre est simple et direct. Il se lit comme une prose bien Ã©crite.â€ â€” Grady Booch\nâ€œUn commentaire mensonger est pire que pas de commentaire du tout.â€ â€” Robert C. Martin\nChecklist Avant de Commiter du Code Mes variables ont des noms significatifs et rÃ©vÃ¨lent leur intention Mes mÃ©thodes font UNE SEULE chose Mes mÃ©thodes ont moins de 20 lignes Mes mÃ©thodes ont 3 paramÃ¨tres ou moins Jâ€™ai Ã©liminÃ© les commentaires qui dÃ©crivent ce que le code fait Mes commentaires (sâ€™il y en a) expliquent le POURQUOI Mon code se lit comme une histoire claire ğŸ¯ DÃ©fi de la Semaine Trouvez dans votre propre code :\n3 variables avec des noms non significatifs â†’ Renommez-les 1 fonction longue (\u003e30 lignes) â†’ DÃ©composez-la 5 commentaires inutiles â†’ Supprimez-les en rendant le code auto-documentÃ© Partagez vos avant/aprÃ¨s avec la classe la semaine prochaine !\nğŸ“š Lectures RecommandÃ©es Clean Code (Chapitre 2: Meaningful Names) Clean Code (Chapitre 3: Functions) Clean Code (Chapitre 4: Comments) ğŸ”œ AperÃ§u Semaine Prochaine La semaine prochaine, nous aborderons :\nCode Duplication (DRY Principle) Classes trop grandes Couplage fort vs Couplage faible â€œLaissez le code plus propre que vous ne lâ€™avez trouvÃ©.â€ â€” RÃ¨gle du Boy Scout",
    "description": "ğŸ§¹ Rubrique Clean Code - Semaine 1 Noms Significatifs et Fonctions Claires ğŸ“‹ Objectifs de cette semaine Apprendre Ã  :\nIdentifier et corriger les noms non significatifs ReconnaÃ®tre et rÃ©soudre les fonctions trop longues Ã‰liminer les commentaires inutiles en Ã©crivant du code auto-explicatif ğŸ’¡ Citation de la semaine â€œLe code est lu beaucoup plus souvent quâ€™il nâ€™est Ã©crit. Facilitez la lecture, pas lâ€™Ã©criture.â€",
    "tags": [],
    "title": "Affichage console",
    "uri": "/420-413/rubrique/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "1. Introduction Ã  Visual Studio 2022 Quâ€™est-ce que Visual Studio ? Visual Studio 2022 est lâ€™Environnement de DÃ©veloppement IntÃ©grÃ© (IDE) de Microsoft dÃ©diÃ© au dÃ©veloppement dâ€™applications sur les plateformes .NET. Il offre un ensemble complet dâ€™outils pour coder, tester, dÃ©boguer, dÃ©ployer et collaborer efficacement.\nLes Ã©ditions de Visual Studio 2022 Ã‰dition Public cible Community Gratuit : Ã©tudiants, dÃ©veloppeurs open source et particuliers. Professional DÃ©veloppeurs professionnels et petites Ã©quipes. Enterprise Grandes Ã©quipes : outils avancÃ©s de test, performance et intÃ©gration continue. 2. Installation et Configuration Ã‰tapes dâ€™installation TÃ©lÃ©chargement : Se rendre sur visualstudio.microsoft.com/fr pour choisir sa version. SÃ©lection des charges de travail : Pour le dÃ©veloppement C# (Windows Forms ou WPF), il est impÃ©ratif de sÃ©lectionner .NET Desktop Development. Si vous disposez dÃ©jÃ  de Visual Studio, vous pouvez ajouter la charge de travail de dÃ©veloppement de bureau .NET comme suit :\nLancez Visual Studio Installer. Si vous y Ãªtes invitÃ©, autorisez le programme dâ€™installation Ã  se mettre Ã  jour. Si une mise Ã  jour pour Visual Studio est disponible, un bouton Mettre Ã  jour sâ€™affiche. SÃ©lectionnez-la pour la mettre Ã  jour avant de modifier lâ€™installation. Recherchez votre installation de Visual Studio et sÃ©lectionnez le bouton Modifier . Sâ€™il nâ€™est pas dÃ©jÃ  sÃ©lectionnÃ©, sÃ©lectionnez la charge de travail de dÃ©veloppement du bureau .NET , puis sÃ©lectionnez le bouton Modifier . Sinon, fermez simplement la fenÃªtre de dialogue. Personnalisation Lâ€™interface est entiÃ¨rement personnalisable : thÃ¨mes, raccourcis clavier et extensions. Pour un environnement complet, il est recommandÃ© dâ€™installer Git pour la gestion de versions.\nCaution Note sur lâ€™IA : Des outils comme GitHub Copilot sont disponibles, mais ils ne doivent pas Ãªtre utilisÃ©s dans le cadre de ce cours afin de ne pas nuire Ã  lâ€™apprentissage des concepts fondamentaux.\n3. FonctionnalitÃ©s principales Source : https://learn.microsoft.com/fr-fr/visualstudio/get-started/media/visual-studio-overview.png?view=vs-2022\nLâ€™Ã©diteur de texte Lâ€™Ã©diteur de texte de Visual Studio est un puissant outil permettant de saisir le code de lâ€™application.\nVoici quelques fonctionnalitÃ©s de lâ€™Ã©diteur de texte:\nLes mots-clÃ©s et les types sont colorÃ©s pour faciliter la lecture et la comprÃ©hension du code. La qualitÃ© du document en cours de visualisation est annoncÃ©e grÃ¢ce Ã  lâ€™icÃ´ne en bas du document pour indiquer sâ€™il contient des suggestions, des avertissements ou des erreurs. Lâ€™intellisense permet dâ€™afficher les classes et leurs membres en rapport avec le code saisi ainsi que les paramÃ¨tres et les surcharges possibles pour les mÃ©thodes Lâ€™intellicode vous permet dâ€™assurer la prÃ©cision et la cohÃ©rence de lâ€™exÃ©cution du code qui peut remplir une ligne entiÃ¨re Ã  la fois. Lâ€™IA dÃ©tecte votre contexte de code, notamment les noms de variables, les fonctions et le type de code que vous Ã©crivez, pour vous donner les meilleures suggestions. Encore mieuxÂ : IntelliCode sâ€™exÃ©cute sur votre ordinateur, ce qui garantit que votre code privÃ© reste privÃ©. Autres outils de Visual Studio Code 2022 Gestion de builds : CrÃ©ation de configurations adaptÃ©es aux environnements de dÃ©veloppement ou de production.\nDÃ©bogage et tests : DÃ©bogueur intÃ©grÃ© pour lâ€™exÃ©cution pas Ã  pas et outils de tests unitaires (NUnit, xUnit). Le mode dÃ©bogage peut Ãªtre lancÃ© en allant sur DÃ©boguer -\u003e DÃ©marrer le dÃ©bogage ou juste F5\nCollaboration : IntÃ©gration native de Git/GitHub et support de Live Share pour le dÃ©veloppement collaboratif en temps rÃ©el.\n4. Exploration de lâ€™interface Lors du lancement, la fenÃªtre de dÃ©marrage propose quatre options principales:\nClone a repository : RÃ©cupÃ©rer du code depuis GitHub ou Azure DevOps. Open a project or solution : Ouvrir un fichier projet local. Open a local folder : Naviguer et Ã©diter du code dans nâ€™importe quel dossier. Create a new project : Commencer Ã  partir dâ€™un modÃ¨le prÃ©dÃ©fini. ` 5. Projets et Solutions CrÃ©er votre solution et projet DÃ©marrez Visual Studio et sÃ©lectionnez CrÃ©er un projet. Dans la fenÃªtre CrÃ©er un projet, recherchez et sÃ©lectionnez un modÃ¨le dâ€™application console C#, puis sÃ©lectionnez Suivant.. Configurez votre projet (nom, emplacement). Ã€ cette Ã©tape, vous pouvez dÃ©cidez de placer la solution .sln et le projet .csproj. Puis sÃ©lectionnez Suivant. Dans la fenÃªtre Informations supplÃ©mentaires , vÃ©rifiez que .NET 8.0 apparaÃ®t dans le menu dÃ©roulant Framework, puis sÃ©lectionnez CrÃ©er. DiffÃ©rences fondamentales entre projet et solution Un projet est un ensemble de fichiers qui seront compilÃ©s en un seul assemblage. Une solution est un ensemble dâ€™un ou plusieurs projets. Un projet dâ€™application exÃ©cutable possÃ¨de un point dâ€™entrÃ©e. Câ€™est la mÃ©thode Main. Cette mÃ©thode doit Ãªtre publique et statique en utilisant les mots-clÃ©s public et static, qui spÃ©cifient respectivement que la mÃ©thode est accessible depuis lâ€™application et en dehors, que la mÃ©thode est globale et que la classe nâ€™a pas besoin dâ€™Ãªtre instanciÃ©e pour pouvoir lâ€™appeler. Une solution possÃ¨de aussi un projet de dÃ©marrage. Ce projet est identifiable dans lâ€™explorateur de solutions, car son nom est en gras. Pour modifier cette propriÃ©tÃ©, un clic droit sur le projet permet de sÃ©lectionner DÃ©finir en tant que projet de dÃ©marrage dans le menu contextuel. Le point dâ€™entrÃ©e (MÃ©thode Main) Un projet exÃ©cutable possÃ¨de une mÃ©thode Main. Elle doit Ãªtre dÃ©finie comme suit:\npublic : Accessible depuis lâ€™application et lâ€™extÃ©rieur. static : La mÃ©thode est globale et la classe nâ€™a pas besoin dâ€™Ãªtre instanciÃ©e pour lâ€™appeler. Projet de dÃ©marrage : Dans une solution, le projet de dÃ©marrage apparaÃ®t en gras dans lâ€™explorateur de solutions. On peut le modifier via un clic droit -\u003e DÃ©finir en tant que projet de dÃ©marrage.\n6. ExÃ©cution et DÃ©bogage Lancement : Cliquez sur la flÃ¨che verte ou appuyez sur F5. Points dâ€™arrÃªt (Breakpoints) : Permettent dâ€™interrompre lâ€™exÃ©cution pour examiner lâ€™Ã©tat des variables Ã  des endroits prÃ©cis.\nLes diffÃ©rents fichiers compris dans la solution Le fichier program.cs qui contient le code qui est compilÃ© et exÃ©cutÃ© Quand on fait un clic droit sur le projet, ensuite on choisit â€œOuvrir le dossier dans lâ€™Explorateur de fichiersâ€,Â on peut voir le fichier du projet dont lâ€™extension est csproj. Un niveau plus haut, on voit le fichier de la solution dont lâ€™extension est sln. Plus bas, dans le dossier bin -\u003e Debug -\u003e net8.0, on peut voir le fichier exÃ©cutable .exe qui est lâ€™application qui vient dâ€™Ãªtre crÃ©Ã©e. Si on double-clique sur lâ€™exÃ©cutable, on ouvre lâ€™application. On peut aussi ouvrir la ligne de commande cmd et exÃ©cuter lâ€™application enÂ tapant le nom de lâ€™exÃ©cutable. Ressources supplÃ©mentaires Documentation Visual Studio Documentation IntelliCode",
    "description": "1. Introduction Ã  Visual Studio 2022 Quâ€™est-ce que Visual Studio ? Visual Studio 2022 est lâ€™Environnement de DÃ©veloppement IntÃ©grÃ© (IDE) de Microsoft dÃ©diÃ© au dÃ©veloppement dâ€™applications sur les plateformes .NET. Il offre un ensemble complet dâ€™outils pour coder, tester, dÃ©boguer, dÃ©ployer et collaborer efficacement.",
    "tags": [],
    "title": "Intro Ã  Visual Studio 2022",
    "uri": "/420-413/intro/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Introduction Ã  .NET .NET : Un Ã©cosystÃ¨me pour le dÃ©veloppement dÊ¼applications qui prend en charge plusieurs langages, dont C#, F#, et VB.NET. Il fournit des outils, des bibliothÃ¨ques, et un environnement dÊ¼exÃ©cution pour faciliter le dÃ©veloppement dâ€™applications.\nLa plateforme .NET La plateforme .NET repose sur une architecture en couches qui permet lâ€™exÃ©cution de code Ã©crit dans diffÃ©rents langages (C#, F#, VB.NET) de maniÃ¨re unifiÃ©e et performante.\n1. Les composants fondamentaux Lâ€™architecture sâ€™appuie principalement sur deux piliers :\nCLR (Common Language Runtime) : Câ€™est le moteur/coeur dâ€™exÃ©cution. Il gÃ¨re lâ€™exÃ©cution des programmes, la mÃ©moire (Garbage Collector), la sÃ©curitÃ© et la compilation Ã  la volÃ©e (JIT). Moteur dâ€™exÃ©cution : Le CLR est responsable de charger et exÃ©cuter des programmes .NET et assure la gestion de la mÃ©moire, la sÃ©curitÃ©, et la gestion des exceptions. Conversion IL -\u003e Code natif : Le code C# est dâ€™abord compilÃ© en Intermediate Language (IL), puis converti en code machine natif par le CLR. Gestion de la mÃ©moire : Le CLR gÃ¨re automatiquement la mÃ©moire via la garbage collection (collecte des objets non utilisÃ©s). SÃ©curitÃ© : Le CLR applique des rÃ¨gles de sÃ©curitÃ© pour exÃ©cuter les programmes de maniÃ¨re sÃ©curisÃ©e. BCL (Base Class Library) : Une immense bibliothÃ¨que de classes rÃ©utilisables qui fournit les fonctionnalitÃ©s de base (gestion des fichiers, rÃ©seau, dates, collections, etc.). 2. Le MÃ©canisme de Compilation du Code Source C# Code source C# : Lorsquâ€™un programme C# est Ã©crit, le code source est dâ€™abord compilÃ© en IL (Intermediate Language). Le compilateur C# sâ€™appelle Roslyn Le CIL (Common Intermediate Language) : Le compilateur ne crÃ©e pas tout de suite un programme fini. Il traduit votre C# en un langage intermÃ©diaire (autrefois appelÃ© MSIL). Pourquoi ? Parce que ce langage est universel au sein de lâ€™Ã©cosystÃ¨me .NET. Que vous Ã©criviez en C#, F# ou VB.NET, tout finit en CIL. Cela permet Ã  diffÃ©rents langages de fonctionner ensemble.\nEn plus du code IL, le compilateur gÃ©nÃ¨re des informations cruciales :\nMÃ©tadonnÃ©es : Une description de chaque classe, mÃ©thode et variable dÃ©finie dans votre code.\nManifeste : La â€œcarte dâ€™identitÃ©â€ du programme (nom, version, bibliothÃ¨ques externes nÃ©cessaires).\nAssembly : Le code et les ressources sont stockÃ©s dans un fichier assembly (gÃ©nÃ©ralement avec lâ€™extension .dll ou .exe). Un assembly contient un manifeste qui dÃ©crit ses types, sa version, et ses mÃ©tadonnÃ©es. Compilation Just-In-Time (JIT) : Lorsque le programme est exÃ©cutÃ©, le CLR charge lÊ¼assembly, et le code IL est compilÃ© en code natif via la compilation JIT. ParticularitÃ© : Le JIT ne compile que les morceaux de code au fur et Ã  mesure quâ€™ils sont appelÃ©s (â€œJuste Ã  tempsâ€). Si une fonction nâ€™est jamais utilisÃ©e pendant une session, elle nâ€™est jamais compilÃ©e en code machine, ce qui Ã©conomise des ressources.",
    "description": "Introduction Ã  .NET .NET : Un Ã©cosystÃ¨me pour le dÃ©veloppement dÊ¼applications qui prend en charge plusieurs langages, dont C#, F#, et VB.NET. Il fournit des outils, des bibliothÃ¨ques, et un environnement dÊ¼exÃ©cution pour faciliter le dÃ©veloppement dâ€™applications.\nLa plateforme .NET La plateforme .NET repose sur une architecture en couches qui permet lâ€™exÃ©cution de code Ã©crit dans diffÃ©rents langages (C#, F#, VB.NET) de maniÃ¨re unifiÃ©e et performante.",
    "tags": [],
    "title": "Architecture .NET",
    "uri": "/420-413/architecture/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Introduction Ã  C# C# (prononcÃ© â€œC Sharpâ€) est un langage de programmation moderne, orientÃ© objet et fortement typÃ©. C# est dÃ©veloppÃ© par Microsoft en 2000 et est principalement utilisÃ© pour le dÃ©veloppement dÊ¼applications sous la plateforme .NET. La syntaxe de C# est influencÃ©e par C, C++ et Java, mais elle prÃ©sente certaines spÃ©cificitÃ©s qui lui sont propres.\nC# est un langage sensible Ã  la casse.\nLâ€™extension des fichiers C# est .cs\nCaractÃ©ristiques principales: OrientÃ© objet: tout est basÃ© sur des classes et des objets TypÃ© statiquement: les types de variables doivent Ãªtre dÃ©clarÃ©s GÃ©rÃ©: la mÃ©moire est gÃ©rÃ©e automatiquement par le garbage collector Polyvalent: applications desktop, web, mobile, jeux vidÃ©o (Unity) Moderne: syntaxe claire et Ã©volutive Domaines dâ€™utilisation: Avec C#, on peut crÃ©er :\nğŸ–¥ï¸ des applications console\nğŸ–¥ï¸ Applications Windows (WPF, WinForms)\nğŸŒ des sites Web et des API\nğŸ“± des applications mobiles\nğŸ® des jeux (Unity utilise C#)\nğŸ‘‰ Bref : un langage, plusieurs carriÃ¨res possibles.\nStructure de base dâ€™un programme C# Un programme C# est composÃ© de plusieurs Ã©lÃ©ments clÃ©s : lâ€™espace de noms (namespace), les classes, et la mÃ©thode Main, qui est le point dâ€™entrÃ©e de lâ€™application.\nusing System; // Importation des bibliothÃ¨ques namespace MyProgram // DÃ©finition de l'espace de noms { class Program // DÃ©finition de la classe { static void Main(string[] args) // MÃ©thode Main, point d'entrÃ©e du programme { Console.WriteLine(\"Hello, World!\"); // Affichage d'un message et aller Ã  la prochaine ligne } } } using : UtilisÃ© pour importer des bibliothÃ¨ques externes (par exemple, System contient des classes utiles comme Console). namespace : Un conteneur logique pour les classes et autres types. En dâ€™autres termes, câ€™est une faÃ§on dâ€™organiser le code. Pense Ã  un namespace comme : un dossier une section ou un casier pour ranger des classes. Sans namespaces, ce serait le chaos total ğŸ˜±. Imagine des milliers de classes, toutes avec des noms simples comme Console, List, Button. Sans namespace : ğŸ’¥ conflits de noms ğŸ’¥ code impossible Ã  lire ğŸ’¥ dÃ©veloppeurs en dÃ©pression class : Un modÃ¨le pour crÃ©er des objets. Tout programme C# doit contenir au moins une classe. Main : La mÃ©thode Main est le point de dÃ©part dâ€™une application C#. Câ€™est ici que lâ€™exÃ©cution du programme commence. Les identifiants ou les identificateurs Ce sont les noms donnÃ©s aux classes et Ã  leurs membres. Un identifiant doit Ãªtre composÃ© dâ€™un seul mot commenÃ§ant par une lettre ou un caractÃ¨re underscore (_). Mais, il peut contenir aussi un chiffre qui ne doit pas se placer au dÃ©but de lâ€™identifiant. Ils peuvent Ãªtre composÃ©s de lettres majuscules et minuscules, mais le langage C# Ã©tant sensible Ã  la casse, les majuscules et minuscules doivent Ãªtre respectÃ©es pour faire rÃ©fÃ©rence au bon identifiant Par exemple: les identifiants suivants ne sont pas les mÃªmes monIdentifiant et MonIdentifiant. Les mots-clÃ©s Les mots clÃ©s sont des noms rÃ©servÃ©s par le langage C#, qui ont des significations spÃ©cifiques pour le compilateur. Ils ne peuvent pas Ãªtre utilisÃ©s comme identifiants dans votre programme, sauf sâ€™ils incluent @ comme prÃ©fixe. Par exemple, @if est un identifiant valide, mais pas if, car if est un mot clÃ©.\nPar dÃ©faut, les mots-clÃ©s sont colorÃ©s en bleu dans lâ€™Ã©diteur de Visual Studio. Le caractÃ¨re @ peut Ã©galement prÃ©fixer des identifiants qui nâ€™ont aucun conflit avec les mots-clÃ©s. Ainsi @monIdentifiant et monIdentifiant seront interprÃ©tÃ©s de la mÃªme maniÃ¨re (la mÃªme variable). Les commentaires C# prend en charge deux formes diffÃ©rentes de commentaires:\nLes commentaires sur une seule ligne commencent par // et se terminent Ã  la fin de cette ligne de code. Les commentaires multilignes commencent par /* et se terminent par */ Le commentaire sur plusieurs lignes peut Ã©galement Ãªtre utilisÃ© pour insÃ©rer du texte dans une ligne de code. Ã‰tant donnÃ© que ces commentaires ont un caractÃ¨re de fermeture explicite, vous pouvez inclure plus de code exÃ©cutable aprÃ¨s le commentaire:\npublic static int additioner(int nombre1, int nombre2) { return nombre1 /* premiÃ¨re opÃ©rande */ + nombre2 /* deuxiÃ¨me opÃ©rande*/; } Le commentaire sur une seule ligne peut apparaÃ®tre aprÃ¨s le code exÃ©cutable sur la mÃªme ligne. Le commentaire se termine Ã  la fin de la ligne de texte :\nfloat temperature = 34.4f; // Si nous n'ajoutons pas le f ou le F aprÃ¨s la valeur, nous obtiendrons une erreur",
    "description": "Introduction Ã  C# C# (prononcÃ© â€œC Sharpâ€) est un langage de programmation moderne, orientÃ© objet et fortement typÃ©. C# est dÃ©veloppÃ© par Microsoft en 2000 et est principalement utilisÃ© pour le dÃ©veloppement dÊ¼applications sous la plateforme .NET. La syntaxe de C# est influencÃ©e par C, C++ et Java, mais elle prÃ©sente certaines spÃ©cificitÃ©s qui lui sont propres.",
    "tags": [],
    "title": "Intro et syntaxe du C#",
    "uri": "/420-413/intro_syntaxe_c_sharp/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "1. DÃ©claration de variables et types de donnÃ©es C# est un langage fortement typÃ©, ce qui signifie que chaque variable doit Ãªtre dÃ©clarÃ©e avec un type spÃ©cifique. Voici quelques types de base :\nint age = 25; // Entier double price = 19.99; // Nombre Ã  virgule flottante char grade = 'A'; // CaractÃ¨re unique string name = \"John\"; // ChaÃ®ne de caractÃ¨res bool isActive = true; // BoolÃ©en (vrai ou faux) Une variable peut Ãªtre dÃ©clarÃ©e et initialisÃ©e avec la mÃªme instruction.\nstring salutation = \"Bonjour tout le monde!\";\nIl est Ã©galement possible de dÃ©clarer et dâ€™initier plusieurs variables en une seule instruction, Ã  la condition quâ€™elles soient du mÃªme type. Dans ce cas, les variables sont sÃ©parÃ©es par une virgule. bool joyeux = true, content = true;\nUne variable peut Ã©galement Ãªtre marquÃ©e par le mot-clÃ© const qui spÃ©cifie que la valeur de la variable ne peut pas Ãªtre modifiÃ©e pendant lâ€™exÃ©cution. Câ€™est une variable en lecture seule. const double Pi = 3.14;\nLâ€™infÃ©rence de type (var) : Le mot-clÃ© var permet au compilateur de deviner le type de la variable lors de lâ€™initialisation. Attention : le type reste fixe aprÃ¨s lâ€™assignation.\nvar total = 15.5; // Le compilateur dÃ©duit 'double'\nğŸ’¡ Voici quelques conventions de codage applicables aux variables : La rÃ¨gle dâ€™or : Camel Case Pour les variables locales (celles dÃ©finies Ã  lâ€™intÃ©rieur dâ€™une mÃ©thode), la convention universelle en C# est le camelCase. Par exempleÂ :Â string thisIsCamelCase;. Le premier mot commence par une lettre minuscule.\nChaque mot suivant commence par une lettre majuscule.\nOn ne doit pas utiliser de chiffres au dÃ©but du nom.\nLe trait de soulignement (_) est proscrit pour le moment.\nint nombreEtudiants; // Correct\tstring codePermanent; // Correct double soldeBanque;\t// Correct int NombreEtudiants; // (PascalCase) Incorrect (ou non conventionnel) string code_permanent; // (snake_case) non conventionnel) double soldebanque; // (tout en minuscule) Incorrect (ou non conventionnel) SÃ©mantique (Donner du sens)\nUne variable doit dÃ©crire son contenu sans ambiguÃ¯tÃ©. En programmation professionnelle, on Ã©vite les noms dâ€™une seule lettre.\nÃ‰vitez : string s = \"Informatique\";\nPrivilÃ©giez : string nomProgramme = \"Informatique\";\nTableau rÃ©capitulatif des conventions de nommage C# Ã‰lÃ©ment Convention Exemple Variable locale camelCase uniteDisponible ParamÃ¨tre de mÃ©thode camelCase (int quantiteItems) Constante PascalCase TauxTaxeFederale Classe PascalCase GestionnaireEtudiant MÃ©thode PascalCase CalculerSalaire() 2. Les types de base Les types de donnÃ©es permettent de stocker des valeurs dans lâ€™application. Les langages .NET Ã©tant fortement typÃ©s, il nâ€™est pas toujours possible de convertir un type de donnÃ©es Ã  un autre. Les conversions permettent de convertir les types de donnÃ©es. Cela est possible, car tous les types du Framework .NET dÃ©rivent du type Object qui est le type de case de tous les autres types Les types numÃ©riques Les types numÃ©riques sont dÃ©composÃ©s en deux parties: Les entiers et les dÃ©cimaux. Chacun dispose dâ€™un ensemble de types pour reprÃ©senter les donnÃ©es de la maniÃ¨re la plus judicieuse en fonction des besoins.\nLes entiers Une valeur peut Ãªtre assignÃ©e Ã  un entier avec une notation dÃ©cimale:\nint nombre = 10; //Notation dÃ©cimale La notation hexadÃ©cimale peut Ãªtre utilisÃ©e et elle doit Ãªtre prÃ©cÃ©dÃ©e du prÃ©fixe 0x:\nint nombre = 0x4B; // Notation hexadÃ©cimale Ã©quivalente Ã  75 La notation binaire peut Ãªtre utilisÃ©e et elle doit Ãªtre prÃ©cÃ©dÃ©e du prÃ©fixe 0b:\nint nombre = 0b1101; // Notation binaire Ã©quivalente Ã  13 Les dÃ©cimaux Les boolÃ©ens Un boolÃ©en est un type qui permet de reprÃ©senter une valeur qui est soit true, soit false. Le type .NET correspondant est System.Boolean et son nom C# est bool. Il est possible dâ€™assigner Ã  un boolÃ©en le rÃ©sultat dâ€™une comparaison:\nint nombre = 8; bool estPair = nombre % 2 == 0; Les chaÃ®nes de caractÃ¨res Le type System.String (string) est un type de rÃ©fÃ©rence qui reprÃ©sente une sÃ©rie de types System.Char (char)\nUne variable de type char est assignÃ©e avec un caractÃ¨re placÃ© entre guillemets simples:\nchar premiereLettre = 'a'; Une variable de type string est assignÃ©e avec une chaÃ®ne de caractÃ¨re placÃ©e entre des guillemets doubles\nstring salutation = \"Bonjour tout le monde!\"; La propriÃ©tÃ© Length permet de savoir quelle est la longueur dâ€™un string\nConsole.WriteLine(\"Hello\".Length); // RÃ©sultat: 5 DÃ©claration des chaines de caractÃ¨res // DÃ©clarer sans initialiser. string message1; // Initialiser Ã  null. string message2 = null; // Initialise comme une chaÃ®ne vide (empty string). // Utilise la constante Empty au lieu de \"\". string message3 = System.String.Empty; // Initialiser avec une chaÃ®ne de caractÃ¨res normale. string vieuxChemin = \"c:\\\\Program Files\\\\Microsoft Visual Studio 8.0\"; // Initialiser avec un littÃ©ral de chaÃ®ne verbatim (pratique pour les chemins). string nouveauChemin = @\"c:\\Program Files\\Microsoft Visual Studio 9.0\"; // Utilisez System.String si vous prÃ©fÃ©rez. System.String salutation = \"Hello World!\"; // Dans les variables locales (c'est-Ã -dire dans le corps d'une mÃ©thode), // vous pouvez utiliser le typage implicite. var temporaire = \"I'm still a strongly-typed System.String!\"; // Utilisez une chaÃ®ne const pour empÃªcher la variable de stocker une autre valeur. const string MessagePermanent = \"Tu ne peux pas te dÃ©barrasser de moi!\"; // Utilisez le constructeur String uniquement lors de la crÃ©ation // d'une chaÃ®ne Ã  partir d'un char*, char[] ou sbyte*. char[] lettres = { 'A', 'B', 'C' }; string alphabet = new string(lettres); Quelques propriÃ©tÃ©s et mÃ©thodes de la classe string Soit la variable suivanteÂ : string salutation = \"Bonjour tout le monde!\";\nLa nombre de caractÃ¨re:\nint nombreCaractere = salutation.Length; // 22 Convertir tous les caractÃ¨res de la chaÃ®ne en majuscule:\nstring salutationMajuscule = salutation.ToUpper(); //Â BONJOUR TOUT LE MONDE! Convertir tous les caractÃ¨res de la chaÃ®ne en lettre minuscule\nstringÂ salutationMinuscule = salutation.ToLower(); // bonjour tout le monde! VÃ©rifier si le string contient une sous-chaÃ®ne de caractÃ¨re ou un mot\nbool contientBonjour = salutation.Contains(\"bonjour\"); contientBonjour = salutation.Contains(\"Bonjour\");Â //true Remplacer toutes les occurrences dâ€™un caractÃ¨re dans la chaÃ®ne par un autre\nstring salut =Â salutation.Replace(\"Bonjour\", \"Salut\") //Â Salut tout le monde! Retourne une partie de la chaine, le 0 est lâ€™index du dÃ©but, et le 7 est leÂ nombre de caractÃ¨re Ã  considÃ©rer\nstring bonjour =Â salutation.Substring(0, 7); // Bonjour Admettons que jâ€™ajoute un autre string, pour ConcatÃ©ner les strings\nstring question = \"Comment allez-vous?\"; StringÂ nouvelleSalutationÂ =Â string.Concat(salutation, \" \", question);Â //Bonjour tout le monde!Â Comment allez-vous? Formatter la chaine de caractÃ¨re pour remplacer les expressions de type {0}, {1}, {2}, {3}, etc. PrÃ©sentes dans la chaÃ®ne par les valeurs passÃ©es en paramÃ¨tres lors de lâ€™appel de la fonction.\nstring firstName = \"Sara\"; int count = 25; float temperature = 34.4f; Console.WriteLine(\"Bonjour, {0}! Tu as {1} messages dans ta boÃ®te. La tempÃ©rature est {2} celsius.\", prenom, count, temperature); Lâ€™interpolation de string Soit les variables suivantes:\nstring nom = \"Samuel\"; int age = 28; On aimerait crÃ©er le string: Je mâ€™appelle Marc, jâ€™ai 20 ans. Si on utilise lâ€™addition des chaÃ®nes de caractÃ¨res, on aurait:\nstring presentation = \"Je m'appelle \" + nom + \", j'ai \" +Â age + \" ans.\"; En utilisant la mÃ©thode string.format:\nstring presentation = string.Format(\"Je m'appelle {0}, j'ai {1} ans. \",Â nom, age); En utilisant lâ€™interpolation:\nstring presentation = $\"Je m'appelle {nom}, j'ai {age} ans. \"; Convertir une chaÃ®ne de caractÃ¨res aux autres types Utiliser la mÃ©thode Parse pour convertir un string vers un autre type\nint age = int.Parse(\"35\");Â bool vrai = bool.Parse(\"true\"); Il se peut quâ€™on essaie de convertir une valeur incorrecte. Par exemple, si on essaie de convertir la chaÃ®ne de caractÃ¨re â€œSamuelâ€ en int. On aura une erreur lors de lâ€™exÃ©cution. Pour Ã©viter dâ€™avoir une erreur, on utilise TryParse pour vÃ©rifier si la chaÃ®ne de caractÃ¨re peut se convertirÂ au type dÃ©sirÃ© Type implicite et explicite Jusquâ€™Ã  maintenant, on a vu diffÃ©rents types explicites qui existent, par exemple : int, double, bool, string, etc. Depuis C# 3, C# permet dâ€™utiliser un type implicite. De ce fait, le programmeur demande Ã  C# de trouver le type associÃ© Ã  la variable.\nOn utilise le mot-clÃ© var pour dÃ©finir une variable implicite\nvar nombre = 6; // C# sait que c'est un int var content = true; // C# sait que c'est un boolÃ©en varÂ salutation = \"Bonjour\"; // sait que c'est un string Par contre, si on dÃ©clare une variable implicite sans lâ€™initialiser, C# donnera une erreur de compilation.\n// âŒ Erreur de compilation : \"Implicitly-typed variables must be initialized\" var message; // âœ… Correct : Le compilateur voit \"Bonjour\" et dÃ©duit que 'message' est de type string var message = \"Bonjour\"; Avec string message;, vous dites explicitement au compilateur : â€œRÃ©serve une boÃ®te pour du texteâ€. Avec var message;, vous ne lui donnez aucun indice. Le compilateur refuse de deviner ou de laisser la variable â€œsans typeâ€ jusquâ€™Ã  plus tard.*",
    "description": "1. DÃ©claration de variables et types de donnÃ©es C# est un langage fortement typÃ©, ce qui signifie que chaque variable doit Ãªtre dÃ©clarÃ©e avec un type spÃ©cifique. Voici quelques types de base :\nint age = 25; // Entier double price = 19.99; // Nombre Ã  virgule flottante char grade = 'A'; // CaractÃ¨re unique string name = \"John\"; // ChaÃ®ne de caractÃ¨res bool isActive = true; // BoolÃ©en (vrai ou faux) Une variable peut Ãªtre dÃ©clarÃ©e et initialisÃ©e avec la mÃªme instruction.\nstring salutation = \"Bonjour tout le monde!\";",
    "tags": [],
    "title": "Variables",
    "uri": "/420-413/variables/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Les opÃ©rateurs OpÃ©rateurs ArithmÃ©tiques en C# OpÃ©rateur Nom Description Exemple RÃ©sultat + Addition Somme de deux valeurs int x = 10 + 5; 15 - Soustraction DiffÃ©rence entre deux valeurs int x = 20 - 8; 12 * Multiplication Produit de deux valeurs double x = 5.5 * 2; 11.0 / Division Quotient de la division int x = 10 / 3; 3 (Entier) % Modulo Reste de la division entiÃ¨re int x = 10 % 3; 1 OpÃ©rateurs dâ€™incrÃ©mentation et de dÃ©crÃ©mentation OpÃ©rateur Nom Position Description Exemple RÃ©sultat (x) ++x PrÃ©-incrÃ©mentation Avant IncrÃ©mente, puis retourne la valeur int y = ++x; AugmentÃ© de 1 x++ Post-incrÃ©mentation AprÃ¨s Retourne la valeur, puis incrÃ©mente int y = x++; AugmentÃ© de 1 --x PrÃ©-dÃ©crÃ©mentation Avant DÃ©crÃ©mente, puis retourne la valeur int y = --x; DiminuÃ© de 1 x-- Post-dÃ©crÃ©mentation AprÃ¨s Retourne la valeur, puis dÃ©crÃ©mente int y = x--; DiminuÃ© de 1 Pourquoi la position est-elle importante ? La diffÃ©rence rÃ©side dans la valeur retournÃ©e par lâ€™expression au moment de lâ€™exÃ©cution :\nPrÃ© (++x) : Câ€™est le mode â€œMise Ã  jour dâ€™abordâ€. On change la valeur et on utilise le nouveau rÃ©sultat tout de suite. Post (x++) : Câ€™est le mode â€œUtilisation dâ€™abordâ€. On utilise la valeur actuelle dans le calcul, et lâ€™ajout de 1 se fait juste aprÃ¨s. Exemple de comparaison : int a = 10; int b = 10; int resultatA = ++a; // a devient 11, puis resultatA reÃ§oit 11. int resultatB = b++; // resultatB reÃ§oit 10, puis b devient 11. // Ã€ la fin : // a est 11, resultatA est 11 // b est 11, resultatB est 10 OpÃ©rateurs Logiques en C# Les opÃ©rateurs logiques permettent de tester plusieurs conditions Ã  la fois et retournent toujours une valeur boolÃ©enne (true ou false).\nOpÃ©rateur Nom Description Exemple \u0026\u0026 ET (AND) Retourne true si toutes les conditions sont vraies. (age \u003e= 18 \u0026\u0026 aPermis) || OU (OR) Retourne true si au moins une des conditions est vraie. (estSamedi || estDimanche) ! NON (NOT) Inverse lâ€™Ã©tat logique (vrai devient faux et inversement). !estConnecte ^ OU exclusif (XOR) Retourne true si une seule des deux conditions est vraie. (estOptionA ^ estOptionB) Tables de vÃ©ritÃ© (RÃ©sumÃ©) A B A \u0026\u0026 B A || B A ^ B !A true true true true false false true false false true true false false true false true true true false false false false false true Le concept de â€œCourt-circuitâ€ (Short-circuit) Les opÃ©rateurs \u0026\u0026 et || sont dits â€œintelligentsâ€ en C# :\nAvec \u0026\u0026 : Si la premiÃ¨re condition est fausse, C# nâ€™Ã©value mÃªme pas la deuxiÃ¨me (car le rÃ©sultat sera forcÃ©ment faux). Avec || : Si la premiÃ¨re condition est vraie, C# sâ€™arrÃªte lÃ  (car le rÃ©sultat sera forcÃ©ment vrai). Astuce : Placez toujours la condition la plus â€œlourdeâ€ ou risquÃ©e en deuxiÃ¨me position pour profiter du court-circuit.\nOpÃ©rateurs logiques : Court-circuit vs Ã‰valuation complÃ¨te Il existe deux variantes pour les opÃ©rateurs ET et OU. La diffÃ©rence rÃ©side dans la gestion de la deuxiÃ¨me condition.\nType ET OU Comportement Court-circuit \u0026\u0026 || Ã‰value la 2e condition uniquement si nÃ©cessaire. Ã‰valuation complÃ¨te \u0026 | Ã‰value toujours les deux conditions, sans exception. Pourquoi utiliser lâ€™Ã©valuation complÃ¨te (\u0026 et |) ? Lâ€™utilisation de \u0026 et | sur des boolÃ©ens est plus rare, mais elle est nÃ©cessaire si la deuxiÃ¨me condition contient un effet de bord (une action qui doit absolument se produire, comme une incrÃ©mentation ou lâ€™appel dâ€™une mÃ©thode).\nExemple de diffÃ©rence : int compteur = 0; bool conditionFausse = false; // Cas 1 : Court-circuit (\u0026\u0026) if (conditionFausse \u0026\u0026 ++compteur \u003e 0) { /* ... */ } Console.WriteLine(compteur); // Affiche 0 (le ++ n'a jamais Ã©tÃ© exÃ©cutÃ©) // Cas 2 : Ã‰valuation complÃ¨te (\u0026) if (conditionFausse \u0026 ++compteur \u003e 0) { /* ... */ } Console.WriteLine(compteur); // Affiche 1 (le ++ a Ã©tÃ© exÃ©cutÃ© malgrÃ© le faux) OpÃ©rateurs de comparaison en C# Les opÃ©rateurs de comparaison permettent de vÃ©rifier la relation entre deux expressions. Le rÃ©sultat est toujours une valeur boolÃ©enne (true ou false).\nOpÃ©rateur Nom Description Exemple RÃ©sultat == Ã‰galitÃ© true si les valeurs sont identiques 5 == 5 true != InÃ©galitÃ© true si les valeurs sont diffÃ©rentes 5 != 3 true \u003e Plus grand que true si la gauche est strictement supÃ©rieure 10 \u003e 5 true \u003c Plus petit que true si la gauche est strictement infÃ©rieure 2 \u003c 1 false \u003e= Plus grand ou Ã©gal true si la gauche est supÃ©rieure ou Ã©gale 5 \u003e= 5 true \u003c= Plus petit ou Ã©gal true si la gauche est infÃ©rieure ou Ã©gale 4 \u003c= 3 false Confusion entre = et == Câ€™est lâ€™erreur la plus frÃ©quente chez les dÃ©butants :\n= est lâ€™opÃ©rateur dâ€™assignation (on donne une valeur Ã  une variable). == est lâ€™opÃ©rateur de comparaison (on vÃ©rifie si deux valeurs sont Ã©gales). Comparaison de chaÃ®nes de caractÃ¨res (string) En C#, lâ€™opÃ©rateur == fonctionne pour comparer le contenu des chaÃ®nes de caractÃ¨res. Attention : la comparaison est sensible Ã  la casse.\nstring nomUn = \"Bob\"; string nomDeux = \"bob\"; bool sontEgaux = (nomUn == nomDeux); // RÃ©sultat: false",
    "description": "Les opÃ©rateurs OpÃ©rateurs ArithmÃ©tiques en C# OpÃ©rateur Nom Description Exemple RÃ©sultat + Addition Somme de deux valeurs int x = 10 + 5; 15 - Soustraction DiffÃ©rence entre deux valeurs int x = 20 - 8; 12 * Multiplication Produit de deux valeurs double x = 5.5 * 2; 11.0 / Division Quotient de la division int x = 10 / 3; 3 (Entier) % Modulo Reste de la division entiÃ¨re int x = 10 % 3; 1 OpÃ©rateurs dâ€™incrÃ©mentation et de dÃ©crÃ©mentation OpÃ©rateur Nom Position Description Exemple RÃ©sultat (x) ++x PrÃ©-incrÃ©mentation Avant IncrÃ©mente, puis retourne la valeur int y = ++x; AugmentÃ© de 1 x++ Post-incrÃ©mentation AprÃ¨s Retourne la valeur, puis incrÃ©mente int y = x++; AugmentÃ© de 1 --x PrÃ©-dÃ©crÃ©mentation Avant DÃ©crÃ©mente, puis retourne la valeur int y = --x; DiminuÃ© de 1 x-- Post-dÃ©crÃ©mentation AprÃ¨s Retourne la valeur, puis dÃ©crÃ©mente int y = x--; DiminuÃ© de 1 Pourquoi la position est-elle importante ? La diffÃ©rence rÃ©side dans la valeur retournÃ©e par lâ€™expression au moment de lâ€™exÃ©cution :",
    "tags": [],
    "title": "OpÃ©rateurs",
    "uri": "/420-413/operateurs/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "1. Structures Conditionnelles 1.1 If-Else Similitudes avec Java : La syntaxe de base est identique.\n// Calcul de rabais selon la quantitÃ© et le montant int quantite = 15; double montantTotal = 250.50; double rabais = 0.0; if (quantite \u003e= 20 \u0026\u0026 montantTotal \u003e= 500) { rabais = 0.20; // 20% pour commandes importantes } else if (quantite \u003e= 10 || montantTotal \u003e= 200) { rabais = 0.10; // 10% pour commandes moyennes } else { rabais = 0.0; // Pas de rabais } double montantFinal = montantTotal * (1 - rabais); Console.WriteLine($\"Montant final: {montantFinal} $\"); âœ… Bonne pratique - Accolades obligatoires\nint stock = 5; int quantite = 10; // âœ… BIEN - Toujours utiliser des accolades if (quantite \u003e stock) { Console.WriteLine(\"Stock insuffisant\"); } // âŒ Ã‰VITER - MÃªme si syntaxiquement valide if (quantite \u003e stock) Console.WriteLine(\"Stock insuffisant\"); 1.2 OpÃ©rateur Ternaire Identique Ã  Java, mais C# encourage son utilisation judicieuse.\n// Calcul de frais d'expÃ©dition // Calcul des frais d'expÃ©dition double montantCommande = 45.00; double fraisExpedition = montantCommande \u003e= 50 ? 0.0 : 5.99; Console.WriteLine($\"Frais d'expÃ©dition : {fraisExpedition:C}\"); // DÃ©termination du statut de paiement int joursRetard = 15; string statutPaiement = joursRetard \u003e 0 ? \"En retard\" : \"Ã€ jour\"; Console.WriteLine($\"Statut : {statutPaiement}\"); âœ… Bonne pratique - Ternaires imbriquÃ©s\nint noteExamen = 85; // âœ… Acceptable pour des cas simples (Logique linÃ©aire) string mention = noteExamen \u003e= 90 ? \"A\" : noteExamen \u003e= 80 ? \"B\" : noteExamen \u003e= 70 ? \"C\" : noteExamen \u003e= 60 ? \"D\" : \"F\"; Console.WriteLine($\"RÃ©sultat : {mention}\"); // âŒ Ã€ Ã‰VITER - Trop complexe, rend le dÃ©bogage difficile int heuresTravaillees = 45; int heuresSupplementaires = 5; bool estWeekend = true; // Cette structure imbriquÃ©e est une \"dette technique\" immÃ©diate double tauxHoraire = heuresTravaillees \u003e 40 ? (estWeekend ? 30.0 : 25.0) : (heuresSupplementaires \u003e 0 ? 22.0 : 20.0); // Difficile Ã  lire et Ã  maintenir ! âœ… Bonne pratique - Assignation conditionnelle simple\nint articlesDansPanier = 5; double prixArticle = 19.99; // Rabais de volume (Logique dÃ©gressive) double prixUnitaire = articlesDansPanier \u003e= 10 ? prixArticle * 0.85 : articlesDansPanier \u003e= 5 ? prixArticle * 0.95 : prixArticle; double coutTotal = articlesDansPanier * prixUnitaire; // Utilisation du symbole $ au lieu du formatage automatique :C Console.WriteLine($\"Prix unitaire : {prixUnitaire} $, Total : {coutTotal} $\"); 1.3 Switch Statement DiffÃ©rence majeure avec Java : Pas de â€œfall-throughâ€ implicite en C#.\nint jour = 3; switch (jour) { case 1: Console.WriteLine(\"Lundi\"); break; // break obligatoire case 2: Console.WriteLine(\"Mardi\"); break; case 3: Console.WriteLine(\"Mercredi\"); break; case 4: Console.WriteLine(\"Jeudi\"); break; case 5: Console.WriteLine(\"Vendredi\"); break; default: Console.WriteLine(\"Weekend ou invalide\"); break; } Fall-through explicite en C#\nint jour = 6; switch (jour) { case 6: case 7: Console.WriteLine(\"Weekend\"); break; // Un seul break pour les deux cas case 1: case 2: case 3: case 4: case 5: Console.WriteLine(\"Jour de semaine\"); break; default: Console.WriteLine(\"Jour invalide\"); break; } âœ… Bonne pratique - Switch avec char et string\n// Switch avec char char noteLettre = 'B'; switch (noteLettre) { case 'A': Console.WriteLine(\"Excellent\"); break; case 'B': Console.WriteLine(\"TrÃ¨s bien\"); break; case 'C': Console.WriteLine(\"Bien\"); break; default: Console.WriteLine(\"Ã€ amÃ©liorer\"); break; } // Switch avec string string commande = \"start\"; switch (commande) { case \"start\": Console.WriteLine(\"DÃ©marrage...\"); break; case \"stop\": Console.WriteLine(\"ArrÃªt...\"); break; case \"pause\": Console.WriteLine(\"Pause...\"); break; default: Console.WriteLine(\"Commande inconnue\"); break; } 1.4 Switch Expression (C# 8.0+) NouveautÃ© C# - Nâ€™existe pas en Java (avant Java 14)\n// Syntaxe concise et fonctionnelle int numeroDuJour = 3; string nomJour = numeroDuJour switch { 1 =\u003e \"Lundi\", 2 =\u003e \"Mardi\", 3 =\u003e \"Mercredi\", 4 =\u003e \"Jeudi\", 5 =\u003e \"Vendredi\", 6 =\u003e \"Weekend\", 7 =\u003e \"Weekend\", _ =\u003e \"Invalide\" }; Console.WriteLine(nomJour); âœ… Bonne pratique - Switch expression pour calculer des valeurs\n// Utilisation de valeurs discrÃ¨tes (cas prÃ©cis) int numeroJour = 3; string typeJour = numeroJour switch { 1 or 2 =\u003e \"DÃ©but de semaine\", 3 or 4 =\u003e \"Milieu de semaine\", 5 =\u003e \"Fin de semaine\", 6 or 7 =\u003e \"Weekend\", _ =\u003e \"Invalide\" }; Console.WriteLine(typeJour); // Pour les comparaisons de ranges, utiliser if-else iint age = 25; double prixBillet; if (age \u003c 5) prixBillet = 0.0; else if (age \u003c 18) prixBillet = 8.50; else if (age \u003c 65) prixBillet = 12.00; else prixBillet = 9.00; Console.WriteLine($\"Prix du billet : {prixBillet} $\"); âœ… Bonne pratique - Switch expression avec valeurs multiples\nchar lettre = 'e'; // âœ… Version optimisÃ©e (C# 9+) : Plus lisible et moins de rÃ©pÃ©titions bool estUneVoyelle = lettre switch { 'a' or 'e' or 'i' or 'o' or 'u' or 'A' or 'E' or 'I' or 'O' or 'U' =\u003e true, _ =\u003e false }; Console.WriteLine($\"Est une voyelle : {estUneVoyelle}\"); âœ… Bonne pratique - Quand utiliser switch vs if-else\nint note = 85; // La switch expression agit comme une \"table de correspondance\" string mention = note switch { \u003e= 90 =\u003e \"A\", \u003e= 80 =\u003e \"B\", \u003e= 70 =\u003e \"C\", \u003e= 60 =\u003e \"D\", _ =\u003e \"F\" // Le discard (_) est obligatoire pour couvrir tous les cas }; Console.WriteLine($\"Mention obtenue : {mention}\"); double solde = 1500.50; int nombreTransactions = 25; bool aUnDecouvert = false; double fraisMensuels = 0.0; // Logique dÃ©cisionnelle basÃ©e sur plusieurs critÃ¨res if (solde \u003e= 5000 \u0026\u0026 nombreTransactions \u003e 50) { fraisMensuels = 0.0; // Compte premium gratuit } else if (solde \u003e= 1000 || nombreTransactions \u003c= 10) { fraisMensuels = 5.0; // Frais rÃ©duits (fidÃ©litÃ© ou faible usage) } else if (aUnDecouvert) { fraisMensuels = 25.0; // PÃ©nalitÃ© pour dÃ©couvert } else { fraisMensuels = 12.0; // Frais standards } // Utilisation du format monÃ©taire :C (trÃ¨s pratique en .NET 8) Console.WriteLine($\"Frais mensuels : {fraisMensuels:C}\"); 2. Structures ItÃ©ratives 2.1 Boucle While Identique Ã  Java.\nint i = 0; while (i \u003c 5) { Console.WriteLine(i); i++; } âœ… Bonne pratique - While avec condition claire\nint somme = 0; int nombre = 1; while (somme \u003c 100) { somme += number; nombre++; } Console.WriteLine($\"Somme: {somme}, Dernier nombre: {nombre}\"); âœ… Bonne pratique - Ã‰viter les boucles infinies\n// âŒ DANGEREUX // while (true) // { // // Sans condition de sortie claire // } // âœ… MIEUX - Avec limite de sÃ©curitÃ© int maxTentatives = 10; int tentatives = 0; bool succes = false; // âœ… Utilisation d'une boucle While avec deux conditions de sortie while (tentatives \u003c maxTentatives \u0026\u0026 !succes) { Console.Write(\"Entrez un nombre entre 1 et 10 : \"); string saisie = Console.ReadLine(); // âœ… int.TryParse Ã©vite que le programme plante si l'utilisateur tape du texte // Le \"out int nombre\" dÃ©clare la variable uniquement si la conversion rÃ©ussit if (int.TryParse(saisie, out int nombre) \u0026\u0026 nombre \u003e= 1 \u0026\u0026 nombre \u003c= 10) { succes = true; Console.WriteLine(\"Valide !\"); } else { tentatives++; Console.WriteLine($\"Invalide. Tentatives restantes : {maxTentatives - tentatives}\"); } } 2.2 Boucle Do-While Identique Ã  Java.\nint i = 0; do { Console.WriteLine(i); i++; } while (i \u003c 5); âœ… Bonne pratique - Utiliser do-while pour validation Utilisation pour la validation de saisie : Cette structure garantit que lâ€™utilisateur verra le message au moins une fois.\nint nombre; string saisie; do { Console.Write(\"Entrez un nombre positif : \"); saisie = Console.ReadLine(); // On boucle tant que la saisie n'est pas un entier OU que le nombre est \u003c= 0 } while (!int.TryParse(saisie, out nombre) || nombre \u003c= 0); Console.WriteLine($\"Vous avez entrÃ© : {nombre}\"); Exemple - Menu simple\nint choix; do { Console.WriteLine(\"\\n--- MENU ---\"); Console.WriteLine(\"1. Addition\"); Console.WriteLine(\"2. Soustraction\"); Console.WriteLine(\"3. Quitter\"); Console.Write(\"Votre choix : \"); //si l'utilisateur ne tape pas un chiffre et que la conversion ne fonction pas, choix va avoir la valeur par dÃ©faut 0 int.TryParse(Console.ReadLine(), out choix); switch (choix) { case 1: Console.WriteLine(\"Addition sÃ©lectionnÃ©e\"); break; case 2: Console.WriteLine(\"Soustraction sÃ©lectionnÃ©e\"); break; case 3: Console.WriteLine(\"Au revoir !\"); break; default: Console.WriteLine(\"Choix invalide, veuillez recommencer.\"); break; } // La boucle continue tant que l'utilisateur n'a pas choisi de quitter (3) } while (choix != 3); 2.3 Boucle For Identique Ã  Java.\nfor (int i = 0; i \u003c 10; i++) { Console.WriteLine(i); } âœ… Bonne pratique - DÃ©clarer la variable dans la boucle\n// âœ… BIEN - PortÃ©e limitÃ©e for (int i = 0; i \u003c 10; i++) { Console.WriteLine(i); } // i n'existe plus ici // âŒ Ã‰VITER - PortÃ©e trop large int j; for (j = 0; j \u003c 10; j++) { Console.WriteLine(j); } // j existe encore ici ItÃ©rer sur un tableau\nLa boucle for est privilÃ©giÃ©e lorsque lâ€™indexation est nÃ©cessaire ou pour manipuler des structures multidimensionnelles.\nint[] nombres = { 10, 20, 30, 40, 50 }; // Calcul de la somme int somme = 0; for (int i = 0; i \u003c nombres.Length; i++) { somme += nombres[i]; } Console.WriteLine($\"Somme : {somme}\"); // Recherche d'un Ã©lÃ©ment int valeurRecherchee = 30; int indexTrouve = -1; for (int i = 0; i \u003c nombres.Length; i++) { if (nombres[i] == valeurRecherchee) { indexTrouve = i; break; // On quitte la boucle dÃ¨s qu'on a trouvÃ© } } if (indexTrouve != -1) { Console.WriteLine($\"TrouvÃ© Ã  l'index {indexTrouve}\"); } âœ… Bonne pratique - Ã‰viter de modifier le compteur dans la boucle\nint[] values = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // âŒ MAUVAIS - Difficile Ã  comprendre for (int i = 0; i \u003c values.Length; i++) { Console.WriteLine(values[i]); if (values[i] % 2 == 0) i++; // Modifie le flux de contrÃ´le - confus! } // âœ… MIEUX - Intention claire for (int i = 0; i \u003c values.Length; i++) { Console.WriteLine(values[i]); if (values[i] % 2 == 0 \u0026\u0026 i + 1 \u003c values.Length) { i++; // Saute le prochain si pair } } Boucles imbriquÃ©es - Tableaux 2D\nint[,] matrice = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; // Affichage de la matrice ligne par ligne for (int ligne = 0; ligne \u003c 3; ligne++) { for (int col = 0; col \u003c 3; col++) { Console.Write($\"{matrice[ligne, col]} \"); } Console.WriteLine(); // Saut de ligne aprÃ¨s chaque rangÃ©e } 2.4 Boucle Foreach DiffÃ©rence avec Java : Mot-clÃ© foreach au lieu de for. Câ€™est lâ€™outil le plus sÃ»r car il Ã©limine les erreurs de dÃ©passement dâ€™index (le fameux IndexOutOfRangeException).\n// Java: for (String name : names) // C#: string[] noms = { \"Alice\", \"Bob\", \"Charlie\" }; foreach (string nom in noms) { Console.WriteLine(nom); } âœ… Bonne pratique - PrÃ©fÃ©rer foreach quand appropriÃ©\niint[] nombres = { 1, 2, 3, 4, 5 }; // âœ… BIEN - Plus lisible, idÃ©al pour le calcul ou l'affichage int somme = 0; foreach (int n in nombres) { somme += n; } Console.WriteLine($\"Somme : {somme}\"); // âŒ Ã€ Ã‰VITER - Sauf si vous avez besoin de l'index 'i' (ex: modification) int sommeAlternative = 0; for (int i = 0; i \u003c nombres.Length; i++) { sommeAlternative += nombres[i]; } Exemples pratiques avec foreach\n// Affichage de prix formatÃ©s (Symbole $ au lieu de :C) double[] prixUnitaires = { 19.99, 29.99, 39.99, 49.99 }; foreach (double p in prixUnitaires) { Console.WriteLine($\"Prix : {p} $\"); } // Comptage avec condition (Filtrage simple) int[] scores = { 45, 78, 92, 65, 88, 54, 91 }; int reussites = 0; foreach (int s in scores) { if (s \u003e= 60) { reussites++; } } Console.WriteLine($\"{reussites} Ã©tudiants ont rÃ©ussi.\"); // Recherche du maximum int[] valeurs = { 23, 67, 12, 89, 45, 34 }; int maximum = valeurs[0]; foreach (int v in valeurs) { if (v \u003e maximum) { maximum = v; } } Console.WriteLine($\"Valeur maximale : {maximum}\"); âš ï¸ Important - Foreach est read-only\nIl est impossible de modifier directement lâ€™Ã©lÃ©ment de la collection Ã  lâ€™intÃ©rieur dâ€™un foreach. Le compilateur .NET 8 bloquera le code.\nint[] chiffres = { 1, 2, 3 }; // âŒ ERREUR DE COMPILATION - On ne peut pas modifier 'c' /* foreach (int c in chiffres) { c = c * 2; } */ // âœ… SOLUTION - Utiliser 'for' pour modifier le contenu du tableau for (int i = 0; i \u003c chiffres.Length; i++) { chiffres[i] = chiffres[i] * 2; } // VÃ©rification (Lecture simple via foreach) foreach (int c in chiffres) { Console.WriteLine(c); // Affiche : 2, 4, 6 } Foreach avec tableaux multidimensionnels\nint[,] matrice = { { 1, 2, 3 }, { 4, 5, 6 } }; // Foreach parcourt automatiquement toutes les lignes et colonnes foreach (int valeur in matrice) { Console.Write($\"{valeur} \"); } // RÃ©sultat : 1 2 3 4 5 6 3. Instructions de ContrÃ´le de Flux 3.1 Break Identique Ã  Java - Sort de la boucle ou du switch.\n// Recherche d'un Ã©lÃ©ment dans un tableau int[] nombres = { 5, 12, 8, 3, 19, 7 }; int cible = 19; int position = -1; for (int i = 0; i \u003c nombres.Length; i++) { if (nombres[i] == cible) { position = i; break; // âœ… SuccÃ¨s : On arrÃªte de chercher pour Ã©conomiser des ressources } } if (position != -1) { Console.WriteLine($\"TrouvÃ© Ã  la position {position}\"); } else { Console.WriteLine(\"L'Ã©lÃ©ment n'a pas Ã©tÃ© trouvÃ©.\"); } Break dans switch\nint operation = 2; int nombre1 = 10; int nombre2 = 5; int resultat = 0; switch (operation) { case 1: resultat = nombre1 + nombre2; break; // Sort du switch aprÃ¨s l'addition case 2: resultat = nombre1 - nombre2; break; // Sort du switch aprÃ¨s la soustraction case 3: resultat = nombre1 * nombre2; break; // Sort du switch aprÃ¨s la multiplication default: Console.WriteLine(\"OpÃ©ration invalide\"); break; } Console.WriteLine($\"RÃ©sultat : {resultat}\"); 3.2 Continue Identique Ã  Java - Passe Ã  lâ€™itÃ©ration suivante.\n// Afficher seulement les nombres impairs for (int i = 0; i \u003c 10; i++) { if (i % 2 == 0) continue; // Saute les nombres pairs Console.WriteLine(i); } // Affiche: 1, 3, 5, 7, 9 Continue pour filtrage simple\nint[] notes = { 45, 78, 0, 92, -1, 65, 88 }; // âœ… BIEN - Utilisation de continue pour filtrer (Style \"Guard Clause\") foreach (int note in notes) { // Si la note est hors limite, on l'ignore immÃ©diatement if (note \u003c 0 || note \u003e 100) continue; // Le code principal reste ici, sans Ãªtre cachÃ© dans un bloc 'if' Console.WriteLine($\"Note valide : {note}\"); } // âŒ MOINS LISIBLE - L'imbrication inutile (Arrow Code) foreach (int note in notes) { if (note \u003e= 0 \u0026\u0026 note \u003c= 100) { // Imaginez si vous aviez 10 conditions... // Le code finirait par Ãªtre trÃ¨s dÃ©calÃ© vers la droite. Console.WriteLine($\"Note valide : {note}\"); } } Exemple - Somme conditionnelle\nint[] nombres = { 5, -3, 12, 0, 8, -7, 15 }; int sommePositifs = 0; foreach (int n in nombres) { // Si le nombre est nÃ©gatif ou nul, on passe directement au suivant if (n \u003c= 0) continue; // On ne traite que les valeurs qui nous intÃ©ressent sommePositifs += n; } Console.WriteLine($\"Somme des nombres positifs : {sommePositifs}\"); 4. Gestion des Exceptions 4.1 Try-Catch-Finally TrÃ¨s similaire Ã  Java.\ntry { int result = 10 / 0; // GÃ©nÃ¨re une exception } catch (DivideByZeroException ex) { Console.WriteLine($\"Erreur: {ex.Message}\"); } catch (Exception ex) { Console.WriteLine($\"Erreur gÃ©nÃ©rale: {ex.Message}\"); } finally { Console.WriteLine(\"Toujours exÃ©cutÃ©\"); }",
    "description": "1. Structures Conditionnelles 1.1 If-Else Similitudes avec Java : La syntaxe de base est identique.\n// Calcul de rabais selon la quantitÃ© et le montant int quantite = 15; double montantTotal = 250.50; double rabais = 0.0; if (quantite \u003e= 20 \u0026\u0026 montantTotal \u003e= 500) { rabais = 0.20; // 20% pour commandes importantes } else if (quantite \u003e= 10 || montantTotal \u003e= 200) { rabais = 0.10; // 10% pour commandes moyennes } else { rabais = 0.0; // Pas de rabais } double montantFinal = montantTotal * (1 - rabais); Console.WriteLine($\"Montant final: {montantFinal} $\"); âœ… Bonne pratique - Accolades obligatoires",
    "tags": [],
    "title": "Structures de contrÃ´les",
    "uri": "/420-413/structures_de_controles/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "En C#, on distingue deux grandes familles pour stocker des groupes de donnÃ©es : les Tableaux (taille fixe) et les Collections (taille dynamique).\nLes tableaux (Array) Un tableau est une structure de donnÃ©es de taille fixe stockÃ©e de maniÃ¨re contiguÃ« en mÃ©moire.\n1. DÃ©claration et initialisation Syntaxe de base // DÃ©claration d'un tableau int[] nombres; // DÃ©claration avec initialisation de la taille int[] nombres = new int[5]; // DÃ©claration avec initialisation des valeurs int[] nombres = new int[] { 10, 20, 30, 40, 50 }; // Syntaxe courte (recommandÃ©e) int[] nombres = { 10, 20, 30, 40, 50 }; Le piÃ¨ge de lâ€™immuabilitÃ© : Si vous crÃ©ez int[] tab = new int[3], vous ne pourrez jamais y mettre un 4e Ã©lÃ©ment. Pour â€œagrandirâ€ un tableau, il faut en crÃ©er un nouveau, copier les donnÃ©es, puis ajouter le nouvel Ã©lÃ©ment. Câ€™est pourquoi nous utilisons les Collections pour les donnÃ©es dynamiques.\nPoints importants Ã  retenir Les tableaux ont une taille fixe dÃ©finie Ã  la crÃ©ation Les collections (comme List\u003cT\u003e) peuvent changer de taille dynamiquement Les propriÃ©tÃ©s en C# (comme .Length, .Count) nâ€™ont pas de parenthÃ¨ses C# offre LINQ (Language Integrated Query) pour manipuler les collections facilement Les collections sont dans le namespace System.Collections.Generic 2. Exemples pratiques Exemple 1 : Gestion des notes dâ€™Ã©tudiants using System; class GestionNotes { static void Main() { // DÃ©claration d'un tableau de notes double[] notesEtudiants = { 85.5, 92.0, 78.5, 88.0, 95.5 }; // Afficher toutes les notes Console.WriteLine(\"=== Notes des Ã©tudiants ===\"); for (int i = 0; i \u003c notesEtudiants.Length; i++) { Console.WriteLine($\"Ã‰tudiant {i + 1}: {notesEtudiants[i]}%\"); } // Calculer la moyenne double somme = 0; foreach (double note in notesEtudiants) { somme += note; } double moyenne = somme / notesEtudiants.Length; Console.WriteLine($\"\\nMoyenne de la classe: {moyenne:F2}%\"); } } Sortie :\n=== Notes des Ã©tudiants ===\rÃ‰tudiant 1: 85.5%\rÃ‰tudiant 2: 92%\rÃ‰tudiant 3: 78.5%\rÃ‰tudiant 4: 88%\rÃ‰tudiant 5: 95.5%\rMoyenne de la classe: 87.90% Exemple 2 : Tableau de chaÃ®nes de caractÃ¨res using System; class GestionPrenoms { static void Main() { // Tableau de prÃ©noms string[] prenoms = { \"Alice\", \"Bernard\", \"Catherine\", \"David\", \"Ã‰milie\" }; // Afficher les prÃ©noms avec leur longueur Console.WriteLine(\"=== Liste des prÃ©noms ===\"); foreach (string prenom in prenoms) { Console.WriteLine($\"{prenom} - {prenom.Length} lettres\"); } // Trouver le prÃ©nom le plus long string prenomPlusLong = prenoms[0]; foreach (string prenom in prenoms) { if (prenom.Length \u003e prenomPlusLong.Length) { prenomPlusLong = prenom; } } Console.WriteLine($\"\\nPrÃ©nom le plus long: {prenomPlusLong}\"); } } 3. Tableaux multidimensionnels Tableau Ã  deux dimensions (matrice) using System; class Matrice { static void Main() { // DÃ©claration d'une matrice 3x3 int[,] matrice = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; // Affichage de la matrice Console.WriteLine(\"=== Matrice 3x3 ===\"); for (int ligne = 0; ligne \u003c 3; ligne++) { for (int colonne = 0; colonne \u003c 3; colonne++) { Console.Write($\"{matrice[ligne, colonne]}\\t\"); } Console.WriteLine(); } // Calculer la somme de chaque ligne Console.WriteLine(\"\\n=== Somme par ligne ===\"); for (int ligne = 0; ligne \u003c 3; ligne++) { int somme = 0; for (int colonne = 0; colonne \u003c 3; colonne++) { somme += matrice[ligne, colonne]; } Console.WriteLine($\"Ligne {ligne + 1}: {somme}\"); } } } Tableau dentelÃ© (jagged array) using System; class TableauDentele { static void Main() { // Tableau oÃ¹ chaque ligne peut avoir une longueur diffÃ©rente int[][] notesParCours = new int[3][]; notesParCours[0] = new int[] { 85, 90, 78 }; // 3 notes notesParCours[1] = new int[] { 92, 88 }; // 2 notes notesParCours[2] = new int[] { 95, 87, 91, 89 }; // 4 notes // Affichage Console.WriteLine(\"=== Notes par cours ===\"); for (int cours = 0; cours \u003c notesParCours.Length; cours++) { Console.Write($\"Cours {cours + 1}: \"); foreach (int note in notesParCours[cours]) { Console.Write($\"{note} \"); } Console.WriteLine(); } } } 4. MÃ©thodes utiles pour les tableaux using System; class MethodesTableaux { static void Main() { int[] nombres = { 45, 12, 78, 34, 90, 23, 67 }; // Longueur du tableau Console.WriteLine($\"Nombre d'Ã©lÃ©ments: {nombres.Length}\"); // Trier le tableau Array.Sort(nombres); Console.WriteLine(\"\\nTableau triÃ©:\"); AfficherTableau(nombres); // Inverser l'ordre Array.Reverse(nombres); Console.WriteLine(\"\\nTableau inversÃ©:\"); AfficherTableau(nombres); // Rechercher un Ã©lÃ©ment int valeurRecherchee = 78; int index = Array.IndexOf(nombres, valeurRecherchee); Console.WriteLine($\"\\nIndex de {valeurRecherchee}: {index}\"); // Copier un tableau int[] copie = new int[nombres.Length]; Array.Copy(nombres, copie, nombres.Length); Console.WriteLine(\"\\nCopie du tableau:\"); AfficherTableau(copie); } static void AfficherTableau(int[] tableau) { foreach (int nombre in tableau) { Console.Write($\"{nombre} \"); } Console.WriteLine(); } } Les Collections Les collections en C# offrent plus de flexibilitÃ© que les tableaux. Elles peuvent changer de taille dynamiquement et offrent des mÃ©thodes pratiques pour manipuler les donnÃ©es.\n1. List - La collection la plus utilisÃ©e Syntaxe de base using System; using System.Collections.Generic; class ExempleList { static void Main() { // CrÃ©ation d'une liste vide List fruits = new List(); // CrÃ©ation avec valeurs initiales List nombres = new List { 1, 2, 3, 4, 5 }; // Ajout d'Ã©lÃ©ments fruits.Add(\"Pomme\"); fruits.Add(\"Banane\"); fruits.Add(\"Orange\"); // Affichage Console.WriteLine(\"=== Liste de fruits ===\"); foreach (string fruit in fruits) { Console.WriteLine(fruit); } // Nombre d'Ã©lÃ©ments Console.WriteLine($\"\\nNombre de fruits: {fruits.Count}\"); } } Exemple 2 : Gestion dâ€™un inventaire simple using System; using System.Collections.Generic; class GestionInventaire { static void Main() { // CrÃ©ation de listes pour stocker les informations List nomsProduits = new List(); List prixProduits = new List(); List quantitesProduits = new List(); // Ajout de produits nomsProduits.Add(\"Ordinateur portable\"); prixProduits.Add(1299.99); quantitesProduits.Add(15); nomsProduits.Add(\"Souris sans fil\"); prixProduits.Add(29.99); quantitesProduits.Add(50); nomsProduits.Add(\"Clavier mÃ©canique\"); prixProduits.Add(149.99); quantitesProduits.Add(25); // Affichage de l'inventaire Console.WriteLine(\"=== INVENTAIRE ===\"); for (int i = 0; i \u003c nomsProduits.Count; i++) { Console.WriteLine($\"{nomsProduits[i]} - {prixProduits[i]:C} - QtÃ©: {quantitesProduits[i]}\"); } // Calculer la valeur totale de l'inventaire double valeurTotale = 0; for (int i = 0; i \u003c nomsProduits.Count; i++) { valeurTotale += prixProduits[i] * quantitesProduits[i]; } Console.WriteLine($\"\\nValeur totale de l'inventaire: {valeurTotale:C}\"); } } MÃ©thodes importantes de List using System; using System.Collections.Generic; class MethodesList { static void Main() { List etudiants = new List { \"Alice\", \"Bernard\", \"Catherine\", \"David\" }; // Add - Ajouter un Ã©lÃ©ment Ã  la fin etudiants.Add(\"Ã‰milie\"); // Insert - InsÃ©rer Ã  une position spÃ©cifique etudiants.Insert(1, \"FranÃ§ois\"); // Remove - Retirer un Ã©lÃ©ment spÃ©cifique etudiants.Remove(\"Bernard\"); // RemoveAt - Retirer Ã  un index spÃ©cifique etudiants.RemoveAt(0); // Contains - VÃ©rifier si un Ã©lÃ©ment existe bool existe = etudiants.Contains(\"Catherine\"); Console.WriteLine($\"Catherine est dans la liste: {existe}\"); // IndexOf - Trouver l'index d'un Ã©lÃ©ment int index = etudiants.IndexOf(\"David\"); Console.WriteLine($\"Index de David: {index}\"); // Clear - Vider la liste // etudiants.Clear(); // Sort - Trier la liste etudiants.Sort(); // Reverse - Inverser l'ordre etudiants.Reverse(); // Count - Nombre d'Ã©lÃ©ments Console.WriteLine($\"Nombre d'Ã©tudiants: {etudiants.Count}\"); // Affichage final Console.WriteLine(\"\\n=== Liste finale ===\"); foreach (string etudiant in etudiants) { Console.WriteLine(etudiant); } } } 2. Dictionary\u003cTKey, TValue\u003e - Paires clÃ©-valeur using System; using System.Collections.Generic; class ExempleDictionnaire { static void Main() { // CrÃ©ation d'un dictionnaire pour stocker des codes postaux Dictionary codesPostaux = new Dictionary(); // Ajout d'Ã©lÃ©ments codesPostaux.Add(\"MontrÃ©al\", \"H1A\"); codesPostaux.Add(\"QuÃ©bec\", \"G1A\"); codesPostaux.Add(\"Laval\", \"H7A\"); codesPostaux.Add(\"Gatineau\", \"J8T\"); // AccÃ¨s Ã  une valeur Console.WriteLine($\"Code postal de MontrÃ©al: {codesPostaux[\"MontrÃ©al\"]}\"); // VÃ©rifier si une clÃ© existe if (codesPostaux.ContainsKey(\"QuÃ©bec\")) { Console.WriteLine($\"Code postal de QuÃ©bec: {codesPostaux[\"QuÃ©bec\"]}\"); } // Parcourir le dictionnaire Console.WriteLine(\"\\n=== Tous les codes postaux ===\"); foreach (KeyValuePair paire in codesPostaux) { Console.WriteLine($\"{paire.Key}: {paire.Value}\"); } // Modifier une valeur codesPostaux[\"MontrÃ©al\"] = \"H2X\"; // Retirer un Ã©lÃ©ment codesPostaux.Remove(\"Gatineau\"); Console.WriteLine($\"\\nNombre de villes: {codesPostaux.Count}\"); } } Exemple pratique : SystÃ¨me de notes using System; using System.Collections.Generic; class SystemeNotes { static void Main() { // Dictionnaire: nom de l'Ã©tudiant -\u003e liste de notes Dictionary\u003e notesEtudiants = new Dictionary\u003e(); // Ajout des Ã©tudiants et leurs notes notesEtudiants.Add(\"Alice\", new List { 85.5, 92.0, 88.5 }); notesEtudiants.Add(\"Bernard\", new List { 78.0, 82.5, 80.0 }); notesEtudiants.Add(\"Catherine\", new List { 95.0, 93.5, 97.0 }); // Afficher les notes et moyennes Console.WriteLine(\"=== NOTES ET MOYENNES ===\\n\"); foreach (KeyValuePair\u003e etudiant in notesEtudiants) { string nom = etudiant.Key; List notes = etudiant.Value; Console.WriteLine($\"Ã‰tudiant: {nom}\"); Console.Write(\"Notes: \"); foreach (double note in notes) { Console.Write($\"{note}% \"); } // Calculer la moyenne double somme = 0; foreach (double note in notes) { somme += note; } double moyenne = somme / notes.Count; Console.WriteLine($\"\\nMoyenne: {moyenne:F2}%\\n\"); } } } 3. Queue - File dâ€™attente (FIFO) using System; using System.Collections.Generic; class ExempleQueue { static void Main() { // CrÃ©ation d'une file d'attente Queue fileAttente = new Queue(); // Enqueue - Ajouter Ã  la fin de la file fileAttente.Enqueue(\"Client 1\"); fileAttente.Enqueue(\"Client 2\"); fileAttente.Enqueue(\"Client 3\"); fileAttente.Enqueue(\"Client 4\"); Console.WriteLine($\"Nombre de clients: {fileAttente.Count}\"); // Peek - Voir le premier Ã©lÃ©ment sans le retirer string premier = fileAttente.Peek(); Console.WriteLine($\"Prochain client Ã  servir: {premier}\"); // Dequeue - Retirer et retourner le premier Ã©lÃ©ment Console.WriteLine(\"\\n=== Service des clients ===\"); while (fileAttente.Count \u003e 0) { string client = fileAttente.Dequeue(); Console.WriteLine($\"Servir: {client}\"); } Console.WriteLine($\"\\nClients restants: {fileAttente.Count}\"); } } 4. Stack - Pile (LIFO) using System; using System.Collections.Generic; class ExempleStack { static void Main() { // CrÃ©ation d'une pile Stack historiqueNavigation = new Stack(); // Push - Ajouter au sommet de la pile historiqueNavigation.Push(\"Page d'accueil\"); historiqueNavigation.Push(\"Page de recherche\"); historiqueNavigation.Push(\"Page de rÃ©sultats\"); historiqueNavigation.Push(\"Page de dÃ©tails\"); Console.WriteLine($\"Nombre de pages visitÃ©es: {historiqueNavigation.Count}\"); // Peek - Voir le sommet sans retirer string pageActuelle = historiqueNavigation.Peek(); Console.WriteLine($\"Page actuelle: {pageActuelle}\"); // Pop - Retirer et retourner l'Ã©lÃ©ment du sommet Console.WriteLine(\"\\n=== Navigation arriÃ¨re ===\"); while (historiqueNavigation.Count \u003e 0) { string page = historiqueNavigation.Pop(); Console.WriteLine($\"Retour Ã : {page}\"); } } } 5. HashSet - Ensemble (pas de doublons) using System; using System.Collections.Generic; class ExempleHashSet { static void Main() { // CrÃ©ation d'un ensemble HashSet tagsUniques = new HashSet(); // Add - Ajouter un Ã©lÃ©ment (ignore les doublons) tagsUniques.Add(\"programmation\"); tagsUniques.Add(\"csharp\"); tagsUniques.Add(\"collections\"); tagsUniques.Add(\"csharp\"); // Sera ignorÃ© (doublon) tagsUniques.Add(\"dotnet\"); Console.WriteLine($\"Nombre de tags uniques: {tagsUniques.Count}\"); // Affichage Console.WriteLine(\"\\n=== Tags ===\"); foreach (string tag in tagsUniques) { Console.WriteLine($\"- {tag}\"); } // Contains - VÃ©rifier l'existence bool existe = tagsUniques.Contains(\"csharp\"); Console.WriteLine($\"\\nLe tag 'csharp' existe: {existe}\"); // OpÃ©rations sur les ensembles HashSet autresTags = new HashSet { \"csharp\", \"java\", \"python\" }; // Union tagsUniques.UnionWith(autresTags); Console.WriteLine($\"\\nAprÃ¨s union: {tagsUniques.Count} tags\"); // Intersection HashSet langages = new HashSet { \"csharp\", \"java\", \"python\" }; HashSet appris = new HashSet { \"csharp\", \"javascript\" }; langages.IntersectWith(appris); Console.WriteLine(\"\\n=== Langages en commun ===\"); foreach (string langage in langages) { Console.WriteLine(langage); } } }",
    "description": "En C#, on distingue deux grandes familles pour stocker des groupes de donnÃ©es : les Tableaux (taille fixe) et les Collections (taille dynamique).\nLes tableaux (Array) Un tableau est une structure de donnÃ©es de taille fixe stockÃ©e de maniÃ¨re contiguÃ« en mÃ©moire.\n1. DÃ©claration et initialisation Syntaxe de base // DÃ©claration d'un tableau int[] nombres; // DÃ©claration avec initialisation de la taille int[] nombres = new int[5]; // DÃ©claration avec initialisation des valeurs int[] nombres = new int[] { 10, 20, 30, 40, 50 }; // Syntaxe courte (recommandÃ©e) int[] nombres = { 10, 20, 30, 40, 50 }; Le piÃ¨ge de lâ€™immuabilitÃ© : Si vous crÃ©ez int[] tab = new int[3], vous ne pourrez jamais y mettre un 4e Ã©lÃ©ment. Pour â€œagrandirâ€ un tableau, il faut en crÃ©er un nouveau, copier les donnÃ©es, puis ajouter le nouvel Ã©lÃ©ment. Câ€™est pourquoi nous utilisons les Collections pour les donnÃ©es dynamiques.",
    "tags": [],
    "title": "Tableaux et collections",
    "uri": "/420-413/tableaux_collections/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Table des matiÃ¨res Introduction Syntaxe de base ParamÃ¨tres de mÃ©thodes ParamÃ¨tres par rÃ©fÃ©rence (ref) ParamÃ¨tres de sortie (out) ParamÃ¨tres optionnels Surcharge de mÃ©thodes PortÃ©e des variables Exercices Introduction Les mÃ©thodes (aussi appelÃ©es fonctions) sont des blocs de code rÃ©utilisables qui effectuent une tÃ¢che spÃ©cifique. Elles permettent de :\nOrganiser le code de maniÃ¨re logique Ã‰viter la rÃ©pÃ©tition de code Faciliter la maintenance et la lecture du programme Diviser un problÃ¨me complexe en sous-problÃ¨mes plus simples Avantages des mÃ©thodes RÃ©utilisabilitÃ© : Ã‰crire une fois, utiliser plusieurs fois LisibilitÃ© : Code plus clair et organisÃ© Maintenance : Plus facile de corriger ou modifier le code Tests : Plus facile de tester des petites unitÃ©s de code Syntaxe de base Structure dâ€™une mÃ©thode modificateurAcces [static] typeRetour NomMethode(typeParam1 param1, typeParam2 param2) { // Corps de la mÃ©thode // Instructions Ã  exÃ©cuter return valeur; // Si la mÃ©thode retourne une valeur } Composantes :\nmodificateurAcces : ContrÃ´le la visibilitÃ© de la mÃ©thode (public, private, protected, internal) static : Indique que la mÃ©thode appartient Ã  la classe, pas Ã  une instance (obligatoire pour lâ€™instant) typeRetour : Le type de donnÃ©es que la mÃ©thode retourne (int, string, double, void, etc.) NomMethode : Le nom de la mÃ©thode (convention : commence par une majuscule en C#) ParamÃ¨tres : Les donnÃ©es dâ€™entrÃ©e (optionnels) Corps : Le code qui sâ€™exÃ©cute quand la mÃ©thode est appelÃ©e return : Retourne une valeur (sauf si void) Les modificateurs dâ€™accÃ¨s Modificateur Description Utilisation public Accessible partout Pour les mÃ©thodes utilisÃ©es par dâ€™autres classes private Accessible seulement dans la classe actuelle Pour les mÃ©thodes internes (par dÃ©faut) protected Accessible dans la classe et ses classes dÃ©rivÃ©es Pour lâ€™hÃ©ritage (POO) internal Accessible dans le mÃªme assembly Pour les mÃ©thodes partagÃ©es dans un projet Note : Pour lâ€™instant, nous utilisons principalement static avec nos mÃ©thodes car nous ne travaillons pas encore avec la programmation orientÃ©e objet. Les mÃ©thodes static peuvent Ãªtre appelÃ©es directement sans crÃ©er dâ€™objet.\nExemples de dÃ©clarations de mÃ©thodes // MÃ©thode publique statique qui retourne un entier public static int CalculerSomme(int a, int b) { return a + b; } // MÃ©thode privÃ©e statique qui ne retourne rien (void) private static void AfficherMessage() { Console.WriteLine(\"Message privÃ©\"); } // MÃ©thode publique statique avec plusieurs paramÃ¨tres public static double CalculerMoyenne(double note1, double note2, double note3) { return (note1 + note2 + note3) / 3; } // MÃ©thode publique statique sans paramÃ¨tres public static void AfficherBienvenue() { Console.WriteLine(\"Bienvenue!\"); } Exemple simple : MÃ©thode sans paramÃ¨tres using System; class Programme { public static void AfficherMessage() { Console.WriteLine(\"Bonjour du CÃ‰GEP!\"); Console.WriteLine(\"Bienvenue dans le cours de C#\"); } static void Main() { AfficherMessage(); // Appel de la mÃ©thode AfficherMessage(); // On peut l'appeler plusieurs fois } } Sortie :\nBonjour du CÃ‰GEP!\rBienvenue dans le cours de C#\rBonjour du CÃ‰GEP!\rBienvenue dans le cours de C# Exemple : MÃ©thode avec retour using System; class Programme { public static int ObtenirAnneeActuelle() { return 2024; } static void Main() { int annee = ObtenirAnneeActuelle(); Console.WriteLine($\"Nous sommes en {annee}\"); } } ParamÃ¨tres de mÃ©thodes Les paramÃ¨tres permettent de passer des donnÃ©es Ã  une mÃ©thode.\nPassage par valeur (comportement par dÃ©faut) Quand vous passez une variable Ã  une mÃ©thode, C# crÃ©e une copie de la valeur. Les modifications dans la mÃ©thode nâ€™affectent pas la variable originale.\nusing System; class Programme { public static void AugmenterNombre(int nombre) { nombre = nombre + 10; Console.WriteLine($\"Dans la mÃ©thode: {nombre}\"); } static void Main() { int valeur = 5; Console.WriteLine($\"Avant l'appel: {valeur}\"); AugmenterNombre(valeur); Console.WriteLine($\"AprÃ¨s l'appel: {valeur}\"); } } Sortie :\nAvant l'appel: 5\rDans la mÃ©thode: 15\rAprÃ¨s l'appel: 5 Explication : La variable valeur nâ€™a pas changÃ© car la mÃ©thode a travaillÃ© avec une copie.\nExemple : Calculer lâ€™aire dâ€™un rectangle using System; class Programme { public static double CalculerAireRectangle(double longueur, double largeur) { double aire = longueur * largeur; return aire; } static void Main() { double resultat = CalculerAireRectangle(5.5, 3.2); Console.WriteLine($\"L'aire du rectangle est: {resultat:F2} mÂ²\"); // Appel avec d'autres valeurs resultat = CalculerAireRectangle(10.0, 7.5); Console.WriteLine($\"L'aire du rectangle est: {resultat:F2} mÂ²\"); } } Exemple : MÃ©thode avec plusieurs paramÃ¨tres using System; class Programme { public static void AfficherInfoEtudiant(string nom, string prenom, int age, double moyenne) { Console.WriteLine(\"=== FICHE Ã‰TUDIANT ===\"); Console.WriteLine($\"Nom: {nom}\"); Console.WriteLine($\"PrÃ©nom: {prenom}\"); Console.WriteLine($\"Ã‚ge: {age} ans\"); Console.WriteLine($\"Moyenne: {moyenne:F1}%\"); Console.WriteLine(\"=====================\"); } static void Main() { AfficherInfoEtudiant(\"Tremblay\", \"Alice\", 19, 87.5); AfficherInfoEtudiant(\"Lavoie\", \"Bernard\", 20, 82.3); } } ParamÃ¨tres par rÃ©fÃ©rence (ref) Le mot-clÃ© ref permet de passer une variable par rÃ©fÃ©rence plutÃ´t que par valeur. Cela signifie que la mÃ©thode travaille directement avec la variable originale, pas avec une copie.\nCaractÃ©ristiques de ref La variable DOIT Ãªtre initialisÃ©e avant lâ€™appel Les modifications dans la mÃ©thode affectent la variable originale Le mot-clÃ© ref doit apparaÃ®tre Ã  la dÃ©finition ET Ã  lâ€™appel de la mÃ©thode Syntaxe public static void NomMethode(ref int parametre) { parametre = parametre * 2; } // Appel int nombre = 10; NomMethode(ref nombre); // Utiliser 'ref' lors de l'appel Exemple : Ã‰changer deux valeurs using System; class Programme { public static void EchangerValeurs(ref int a, ref int b) { int temporaire = a; a = b; b = temporaire; Console.WriteLine($\"Dans la mÃ©thode - a: {a}, b: {b}\"); } static void Main() { int x = 10; int y = 20; Console.WriteLine($\"Avant l'Ã©change - x: {x}, y: {y}\"); EchangerValeurs(ref x, ref y); Console.WriteLine($\"AprÃ¨s l'Ã©change - x: {x}, y: {y}\"); } } Sortie :\nAvant l'Ã©change - x: 10, y: 20\rDans la mÃ©thode - a: 20, b: 10\rAprÃ¨s l'Ã©change - x: 20, y: 10 Exemple : Doubler une valeur using System; class Programme { public static void DoublerValeur(ref int nombre) { nombre = nombre * 2; } static void Main() { int valeur = 15; Console.WriteLine($\"Valeur initiale: {valeur}\"); DoublerValeur(ref valeur); Console.WriteLine($\"Valeur aprÃ¨s doublement: {valeur}\"); } } Sortie :\nValeur initiale: 15\rValeur aprÃ¨s doublement: 30 Exemple : Modifier plusieurs valeurs using System; class Programme { public static void AppliquerTaxes(ref double prix, double tauxTPS, double tauxTVQ) { double tps = prix * tauxTPS; double tvq = prix * tauxTVQ; prix = prix + tps + tvq; } static void Main() { double prixProduit = 100.00; Console.WriteLine($\"Prix avant taxes: {prixProduit:C}\"); AppliquerTaxes(ref prixProduit, 0.05, 0.09975); Console.WriteLine($\"Prix aprÃ¨s taxes: {prixProduit:C}\"); } } ParamÃ¨tres de sortie (out) Le mot-clÃ© out est similaire Ã  ref, mais avec des diffÃ©rences importantes :\nDiffÃ©rences entre ref et out CaractÃ©ristique ref out Initialisation avant appel REQUISE Pas nÃ©cessaire Assignation dans la mÃ©thode Optionnelle OBLIGATOIRE Utilisation principale Modifier une valeur existante Retourner plusieurs valeurs CaractÃ©ristiques de out La variable Nâ€™A PAS BESOIN dâ€™Ãªtre initialisÃ©e avant lâ€™appel La mÃ©thode DOIT assigner une valeur au paramÃ¨tre out UtilisÃ© principalement pour retourner plusieurs valeurs dâ€™une mÃ©thode Le mot-clÃ© out doit apparaÃ®tre Ã  la dÃ©finition ET Ã  lâ€™appel Syntaxe public static void CalculerStatistiques(int[] nombres, out double moyenne, out int maximum) { // La mÃ©thode DOIT assigner des valeurs Ã  moyenne et maximum moyenne = ...; maximum = ...; } // Appel double moy; int max; CalculerStatistiques(tableau, out moy, out max); Exemple : Retourner plusieurs valeurs using System; class Programme { public static void CalculerRectangle(double longueur, double largeur, out double aire, out double perimetre) { aire = longueur * largeur; perimetre = 2 * (longueur + largeur); } static void Main() { double surfaceResultat; double perimetreResultat; CalculerRectangle(5.0, 3.0, out surfaceResultat, out perimetreResultat); Console.WriteLine($\"Aire: {surfaceResultat} mÂ²\"); Console.WriteLine($\"PÃ©rimÃ¨tre: {perimetreResultat} m\"); } } Sortie :\nAire: 15 mÂ²\rPÃ©rimÃ¨tre: 16 m DÃ©claration inline (C# 7.0+) Depuis C# 7.0, vous pouvez dÃ©clarer les variables out directement dans lâ€™appel :\nusing System; class Programme { public static void DiviserAvecReste(int dividende, int diviseur, out int quotient, out int reste) { quotient = dividende / diviseur; reste = dividende % diviseur; } static void Main() { // DÃ©claration inline - plus concis! DiviserAvecReste(17, 5, out int q, out int r); Console.WriteLine($\"17 Ã· 5 = {q} reste {r}\"); } } Exemple : Statistiques dâ€™un tableau using System; class Programme { public static void CalculerStatistiques(int[] nombres, out double moyenne, out int minimum, out int maximum) { // Calcul de la somme et moyenne int somme = 0; foreach (int nombre in nombres) { somme += nombre; } moyenne = (double)somme / nombres.Length; // Trouver min et max minimum = nombres[0]; maximum = nombres[0]; foreach (int nombre in nombres) { if (nombre \u003c minimum) minimum = nombre; if (nombre \u003e maximum) maximum = nombre; } } static void Main() { int[] notes = { 85, 92, 78, 95, 88, 76, 90 }; CalculerStatistiques(notes, out double moy, out int min, out int max); Console.WriteLine(\"=== STATISTIQUES DES NOTES ===\"); Console.WriteLine($\"Moyenne: {moy:F2}%\"); Console.WriteLine($\"Note minimale: {min}%\"); Console.WriteLine($\"Note maximale: {max}%\"); } } Exemple : Validation dâ€™entrÃ©e avec TryParse La mÃ©thode TryParse utilise out pour retourner le rÃ©sultat de la conversion :\nusing System; class Programme { static void Main() { Console.Write(\"Entrez votre Ã¢ge: \"); string entree = Console.ReadLine(); // TryParse retourne true si la conversion rÃ©ussit // et met le rÃ©sultat dans la variable 'age' if (int.TryParse(entree, out int age)) { Console.WriteLine($\"Votre Ã¢ge est: {age} ans\"); if (age \u003e= 18) Console.WriteLine(\"Vous Ãªtes majeur\"); else Console.WriteLine(\"Vous Ãªtes mineur\"); } else { Console.WriteLine(\"EntrÃ©e invalide!\"); } } } Exemple : Analyse de chaÃ®ne using System; class Programme { public static bool ExtraireNomPrenom(string nomComplet, out string nom, out string prenom) { string[] parties = nomComplet.Split(' '); if (parties.Length \u003e= 2) { prenom = parties[0]; nom = parties[1]; return true; } else { nom = \"\"; prenom = \"\"; return false; } } static void Main() { string nomComplet = \"Alice Tremblay\"; if (ExtraireNomPrenom(nomComplet, out string n, out string p)) { Console.WriteLine($\"PrÃ©nom: {p}\"); Console.WriteLine($\"Nom: {n}\"); } else { Console.WriteLine(\"Format invalide\"); } } } ParamÃ¨tres optionnels Les paramÃ¨tres optionnels ont des valeurs par dÃ©faut et peuvent Ãªtre omis lors de lâ€™appel.\nRÃ¨gles Les paramÃ¨tres optionnels doivent Ãªtre Ã  la fin de la liste de paramÃ¨tres Vous devez fournir une valeur par dÃ©faut Si omis lors de lâ€™appel, la valeur par dÃ©faut est utilisÃ©e Syntaxe public static void NomMethode(int obligatoire, int optionnel = 10) { // Corps de la mÃ©thode } // Appels possibles NomMethode(5); // optionnel = 10 (valeur par dÃ©faut) NomMethode(5, 20); // optionnel = 20 Exemple : Afficher un message personnalisÃ© using System; class Programme { public static void AfficherBienvenue(string nom, string titre = \"Ã‰tudiant\") { Console.WriteLine($\"Bonjour {titre} {nom}!\"); } static void Main() { AfficherBienvenue(\"Alice\"); // Utilise \"Ã‰tudiant\" par dÃ©faut AfficherBienvenue(\"Bernard\", \"Professeur\"); // Utilise \"Professeur\" AfficherBienvenue(\"Catherine\", \"Directrice\"); } } Sortie :\nBonjour Ã‰tudiant Alice!\rBonjour Professeur Bernard!\rBonjour Directrice Catherine! Exemple : Calcul avec taux par dÃ©faut using System; class Programme { public static double CalculerPrixTotal(double prixBase, double tauxTaxe = 0.15) { return prixBase * (1 + tauxTaxe); } static void Main() { // Utilise le taux par dÃ©faut (15%) double total1 = CalculerPrixTotal(100.00); Console.WriteLine($\"Prix avec taxe par dÃ©faut: {total1:C}\"); // SpÃ©cifie un taux diffÃ©rent double total2 = CalculerPrixTotal(100.00, 0.20); Console.WriteLine($\"Prix avec 20% de taxe: {total2:C}\"); } } Exemple : Affichage formatÃ© using System; class Programme { public static void AfficherLigne(string texte, char caractere = '-', int longueur = 40) { Console.WriteLine(texte); Console.WriteLine(new string(caractere, longueur)); } static void Main() { AfficherLigne(\"Titre 1\"); // - et 40 par dÃ©faut AfficherLigne(\"Titre 2\", '='); // = et 40 AfficherLigne(\"Titre 3\", '*', 30); // * et 30 } } Sortie :\nTitre 1\r----------------------------------------\rTitre 2\r========================================\rTitre 3\r****************************** Surcharge de mÃ©thodes La surcharge (overloading) permet dâ€™avoir plusieurs mÃ©thodes avec le mÃªme nom mais des signatures diffÃ©rentes.\nQuâ€™est-ce quâ€™une signature? La signature dâ€™une mÃ©thode inclut :\nLe nom de la mÃ©thode Le nombre de paramÃ¨tres Le type des paramÃ¨tres Lâ€™ordre des paramÃ¨tres Note : Le type de retour ne fait PAS partie de la signature.\nExemple : Calculer lâ€™aire de diffÃ©rentes formes using System; class Programme { // Aire d'un carrÃ© public static double CalculerAire(double cote) { return cote * cote; } // Aire d'un rectangle public static double CalculerAire(double longueur, double largeur) { return longueur * largeur; } // Aire d'un cercle public static double CalculerAire(double rayon, bool estCercle) { return Math.PI * rayon * rayon; } static void Main() { double aireCarre = CalculerAire(5.0); Console.WriteLine($\"Aire du carrÃ©: {aireCarre:F2} mÂ²\"); double aireRectangle = CalculerAire(5.0, 3.0); Console.WriteLine($\"Aire du rectangle: {aireRectangle:F2} mÂ²\"); double aireCercle = CalculerAire(4.0, true); Console.WriteLine($\"Aire du cercle: {aireCercle:F2} mÂ²\"); } } Exemple : Afficher diffÃ©rents types using System; class Programme { public static void Afficher(int nombre) { Console.WriteLine($\"Nombre entier: {nombre}\"); } public static void Afficher(double nombre) { Console.WriteLine($\"Nombre dÃ©cimal: {nombre:F2}\"); } public static void Afficher(string texte) { Console.WriteLine($\"Texte: {texte}\"); } public static void Afficher(int[] tableau) { Console.Write(\"Tableau: \"); foreach (int n in tableau) { Console.Write($\"{n} \"); } Console.WriteLine(); } static void Main() { Afficher(42); Afficher(3.14159); Afficher(\"Bonjour!\"); Afficher(new int[] { 1, 2, 3, 4, 5 }); } } Exemple : CrÃ©er un message de bienvenue using System; class Programme { // Version simple public static string CreerBienvenue(string nom) { return $\"Bienvenue {nom}!\"; } // Version avec prÃ©nom et nom public static string CreerBienvenue(string prenom, string nom) { return $\"Bienvenue {prenom} {nom}!\"; } // Version avec titre public static string CreerBienvenue(string prenom, string nom, string titre) { return $\"Bienvenue {titre} {prenom} {nom}!\"; } static void Main() { Console.WriteLine(CreerBienvenue(\"Alice\")); Console.WriteLine(CreerBienvenue(\"Alice\", \"Tremblay\")); Console.WriteLine(CreerBienvenue(\"Alice\", \"Tremblay\", \"Dr.\")); } } PortÃ©e des variables La portÃ©e (scope) dâ€™une variable dÃ©termine oÃ¹ elle peut Ãªtre utilisÃ©e dans le code.\nVariables locales Les variables dÃ©clarÃ©es Ã  lâ€™intÃ©rieur dâ€™une mÃ©thode sont locales Ã  cette mÃ©thode.\nusing System; class Programme { public static void Methode1() { int x = 10; // Variable locale Ã  Methode1 Console.WriteLine($\"Dans Methode1: x = {x}\"); } public static void Methode2() { int x = 20; // Variable diffÃ©rente, locale Ã  Methode2 Console.WriteLine($\"Dans Methode2: x = {x}\"); } static void Main() { Methode1(); Methode2(); // Console.WriteLine(x); // ERREUR: x n'existe pas ici } } PortÃ©e de bloc Les variables dÃ©clarÃ©es dans un bloc { } ne sont visibles que dans ce bloc.\nusing System; class Programme { static void Main() { int nombre = 10; if (nombre \u003e 5) { int resultat = nombre * 2; // Variable locale au bloc if Console.WriteLine($\"RÃ©sultat: {resultat}\"); } // Console.WriteLine(resultat); // ERREUR: resultat n'existe plus for (int i = 0; i \u003c 3; i++) // i existe seulement dans le for { Console.WriteLine($\"i = {i}\"); } // Console.WriteLine(i); // ERREUR: i n'existe plus } } Exemple : PortÃ©e et mÃ©thodes using System; class Programme { public static int CalculerCarre(int nombre) { int resultat = nombre * nombre; // Variable locale return resultat; } static void Main() { int valeur = 5; int carre = CalculerCarre(valeur); Console.WriteLine($\"Le carrÃ© de {valeur} est {carre}\"); // Console.WriteLine(resultat); // ERREUR: resultat est local Ã  CalculerCarre } } Bonnes pratiques 1. Nommage des mÃ©thodes Utilisez des verbes qui dÃ©crivent lâ€™action Commencez par une majuscule (convention C#) Soyez descriptif // Bon public static void CalculerMoyenne() public static bool VerifierAge() public static string ObtenirNomComplet() // Ã€ Ã©viter public static void calc() public static bool check() public static string get() 2. Une mÃ©thode = une tÃ¢che Chaque mÃ©thode devrait faire une seule chose et la faire bien.\n// Bon - une mÃ©thode par tÃ¢che public static double CalculerMoyenne(int[] notes) { // Calcule seulement la moyenne } public static void AfficherResultats(double moyenne) { // Affiche seulement les rÃ©sultats } // Moins bon - fait trop de choses public static void CalculerEtAfficher(int[] notes) { // Calcule ET affiche } 3. Limiter le nombre de paramÃ¨tres Si une mÃ©thode a trop de paramÃ¨tres (plus de 4-5), considÃ©rez regrouper les donnÃ©es.\n// Peut devenir difficile Ã  gÃ©rer public static void CreerEtudiant(string nom, string prenom, int age, string adresse, string telephone, string courriel) { // Beaucoup de paramÃ¨tres! } 4. Utiliser des noms de paramÃ¨tres significatifs // Bon public static double CalculerPrixTotal(double prixBase, double tauxTaxe) { return prixBase * (1 + tauxTaxe); } // Moins clair public static double Calculer(double p, double t) { return p * (1 + t); } RÃ©capitulatif : ref vs out Utilisez ref quand : Vous voulez modifier une valeur existante La variable doit Ãªtre initialisÃ©e avant lâ€™appel Vous voulez que les changements affectent la variable originale Utilisez out quand : Vous voulez retourner plusieurs valeurs dâ€™une mÃ©thode La variable nâ€™a pas besoin dâ€™Ãªtre initialisÃ©e avant lâ€™appel La mÃ©thode va crÃ©er/calculer une nouvelle valeur Tableau comparatif Aspect Passage par valeur ref out Initialisation requise Non Oui Non Modifie lâ€™original Non Oui Oui Doit assigner dans mÃ©thode Non Non Oui Usage principal Donner des donnÃ©es Modifier des donnÃ©es Retourner plusieurs valeurs Exercices Exercice 1 : MÃ©thode simple DifficultÃ© : Facile\nCrÃ©ez une mÃ©thode AfficherTableMultiplication qui prend un nombre en paramÃ¨tre et affiche sa table de multiplication de 1 Ã  10.\nExemple de sortie pour le nombre 5 :\n5 x 1 = 5\r5 x 2 = 10\r5 x 3 = 15\r...\r5 x 10 = 50 Exercice 2 : MÃ©thode avec retour DifficultÃ© : Facile\nCrÃ©ez une mÃ©thode EstPair qui prend un nombre entier en paramÃ¨tre et retourne true sâ€™il est pair, false sinon.\nIndice : Un nombre est pair si nombre % 2 == 0\nExercice 3 : MÃ©thode avec plusieurs paramÃ¨tres DifficultÃ© : Facile\nCrÃ©ez une mÃ©thode CalculerMoyenne qui prend trois notes (double) en paramÃ¨tres et retourne leur moyenne.\nExercice 4 : Utilisation de ref DifficultÃ© : Moyenne\nCrÃ©ez une mÃ©thode AugmenterDe10Pourcent qui prend un prix en paramÃ¨tre (ref double) et lâ€™augmente de 10%.\nTestez avec un prix initial de 100.00$ et vÃ©rifiez que la variable originale est bien modifiÃ©e.\nExercice 5 : Utilisation de out - Division DifficultÃ© : Moyenne\nCrÃ©ez une mÃ©thode DiviserEntiers qui prend deux entiers (dividende et diviseur) et retourne le quotient ET le reste en utilisant des paramÃ¨tres out.\nExemple : 17 divisÃ© par 5 donne quotient = 3 et reste = 2\nIndice : Utilisez les opÃ©rateurs / pour le quotient et % pour le reste.\nExercice 6 : Utilisation de out - Statistiques DifficultÃ© : Moyenne\nCrÃ©ez une mÃ©thode AnalyserTableau qui prend un tableau dâ€™entiers et retourne (via out) :\nLa somme de tous les Ã©lÃ©ments La moyenne Le nombre dâ€™Ã©lÃ©ments Testez avec le tableau : {10, 20, 30, 40, 50}\nExercice 7 : ParamÃ¨tres optionnels DifficultÃ© : Moyenne\nCrÃ©ez une mÃ©thode AfficherFacture qui prend :\nLe montant (obligatoire) Le taux de TPS (optionnel, dÃ©faut = 0.05) Le taux de TVQ (optionnel, dÃ©faut = 0.09975) La mÃ©thode calcule et affiche le montant avant taxes, les taxes, et le total.\nExercice 8 : Surcharge de mÃ©thodes DifficultÃ© : Moyenne\nCrÃ©ez trois versions surchargÃ©es dâ€™une mÃ©thode CalculerVolume :\nVolume dâ€™un cube : CalculerVolume(double cote) Volume dâ€™un parallÃ©lÃ©pipÃ¨de : CalculerVolume(double longueur, double largeur, double hauteur) Volume dâ€™un cylindre : CalculerVolume(double rayon, double hauteur, bool estCylindre) Formules :\nCube : cÃ´tÃ©Â³ ParallÃ©lÃ©pipÃ¨de : longueur Ã— largeur Ã— hauteur Cylindre : Ï€ Ã— rayonÂ² Ã— hauteur Exercice 9 : Validation avec TryParse DifficultÃ© : Moyenne\nCrÃ©ez un programme qui demande Ã  lâ€™utilisateur dâ€™entrer un nombre. Utilisez int.TryParse avec un paramÃ¨tre out pour valider lâ€™entrÃ©e. Si lâ€™entrÃ©e est valide, affichez le carrÃ© du nombre. Sinon, affichez un message dâ€™erreur.\nExercice 10 : Calculatrice simple DifficultÃ© : Difficile\nCrÃ©ez les mÃ©thodes suivantes pour une calculatrice :\nAdditionner(double a, double b) - retourne a + b Soustraire(double a, double b) - retourne a - b Multiplier(double a, double b) - retourne a Ã— b Diviser(double a, double b, out bool succes) - retourne a Ã· b et indique si la division a rÃ©ussi (pas de division par zÃ©ro) CrÃ©ez un menu qui permet Ã  lâ€™utilisateur de choisir une opÃ©ration et dâ€™entrer deux nombres.\nExercice 11 : Analyse de texte DifficultÃ© : Difficile\nCrÃ©ez une mÃ©thode AnalyserTexte qui prend une chaÃ®ne de caractÃ¨res et retourne (via out) :\nLe nombre de caractÃ¨res Le nombre de mots Le nombre de voyelles Indice : Utilisez .Split(' ') pour sÃ©parer les mots, et une boucle pour compter les voyelles (a, e, i, o, u).\nExercice 12 : Conversion de tempÃ©rature DifficultÃ© : Difficile\nCrÃ©ez les mÃ©thodes suivantes avec surcharge :\nConvertirTemperature(double celsius) - convertit Celsius â†’ Fahrenheit ConvertirTemperature(double fahrenheit, bool versCelsius) - convertit Fahrenheit â†’ Celsius Puis crÃ©ez une mÃ©thode ConvertirAvecValidation qui utilise un paramÃ¨tre out bool pour indiquer si la tempÃ©rature est physiquement possible (au-dessus du zÃ©ro absolu : -273.15Â°C ou -459.67Â°F).\nFormules :\nC â†’ F : (C Ã— 9/5) + 32 F â†’ C : (F - 32) Ã— 5/9 Conclusion Les mÃ©thodes sont un outil fondamental en programmation. Vous avez appris :\nâœ… Syntaxe de base : Comment crÃ©er et appeler des mÃ©thodes\nâœ… ParamÃ¨tres : Passage par valeur vs passage par rÃ©fÃ©rence\nâœ… ref : Modifier des variables existantes\nâœ… out : Retourner plusieurs valeurs\nâœ… ParamÃ¨tres optionnels : Valeurs par dÃ©faut\nâœ… Surcharge : Plusieurs mÃ©thodes avec le mÃªme nom\nâœ… PortÃ©e : OÃ¹ les variables sont accessibles\nConcepts clÃ©s Ã  retenir Une mÃ©thode = une tÃ¢che : Gardez vos mÃ©thodes simples et ciblÃ©es Nommage clair : Le nom doit dÃ©crire ce que fait la mÃ©thode ref pour modifier, out pour retourner : Choisissez selon votre besoin RÃ©utilisabilitÃ© : Ã‰crivez une fois, utilisez plusieurs fois",
    "description": "Table des matiÃ¨res Introduction Syntaxe de base ParamÃ¨tres de mÃ©thodes ParamÃ¨tres par rÃ©fÃ©rence (ref) ParamÃ¨tres de sortie (out) ParamÃ¨tres optionnels Surcharge de mÃ©thodes PortÃ©e des variables Exercices Introduction Les mÃ©thodes (aussi appelÃ©es fonctions) sont des blocs de code rÃ©utilisables qui effectuent une tÃ¢che spÃ©cifique. Elles permettent de :",
    "tags": [],
    "title": "Les mÃ©thodes en c#",
    "uri": "/420-413/methodes/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "PremiÃ¨re partie 1 : Calculatrice Simple Concepts pratiquÃ©s : Variables, opÃ©rateurs arithmÃ©tiques, types numÃ©riques\nDescription : CrÃ©ez un programme qui demande Ã  lâ€™utilisateur deux nombres et une opÃ©ration (+, -, *, /), puis affiche le rÃ©sultat.\nFonctionnalitÃ©s requises :\nDemander deux nombres dÃ©cimaux Ã  lâ€™utilisateur Demander lâ€™opÃ©ration souhaitÃ©e Effectuer le calcul appropriÃ© Afficher le rÃ©sultat avec 2 dÃ©cimales GÃ©rer la division par zÃ©ro Exemple dâ€™exÃ©cution :\nEntrez le premier nombre : 15.5\rEntrez le deuxiÃ¨me nombre : 3.2\rChoisissez l'opÃ©ration (+, -, *, /) : *\rRÃ©sultat : 15.5 * 3.2 = 49.60 2 : Convertisseur de TempÃ©rature Concepts pratiquÃ©s : Variables, opÃ©rateurs, formules mathÃ©matiques, casting\nDescription : DÃ©veloppez un convertisseur qui transforme une tempÃ©rature de Celsius vers Fahrenheit et Kelvin.\nFonctionnalitÃ©s requises :\nDemander une tempÃ©rature en Celsius Calculer lâ€™Ã©quivalent en Fahrenheit : F = (C Ã— 9/5) + 32 Calculer lâ€™Ã©quivalent en Kelvin : K = C + 273.15 Afficher les trois tempÃ©ratures avec 2 dÃ©cimales Exemple dâ€™exÃ©cution :\nEntrez la tempÃ©rature en Celsius : 25\r25.00Â°C = 77.00Â°F = 298.15K 3 : VÃ©rificateur de Nombre Pair ou Impair Concepts pratiquÃ©s : Variables, opÃ©rateur modulo, structure if/else\nDescription : CrÃ©ez un programme qui dÃ©termine si un nombre entier est pair ou impair.\nFonctionnalitÃ©s requises :\nDemander un nombre entier Ã  lâ€™utilisateur Utiliser lâ€™opÃ©rateur modulo (%) pour vÃ©rifier la paritÃ© Afficher si le nombre est pair ou impair Bonus : indiquer si le nombre est positif, nÃ©gatif ou zÃ©ro Exemple dâ€™exÃ©cution :\nEntrez un nombre entier : 42\rLe nombre 42 est pair et positif. 4 : Calculateur dâ€™IMC (Indice de Masse Corporelle) Concepts pratiquÃ©s : Variables, opÃ©rateurs, structures de contrÃ´le if/else if\nDescription : DÃ©veloppez un calculateur dâ€™IMC qui catÃ©gorise le rÃ©sultat selon les normes de santÃ©.\nFonctionnalitÃ©s requises :\nDemander le poids en kg et la taille en mÃ¨tres Calculer lâ€™IMC : IMC = poids / (taille Ã— taille) CatÃ©goriser le rÃ©sultat : Moins de 18.5 : Insuffisance pondÃ©rale 18.5 Ã  24.9 : Poids normal 25 Ã  29.9 : Surpoids 30 ou plus : ObÃ©sitÃ© Afficher lâ€™IMC et la catÃ©gorie Exemple dâ€™exÃ©cution :\nEntrez votre poids (kg) : 70\rEntrez votre taille (m) : 1.75\rVotre IMC est de 22.86 - Poids normal 5 : Jeu du Plus ou Moins Concepts pratiquÃ©s : Variables, Random, boucles while, structures if/else\nDescription : CrÃ©ez un jeu oÃ¹ lâ€™ordinateur choisit un nombre alÃ©atoire entre 1 et 100, et lâ€™utilisateur doit le deviner.\nFonctionnalitÃ©s requises :\nGÃ©nÃ©rer un nombre alÃ©atoire entre 1 et 100 Utiliser une boucle pour permettre plusieurs tentatives Indiquer si la proposition est trop haute ou trop basse Compter le nombre de tentatives Afficher un message de victoire avec le nombre de coups Exemple dâ€™exÃ©cution :\nJ'ai choisi un nombre entre 1 et 100. Devinez !\rVotre proposition : 50\rTrop bas !\rVotre proposition : 75\rTrop haut !\rVotre proposition : 63\rBravo ! Vous avez trouvÃ© en 3 coups ! 6 : Calculateur de Facture avec Pourboire Concepts pratiquÃ©s : Variables, opÃ©rateurs, types dÃ©cimaux, formatage\nDescription : DÃ©veloppez un programme qui calcule le montant total dâ€™une facture incluant taxes et pourboire.\nFonctionnalitÃ©s requises :\nDemander le montant de base de la facture Demander le pourcentage de taxes (ex: 15%) Demander le pourcentage de pourboire (ex: 18%) Calculer le montant des taxes Calculer le montant du pourboire (sur le sous-total avec taxes) Afficher le dÃ©tail complet de la facture Exemple dâ€™exÃ©cution :\nMontant de base : 50.00$\rPourcentage de taxes : 15\rPourcentage de pourboire : 18\r--- Facture dÃ©taillÃ©e ---\rMontant de base : 50.00$\rTaxes (15%) : 7.50$\rSous-total : 57.50$\rPourboire (18%) : 10.35$\rTOTAL Ã€ PAYER : 67.85$ 7 : Validateur de Mot de Passe Concepts pratiquÃ©s : Variables string, opÃ©rateurs logiques, structures if/else, mÃ©thodes de string\nDescription : CrÃ©ez un validateur qui vÃ©rifie si un mot de passe respecte certains critÃ¨res de sÃ©curitÃ©.\nFonctionnalitÃ©s requises :\nDemander un mot de passe Ã  lâ€™utilisateur VÃ©rifier que le mot de passe : Contient au moins 8 caractÃ¨res Contient au moins une majuscule Contient au moins une minuscule Contient au moins un chiffre Afficher si le mot de passe est valide ou non Lister les critÃ¨res non respectÃ©s Exemple dâ€™exÃ©cution :\nEntrez un mot de passe : Hello123\râœ“ Au moins 8 caractÃ¨res\râœ“ Contient une majuscule\râœ“ Contient une minuscule\râœ“ Contient un chiffre\rMot de passe valide ! 8 : ChronomÃ©treur de Temps de RÃ©action Concepts pratiquÃ©s : Variables, Random, DateTime, boucles, opÃ©rateurs de comparaison\nDescription : DÃ©veloppez un mini-jeu qui teste le temps de rÃ©action de lâ€™utilisateur.\nFonctionnalitÃ©s requises :\nAfficher â€œPrÃ©parez-vousâ€¦â€ Attendre un dÃ©lai alÃ©atoire (2 Ã  5 secondes) Afficher â€œMAINTENANT !â€ et enregistrer lâ€™heure Attendre que lâ€™utilisateur appuie sur EntrÃ©e Calculer et afficher le temps de rÃ©action en millisecondes Proposer de rejouer Exemple dâ€™exÃ©cution :\nPrÃ©parez-vous...\rMAINTENANT !\r[utilisateur appuie sur EntrÃ©e]\rVotre temps de rÃ©action : 342 ms\rExcellent !\rVoulez-vous rejouer ? (o/n) 9 : Convertisseur de Devises Concepts pratiquÃ©s : Variables, opÃ©rateurs, switch/case, types dÃ©cimaux\nDescription : CrÃ©ez un convertisseur qui transforme un montant en dollars canadiens vers diffÃ©rentes devises.\nFonctionnalitÃ©s requises :\nDemander un montant en CAD Proposer plusieurs devises (USD, EUR, GBP, JPY) Utiliser un switch pour sÃ©lectionner le taux de change appropriÃ© Calculer et afficher la conversion Utiliser des taux de change rÃ©alistes Exemple dâ€™exÃ©cution :\nMontant en CAD : 100\rChoisissez la devise :\r1. USD (Dollar amÃ©ricain)\r2. EUR (Euro)\r3. GBP (Livre sterling)\r4. JPY (Yen japonais)\rVotre choix : 1\r100.00 CAD = 72.50 USD 10 : Calculateur de Note Finale Concepts pratiquÃ©s : Variables, opÃ©rateurs, structures if/else, moyenne pondÃ©rÃ©e\nDescription : DÃ©veloppez un programme qui calcule la note finale dâ€™un Ã©tudiant selon diffÃ©rents critÃ¨res pondÃ©rÃ©s.\nFonctionnalitÃ©s requises :\nDemander les notes pour : Examens (40% de la note finale) Devoirs (30% de la note finale) Participation (10% de la note finale) final (20% de la note finale) Calculer la note finale pondÃ©rÃ©e DÃ©terminer la cote (A+, A, B+, B, C+, C, D, E) Indiquer si lâ€™Ã©tudiant a rÃ©ussi (60% et plus) Exemple dâ€™exÃ©cution :\nNote des examens (sur 100) : 85\rNote des devoirs (sur 100) : 78\rNote de participation (sur 100) : 92\rNote du final (sur 100) : 88\r--- RÃ©sultat final ---\rNote finale : 84.2 / 100\rCote : A\rStatut : RÃ©ussite 11 : Simulateur de DÃ©s Concepts pratiquÃ©s : Variables, Random, boucles for, opÃ©rateurs\nDescription : CrÃ©ez un simulateur qui lance plusieurs dÃ©s et calcule des statistiques.\nFonctionnalitÃ©s requises :\nDemander le nombre de dÃ©s Ã  lancer (1-10) Demander le nombre de faces par dÃ© (4, 6, 8, 12, 20) Lancer tous les dÃ©s Afficher le rÃ©sultat de chaque dÃ© Calculer et afficher la somme totale Afficher le rÃ©sultat minimum et maximum obtenu Exemple dâ€™exÃ©cution :\nNombre de dÃ©s : 3\rNombre de faces : 6\rLancer des dÃ©s...\rDÃ© 1 : 4\rDÃ© 2 : 6\rDÃ© 3 : 2\rSomme totale : 12\rMinimum : 2\rMaximum : 6 12 : Compteur de Voyelles et Consonnes Concepts pratiquÃ©s : Variables string, boucles foreach, switch/case, opÃ©rateurs\nDescription : DÃ©veloppez un programme qui analyse une phrase et compte les voyelles et consonnes.\nFonctionnalitÃ©s requises :\nDemander une phrase Ã  lâ€™utilisateur Parcourir chaque caractÃ¨re de la phrase Compter les voyelles (a, e, i, o, u, y - majuscules et minuscules) Compter les consonnes Compter les espaces et caractÃ¨res spÃ©ciaux Afficher les statistiques complÃ¨tes Exemple dâ€™exÃ©cution :\nEntrez une phrase : Bonjour le monde!\r--- Analyse ---\rVoyelles : 6\rConsonnes : 8\rEspaces : 2\rAutres caractÃ¨res : 1\rTotal de caractÃ¨res : 17 13 : GÃ©nÃ©rateur de Tables de Multiplication Concepts pratiquÃ©s : Variables, boucles for imbriquÃ©es, opÃ©rateurs, formatage\nDescription : CrÃ©ez un programme qui gÃ©nÃ¨re et affiche des tables de multiplication.\nFonctionnalitÃ©s requises :\nDemander quel nombre de table lâ€™utilisateur veut voir (1-12) Demander jusquâ€™Ã  quel multiplicateur (gÃ©nÃ©ralement 10 ou 12) Utiliser une boucle pour gÃ©nÃ©rer la table Afficher la table de maniÃ¨re formatÃ©e et lisible Bonus : afficher plusieurs tables cÃ´te Ã  cÃ´te Exemple dâ€™exÃ©cution :\nTable de multiplication de : 7\rJusqu'Ã  : 10\r7 x 1 = 7\r7 x 2 = 14\r7 x 3 = 21\r7 x 4 = 28\r7 x 5 = 35\r7 x 6 = 42\r7 x 7 = 49\r7 x 8 = 56\r7 x 9 = 63\r7 x 10 = 70 14 : Calculateur dâ€™Ã‚ge PrÃ©cis Concepts pratiquÃ©s : Variables, DateTime, opÃ©rateurs, structures if/else\nDescription : DÃ©veloppez un programme qui calcule lâ€™Ã¢ge prÃ©cis dâ€™une personne en annÃ©es, mois et jours.\nFonctionnalitÃ©s requises :\nDemander la date de naissance (jour, mois, annÃ©e) Utiliser DateTime pour les calculs Calculer lâ€™Ã¢ge en annÃ©es, mois et jours Calculer le nombre total de jours vÃ©cus Calculer le jour de la semaine de la naissance Afficher le prochain anniversaire Exemple dâ€™exÃ©cution :\nDate de naissance\rJour : 15\rMois : 3\rAnnÃ©e : 2005\rVous avez 20 ans, 10 mois et 15 jours\rTotal de jours vÃ©cus : 7625 jours\rVous Ãªtes nÃ©(e) un mardi\rProchain anniversaire : dans 136 jours 15 : DÃ©tecteur de Nombre Premier Concepts pratiquÃ©s : Variables, boucles for, opÃ©rateurs, structures if/else\nDescription : CrÃ©ez un programme qui dÃ©termine si un nombre est premier et trouve tous les nombres premiers dans une plage.\nFonctionnalitÃ©s requises :\nDemander un nombre Ã  lâ€™utilisateur VÃ©rifier sâ€™il est premier (divisible seulement par 1 et lui-mÃªme) Afficher tous les diviseurs du nombre Option : afficher tous les nombres premiers jusquâ€™Ã  ce nombre Optimiser lâ€™algorithme (vÃ©rifier jusquâ€™Ã  la racine carrÃ©e) Exemple dâ€™exÃ©cution :\nEntrez un nombre : 17\rLe nombre 17 est PREMIER\rDiviseurs : 1, 17\rVoulez-vous voir tous les nombres premiers jusqu'Ã  17 ? (o/n) : o\r2, 3, 5, 7, 11, 13, 17\rTotal : 7 nombres premiers 16 : Simulateur de Distributeur Bancaire Concepts pratiquÃ©s : Variables, switch/case, boucles while, opÃ©rateurs\nDescription : DÃ©veloppez un simulateur de guichet automatique avec un menu et des opÃ©rations bancaires de base.\nFonctionnalitÃ©s requises :\nDÃ©finir un solde initial (ex: 1000$) CrÃ©er un menu avec options : Consulter le solde DÃ©poser de lâ€™argent Retirer de lâ€™argent Quitter VÃ©rifier que les retraits nâ€™excÃ¨dent pas le solde Utiliser une boucle pour rÃ©pÃ©ter le menu Afficher lâ€™historique des transactions Exemple dâ€™exÃ©cution :\n=== Guichet Automatique ===\r1. Consulter le solde\r2. DÃ©poser\r3. Retirer\r4. Quitter\rVotre choix : 3\rMontant Ã  retirer : 50\rRetrait effectuÃ©. Nouveau solde : 950.00$ 17 : Convertisseur Binaire/DÃ©cimal Concepts pratiquÃ©s : Variables, boucles while, opÃ©rateurs, types numÃ©riques\nDescription : CrÃ©ez un convertisseur bidirectionnel entre nombres dÃ©cimaux et binaires.\nFonctionnalitÃ©s requises :\nProposer deux options : DÃ©cimal vers binaire Binaire vers dÃ©cimal Pour dÃ©cimal vers binaire : utiliser la division successive par 2 Pour binaire vers dÃ©cimal : utiliser les puissances de 2 Afficher les Ã©tapes de conversion Valider que lâ€™entrÃ©e binaire contient seulement 0 et 1 Exemple dâ€™exÃ©cution :\n1. DÃ©cimal vers Binaire\r2. Binaire vers DÃ©cimal\rVotre choix : 1\rEntrez un nombre dÃ©cimal : 42\rConversion de 42 en binaire :\r42 Ã· 2 = 21 reste 0\r21 Ã· 2 = 10 reste 1\r10 Ã· 2 = 5 reste 0\r5 Ã· 2 = 2 reste 1\r2 Ã· 2 = 1 reste 0\r1 Ã· 2 = 0 reste 1\rRÃ©sultat : 42 (dÃ©cimal) = 101010 (binaire) 18 : Jeu de Pierre-Papier-Ciseaux Concepts pratiquÃ©s : Variables, Random, switch/case, structures de contrÃ´le, boucles\nDescription : DÃ©veloppez le jeu classique Pierre-Papier-Ciseaux contre lâ€™ordinateur avec score.\nFonctionnalitÃ©s requises :\nCrÃ©er un menu avec les 3 choix possibles GÃ©nÃ©rer un choix alÃ©atoire pour lâ€™ordinateur DÃ©terminer le gagnant selon les rÃ¨gles : Pierre bat Ciseaux Ciseaux bat Papier Papier bat Pierre Tenir un score (victoires, dÃ©faites, Ã©galitÃ©s) Permettre de jouer plusieurs parties Afficher le score final Exemple dâ€™exÃ©cution :\n=== Pierre-Papier-Ciseaux ===\r1. Pierre\r2. Papier\r3. Ciseaux\rVotre choix : 1\rVous : Pierre\rOrdinateur : Ciseaux\rVous gagnez !\rScore - Vous: 1 | Ordi: 0 | Ã‰galitÃ©s: 0\rRejouer ? (o/n) 19 : Calculateur de Moyenne Mobile Concepts pratiquÃ©s : Variables, boucles for, opÃ©rateurs, types numÃ©riques\nDescription : CrÃ©ez un programme qui calcule la moyenne dâ€™une sÃ©rie de nombres entrÃ©s par lâ€™utilisateur.\nFonctionnalitÃ©s requises :\nDemander combien de nombres lâ€™utilisateur veut entrer Utiliser une boucle pour saisir chaque nombre Calculer la moyenne, le minimum et le maximum Calculer lâ€™Ã©cart-type (bonus) Afficher tous les nombres au-dessus et en-dessous de la moyenne Exemple dâ€™exÃ©cution :\nCombien de nombres : 5\rNombre 1 : 12\rNombre 2 : 15\rNombre 3 : 8\rNombre 4 : 20\rNombre 5 : 10\r--- Statistiques ---\rMoyenne : 13.00\rMinimum : 8\rMaximum : 20\rNombres au-dessus de la moyenne : 15, 20\rNombres en-dessous de la moyenne : 12, 8, 10 20 : GÃ©nÃ©rateur de Calendrier Mensuel Concepts pratiquÃ©s : Variables, DateTime, boucles, structures if/else, formatage\nDescription : DÃ©veloppez un programme qui affiche le calendrier dâ€™un mois donnÃ©.\nFonctionnalitÃ©s requises :\nDemander le mois et lâ€™annÃ©e DÃ©terminer le premier jour du mois (lundi, mardi, etc.) Calculer le nombre de jours dans le mois Afficher le calendrier formatÃ© avec les jours de la semaine Mettre en Ã©vidence le jour actuel si câ€™est le mois en cours Bonus : marquer les fins de semaine diffÃ©remment Exemple dâ€™exÃ©cution :\nMois (1-12) : 2\rAnnÃ©e : 2026\rFÃ©vrier 2026\rDim Lun Mar Mer Jeu Ven Sam\r1 2 3 4 5 6 7\r8 9 10 11 12 13 14\r15 16 17 18 19 20 21\r22 23 24 25 26 27 28 s AvancÃ©s Ces s intÃ¨grent tableaux, collections (List, Dictionary), mÃ©thodes et tous les concepts prÃ©cÃ©dents.\n21 : Gestionnaire de Liste de Courses Concepts pratiquÃ©s : List, mÃ©thodes, boucles, switch/case\nDescription : CrÃ©ez une application complÃ¨te pour gÃ©rer une liste de courses avec ajout, suppression et affichage.\nFonctionnalitÃ©s requises :\nCrÃ©er une List pour stocker les articles Menu avec options : Ajouter un article Supprimer un article Afficher la liste Rechercher un article Vider la liste Compter les articles Quitter CrÃ©er des mÃ©thodes pour chaque fonctionnalitÃ© Ã‰viter les doublons Trier la liste alphabÃ©tiquement (option) Structure suggÃ©rÃ©e :\nstatic List\u003cstring\u003e listeDesCourses = new List\u003cstring\u003e(); static void AjouterArticle() static void SupprimerArticle() static void AfficherListe() static void RechercherArticle() Exemple dâ€™exÃ©cution :\n=== Liste de Courses ===\r1. Ajouter un article\r2. Supprimer un article\r3. Afficher la liste\r4. Rechercher un article\r5. Vider la liste\r6. Quitter\rChoix : 1\rArticle Ã  ajouter : Lait\rArticle ajoutÃ© ! Total : 1 article(s) 22 : Carnet dâ€™Adresses Concepts pratiquÃ©s : Dictionary, mÃ©thodes, structures (ou classes), collections\nDescription : DÃ©veloppez un carnet dâ€™adresses qui stocke nom, tÃ©lÃ©phone et courriel de plusieurs contacts.\nFonctionnalitÃ©s requises :\nUtiliser un Dictionary\u003cstring, Contact\u003e (nom comme clÃ©) CrÃ©er une structure Contact avec propriÃ©tÃ©s : Nom TÃ©lÃ©phone Courriel MÃ©thodes pour : Ajouter un contact Modifier un contact Supprimer un contact Rechercher un contact Afficher tous les contacts Afficher les contacts par ordre alphabÃ©tique Structure suggÃ©rÃ©e :\nstruct Contact { public string Nom; public string Telephone; public string Courriel; } static Dictionary\u003cstring, Contact\u003e carnet = new Dictionary\u003cstring, Contact\u003e(); static void AjouterContact() static Contact RechercherContact(string nom) Exemple dâ€™exÃ©cution :\n=== Carnet d'Adresses ===\r1. Ajouter un contact\r2. Rechercher\r3. Afficher tous\r4. Quitter\rChoix : 1\rNom : Jean Tremblay\rTÃ©lÃ©phone : 514-555-1234\rCourriel : jean@email.com\rContact ajoutÃ© ! 23 : Analyseur de Texte AvancÃ© Concepts pratiquÃ©s : Tableaux, string methods, Dictionary, mÃ©thodes, LINQ\nDescription : CrÃ©ez un analyseur qui effectue des statistiques dÃ©taillÃ©es sur un texte.\nFonctionnalitÃ©s requises :\nDemander un texte Ã  lâ€™utilisateur (plusieurs phrases) CrÃ©er des mÃ©thodes pour : Compter les mots Compter les phrases Calculer la longueur moyenne des mots Trouver le mot le plus long Compter la frÃ©quence de chaque mot (Dictionary) Afficher les 5 mots les plus frÃ©quents Ignorer la ponctuation et la casse pour le comptage MÃ©thodes suggÃ©rÃ©es :\nstatic int CompterMots(string texte) static int CompterPhrases(string texte) static double LongueurMoyenneMots(string texte) static string TrouverMotLePlusLong(string texte) static Dictionary\u003cstring, int\u003e CompterFrequenceMots(string texte) static void AfficherTopMots(Dictionary\u003cstring, int\u003e frequences, int top) Exemple dâ€™exÃ©cution :\nEntrez votre texte :\rLe chat est sur le tapis. Le chat dort.\r--- Analyse ---\rNombre de mots : 9\rNombre de phrases : 2\rLongueur moyenne des mots : 3.33 lettres\rMot le plus long : tapis (5 lettres)\rMots les plus frÃ©quents :\r1. le (3 fois)\r2. chat (2 fois)\r3. est (1 fois)\r4. sur (1 fois)\r5. tapis (1 fois) 24 : Jeu du Pendu Concepts pratiquÃ©s : Tableaux char, List, mÃ©thodes, string manipulation, Random\nDescription : DÃ©veloppez le jeu classique du pendu avec une banque de mots et gestion des vies.\nFonctionnalitÃ©s requises :\nCrÃ©er un tableau de mots Ã  deviner Choisir un mot alÃ©atoirement Utiliser un tableau de char pour le mot masquÃ© GÃ©rer une List pour les lettres dÃ©jÃ  proposÃ©es Compter les erreurs (maximum 6) CrÃ©er des mÃ©thodes pour : Afficher le mot masquÃ© VÃ©rifier si une lettre est dans le mot Afficher le dessin du pendu selon les erreurs VÃ©rifier si le jeu est gagnÃ©/perdu MÃ©thodes suggÃ©rÃ©es :\nstatic string[] banqueDeMots = { \"programmation\", \"ordinateur\", \"clavier\" }; static List\u003cchar\u003e lettresProposees = new List\u003cchar\u003e(); static string ChoisirMotAleatoire() static void AfficherMotMasque(string mot) static bool VerifierLettre(string mot, char lettre) static void DessinerPendu(int erreurs) static bool EstMotTrouve(string mot) Exemple dâ€™exÃ©cution :\n=== Jeu du Pendu ===\rMot Ã  deviner : _ _ _ _ _ _ _ _ _ _ _ (11 lettres)\rErreurs : 0/6\rProposez une lettre : e\rBien jouÃ© !\rMot : _ _ _ _ _ _ _ _ _ _ e 25 : Gestionnaire de Notes dâ€™Ã‰tudiants Concepts pratiquÃ©s : Dictionary, List, mÃ©thodes, structures/classes, calculs statistiques\nDescription : CrÃ©ez un systÃ¨me complet pour gÃ©rer les notes de plusieurs Ã©tudiants dans plusieurs matiÃ¨res.\nFonctionnalitÃ©s requises :\nUtiliser un Dictionary\u003cstring, Etudiant\u003e CrÃ©er une classe/struct Etudiant avec : Nom Dictionary\u003cstring, double\u003e pour les notes par matiÃ¨re MÃ©thodes pour : Ajouter un Ã©tudiant Ajouter une note pour une matiÃ¨re Calculer la moyenne dâ€™un Ã©tudiant Calculer la moyenne de classe pour une matiÃ¨re Afficher le bulletin dâ€™un Ã©tudiant Trouver le meilleur Ã©tudiant Afficher les statistiques gÃ©nÃ©rales Structure suggÃ©rÃ©e :\nclass Etudiant { public string Nom { get; set; } public Dictionary\u003cstring, double\u003e Notes { get; set; } public double CalculerMoyenne() public void AfficherBulletin() } static Dictionary\u003cstring, Etudiant\u003e etudiants = new Dictionary\u003cstring, Etudiant\u003e(); static void AjouterEtudiant() static void AjouterNote() static double CalculerMoyenneClasse(string matiere) Exemple dâ€™exÃ©cution :\n=== Gestionnaire de Notes ===\r1. Ajouter Ã©tudiant\r2. Ajouter note\r3. Bulletin Ã©tudiant\r4. Statistiques classe\r5. Quitter\rChoix : 3\rNom de l'Ã©tudiant : Marie Dubois\r--- Bulletin de Marie Dubois ---\rMathÃ©matiques : 85\rFranÃ§ais : 92\rSciences : 78\rMoyenne gÃ©nÃ©rale : 85.0 26 : SystÃ¨me de Playlist Musicale Concepts pratiquÃ©s : List, mÃ©thodes, Random, manipulation de listes\nDescription : DÃ©veloppez un gestionnaire de playlist musicale avec lecture alÃ©atoire et rÃ©pÃ©tition.\nFonctionnalitÃ©s requises :\nCrÃ©er une List pour stocker les chansons MÃ©thodes pour : Ajouter une chanson Supprimer une chanson Afficher toute la playlist Lire la playlist en ordre Lire en mode alÃ©atoire (shuffle) Rechercher une chanson DÃ©placer une chanson (changer lâ€™ordre) Afficher le nombre total de chansons Vider la playlist Simuler la lecture avec un compteur de chansons jouÃ©es MÃ©thodes suggÃ©rÃ©es :\nstatic List\u003cstring\u003e playlist = new List\u003cstring\u003e(); static Random rand = new Random(); static void AjouterChanson() static void SupprimerChanson() static void AfficherPlaylist() static void LireEnOrdre() static void LireAleatoire() static void DeplacerChanson(int indexDepart, int indexArrivee) Exemple dâ€™exÃ©cution :\n=== Gestionnaire de Playlist ===\r1. Ajouter chanson\r2. Supprimer chanson\r3. Afficher playlist\r4. Lire en ordre\r5. Lire alÃ©atoire\r6. Quitter\rChoix : 3\r--- Ma Playlist (4 chansons) ---\r1. Bohemian Rhapsody - Queen\r2. Imagine - John Lennon\r3. Hotel California - Eagles\r4. Stairway to Heaven - Led Zeppelin\rChoix : 5\rMode lecture alÃ©atoire activÃ©...\râ™ª Lecture : Hotel California - Eagles\râ™ª Lecture : Bohemian Rhapsody - Queen\râ™ª Lecture : Stairway to Heaven - Led Zeppelin\râ™ª Lecture : Imagine - John Lennon\rPlaylist terminÃ©e ! 27 : GÃ©nÃ©rateur et Analyseur de Statistiques Concepts pratiquÃ©s : Tableaux, mÃ©thodes mathÃ©matiques, Random, tri, calculs statistiques\nDescription : CrÃ©ez un programme qui gÃ©nÃ¨re des donnÃ©es alÃ©atoires et effectue des analyses statistiques complÃ¨tes.\nFonctionnalitÃ©s requises :\nGÃ©nÃ©rer un tableau de N nombres alÃ©atoires (10-100) CrÃ©er des mÃ©thodes pour calculer : Moyenne MÃ©diane (valeur centrale aprÃ¨s tri) Mode (valeur la plus frÃ©quente) Ã‰cart-type Minimum et maximum Premier et troisiÃ¨me quartile Afficher un histogramme simple en console CrÃ©er une mÃ©thode pour trier le tableau MÃ©thodes suggÃ©rÃ©es :\nstatic double[] GenererDonnees(int taille, int min, int max) static double CalculerMoyenne(double[] donnees) static double CalculerMediane(double[] donnees) static double CalculerMode(double[] donnees) static double CalculerEcartType(double[] donnees) static void AfficherHistogramme(double[] donnees) static double[] TrierTableau(double[] donnees) Exemple dâ€™exÃ©cution :\nGÃ©nÃ©ration de 20 nombres entre 1 et 100...\rDonnÃ©es gÃ©nÃ©rÃ©es : 45, 23, 78, 45, 12, ...\r--- Statistiques ---\rMoyenne : 48.5\rMÃ©diane : 46.0\rMode : 45 (apparaÃ®t 3 fois)\rÃ‰cart-type : 24.3\rMin : 12\rMax : 98\rPremier quartile : 28.5\rTroisiÃ¨me quartile : 71.0\r--- Histogramme ---\r0-20: *** (3)\r21-40: ***** (5)\r41-60: ******* (7)\r61-80: **** (4)\r81-100: * (1) 28 : Simulateur de Loto et Statistiques Concepts pratiquÃ©s : Tableaux, List, Random, mÃ©thodes, comparaison\nDescription : CrÃ©ez un simulateur de loterie qui gÃ©nÃ¨re des numÃ©ros et vÃ©rifie les gains.\nFonctionnalitÃ©s requises :\nDemander Ã  lâ€™utilisateur de choisir 6 numÃ©ros entre 1 et 49 GÃ©nÃ©rer un tirage alÃ©atoire de 6 numÃ©ros (sans rÃ©pÃ©tition) Comparer les numÃ©ros du joueur avec le tirage Calculer le gain selon le nombre de numÃ©ros correspondants : 6 numÃ©ros : Jackpot (1 000 000$) 5 numÃ©ros : 10 000$ 4 numÃ©ros : 500$ 3 numÃ©ros : 20$ 2 numÃ©ros : 5$ MÃ©thodes pour : GÃ©nÃ©rer des numÃ©ros alÃ©atoires uniques Valider les choix de lâ€™utilisateur (pas de doublons, dans la plage) Comparer deux listes de numÃ©ros Calculer le gain Afficher les statistiques aprÃ¨s plusieurs parties MÃ©thodes suggÃ©rÃ©es :\nstatic int[] numeros_joueur = new int[6]; static int[] numeros_gagnants = new int[6]; static void ChoisirNumeros() static int[] GenererTirage() static int CompterNumerosCorrespondants() static double CalculerGain(int correspondants) static bool ContiendreNumero(int[] tableau, int numero) static void TrierTableau(int[] tableau) Exemple dâ€™exÃ©cution :\n=== Simulateur de Loto 6/49 ===\rChoisissez 6 numÃ©ros entre 1 et 49 :\rNumÃ©ro 1 : 7\rNumÃ©ro 2 : 14\rNumÃ©ro 3 : 21\rNumÃ©ro 4 : 28\rNumÃ©ro 5 : 35\rNumÃ©ro 6 : 42\rVos numÃ©ros : 7, 14, 21, 28, 35, 42\rTirage en cours...\rNumÃ©ros gagnants : 12, 14, 23, 28, 35, 41\rNumÃ©ros correspondants : 14, 28, 35\rTotal : 3 numÃ©ros\rVous gagnez : 20.00$ !\rRejouer ? (o/n) 29 : Gestion dâ€™Inventaire de Magasin Concepts pratiquÃ©s : Tableaux parallÃ¨les, mÃ©thodes, recherche, tri\nDescription : CrÃ©ez un systÃ¨me de gestion dâ€™inventaire avec produits, quantitÃ©s et prix en utilisant des tableaux parallÃ¨les.\nFonctionnalitÃ©s requises :\nUtiliser 4 tableaux parallÃ¨les pour stocker : string[] codes (codes produits) string[] noms (noms des produits) int[] quantites (quantitÃ©s en stock) double[] prix (prix unitaires) MÃ©thodes pour : Ajouter un produit Modifier un produit Supprimer un produit Rechercher par code ou nom Afficher tous les produits Afficher les produits en rupture de stock (quantitÃ© = 0) Calculer la valeur totale de lâ€™inventaire Vendre un produit (diminuer quantitÃ©) Trier les produits par prix MÃ©thodes suggÃ©rÃ©es :\nstatic string[] codes = new string[100]; static string[] noms = new string[100]; static int[] quantites = new int[100]; static double[] prix = new double[100]; static int nombreProduits = 0; static void AjouterProduit() static int RechercherParCode(string code) static void AfficherInventaire() static void ProduitsEnRupture() static double ValeurTotaleInventaire() static void VendreProduit(string code, int quantite) Exemple dâ€™exÃ©cution :\n=== Gestion d'Inventaire ===\r1. Ajouter produit\r2. Vendre\r3. Rechercher\r4. Afficher inventaire\r5. Ruptures de stock\r6. Valeur totale\r7. Quitter\rChoix : 4\r--- Inventaire (3 produits) ---\rCode Nom QtÃ© Prix Valeur\rP001 Clavier USB 25 29.99 749.75\rP002 Souris sans fil 12 19.99 239.88\rP003 Ã‰cran 24\" 0 299.99 0.00\rTotal produits : 3\rValeur totale : 989.63$ 30 : Convertisseur dâ€™UnitÃ©s Universel Concepts pratiquÃ©s : Dictionary, mÃ©thodes, conversions, switch/case\nDescription : DÃ©veloppez un convertisseur complet pour diffÃ©rentes catÃ©gories dâ€™unitÃ©s.\nFonctionnalitÃ©s requises :\nCatÃ©gories de conversion : Longueur (m, km, cm, mm, miles, yards, pieds, pouces) Poids (kg, g, mg, livres, onces) TempÃ©rature (Celsius, Fahrenheit, Kelvin) Volume (L, mL, gallons, pintes) Utiliser des Dictionary pour les facteurs de conversion MÃ©thodes pour chaque catÃ©gorie de conversion Menu pour sÃ©lectionner la catÃ©gorie Afficher toutes les conversions possibles depuis lâ€™unitÃ© saisie MÃ©thodes suggÃ©rÃ©es :\nstatic Dictionary\u003cstring, double\u003e facteursLongueur = new Dictionary\u003cstring, double\u003e { { \"m\", 1 }, { \"km\", 1000 }, { \"cm\", 0.01 }, // etc. }; static double ConvertirLongueur(double valeur, string deUnite, string versUnite) static double ConvertirTemperature(double valeur, string deUnite, string versUnite) static void AfficherToutesConversions(double valeur, string unite, string categorie) Exemple dâ€™exÃ©cution :\n=== Convertisseur d'UnitÃ©s ===\r1. Longueur\r2. Poids\r3. TempÃ©rature\r4. Volume\r5. Quitter\rChoix : 1\rValeur : 5\rUnitÃ© de dÃ©part : m\r5 mÃ¨tres =\r- 5000 millimÃ¨tres\r- 500 centimÃ¨tres\r- 0.005 kilomÃ¨tres\r- 5.468 yards\r- 16.404 pieds\r- 196.850 pouces\r- 0.003 miles 31 : GÃ©nÃ©rateur de Mots de Passe SÃ©curisÃ©s Concepts pratiquÃ©s : Tableaux, Random, mÃ©thodes, string manipulation, validation\nDescription : CrÃ©ez un gÃ©nÃ©rateur de mots de passe avec options de personnalisation et vÃ©rification de force.\nFonctionnalitÃ©s requises :\nOptions configurables : Longueur du mot de passe (8-50 caractÃ¨res) Inclure majuscules (A-Z) Inclure minuscules (a-z) Inclure chiffres (0-9) Inclure symboles (!@#$%^\u0026*) GÃ©nÃ©rer plusieurs mots de passe Ã  la fois CrÃ©er une mÃ©thode pour Ã©valuer la force du mot de passe (faible/moyen/fort) Ã‰viter les caractÃ¨res ambigus (0/O, 1/l/I) Permettre de sauvegarder les mots de passe gÃ©nÃ©rÃ©s dans une List MÃ©thodes suggÃ©rÃ©es :\nstatic char[] majuscules = \"ABCDEFGHJKLMNPQRSTUVWXYZ\".ToCharArray(); static char[] minuscules = \"abcdefghijkmnopqrstuvwxyz\".ToCharArray(); static char[] chiffres = \"23456789\".ToCharArray(); static char[] symboles = \"!@#$%^\u0026*\".ToCharArray(); static string GenererMotDePasse(int longueur, bool maj, bool min, bool chif, bool sym) static string EvaluerForce(string motDePasse) static List\u003cchar\u003e CreerPoolDeCaracteres(bool maj, bool min, bool chif, bool sym) Exemple dâ€™exÃ©cution :\n=== GÃ©nÃ©rateur de Mots de Passe ===\rLongueur (8-50) : 16\rInclure majuscules ? (o/n) : o\rInclure minuscules ? (o/n) : o\rInclure chiffres ? (o/n) : o\rInclure symboles ? (o/n) : o\rMots de passe gÃ©nÃ©rÃ©s :\r1. kT8#mPq2nL9@wXz5 (Force: Fort)\r2. Vy3$bNr7hK4\u0026qWm2 (Force: Fort)\r3. Jp6%dGt8sM3!xZn9 (Force: Fort)\rGÃ©nÃ©rer d'autres mots de passe ? (o/n) 32 : Calculatrice de PrÃªt HypothÃ©caire Concepts pratiquÃ©s : MÃ©thodes, calculs financiers, tableaux, formatage, boucles\nDescription : DÃ©veloppez une calculatrice qui calcule les paiements mensuels et gÃ©nÃ¨re un tableau dâ€™amortissement.\nFonctionnalitÃ©s requises :\nDemander : Montant du prÃªt Taux dâ€™intÃ©rÃªt annuel DurÃ©e en annÃ©es Calculer le paiement mensuel avec la formule : M = P[r(1+r)^n]/[(1+r)^n-1] M = paiement mensuel P = montant principal r = taux mensuel n = nombre de paiements Utiliser des tableaux pour stocker : double[] paiements double[] interets double[] capital double[] soldes Afficher les premiers et derniers mois Calculer le total des intÃ©rÃªts payÃ©s Option : comparer diffÃ©rents scÃ©narios MÃ©thodes suggÃ©rÃ©es :\nstatic double CalculerPaiementMensuel(double montant, double tauxAnnuel, int annees) static void GenererTableauAmortissement(double montant, double tauxAnnuel, int annees, out double[] paiements, out double[] interets, out double[] capital, out double[] soldes) static void AfficherLigneTableau(int mois, double paiement, double interet, double cap, double solde) static double CalculerTotalInterets(double[] interets) Exemple dâ€™exÃ©cution :\n=== Calculatrice HypothÃ©caire ===\rMontant du prÃªt : 300000\rTaux d'intÃ©rÃªt annuel (%) : 3.5\rDurÃ©e (annÃ©es) : 25\rPaiement mensuel : 1498.88$\rTotal des intÃ©rÃªts : 149664.00$\rTotal Ã  rembourser : 449664.00$\r--- Tableau d'amortissement (premiers mois) ---\rMois Paiement IntÃ©rÃªts Capital Solde\r1 1498.88 875.00 623.88 299376.12\r2 1498.88 873.18 625.70 298750.42\r3 1498.88 871.36 627.52 298122.90\r4 1498.88 869.53 629.35 297493.55\r5 1498.88 867.69 631.19 296862.36\r...\rAfficher tous les mois ? (o/n) 33 : SystÃ¨me de Quiz avec Banque de Questions Concepts pratiquÃ©s : Tableaux parallÃ¨les, mÃ©thodes, Random, score, validation\nDescription : CrÃ©ez un systÃ¨me de quiz interactif avec diffÃ©rentes catÃ©gories et suivi des rÃ©sultats.\nFonctionnalitÃ©s requises :\nUtiliser des tableaux parallÃ¨les pour stocker les questions : string[] questions string[] choixA, choixB, choixC, choixD int[] bonnesReponses (1-4) string[] categories CrÃ©er une banque dâ€™au moins 15 questions MÃ©thodes pour : SÃ©lectionner des questions alÃ©atoires Afficher une question avec ses choix Valider la rÃ©ponse de lâ€™utilisateur Calculer le score Afficher les statistiques finales Filtrer par catÃ©gorie MÃ©langer lâ€™ordre des questions EmpÃªcher les doublons dans un mÃªme quiz MÃ©thodes suggÃ©rÃ©es :\nstatic string[] questions = new string[50]; static string[] choixA = new string[50]; static string[] choixB = new string[50]; static string[] choixC = new string[50]; static string[] choixD = new string[50]; static int[] bonnesReponses = new int[50]; static string[] categories = new string[50]; static int nombreQuestions = 0; static void InitialiserQuestions() static int[] SelectionnerQuestionsAleatoires(int nombre) static void AfficherQuestion(int index) static bool VerifierReponse(int index, int reponseUtilisateur) static void AfficherResultats(int bonnes, int totales) Exemple dâ€™exÃ©cution :\n=== Quiz C# ===\rCatÃ©gories disponibles :\r1. Programmation C#\r2. MathÃ©matiques\r3. Culture gÃ©nÃ©rale\r4. Toutes catÃ©gories\rChoix : 1\rNombre de questions : 5\r--- Question 1/5 ---\rCatÃ©gorie : Programmation C#\rQuel est le rÃ©sultat de 5 % 2 en C# ?\r1. 2.5\r2. 1\r3. 2\r4. 0\rVotre rÃ©ponse : 2\râœ“ Correct !\rScore actuel : 1/1\r--- Question 2/5 ---\r...\r=== RÃ©sultats finaux ===\rBonnes rÃ©ponses : 4/5 (80%)\rMauvaises rÃ©ponses : 1/5 (20%)\rNote : B+ 34 : Simulateur de Compte Bancaire avec Historique Concepts pratiquÃ©s : List, mÃ©thodes, DateTime, formatage, validation\nDescription : DÃ©veloppez un simulateur de compte bancaire complet avec transactions et historique dÃ©taillÃ©.\nFonctionnalitÃ©s requises :\nVariables globales pour le compte : string numeroCompte string titulaire double solde Utiliser des List pour lâ€™historique : List typesTransactions (Depot, Retrait, etc.) List montants List dates List soldesApres List descriptions MÃ©thodes pour : DÃ©poser (ajouter Ã  lâ€™historique) Retirer (avec vÃ©rification solde, ajouter Ã  lâ€™historique) Afficher lâ€™historique complet Afficher les dÃ©pÃ´ts seulement Afficher les retraits seulement Calculer solde moyen sur une pÃ©riode Afficher les transactions dâ€™un mois spÃ©cifique Calculer des intÃ©rÃªts mensuels (bonus) MÃ©thodes suggÃ©rÃ©es :\nstatic string numeroCompte = \"12345-67890\"; static string titulaire = \"Jean Tremblay\"; static double solde = 1000.00; static List\u003cstring\u003e typesTransactions = new List\u003cstring\u003e(); static List\u003cdouble\u003e montants = new List\u003cdouble\u003e(); static List\u003cDateTime\u003e dates = new List\u003cDateTime\u003e(); static List\u003cdouble\u003e soldesApres = new List\u003cdouble\u003e(); static List\u003cstring\u003e descriptions = new List\u003cstring\u003e(); static bool Deposer(double montant, string description) static bool Retirer(double montant, string description) static void AfficherHistorique() static void FiltrerParType(string type) static void FiltrerParMois(int mois, int annee) static double CalculerSoldeMoyen() Exemple dâ€™exÃ©cution :\n=== Compte Bancaire - Jean Tremblay ===\rNumÃ©ro : 12345-67890\rSolde actuel : 1500.00$\r1. DÃ©poser\r2. Retirer\r3. Historique complet\r4. Voir dÃ©pÃ´ts uniquement\r5. Voir retraits uniquement\r6. Statistiques\r7. Quitter\rChoix : 3\r--- Historique des transactions ---\rDate Type Montant Solde Description\r2026-01-15 10:30 DÃ©pÃ´t +500.00 1500.00 Paie janvier\r2026-01-16 14:20 Retrait -50.00 1450.00 Ã‰picerie\r2026-01-18 09:15 DÃ©pÃ´t +200.00 1650.00 Remboursement\r2026-01-20 16:45 Retrait -150.00 1500.00 Facture tÃ©lÃ©phone\rTotal transactions : 4\rSolde moyen : 1537.50$ 35 : Simulateur de Machine Ã  Sous (Slot Machine) Concepts pratiquÃ©s : Random, tableaux, mÃ©thodes, boucles, calculs\nDescription : CrÃ©ez un jeu de machine Ã  sous avec 3 rouleaux et diffÃ©rentes combinaisons gagnantes.\nFonctionnalitÃ©s requises :\nDÃ©finir les symboles possibles : ğŸ’ (Cerise), ğŸ‹ (Citron), ğŸŠ (Orange), ğŸ‡ (Raisin), ğŸ’ (Diamant), 7ï¸âƒ£ (Sept) Utiliser un tableau de string pour les symboles Variables pour : Solde du joueur Mise actuelle MÃ©thodes pour : Tourner les 3 rouleaux (gÃ©nÃ©rer 3 symboles alÃ©atoires) Afficher les rouleaux VÃ©rifier les combinaisons gagnantes : 3 identiques : Jackpot (mise Ã— 50) 3 Sept : Super Jackpot (mise Ã— 100) 2 identiques : Petit gain (mise Ã— 5) 3 Diamants : Gros gain (mise Ã— 25) Calculer les gains GÃ©rer le solde du joueur Historique des gains et pertes MÃ©thodes suggÃ©rÃ©es :\nstatic string[] symboles = { \"ğŸ’\", \"ğŸ‹\", \"ğŸŠ\", \"ğŸ‡\", \"ğŸ’\", \"7ï¸âƒ£\" }; static Random rand = new Random(); static double solde = 100.00; static string[] TournerRouleaux() static void AfficherRouleaux(string[] rouleaux) static double CalculerGain(string[] rouleaux, double mise) static bool VerifierTroisIdentiques(string[] rouleaux) static bool VerifierDeuxIdentiques(string[] rouleaux) Exemple dâ€™exÃ©cution :\n=== Machine Ã  Sous ğŸ° ===\rSolde : 100.00$\rSymboles :\rğŸ’ Cerise ğŸ‹ Citron ğŸŠ Orange\rğŸ‡ Raisin ğŸ’ Diamant 7ï¸âƒ£ Sept\rEntrez votre mise (min 1$, max 10$) : 5\râ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”\râ”‚ ğŸ’ â”‚ ğŸ’ â”‚ ğŸ‹ â”‚\râ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜\rDeux cerises ! Vous gagnez 25.00$ !\rSolde : 120.00$\rRejouer ? (o/n) : o\rEntrez votre mise : 10\râ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”\râ”‚ ğŸ’ â”‚ ğŸ’ â”‚ ğŸ’ â”‚\râ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜\rJACKPOT ! Trois diamants !\rVous gagnez 250.00$ !\rSolde : 360.00$ 36 : Planificateur de TÃ¢ches avec PrioritÃ©s Concepts pratiquÃ©s : List, tableaux parallÃ¨les, mÃ©thodes, tri, DateTime\nDescription : DÃ©veloppez une application de gestion de tÃ¢ches avec catÃ©gories, prioritÃ©s et Ã©chÃ©ances.\nFonctionnalitÃ©s requises :\nUtiliser des List pour stocker les tÃ¢ches : List titres List descriptions List priorites (1=Basse, 2=Moyenne, 3=Haute, 4=Urgente) List categories List datesEcheance List statuts (1=Ã€ faire, 2=En cours, 3=TerminÃ©e) MÃ©thodes pour : Ajouter une tÃ¢che Modifier une tÃ¢che Marquer comme terminÃ©e Supprimer une tÃ¢che Afficher toutes les tÃ¢ches Filtrer par prioritÃ©, catÃ©gorie ou statut Trier par date dâ€™Ã©chÃ©ance ou prioritÃ© Afficher les tÃ¢ches en retard Statistiques (nombre par statut, taux de complÃ©tion) MÃ©thodes suggÃ©rÃ©es :\nstatic List\u003cstring\u003e titres = new List\u003cstring\u003e(); static List\u003cstring\u003e descriptions = new List\u003cstring\u003e(); static List\u003cint\u003e priorites = new List\u003cint\u003e(); static List\u003cstring\u003e categories = new List\u003cstring\u003e(); static List\u003cDateTime\u003e datesEcheance = new List\u003cDateTime\u003e(); static List\u003cint\u003e statuts = new List\u003cint\u003e(); static void AjouterTache() static void AfficherTaches() static void FiltrerParPriorite(int priorite) static void AfficherTachesEnRetard() static void AfficherStatistiques() static string ObtenirNomPriorite(int priorite) static string ObtenirNomStatut(int statut) static int CalculerJoursRestants(DateTime dateEcheance) Exemple dâ€™exÃ©cution :\n=== Planificateur de TÃ¢ches ===\r1. Ajouter tÃ¢che\r2. Voir toutes les tÃ¢ches\r3. Filtrer\r4. Marquer terminÃ©e\r5. TÃ¢ches en retard\r6. Statistiques\r7. Quitter\rChoix : 2\r--- Toutes les tÃ¢ches ---\r[1] [URGENTE] Terminer C# - CatÃ©gorie: Ã‰cole\rÃ‰chÃ©ance: 2026-02-05 (6 jours) - Statut: En cours\rDescription: ComplÃ©ter les 40 mini-s\r[2] [HAUTE] RÃ©viser pour examen - CatÃ©gorie: Ã‰cole\rÃ‰chÃ©ance: 2026-02-10 (11 jours) - Statut: Ã€ faire\rDescription: RÃ©viser chapitres 1 Ã  5\r[3] [MOYENNE] Faire l'Ã©picerie - CatÃ©gorie: Personnel\rÃ‰chÃ©ance: 2026-02-01 (2 jours) - Statut: Ã€ faire\rDescription: Acheter fruits et lÃ©gumes 37 : SystÃ¨me de Sondage et Analyse Concepts pratiquÃ©s : List, Dictionary, mÃ©thodes, statistiques, pourcentages\nDescription : CrÃ©ez un systÃ¨me pour crÃ©er des sondages, collecter des rÃ©ponses et analyser les rÃ©sultats.\nFonctionnalitÃ©s requises :\nUtiliser des List pour stocker les questions : List questions List option1, option2, option3, option4 Utiliser Dictionary\u003cstring, int\u003e pour compter les rÃ©ponses ClÃ© : â€œQuestion1_Option1â€, â€œQuestion1_Option2â€, etc. MÃ©thodes pour : CrÃ©er un sondage (ajouter questions et options) RÃ©pondre au sondage (un participant Ã  la fois) Afficher les rÃ©sultats : Calculer les pourcentages pour chaque option Afficher un graphique en mode texte (barres ASCII) Trouver lâ€™option la plus populaire Calculer le nombre total de participants RÃ©initialiser les rÃ©sultats MÃ©thodes suggÃ©rÃ©es :\nstatic List\u003cstring\u003e questions = new List\u003cstring\u003e(); static List\u003cstring\u003e option1 = new List\u003cstring\u003e(); static List\u003cstring\u003e option2 = new List\u003cstring\u003e(); static List\u003cstring\u003e option3 = new List\u003cstring\u003e(); static List\u003cstring\u003e option4 = new List\u003cstring\u003e(); static Dictionary\u003cstring, int\u003e reponses = new Dictionary\u003cstring, int\u003e(); static int nombreParticipants = 0; static void CreerSondage() static void RemplirSondage() static void AnalyserResultats() static void AfficherGraphique(int questionIndex) static double CalculerPourcentage(int nbReponses, int total) static string GenererBarre(double pourcentage) Exemple dâ€™exÃ©cution :\n=== SystÃ¨me de Sondage ===\r1. CrÃ©er sondage\r2. RÃ©pondre Ã  un sondage\r3. Voir rÃ©sultats\r4. Quitter\rChoix : 3\rSondage : Satisfaction des Ã©tudiants\rParticipants : 20\rQuestion 1: Comment Ã©valuez-vous la qualitÃ© du cours ?\rExcellent : â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 45% (9 rÃ©ponses)\rBon : â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 30% (6 rÃ©ponses)\rMoyen : â–ˆâ–ˆâ–ˆâ–ˆ 15% (3 rÃ©ponses)\rFaible : â–ˆâ–ˆ 10% (2 rÃ©ponses)\rQuestion 2: Recommanderiez-vous ce cours ?\rOui, certainement : â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 60% (12 rÃ©ponses)\rProbablement oui : â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 25% (5 rÃ©ponses)\rProbablement non : â–ˆâ–ˆâ–ˆâ–ˆ 10% (2 rÃ©ponses)\rNon, certainement pas : â–ˆâ–ˆ 5% (1 rÃ©ponse)\rOption la plus populaire : \"Oui, certainement\" 38 : Jeu de MÃ©moire avec Cartes Concepts pratiquÃ©s : Tableaux, List, mÃ©thodes, Random, logique de jeu, temps\nDescription : DÃ©veloppez un jeu de mÃ©moire simplifiÃ© oÃ¹ il faut retrouver les paires de nombres identiques.\nFonctionnalitÃ©s requises :\nCrÃ©er un tableau de 16 cartes (8 paires de nombres de 1 Ã  8) Utiliser des tableaux pour gÃ©rer lâ€™Ã©tat : int[] valeurs (contient les nombres 1-8 en double) bool[] estVisible (true si carte retournÃ©e) bool[] estTrouvee (true si paire trouvÃ©e) MÃ©langer les cartes au dÃ©but MÃ©thodes pour : Initialiser et mÃ©langer les cartes Afficher toutes les cartes (cachÃ©es sauf visibles et trouvÃ©es) Retourner une carte (par sa position 0-15) VÃ©rifier si deux cartes forment une paire Compter le nombre de coups VÃ©rifier si toutes les paires sont trouvÃ©es EmpÃªcher de retourner plus de 2 cartes Ã  la fois Afficher le temps Ã©coulÃ© MÃ©thodes suggÃ©rÃ©es :\nstatic int[] valeurs = new int[16]; static bool[] estVisible = new bool[16]; static bool[] estTrouvee = new bool[16]; static Random rand = new Random(); static int nombreCoups = 0; static void InitialiserJeu() static void MelangerCartes() static void AfficherCartes() static void RetournerCarte(int position) static bool VerifierPaire(int pos1, int pos2) static bool JeuTermine() Exemple dâ€™exÃ©cution :\n=== Jeu de MÃ©moire ğŸ´ ===\rPositions : 0 Ã  15\r0 1 2 3 4 5 6 7\r[?] [?] [?] [?] [?] [?] [?] [?]\r8 9 10 11 12 13 14 15\r[?] [?] [?] [?] [?] [?] [?] [?]\rPaires trouvÃ©es : 0/8\rCoups : 0\rPremiÃ¨re carte (0-15) : 3\r0 1 2 3 4 5 6 7\r[?] [?] [?] [5] [?] [?] [?] [?]\rDeuxiÃ¨me carte (0-15) : 11\r0 1 2 3 4 5 6 7\r[?] [?] [?] [5] [?] [?] [?] [?]\r8 9 10 11 12 13 14 15\r[?] [?] [?] [3] [?] [?] [?] [?]\rPas de paire ! Cartes cachÃ©es...\rPaires trouvÃ©es : 0/8\rCoups : 1 39 : Calculatrice de Budget Personnel Concepts pratiquÃ©s : List, Dictionary, mÃ©thodes, calculs financiers, DateTime\nDescription : CrÃ©ez une application complÃ¨te pour gÃ©rer un budget personnel avec revenus, dÃ©penses et analyse.\nFonctionnalitÃ©s requises :\nUtiliser des List pour stocker les transactions : List types (â€œRevenuâ€ ou â€œDepenseâ€) List montants List categories (Salaire, Ã‰picerie, Transport, Loisirs, etc.) List dates List descriptions Utiliser un Dictionary\u003cstring, double\u003e pour les budgets prÃ©vus par catÃ©gorie MÃ©thodes pour : Ajouter revenu/dÃ©pense Afficher le rÃ©sumÃ© mensuel Calculer solde actuel Afficher dÃ©penses par catÃ©gorie (avec pourcentages) Comparer budget prÃ©vu vs rÃ©el Afficher graphique en barres des dÃ©penses Identifier les plus grosses dÃ©penses Filtrer par mois MÃ©thodes suggÃ©rÃ©es :\nstatic List\u003cstring\u003e types = new List\u003cstring\u003e(); static List\u003cdouble\u003e montants = new List\u003cdouble\u003e(); static List\u003cstring\u003e categories = new List\u003cstring\u003e(); static List\u003cDateTime\u003e dates = new List\u003cDateTime\u003e(); static List\u003cstring\u003e descriptions = new List\u003cstring\u003e(); static Dictionary\u003cstring, double\u003e budgetsPrevus = new Dictionary\u003cstring, double\u003e(); static void AjouterTransaction() static double CalculerRevenusMois(int mois, int annee) static double CalculerDepensesMois(int mois, int annee) static Dictionary\u003cstring, double\u003e DepensesParCategorie(int mois, int annee) static void AfficherResumeMensuel(int mois, int annee) static void AfficherGraphiqueDepenses(Dictionary\u003cstring, double\u003e depenses, double total) static string GenererBarre(double pourcentage) Exemple dâ€™exÃ©cution :\n=== Budget Personnel - Janvier 2026 ===\rRevenus totaux : 3200.00$\rDÃ©penses totales : 2450.00$\rSolde : +750.00$\r--- DÃ©penses par catÃ©gorie ---\rLoyer : 1200.00$ (49%) â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\rÃ‰picerie : 450.00$ (18%) â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\rTransport : 200.00$ (8%) â–ˆâ–ˆâ–ˆ\rLoisirs : 300.00$ (12%) â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\rTÃ©lÃ©phone : 80.00$ (3%) â–ˆ\rAutres : 220.00$ (9%) â–ˆâ–ˆâ–ˆâ–ˆ\r--- Budget prÃ©vu vs rÃ©el ---\rÃ‰picerie : 450$ / 500$ (sous budget de 50$)\rTransport : 200$ / 150$ (dÃ©passement de 50$)\rLoisirs : 300$ / 250$ (dÃ©passement de 50$)\rPlus grosses dÃ©penses du mois :\r1. Loyer - 1200.00$ (2026-01-01)\r2. Ã‰picerie Costco - 180.00$ (2026-01-15)\r3. Restaurant - 120.00$ (2026-01-20) 40 : Simulateur de Tournoi Sportif (Round-Robin) Concepts pratiquÃ©s : List, tableaux parallÃ¨les, mÃ©thodes, algorithmes, tri\nDescription : DÃ©veloppez un systÃ¨me pour gÃ©rer un tournoi sportif oÃ¹ chaque Ã©quipe affronte toutes les autres.\nFonctionnalitÃ©s requises :\nUtiliser des tableaux/listes parallÃ¨les pour stocker les Ã©quipes : List nomsEquipes List victoires List defaites List nulles List pointsMarques List pointsEncaisses CrÃ©er des List pour les matches : List equipe1 List equipe2 List score1 List score2 List rondes MÃ©thodes pour : Ajouter des Ã©quipes GÃ©nÃ©rer le calendrier complet (round-robin) Simuler un match (alÃ©atoire ou saisie manuelle) Enregistrer les rÃ©sultats Mettre Ã  jour les classements Afficher le classement actuel Afficher les matches Ã  venir Calculer les statistiques (diffÃ©rentiel de points, taux de victoire) MÃ©thodes suggÃ©rÃ©es :\nstatic List\u003cstring\u003e nomsEquipes = new List\u003cstring\u003e(); static List\u003cint\u003e victoires = new List\u003cint\u003e(); static List\u003cint\u003e defaites = new List\u003cint\u003e(); static List\u003cint\u003e nulles = new List\u003cint\u003e(); static List\u003cint\u003e pointsMarques = new List\u003cint\u003e(); static List\u003cint\u003e pointsEncaisses = new List\u003cint\u003e(); static List\u003cstring\u003e matchEquipe1 = new List\u003cstring\u003e(); static List\u003cstring\u003e matchEquipe2 = new List\u003cstring\u003e(); static List\u003cint\u003e matchScore1 = new List\u003cint\u003e(); static List\u003cint\u003e matchScore2 = new List\u003cint\u003e(); static void AjouterEquipe(string nom) static void GenererCalendrier() static void SimulerMatch(int indexMatch) static void EnregistrerResultat(string equipe1, string equipe2, int score1, int score2) static void AfficherClassement() static int TrouverIndexEquipe(string nom) static double CalculerTauxVictoire(int index) static int CalculerPoints(int index) // Victoire = 3pts, Nulle = 1pt Exemple dâ€™exÃ©cution :\n=== Tournoi de Hockey Round-Robin ===\rParticipants : 6 Ã©quipes\rNombre total de matches : 15\r--- Classement aprÃ¨s ronde 3 ---\rPos Ã‰quipe Pts V N D PM PE Diff\r1 Canadiens MTL 9 3 0 0 15 8 +7\r2 Maple Leafs TOR 6 2 0 1 12 10 +2\r3 Bruins BOS 6 2 0 1 10 9 +1\r4 Senators OTT 3 1 0 2 9 11 -2\r5 Sabres BUF 3 1 0 2 7 10 -3\r6 Red Wings DET 0 0 0 3 5 10 -5\r--- Prochaine ronde (Ronde 4) ---\rCanadiens MTL vs Senators OTT\rMaple Leafs TOR vs Red Wings DET\rBruins BOS vs Sabres BUF\r1. Simuler ronde suivante\r2. Entrer rÃ©sultats manuellement\r3. Afficher statistiques\r4. Quitter Bonnes Pratiques Nommage : Utilisez des noms descriptifs (camelCase pour variables, PascalCase pour mÃ©thodes) Commentaires : Expliquez les parties complexes de votre code Validation : VÃ©rifiez toujours les entrÃ©es utilisateur Gestion dâ€™erreurs : Utilisez try-catch pour les opÃ©rations risquÃ©es ModularitÃ© : Divisez votre code en mÃ©thodes rÃ©utilisables Tests : Testez tous les scÃ©narios possibles DeuxiÃ¨me partie 1. Le Distributeur de Breuvages Intelligent ScÃ©nario : Vous gÃ©rez une machine qui vend du CafÃ© (2.50$), du ThÃ© (2.00$) et du Chocolat (3.00$). Exigences : CrÃ©er une mÃ©thode AfficherMenu() qui montre les choix et les prix. Lâ€™utilisateur entre un montant. Si le montant est insuffisant, redemander de lâ€™argent ou annuler. Calculer la monnaie Ã  rendre en utilisant le moins de piÃ¨ces possible (piÃ¨ces de 2$, 1$, 0.25$, 0.10$). Notions : while, switch, opÃ©rateurs modulo %. 2. Analyseur de DonnÃ©es MÃ©tÃ©o (Statistiques) ScÃ©nario : Un centre mÃ©tÃ©o a besoin dâ€™analyser les tempÃ©ratures dâ€™une semaine. Exigences : Stocker 7 valeurs double dans un tableau. MÃ©thode CalculerMoyenne(double[] temp) : retourne la moyenne. MÃ©thode TrouverExtremes(double[] temp) : affiche la plus haute et la plus basse sans Max() ou Min(). Afficher un histogramme simple dans la console (ex: 22Â°C = **********). Notions : Boucles for, algorithme de recherche de minimum/maximum. 3. Gestionnaire de Contacts avec Recherche Floue ScÃ©nario : Une liste de noms simple mais interactive. Exigences : Utiliser une List\u003cstring\u003e pour stocker les noms. Menu : 1. Ajouter, 2. Supprimer par nom, 3. Rechercher, 4. Quitter. La recherche doit afficher tous les noms qui contiennent la lettre ou la syllabe saisie (ex: â€œanâ€ trouve â€œAndrÃ©â€ et â€œChantalâ€). Notions : List\u003cT\u003e, mÃ©thode string.Contains(), foreach. 4. SystÃ¨me de Facturation de Magasin ScÃ©nario : Calculer le total dâ€™un panier dâ€™achat avec taxes. Exigences : Lâ€™utilisateur saisit des prix jusquâ€™Ã  ce quâ€™il entre -1. GÃ©rer un tableau de â€œrabaisâ€ : si le prix \u003e 100$, appliquer 10% de rÃ©duction avant taxes. MÃ©thode CalculerTaxes(double total) : retourne le montant des taxes (TPS 5%, TVQ 9.975%). Notions : Accumulateurs, constantes, mÃ©thodes de calcul. 5. Jeu du Pendu : Le DÃ©fi des CaractÃ¨res ScÃ©nario : Deviner un mot cachÃ© lettre par lettre. Exigences : Le mot secret est un char[]. CrÃ©er un second char[] rempli de _. Lâ€™Ã©tudiant doit comparer la lettre saisie avec chaque caractÃ¨re du mot secret. GÃ©rer un maximum de 6 erreurs. Notions : Tableaux de caractÃ¨res, manipulation dâ€™index. 6. Bureau de Scrutin Virtuel ScÃ©nario : Compter les votes pour une Ã©lection Ã  3 candidats. Exigences : Utiliser un Dictionary\u003cstring, int\u003e oÃ¹ la clÃ© est le nom du candidat. Boucle de vote : lâ€™utilisateur tape le nom ou le numÃ©ro du candidat. MÃ©thode AfficherGagnant() : parcourt le dictionnaire pour trouver la valeur la plus Ã©levÃ©e. Notions : Dictionnaires, itÃ©ration sur paires ClÃ©/Valeur. 7. Validateur de ComplexitÃ© de Mot de Passe ScÃ©nario : SÃ©curiser la crÃ©ation de compte. Exigences : CrÃ©er une mÃ©thode VerifierForce(string mdp) qui retourne un score de 1 Ã  5. CritÃ¨res : +1 si \u003e 8 car., +1 si majuscule, +1 si chiffre, +1 si symbole (#, !, $), +1 si \u003e 12 car. Utiliser des boucles pour inspecter chaque caractÃ¨re. Notions : char.IsUpper, char.IsDigit, char.IsPunctuation. 8. Convertisseur de Devises avec Historique ScÃ©nario : Changer de lâ€™argent et garder une trace des transactions. Exigences : Utiliser un tableau double[] fixe pour les taux (USD, EUR, GBP). Chaque conversion effectuÃ©e est ajoutÃ©e sous forme de chaÃ®ne (ex: â€œ10 CAD -\u003e 7 USDâ€) dans une List\u003cstring\u003e. Option pour afficher lâ€™historique complet Ã  la fin. Notions : Tableaux, listes, formatage de texte. 9. Bataille Navale : Tactique 1D ScÃ©nario : DÃ©truire des navires cachÃ©s dans une ligne de 10 cases. Exigences : Un tableau bool[10] oÃ¹ 3 cases alÃ©atoires sont true. Lâ€™utilisateur choisit un index. Afficher â€œTouchÃ©â€ ou â€œÃ€ lâ€™eauâ€. Le jeu sâ€™arrÃªte quand les 3 bateaux sont coulÃ©s. Notions : Random, do-while, tableaux de boolÃ©ens. 10. Calculateur de Moyennes Multidimensionnel ScÃ©nario : GÃ©rer les notes dâ€™une classe de 3 Ã©tudiants ayant chacun 4 examens. Exigences : DÃ©clarer un double[3, 4]. Remplir le tableau via des saisies utilisateur. MÃ©thode MoyenneEtudiant(int index) : calcule la moyenne dâ€™une ligne. MÃ©thode MoyenneExamen(int index) : calcule la moyenne dâ€™une colonne. Notions : Tableaux 2D, boucles imbriquÃ©es. 11. Simulateur de File dâ€™Attente (Banque) ScÃ©nario : GÃ©rer lâ€™ordre de passage des clients. Exigences : Une List\u003cstring\u003e simulant une file dâ€™attente. Options : â€œNouveau clientâ€, â€œServir prochainâ€, â€œAfficher fileâ€. â€œServir prochainâ€ doit afficher le nom et retirer le premier Ã©lÃ©ment (index 0). Notions : List.Add(), List.RemoveAt(). 12. CrÃ©ateur de Deck de Cartes et MÃ©langeur ScÃ©nario : GÃ©nÃ©rer et mÃ©langer un jeu de 52 cartes. Exigences : Deux tableaux : couleurs (Pique, Coeurâ€¦) et valeurs (As, 2, 3â€¦). GÃ©nÃ©rer les 52 combinaisons dans une List\u003cstring\u003e. Algorithme de mÃ©lange : Ã©changer chaque carte avec une autre Ã  un index alÃ©atoire. Notions : Boucles imbriquÃ©es, algorithme de permutation (Swap). 13. DÃ©tecteur de Palindromes et de â€œMirroringâ€ ScÃ©nario : Analyser si un mot est identique Ã  lâ€™envers. Exigences : Saisir un mot. CrÃ©er une mÃ©thode EstPalindrome(string mot). Inverser la chaÃ®ne manuellement dans un tableau de caractÃ¨res pour comparer. Ne pas utiliser Array.Reverse(). Notions : Boucle for dÃ©croissante, manipulation de chaÃ®nes. 14. Inventaire de Magasin (Tableaux DentelÃ©s) ScÃ©nario : GÃ©rer des rayons de diffÃ©rentes tailles. Exigences : Un tableau dentelÃ© string[][] rayons = new string[3][]. Rayon 1 : 2 produits, Rayon 2 : 5 produits, Rayon 3 : 3 produits. Lâ€™utilisateur peut modifier un produit en spÃ©cifiant [rayon, index]. Notions : Jagged Arrays, gestion des limites de tableaux. 15. Le Juste Prix (Multi-joueurs) ScÃ©nario : Deviner un prix secret gÃ©nÃ©rÃ© alÃ©atoirement. Exigences : Le programme gÃ©nÃ¨re un nombre entre 1 et 1000. Plusieurs joueurs entrent leur nom. Chacun joue Ã  tour de rÃ´le. Le programme indique â€œCâ€™est plus !â€ ou â€œCâ€™est moins !â€. Notions : Random, listes de noms, boucle de jeu. 16. SystÃ¨me de Login avec Blocage ScÃ©nario : SÃ©curiser lâ€™accÃ¨s Ã  une console. Exigences : Stocker les utilisateurs/mots de passe dans deux tableaux parallÃ¨les ou un dictionnaire. Lâ€™utilisateur a 3 tentatives. AprÃ¨s 3 erreurs, le programme se verrouille (utilise Thread.Sleep pour simuler une attente). Notions : Compteurs, conditions logiques, sÃ©curitÃ© de base. 17. Analyseur de Texte : Compteur de Mots ScÃ©nario : Analyser la structure dâ€™un paragraphe. Exigences : Lâ€™utilisateur entre un long texte. Compter le nombre de mots (dÃ©limitÃ©s par des espaces). Compter lâ€™occurrence dâ€™une lettre spÃ©cifique demandÃ©e Ã  lâ€™utilisateur. Notions : string.Split(), foreach, compteurs. 18. Calculateur dâ€™IMC Professionnel ScÃ©nario : SantÃ© et nutrition. Exigences : Saisir le nom, le poids et la taille de plusieurs patients. Calculer lâ€™IMC ($poids / taille^2$). MÃ©thode InterpreterIMC(double imc) : retourne une chaÃ®ne (Maigreur, Normal, ObÃ¨se). Notions : MÃ©thodes de retour, formules mathÃ©matiques. 19. Gestionnaire de TÃ¢ches avec PrioritÃ© ScÃ©nario : Une To-Do List intelligente. Exigences : Stocker les tÃ¢ches dans une liste. Lâ€™utilisateur peut ajouter une tÃ¢che avec un niveau dâ€™importance (Haute, Moyenne, Basse). Afficher les tÃ¢ches filtrÃ©es manuellement : dâ€™abord toutes les â€œHauteâ€, ensuite les autres. Notions : Filtrage par boucles, comparaisons de chaÃ®nes. 20. Le CarrÃ© Magique (Validation de Grille) ScÃ©nario : VÃ©rifier si une grille 3x3 est un carrÃ© magique. Exigences : Lâ€™utilisateur entre 9 nombres dans un tableau int[3, 3]. Le programme doit calculer la somme de chaque ligne, chaque colonne et des deux diagonales. Si toutes les sommes sont Ã©gales, câ€™est un carrÃ© magique ! Notions : Algorithmique avancÃ©e sur tableaux 2D.",
    "description": "PremiÃ¨re partie 1 : Calculatrice Simple Concepts pratiquÃ©s : Variables, opÃ©rateurs arithmÃ©tiques, types numÃ©riques\nDescription : CrÃ©ez un programme qui demande Ã  lâ€™utilisateur deux nombres et une opÃ©ration (+, -, *, /), puis affiche le rÃ©sultat.\nFonctionnalitÃ©s requises :\nDemander deux nombres dÃ©cimaux Ã  lâ€™utilisateur Demander lâ€™opÃ©ration souhaitÃ©e Effectuer le calcul appropriÃ© Afficher le rÃ©sultat avec 2 dÃ©cimales GÃ©rer la division par zÃ©ro Exemple dâ€™exÃ©cution :",
    "tags": [],
    "title": "SÃ©rie d'exercices 1",
    "uri": "/420-413/serie_exos_1/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Table des matiÃ¨res Introduction Ã  la POO Les Classes et les Objets Les Attributs (Champs) Les PropriÃ©tÃ©s (Properties) Lâ€™Encapsulation Les MÃ©thodes Les Constructeurs Lâ€™HÃ©ritage Le Polymorphisme 1. Introduction Ã  la POO 1.1 Quâ€™est-ce que la Programmation OrientÃ©e Objet ? La Programmation OrientÃ©e Objet (POO) est un paradigme de programmation qui organise le code autour du concept dâ€™objets plutÃ´t que de fonctions et de logique. Un objet combine des donnÃ©es (ce quâ€™il possÃ¨de) et des comportements (ce quâ€™il peut faire).\nğŸŒ Analogie du monde rÃ©el Pensez Ã  une voiture dans le monde rÃ©el :\nDonnÃ©es : couleur, marque, modÃ¨le, vitesse actuelle, niveau dâ€™essence Comportements : dÃ©marrer, accÃ©lÃ©rer, freiner, tourner, klaxonner En POO, nous modÃ©lisons ces concepts du monde rÃ©el dans notre code.\n1.2 Pourquoi utiliser la POO ? Avant la POO (Programmation procÃ©durale) :\n// Variables dispersÃ©es string voitureMarque = \"Toyota\"; string voitureModele = \"Camry\"; int voitureVitesse = 0; // Fonctions sÃ©parÃ©es void DemarrerVoiture() { /* ... */ } void AccelererVoiture(int vitesse) { /* ... */ } Avec la POO :\n// Tout est regroupÃ© logiquement class Voiture { string marque; string modele; int vitesse; void Demarrer() { /* ... */ } void Accelerer(int increment) { /* ... */ } } Avantages de la POO :\nOrganisation : Le code est structurÃ© et logique RÃ©utilisabilitÃ© : Les classes peuvent Ãªtre rÃ©utilisÃ©es MaintenabilitÃ© : Plus facile Ã  maintenir et modifier ModularitÃ© : Chaque classe a une responsabilitÃ© claire Abstraction : Cache la complexitÃ© interne 1.3 Les 4 Piliers Fondamentaux de la POO 1ï¸âƒ£ Encapsulation Regrouper les donnÃ©es et les mÃ©thodes ensemble, et contrÃ´ler lâ€™accÃ¨s aux donnÃ©es.\nExemple concret : Un compte bancaire\nVous ne pouvez pas modifier directement le solde Vous devez passer par des mÃ©thodes (dÃ©poser, retirer) Cela protÃ¨ge lâ€™intÃ©gritÃ© des donnÃ©es 2ï¸âƒ£ HÃ©ritage CrÃ©er de nouvelles classes basÃ©es sur des classes existantes.\nExemple concret : VÃ©hicules\nClasse de base : Vehicule (propriÃ©tÃ©s communes : marque, modÃ¨le) Classes dÃ©rivÃ©es : Voiture, Moto, Camion (ajoutent leurs spÃ©cificitÃ©s) 3ï¸âƒ£ Polymorphisme Utiliser une mÃªme interface pour des types diffÃ©rents.\nExemple concret : Animaux\nTous peuvent â€œÃ©mettre un sonâ€ Le chien aboie, le chat miaule, lâ€™oiseau chante MÃªme mÃ©thode, comportements diffÃ©rents 4ï¸âƒ£ Abstraction Montrer seulement lâ€™essentiel, cacher les dÃ©tails complexes.\nExemple concret : Conduire une voiture\nVous utilisez le volant, les pÃ©dales Vous nâ€™avez pas besoin de comprendre le moteur interne 2. Les Classes et les Objets 2.1 Quâ€™est-ce quâ€™une Classe ? Une classe est un plan ou un modÃ¨le qui dÃ©finit la structure et le comportement dâ€™objets. Câ€™est comme un plan dâ€™architecte pour construire une maison.\nMÃ©taphore :\nUne classe est comme un moule Ã  biscuits ğŸª Les objets sont les biscuits crÃ©Ã©s avec ce moule Tous les biscuits ont la mÃªme forme (structure), mais peuvent avoir des diffÃ©rences (valeurs) 2.2 Quâ€™est-ce quâ€™un Objet ? Un objet est une instance dâ€™une classe. Câ€™est une entitÃ© concrÃ¨te crÃ©Ã©e Ã  partir du modÃ¨le dÃ©fini par la classe.\n2.3 Anatomie dâ€™une Classe // DÃ©claration d'une classe public class Personne { // ========================================== // ATTRIBUTS (CHAMPS) - Ce que l'objet possÃ¨de // ========================================== private string nom; private string prenom; private int age; // ========================================== // PROPRIÃ‰TÃ‰S - Interface contrÃ´lÃ©e pour les attributs // ========================================== public string Nom { get { return nom; } set { nom = value; } } // ========================================== // CONSTRUCTEUR - Comment crÃ©er l'objet // ========================================== public Personne(string nom, string prenom, int age) { this.nom = nom; this.prenom = prenom; this.age = age; } // ========================================== // MÃ‰THODES - Ce que l'objet peut faire // ========================================== public void SePresenter() { Console.WriteLine($\"Bonjour, je suis {prenom} {nom}, {age} ans.\"); } } 2.4 CrÃ©ation et Utilisation dâ€™Objets class Program { static void Main() { // ========================================== // CRÃ‰ATION D'OBJETS (INSTANCIATION) // ========================================== // Syntaxe : Type nomVariable = new Constructeur(); Personne personne1 = new Personne(\"Tremblay\", \"Marie\", 25); Personne personne2 = new Personne(\"Gagnon\", \"Jean\", 30); Personne personne3 = new Personne(\"Roy\", \"Sophie\", 28); // Chaque objet est UNIQUE et INDÃ‰PENDANT // personne1, personne2, personne3 sont 3 objets diffÃ©rents // ========================================== // UTILISATION DES OBJETS // ========================================== personne1.SePresenter(); // Affiche: Bonjour, je suis Marie Tremblay, 25 ans. personne2.SePresenter(); // Affiche: Bonjour, je suis Jean Gagnon, 30 ans. // AccÃ¨s aux propriÃ©tÃ©s Console.WriteLine(personne1.Nom); // Affiche: Tremblay } } 2.5 Comprendre la MÃ©moire : RÃ©fÃ©rence vs Valeur // Les CLASSES sont des types RÃ‰FÃ‰RENCE Personne p1 = new Personne(\"Dubois\", \"Luc\", 35); Personne p2 = p1; // p2 pointe vers le MÃŠME objet que p1 p2.Nom = \"Martin\"; // Modifie l'objet Console.WriteLine(p1.Nom); // Affiche: Martin Console.WriteLine(p2.Nom); // Affiche: Martin // p1 et p2 pointent vers le mÃªme objet en mÃ©moire ! Illustration :\nMÃ©moire:\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ Objet Personne â”‚\râ”‚ Nom: \"Martin\" â”‚ â†â”€â”€ p1 pointe ici\râ”‚ Prenom: \"Luc\" â”‚ â†â”€â”€ p2 pointe ici aussi\râ”‚ Age: 35 â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 3. Les Attributs (Champs) 3.1 DÃ©finition Les attributs (ou champs ou fields) sont des variables dÃ©clarÃ©es directement dans une classe. Ils reprÃ©sentent lâ€™Ã©tat ou les donnÃ©es de lâ€™objet.\n3.2 DÃ©claration des Attributs public class CompteBancaire { // ========================================== // ATTRIBUTS PRIVÃ‰S (convention : prÃ©fixe _) // ========================================== private string _numeroCompte; private string _titulaire; private decimal _solde; private DateTime _dateOuverture; private bool _estActif; // ========================================== // ATTRIBUTS PUBLICS (Ã  Ã©viter gÃ©nÃ©ralement) // ========================================== public int nombreTransactions; // Moins sÃ©curisÃ© } 3.3 Pourquoi des Attributs PrivÃ©s ? âŒ ProblÃ¨me avec des attributs publics :\npublic class CompteBancaire { public decimal solde; // PUBLIC = DANGER ! } // Dans le code utilisateur CompteBancaire compte = new CompteBancaire(); compte.solde = -5000; // âŒ On peut mettre n'importe quoi ! compte.solde = 999999999; // âŒ Aucune validation ! âœ… Solution avec des attributs privÃ©s :\npublic class CompteBancaire { private decimal _solde; // PRIVÃ‰ = PROTÃ‰GÃ‰ public void Deposer(decimal montant) { if (montant \u003e 0) // âœ… Validation { _solde += montant; } } } 3.4 Initialisation des Attributs public class Voiture { // Initialisation lors de la dÃ©claration private string _marque = \"Inconnue\"; private int _annee = 2020; private double _kilometrage = 0.0; private bool _estDemarree = false; // Sans initialisation (valeurs par dÃ©faut) private int _nombrePortes; // 0 par dÃ©faut private string _couleur; // null par dÃ©faut } Valeurs par dÃ©faut en C# :\nint, double, float : 0 bool : false string, objets : null DateTime : 01/01/0001 00:00:00 4. Les PropriÃ©tÃ©s (Properties) 4.1 Quâ€™est-ce quâ€™une PropriÃ©tÃ© ? Une propriÃ©tÃ© est un membre de classe qui fournit un mÃ©canisme flexible pour lire et Ã©crire les valeurs des attributs privÃ©s. Câ€™est lâ€™interface publique pour accÃ©der aux donnÃ©es privÃ©es.\nAnalogie :\nLâ€™attribut privÃ© = Le coffre-fort ğŸ”’ La propriÃ©tÃ© = La porte avec code dâ€™accÃ¨s ğŸšª Le getter = Ouvrir pour voir le contenu ğŸ‘€ Le setter = Ouvrir pour modifier le contenu âœï¸ 4.2 Syntaxe ComplÃ¨te dâ€™une PropriÃ©tÃ© public class Personne { // ========================================== // ATTRIBUT PRIVÃ‰ // ========================================== private int _age; // ========================================== // PROPRIÃ‰TÃ‰ AVEC GET ET SET COMPLETS // ========================================== public int Age { // GETTER - Lit la valeur get { Console.WriteLine(\"Lecture de l'Ã¢ge\"); return _age; } // SETTER - Modifie la valeur set { Console.WriteLine($\"Modification de l'Ã¢ge: {value}\"); // VALIDATION avant d'assigner if (value \u003e= 0 \u0026\u0026 value \u003c= 150) { _age = value; } else { Console.WriteLine(\"Ã‚ge invalide!\"); } } } } // Utilisation Personne p = new Personne(); p.Age = 25; // Appelle le SETTER avec value = 25 int monAge = p.Age; // Appelle le GETTER 4.3 Types de PropriÃ©tÃ©s A) PropriÃ©tÃ© Lecture/Ã‰criture (Get/Set) public class Produit { private string _nom; public string Nom { get { return _nom; } set { _nom = value; } } } B) PropriÃ©tÃ© en Lecture Seule (Get seulement) public class Personne { private DateTime _dateNaissance; // On peut LIRE mais pas MODIFIER de l'extÃ©rieur public DateTime DateNaissance { get { return _dateNaissance; } // Pas de SET = lecture seule } public Personne(DateTime dateNaissance) { _dateNaissance = dateNaissance; // DÃ©fini dans le constructeur } } // Utilisation Personne p = new Personne(new DateTime(1990, 5, 15)); Console.WriteLine(p.DateNaissance); // âœ… OK - Lecture // p.DateNaissance = DateTime.Now; // âŒ ERREUR - Pas de setter! C) PropriÃ©tÃ© en Ã‰criture Seule (Set seulement) - RARE public class CompteSecurise { private string _motDePasse; // On peut Ã‰CRIRE mais pas LIRE (pour la sÃ©curitÃ©) public string MotDePasse { set { _motDePasse = HashPassword(value); } // Pas de GET pour des raisons de sÃ©curitÃ© } private string HashPassword(string password) { // Logique de hachage return password; // SimplifiÃ© } } D) PropriÃ©tÃ© Auto-ImplÃ©mentÃ©e (Raccourci) public class Livre { // ========================================== // PROPRIÃ‰TÃ‰ AUTO-IMPLÃ‰MENTÃ‰E // Le compilateur crÃ©e automatiquement un attribut privÃ© cachÃ© // ========================================== public string Titre { get; set; } public string Auteur { get; set; } public int NombrePages { get; set; } // Ã‰quivalent Ã  : // private string _titre; // public string Titre { get { return _titre; } set { _titre = value; } } } // Utilisation Livre livre = new Livre(); livre.Titre = \"Le Petit Prince\"; livre.Auteur = \"Antoine de Saint-ExupÃ©ry\"; livre.NombrePages = 96; E) PropriÃ©tÃ© avec Logique MÃ©tier public class Rectangle { private double _longueur; private double _largeur; public double Longueur { get { return _longueur; } set { if (value \u003e 0) _longueur = value; else throw new ArgumentException(\"La longueur doit Ãªtre positive\"); } } public double Largeur { get { return _largeur; } set { if (value \u003e 0) _largeur = value; else throw new ArgumentException(\"La largeur doit Ãªtre positive\"); } } // ========================================== // PROPRIÃ‰TÃ‰ CALCULÃ‰E (pas d'attribut associÃ©) // ========================================== public double Aire { get { return _longueur * _largeur; } // Pas de SET - calculÃ©e Ã  chaque fois } public double Perimetre { get { return 2 * (_longueur + _largeur); } } } // Utilisation Rectangle rect = new Rectangle(); rect.Longueur = 5; rect.Largeur = 3; Console.WriteLine($\"Aire: {rect.Aire}\"); // 15 Console.WriteLine($\"PÃ©rimÃ¨tre: {rect.Perimetre}\"); // 16 F) PropriÃ©tÃ© avec AccessibilitÃ© DiffÃ©rente public class CompteBancaire { private decimal _solde; // ========================================== // GET public, SET privÃ© // Tout le monde peut LIRE, seule la classe peut MODIFIER // ========================================== public decimal Solde { get { return _solde; } private set { _solde = value; } // SET PRIVÃ‰ } // MÃ©thodes publiques pour modifier le solde de maniÃ¨re contrÃ´lÃ©e public void Deposer(decimal montant) { if (montant \u003e 0) Solde += montant; // Utilise le setter privÃ© } public bool Retirer(decimal montant) { if (montant \u003e 0 \u0026\u0026 montant \u003c= Solde) { Solde -= montant; // Utilise le setter privÃ© return true; } return false; } } // Utilisation CompteBancaire compte = new CompteBancaire(); Console.WriteLine(compte.Solde); // âœ… OK - Lecture publique // compte.Solde = 1000; // âŒ ERREUR - Set est privÃ© compte.Deposer(1000); // âœ… OK - MÃ©thode publique 4.4 Le Mot-ClÃ© value Dans un setter, le mot-clÃ© value reprÃ©sente la valeur quâ€™on essaie dâ€™assigner.\npublic class Exemple { private int _nombre; public int Nombre { get { return _nombre; } set { // 'value' contient la valeur assignÃ©e Console.WriteLine($\"Valeur reÃ§ue: {value}\"); _nombre = value; } } } // Utilisation Exemple ex = new Exemple(); ex.Nombre = 42; // 'value' vaut 42 dans le setter 4.5 PropriÃ©tÃ©s: Quand Utiliser Quoi ? Situation Type de PropriÃ©tÃ© DonnÃ©es simples sans validation Auto-implÃ©mentÃ©e { get; set; } DonnÃ©es nÃ©cessitant validation PropriÃ©tÃ© complÃ¨te avec logique DonnÃ©es calculÃ©es Get seulement (calculÃ©e) DonnÃ©es dÃ©finies Ã  la crÃ©ation Get seulement + constructeur DonnÃ©es sensibles Get public, Set privÃ© Mot de passe Set seulement (Ã©criture seule) 5. Lâ€™Encapsulation 5.1 DÃ©finition Approfondie Lâ€™encapsulation est le principe qui consiste Ã  :\nRegrouper les donnÃ©es (attributs) et les comportements (mÃ©thodes) dans une classe Cacher les dÃ©tails dâ€™implÃ©mentation internes ContrÃ´ler lâ€™accÃ¨s aux donnÃ©es via une interface publique MÃ©taphore de la voiture :\nVous nâ€™avez pas besoin de comprendre comment fonctionne le moteur (dÃ©tails cachÃ©s) Vous utilisez le volant, les pÃ©dales, le levier de vitesse (interface publique) Le moteur est protÃ©gÃ© sous le capot (encapsulation) 5.2 Modificateurs dâ€™AccÃ¨s Les modificateurs dâ€™accÃ¨s contrÃ´lent QUI peut accÃ©der Ã  quoi.\nTableau Complet des Modificateurs Modificateur AccÃ¨s Usage Typique private Classe uniquement Attributs, mÃ©thodes internes protected Classe + classes dÃ©rivÃ©es MÃ©thodes partagÃ©es avec enfants internal MÃªme assembly (projet) Classes utilitaires internes protected internal Assembly OU dÃ©rivÃ©es Cas spÃ©cifiques public Partout Interface publique, API Exemples DÃ©taillÃ©s public class Voiture { // ========================================== // PRIVATE - Accessible UNIQUEMENT dans cette classe // ========================================== private string _numeroSerie; // DonnÃ©e sensible private int _temperatureMoteur; // DÃ©tail interne private void DemarrerMoteur() // MÃ©thode interne { Console.WriteLine(\"Moteur dÃ©marrÃ©\"); } // ========================================== // PROTECTED - Accessible dans cette classe ET ses dÃ©rivÃ©es // ========================================== protected double _consommationBase; // Les classes enfants peuvent y accÃ©der protected void CalculerConsommation() // MÃ©thode pour les dÃ©rivÃ©es { Console.WriteLine(\"Calcul de la consommation\"); } // ========================================== // PUBLIC - Accessible PARTOUT // ========================================== public string Marque { get; set; } // PropriÃ©tÃ© publique public string Modele { get; set; } public void Demarrer() // MÃ©thode publique (interface) { DemarrerMoteur(); // Appelle la mÃ©thode privÃ©e Console.WriteLine(\"Voiture dÃ©marrÃ©e\"); } public void Accelerer(int vitesse) { // Interface publique qui utilise des dÃ©tails privÃ©s _temperatureMoteur += 10; Console.WriteLine($\"AccÃ©lÃ©ration Ã  {vitesse} km/h\"); } } // Classe dÃ©rivÃ©e public class VoitureElectrique : Voiture { public void ChargerBatterie() { // âœ… OK - AccÃ¨s Ã  protected _consommationBase = 0.15; CalculerConsommation(); // âŒ ERREUR - Pas d'accÃ¨s Ã  private // _numeroSerie = \"123\"; // ERREUR DE COMPILATION // DemarrerMoteur(); // ERREUR DE COMPILATION // âœ… OK - AccÃ¨s Ã  public Marque = \"Tesla\"; Demarrer(); } } // Utilisation externe class Program { static void Main() { Voiture maVoiture = new Voiture(); // âœ… OK - AccÃ¨s aux membres publics maVoiture.Marque = \"Toyota\"; maVoiture.Demarrer(); maVoiture.Accelerer(50); // âŒ ERREUR - Pas d'accÃ¨s aux membres privÃ©s // maVoiture._numeroSerie = \"ABC123\"; // ERREUR // maVoiture.DemarrerMoteur(); // ERREUR // âŒ ERREUR - Pas d'accÃ¨s aux membres protected // maVoiture._consommationBase = 0.10; // ERREUR // maVoiture.CalculerConsommation(); // ERREUR } } 5.3 Exemple Complet : Compte Bancaire Bien EncapsulÃ© public class CompteBancaire { // ========================================== // ATTRIBUTS PRIVÃ‰S - Ã‰tat interne protÃ©gÃ© // ========================================== private string _numeroCompte; private string _titulaire; private decimal _solde; private List\u003cstring\u003e _historiqueTransactions; private DateTime _dateOuverture; private const decimal FRAIS_RETRAIT = 1.50m; // Constante privÃ©e // ========================================== // PROPRIÃ‰TÃ‰S PUBLIQUES - Interface contrÃ´lÃ©e // ========================================== // Lecture seule de l'extÃ©rieur public string NumeroCompte { get { return _numeroCompte; } private set { _numeroCompte = value; } } public string Titulaire { get { return _titulaire; } set { if (!string.IsNullOrWhiteSpace(value)) _titulaire = value; } } // Lecture seule - impossible de modifier directement public decimal Solde { get { return _solde; } private set { _solde = value; } } public DateTime DateOuverture { get { return _dateOuverture; } } // ========================================== // CONSTRUCTEUR // ========================================== public CompteBancaire(string titulaire, string numeroCompte) { _titulaire = titulaire; _numeroCompte = numeroCompte; _solde = 0; _dateOuverture = DateTime.Now; _historiqueTransactions = new List\u003cstring\u003e(); AjouterTransaction(\"Ouverture du compte\"); } // ========================================== // MÃ‰THODES PUBLIQUES - Actions autorisÃ©es // ========================================== public bool Deposer(decimal montant) { if (montant \u003c= 0) { Console.WriteLine(\"Le montant doit Ãªtre positif\"); return false; } _solde += montant; AjouterTransaction($\"DÃ©pÃ´t de {montant:C}\"); Console.WriteLine($\"DÃ©pÃ´t rÃ©ussi. Nouveau solde: {_solde:C}\"); return true; } public bool Retirer(decimal montant) { if (montant \u003c= 0) { Console.WriteLine(\"Le montant doit Ãªtre positif\"); return false; } decimal montantTotal = montant + FRAIS_RETRAIT; if (montantTotal \u003e _solde) { Console.WriteLine(\"Solde insuffisant\"); return false; } _solde -= montantTotal; AjouterTransaction($\"Retrait de {montant:C} (frais: {FRAIS_RETRAIT:C})\"); Console.WriteLine($\"Retrait rÃ©ussi. Nouveau solde: {_solde:C}\"); return true; } public void AfficherHistorique() { Console.WriteLine($\"\\n=== Historique du compte {_numeroCompte} ===\"); foreach (string transaction in _historiqueTransactions) { Console.WriteLine(transaction); } } // ========================================== // MÃ‰THODES PRIVÃ‰ES - DÃ©tails d'implÃ©mentation // ========================================== private void AjouterTransaction(string description) { string transaction = $\"{DateTime.Now:dd/MM/yyyy HH:mm:ss} - {description}\"; _historiqueTransactions.Add(transaction); } private bool VerifierFrauude() { // Logique complexe de vÃ©rification return true; } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { CompteBancaire compte = new CompteBancaire(\"Jean Dupont\", \"12345\"); // âœ… Interface publique propre et sÃ©curisÃ©e compte.Deposer(1000); compte.Retirer(50); compte.AfficherHistorique(); // âœ… Lecture sÃ©curisÃ©e Console.WriteLine($\"Solde actuel: {compte.Solde:C}\"); // âŒ Impossible de tricher! // compte.Solde = 9999999; // ERREUR - Setter privÃ© // compte._solde += 1000; // ERREUR - Attribut privÃ© } } 5.4 Avantages de lâ€™Encapsulation SÃ©curitÃ© : Protection des donnÃ©es contre les modifications non autorisÃ©es Validation : ContrÃ´le des valeurs assignÃ©es FlexibilitÃ© : Modification de lâ€™implÃ©mentation interne sans casser le code externe Maintenance : Code plus facile Ã  comprendre et modifier DÃ©bogage : Points de contrÃ´le clairs pour tracer les problÃ¨mes 6. Les MÃ©thodes 6.1 DÃ©finition Les mÃ©thodes sont des fonctions dÃ©finies Ã  lâ€™intÃ©rieur dâ€™une classe. Elles reprÃ©sentent les comportements ou actions que les objets peuvent effectuer.\n6.2 Syntaxe ComplÃ¨te [modificateur d'accÃ¨s] [modificateurs] [type de retour] NomMethode([paramÃ¨tres]) { // Corps de la mÃ©thode return valeur; // Si type de retour n'est pas void } 6.3 Types de MÃ©thodes A) MÃ©thode Sans Retour (void) public class Robot { public void Avancer() { Console.WriteLine(\"Le robot avance\"); // Pas de return - void signifie \"ne retourne rien\" } public void Saluer(string nom) { Console.WriteLine($\"Bonjour {nom}!\"); } } B) MÃ©thode Avec Retour public class Calculatrice { public int Additionner(int a, int b) { int resultat = a + b; return resultat; // DOIT retourner un int } public double CalculerMoyenne(double[] nombres) { double somme = 0; foreach (double nombre in nombres) { somme += nombre; } return somme / nombres.Length; } public bool EstPair(int nombre) { return nombre % 2 == 0; // Retourne true ou false } } C) MÃ©thode Avec ParamÃ¨tres public class GestionnaireEmail { // ParamÃ¨tres obligatoires public void EnvoyerEmail(string destinataire, string sujet, string message) { Console.WriteLine($\"Ã€: {destinataire}\"); Console.WriteLine($\"Sujet: {sujet}\"); Console.WriteLine($\"Message: {message}\"); } // ParamÃ¨tres avec valeurs par dÃ©faut public void EnvoyerNotification(string message, string niveau = \"INFO\") { Console.WriteLine($\"[{niveau}] {message}\"); } } // Utilisation GestionnaireEmail gestionnaire = new GestionnaireEmail(); gestionnaire.EnvoyerEmail(\"jean@example.com\", \"Bienvenue\", \"Bonjour!\"); gestionnaire.EnvoyerNotification(\"SystÃ¨me dÃ©marrÃ©\"); // Utilise niveau par dÃ©faut gestionnaire.EnvoyerNotification(\"Erreur dÃ©tectÃ©e\", \"ERREUR\"); // SpÃ©cifie le niveau D) Surcharge de MÃ©thodes (Overloading) Plusieurs mÃ©thodes avec le mÃªme nom mais des paramÃ¨tres diffÃ©rents.\npublic class Calculatrice { // MÃªme nom, paramÃ¨tres diffÃ©rents public int Additionner(int a, int b) { return a + b; } public int Additionner(int a, int b, int c) { return a + b + c; } public double Additionner(double a, double b) { return a + b; } public int Additionner(params int[] nombres) // Nombre variable de paramÃ¨tres { int somme = 0; foreach (int nombre in nombres) { somme += nombre; } return somme; } } // Utilisation Calculatrice calc = new Calculatrice(); calc.Additionner(5, 3); // Appelle la version Ã  2 int calc.Additionner(5, 3, 2); // Appelle la version Ã  3 int calc.Additionner(5.5, 3.2); // Appelle la version Ã  2 double calc.Additionner(1, 2, 3, 4, 5, 6); // Appelle la version avec params 6.4 Le Mot-ClÃ© this this fait rÃ©fÃ©rence Ã  lâ€™instance actuelle de la classe.\npublic class Personne { private string nom; private int age; public Personne(string nom, int age) { // 'this.nom' = attribut de la classe // 'nom' = paramÃ¨tre du constructeur this.nom = nom; // Distingue l'attribut du paramÃ¨tre this.age = age; } public void Comparer(Personne autre) { if (this.age \u003e autre.age) { Console.WriteLine($\"{this.nom} est plus Ã¢gÃ© que {autre.nom}\"); } } public Personne ObtenirRÃ©fÃ©rence() { return this; // Retourne l'objet lui-mÃªme } } 6.5 MÃ©thodes dâ€™Instance vs MÃ©thodes Statiques public class Utilitaires { // Attribut d'instance private int compteur = 0; // ========================================== // MÃ‰THODE D'INSTANCE - NÃ©cessite un objet // ========================================== public void Incrementer() { compteur++; // AccÃ¨de Ã  l'attribut d'instance Console.WriteLine($\"Compteur: {compteur}\"); } // ========================================== // MÃ‰THODE STATIQUE - Pas besoin d'objet // ========================================== public static int Additionner(int a, int b) { // Ne peut PAS accÃ©der aux membres d'instance // compteur++; // âŒ ERREUR! return a + b; } public static double CalculerAire(double rayon) { return Math.PI * rayon * rayon; } } // Utilisation // MÃ©thode d'instance Utilitaires util = new Utilitaires(); util.Incrementer(); // Besoin d'un objet // MÃ©thode statique int somme = Utilitaires.Additionner(5, 3); // Pas besoin d'objet double aire = Utilitaires.CalculerAire(5); 7. Les Constructeurs 7.1 DÃ©finition Approfondie Un constructeur est une mÃ©thode spÃ©ciale qui est automatiquement appelÃ©e lors de la crÃ©ation dâ€™un objet. Son rÃ´le principal est dâ€™initialiser lâ€™objet dans un Ã©tat valide.\nCaractÃ©ristiques dâ€™un constructeur :\nMÃªme nom que la classe Pas de type de retour (mÃªme pas void) Peut avoir des paramÃ¨tres Peut Ãªtre surchargÃ© (plusieurs constructeurs diffÃ©rents) AppelÃ© automatiquement avec new MÃ©taphore : Le constructeur est comme le mode dâ€™emploi dâ€™assemblage dâ€™un meuble IKEA. Il dÃ©finit comment crÃ©er et prÃ©parer lâ€™objet pour quâ€™il soit utilisable.\n7.2 Constructeur Par DÃ©faut public class Voiture { public string Marque; public string Modele; public int Annee; // ========================================== // CONSTRUCTEUR PAR DÃ‰FAUT (sans paramÃ¨tres) // ========================================== public Voiture() { Console.WriteLine(\"Construction d'une voiture...\"); Marque = \"Inconnue\"; Modele = \"Standard\"; Annee = 2020; } } // Utilisation Voiture v = new Voiture(); // Appelle le constructeur par dÃ©faut Console.WriteLine($\"{v.Marque} {v.Modele}\"); // Inconnue Standard Important : Si vous ne dÃ©finissez AUCUN constructeur, C# crÃ©e automatiquement un constructeur par dÃ©faut vide. Mais si vous dÃ©finissez au moins un constructeur, le constructeur par dÃ©faut automatique disparaÃ®t.\npublic class Exemple1 { // Pas de constructeur dÃ©fini // C# crÃ©e automatiquement : public Exemple1() { } } public class Exemple2 { public Exemple2(int valeur) { } // Le constructeur par dÃ©faut automatique N'EXISTE PLUS } // Utilisation Exemple1 e1 = new Exemple1(); // âœ… OK Exemple2 e2 = new Exemple2(); // âŒ ERREUR - Pas de constructeur sans paramÃ¨tre Exemple2 e3 = new Exemple2(5); // âœ… OK 7.3 Constructeur Avec ParamÃ¨tres public class Personne { public string Nom { get; set; } public string Prenom { get; set; } public int Age { get; set; } // ========================================== // CONSTRUCTEUR AVEC PARAMÃˆTRES // ========================================== public Personne(string nom, string prenom, int age) { Console.WriteLine(\"CrÃ©ation d'une personne...\"); // Validation avant assignation if (string.IsNullOrWhiteSpace(nom)) throw new ArgumentException(\"Le nom ne peut pas Ãªtre vide\"); if (age \u003c 0 || age \u003e 150) throw new ArgumentException(\"Ã‚ge invalide\"); Nom = nom; Prenom = prenom; Age = age; } } // Utilisation Personne p1 = new Personne(\"Tremblay\", \"Marie\", 25); // Personne p2 = new Personne(\"\", \"Jean\", 30); // âŒ Exception levÃ©e 7.4 Surcharge de Constructeurs Une classe peut avoir plusieurs constructeurs avec diffÃ©rents paramÃ¨tres.\npublic class Livre { public string Titre { get; set; } public string Auteur { get; set; } public int Annee { get; set; } public int Pages { get; set; } // ========================================== // CONSTRUCTEUR 1 : Sans paramÃ¨tres // ========================================== public Livre() { Titre = \"Sans titre\"; Auteur = \"Anonyme\"; Annee = DateTime.Now.Year; Pages = 0; Console.WriteLine(\"Livre crÃ©Ã© avec valeurs par dÃ©faut\"); } // ========================================== // CONSTRUCTEUR 2 : Titre seulement // ========================================== public Livre(string titre) { Titre = titre; Auteur = \"Anonyme\"; Annee = DateTime.Now.Year; Pages = 0; Console.WriteLine($\"Livre '{titre}' crÃ©Ã©\"); } // ========================================== // CONSTRUCTEUR 3 : Titre et Auteur // ========================================== public Livre(string titre, string auteur) { Titre = titre; Auteur = auteur; Annee = DateTime.Now.Year; Pages = 0; Console.WriteLine($\"Livre '{titre}' de {auteur} crÃ©Ã©\"); } // ========================================== // CONSTRUCTEUR 4 : Tous les paramÃ¨tres // ========================================== public Livre(string titre, string auteur, int annee, int pages) { Titre = titre; Auteur = auteur; Annee = annee; Pages = pages; Console.WriteLine($\"Livre complet crÃ©Ã©\"); } } // Utilisation - Le compilateur choisit le bon constructeur Livre l1 = new Livre(); // Constructeur 1 Livre l2 = new Livre(\"1984\"); // Constructeur 2 Livre l3 = new Livre(\"Le Petit Prince\", \"Saint-ExupÃ©ry\"); // Constructeur 3 Livre l4 = new Livre(\"Dune\", \"Frank Herbert\", 1965, 412); // Constructeur 4 7.5 ChaÃ®nage de Constructeurs avec this Pour Ã©viter la duplication de code, un constructeur peut appeler un autre constructeur de la mÃªme classe avec : this().\npublic class Rectangle { public double Longueur { get; set; } public double Largeur { get; set; } public string Couleur { get; set; } // ========================================== // CONSTRUCTEUR PRINCIPAL (le plus complet) // ========================================== public Rectangle(double longueur, double largeur, string couleur) { Console.WriteLine(\"Constructeur principal appelÃ©\"); Longueur = longueur; Largeur = largeur; Couleur = couleur; } // ========================================== // CONSTRUCTEUR qui appelle le principal // ========================================== public Rectangle(double longueur, double largeur) : this(longueur, largeur, \"Blanc\") // Appelle le constructeur principal { Console.WriteLine(\"Constructeur sans couleur\"); // Pas besoin de rÃ©pÃ©ter l'assignation de longueur et largeur } // ========================================== // CONSTRUCTEUR pour un carrÃ© // ========================================== public Rectangle(double cote) : this(cote, cote, \"Blanc\") // Appelle le constructeur principal { Console.WriteLine(\"Constructeur pour carrÃ©\"); } // ========================================== // CONSTRUCTEUR par dÃ©faut // ========================================== public Rectangle() : this(1, 1, \"Blanc\") // Appelle le constructeur principal { Console.WriteLine(\"Constructeur par dÃ©faut\"); } } // Utilisation Rectangle r1 = new Rectangle(5, 3, \"Rouge\"); // Affiche: \"Constructeur principal appelÃ©\" Rectangle r2 = new Rectangle(5, 3); // Affiche: \"Constructeur principal appelÃ©\" // \"Constructeur sans couleur\" Rectangle r3 = new Rectangle(4); // Affiche: \"Constructeur principal appelÃ©\" // \"Constructeur pour carrÃ©\" Ordre dâ€™exÃ©cution :\nLe constructeur appelÃ© avec : this() sâ€™exÃ©cute en PREMIER Puis le constructeur actuel sâ€™exÃ©cute 7.6 Constructeurs PrivÃ©s Un constructeur peut Ãªtre privÃ© pour contrÃ´ler la crÃ©ation dâ€™instances.\n// ========================================== // PATTERN SINGLETON - Une seule instance possible // ========================================== public class Configuration { private static Configuration _instance = null; public string CheminFichier { get; set; } public string Langue { get; set; } // ========================================== // CONSTRUCTEUR PRIVÃ‰ - Impossible de faire 'new Configuration()' // ========================================== private Configuration() { CheminFichier = \"config.json\"; Langue = \"fr\"; Console.WriteLine(\"Configuration crÃ©Ã©e\"); } // ========================================== // MÃ‰THODE PUBLIQUE pour obtenir l'instance unique // ========================================== public static Configuration ObtenirInstance() { if (_instance == null) { _instance = new Configuration(); } return _instance; } } // Utilisation // Configuration c1 = new Configuration(); // âŒ ERREUR - Constructeur privÃ© Configuration c1 = Configuration.ObtenirInstance(); // âœ… OK Configuration c2 = Configuration.ObtenirInstance(); // Retourne la mÃªme instance Console.WriteLine(c1 == c2); // True - MÃªme objet 7.7 Initialisation dâ€™Objets En plus des constructeurs, C# offre des syntaxes modernes pour initialiser les objets.\npublic class Produit { public string Nom { get; set; } public decimal Prix { get; set; } public string Categorie { get; set; } public Produit() { } public Produit(string nom, decimal prix) { Nom = nom; Prix = prix; } } // ========================================== // SYNTAXE 1 : Constructeur traditionnel // ========================================== Produit p1 = new Produit(\"Laptop\", 999.99m); p1.Categorie = \"Ã‰lectronique\"; // ========================================== // SYNTAXE 2 : Initialiseur d'objet (Object Initializer) // ========================================== Produit p2 = new Produit { Nom = \"Souris\", Prix = 29.99m, Categorie = \"Accessoires\" }; // ========================================== // SYNTAXE 3 : Combinaison constructeur + initialiseur // ========================================== Produit p3 = new Produit(\"Clavier\", 79.99m) { Categorie = \"Accessoires\" // Ajoute la catÃ©gorie aprÃ¨s la construction }; // ========================================== // SYNTAXE 4 : C# 9+ (sans rÃ©pÃ©ter le type) // ========================================== Produit p4 = new(\"Ã‰cran\", 299.99m) { Categorie = \"PÃ©riphÃ©riques\" }; 7.8 Exemple Complet : Classe CompteBancaire public class CompteBancaire { // ========================================== // ATTRIBUTS PRIVÃ‰S // ========================================== private string _numeroCompte; private string _titulaire; private decimal _solde; private DateTime _dateOuverture; private static int _compteurComptes = 0; // Pour gÃ©nÃ©rer des numÃ©ros uniques // ========================================== // PROPRIÃ‰TÃ‰S // ========================================== public string NumeroCompte { get { return _numeroCompte; } } public string Titulaire { get { return _titulaire; } } public decimal Solde { get { return _solde; } } public DateTime DateOuverture { get { return _dateOuverture; } } // ========================================== // CONSTRUCTEUR 1 : Complet // ========================================== public CompteBancaire(string titulaire, decimal soldeInitial, string numeroCompte) { if (string.IsNullOrWhiteSpace(titulaire)) throw new ArgumentException(\"Le titulaire ne peut pas Ãªtre vide\"); if (soldeInitial \u003c 0) throw new ArgumentException(\"Le solde initial ne peut pas Ãªtre nÃ©gatif\"); _titulaire = titulaire; _solde = soldeInitial; _numeroCompte = numeroCompte; _dateOuverture = DateTime.Now; _compteurComptes++; Console.WriteLine($\"Compte {_numeroCompte} crÃ©Ã© pour {_titulaire}\"); } // ========================================== // CONSTRUCTEUR 2 : GÃ©nÃ¨re automatiquement le numÃ©ro // ========================================== public CompteBancaire(string titulaire, decimal soldeInitial) : this(titulaire, soldeInitial, GenererNumeroCompte()) { Console.WriteLine(\"NumÃ©ro de compte gÃ©nÃ©rÃ© automatiquement\"); } // ========================================== // CONSTRUCTEUR 3 : Solde initial de 0$ // ========================================== public CompteBancaire(string titulaire) : this(titulaire, 0) { Console.WriteLine(\"Compte crÃ©Ã© avec solde initial de 0$\"); } // ========================================== // MÃ‰THODE PRIVÃ‰E pour gÃ©nÃ©rer un numÃ©ro // ========================================== private static string GenererNumeroCompte() { return $\"CA{DateTime.Now.Year}{_compteurComptes + 1:D6}\"; } // ========================================== // MÃ‰THODES // ========================================== public void Deposer(decimal montant) { if (montant \u003e 0) { _solde += montant; Console.WriteLine($\"DÃ©pÃ´t de {montant:C}. Nouveau solde: {_solde:C}\"); } } public void AfficherInfos() { Console.WriteLine($\"\\n=== Compte {_numeroCompte} ===\"); Console.WriteLine($\"Titulaire: {_titulaire}\"); Console.WriteLine($\"Solde: {_solde:C}\"); Console.WriteLine($\"Date d'ouverture: {_dateOuverture:d}\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // 3 faÃ§ons de crÃ©er un compte CompteBancaire c1 = new CompteBancaire(\"Marie Tremblay\", 1000, \"CA2024001\"); CompteBancaire c2 = new CompteBancaire(\"Jean Gagnon\", 500); CompteBancaire c3 = new CompteBancaire(\"Sophie Roy\"); c1.AfficherInfos(); c2.AfficherInfos(); c3.AfficherInfos(); c3.Deposer(250); c3.AfficherInfos(); } } 8. Lâ€™HÃ©ritage 8.1 Concept Fondamental Lâ€™hÃ©ritage est un mÃ©canisme qui permet Ã  une classe (appelÃ©e classe dÃ©rivÃ©e, classe enfant ou sous-classe) dâ€™hÃ©riter des membres (attributs et mÃ©thodes) dâ€™une autre classe (appelÃ©e classe de base, classe parent ou super-classe).\nMÃ©taphore biologique :\nVous hÃ©ritez des caractÃ©ristiques de vos parents (couleur des yeux, groupe sanguin) Mais vous avez aussi vos propres caractÃ©ristiques uniques Câ€™est la mÃªme chose en programmation Pourquoi lâ€™hÃ©ritage ?\nRÃ©utilisation du code : Ne pas rÃ©Ã©crire ce qui existe dÃ©jÃ  Organisation hiÃ©rarchique : ModÃ©liser des relations â€œest unâ€ ExtensibilitÃ© : Ajouter des fonctionnalitÃ©s sans modifier lâ€™existant Polymorphisme : Traiter diffÃ©rents objets de maniÃ¨re uniforme 8.2 Syntaxe de lâ€™HÃ©ritage // Syntaxe : class ClasseDerivee : ClasseDeBase public class Animal { // Classe de base } public class Chien : Animal { // Chien hÃ©rite de Animal } 8.3 Exemple DÃ©taillÃ© : HiÃ©rarchie de VÃ©hicules // ========================================== // CLASSE DE BASE (PARENT) // ========================================== public class Vehicule { // ========================================== // MEMBRES PROTÃ‰GÃ‰S - Accessibles aux dÃ©rivÃ©es // ========================================== protected string _marque; protected string _modele; protected int _annee; protected double _kilometrage; // ========================================== // PROPRIÃ‰TÃ‰S PUBLIQUES // ========================================== public string Marque { get { return _marque; } set { _marque = value; } } public string Modele { get { return _modele; } set { _modele = value; } } public int Annee { get; set; } public double Kilometrage { get { return _kilometrage; } protected set // Set protÃ©gÃ© { if (value \u003e= _kilometrage) // Ne peut qu'augmenter _kilometrage = value; } } // ========================================== // CONSTRUCTEUR // ========================================== public Vehicule(string marque, string modele, int annee) { Console.WriteLine(\"Constructeur de Vehicule appelÃ©\"); _marque = marque; _modele = modele; _annee = annee; _kilometrage = 0; } // ========================================== // MÃ‰THODES // ========================================== public void Demarrer() { Console.WriteLine($\"Le vÃ©hicule {_marque} {_modele} dÃ©marre.\"); } public void Rouler(double km) { _kilometrage += km; Console.WriteLine($\"Parcouru {km} km. Total: {_kilometrage} km\"); } public void AfficherInfos() { Console.WriteLine($\"\\n=== {_marque} {_modele} ===\"); Console.WriteLine($\"AnnÃ©e: {_annee}\"); Console.WriteLine($\"KilomÃ©trage: {_kilometrage} km\"); } } // ========================================== // CLASSE DÃ‰RIVÃ‰E 1 (ENFANT) // ========================================== public class Voiture : Vehicule // HÃ©rite de Vehicule { // ========================================== // MEMBRES SPÃ‰CIFIQUES Ã  Voiture // ========================================== private int _nombrePortes; private string _typeCar burant; public int NombrePortes { get { return _nombrePortes; } set { _nombrePortes = value; } } // ========================================== // CONSTRUCTEUR - Doit appeler le constructeur du parent // ========================================== public Voiture(string marque, string modele, int annee, int portes, string carburant) : base(marque, modele, annee) // Appelle le constructeur de Vehicule { Console.WriteLine(\"Constructeur de Voiture appelÃ©\"); _nombrePortes = portes; _typeCarburant = carburant; } // ========================================== // NOUVELLE MÃ‰THODE spÃ©cifique Ã  Voiture // ========================================== public void OuvrirCoffre() { Console.WriteLine(\"Coffre ouvert\"); } // ========================================== // ACCÃˆS AUX MEMBRES HÃ‰RITÃ‰S // ========================================== public void AfficherToutesInfos() { // Peut accÃ©der aux membres protected et public du parent AfficherInfos(); // MÃ©thode hÃ©ritÃ©e Console.WriteLine($\"Nombre de portes: {_nombrePortes}\"); Console.WriteLine($\"Carburant: {_typeCarburant}\"); // Peut accÃ©der aux attributs protected Console.WriteLine($\"Marque (attribut protected): {_marque}\"); } } // ========================================== // CLASSE DÃ‰RIVÃ‰E 2 // ========================================== public class Moto : Vehicule { private bool _aCompartiment; public bool ACompartiment { get; set; } public Moto(string marque, string modele, int annee, bool compartiment) : base(marque, modele, annee) { Console.WriteLine(\"Constructeur de Moto appelÃ©\"); _aCompartiment = compartiment; } public void FaireWheeling() { Console.WriteLine($\"La moto {Marque} fait un wheeling!\"); } } // ========================================== // CLASSE DÃ‰RIVÃ‰E 3 // ========================================== public class Camion : Vehicule { private double _capaciteCharge; // En tonnes public double CapaciteCharge { get; set; } public Camion(string marque, string modele, int annee, double capacite) : base(marque, modele, annee) { _capaciteCharge = capacite; } public void Charger(double poids) { if (poids \u003c= _capaciteCharge) Console.WriteLine($\"Chargement de {poids} tonnes\"); else Console.WriteLine($\"DÃ©passement de capacitÃ©!\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // CrÃ©ation d'objets dÃ©rivÃ©s Voiture voiture = new Voiture(\"Toyota\", \"Camry\", 2023, 4, \"Essence\"); Moto moto = new Moto(\"Harley-Davidson\", \"Street 750\", 2022, true); Camion camion = new Camion(\"Volvo\", \"FH16\", 2021, 20); // ========================================== // La voiture hÃ©rite de TOUT ce que Vehicule possÃ¨de // ========================================== voiture.Demarrer(); // âœ… MÃ©thode hÃ©ritÃ©e voiture.Rouler(150); // âœ… MÃ©thode hÃ©ritÃ©e voiture.AfficherInfos(); // âœ… MÃ©thode hÃ©ritÃ©e voiture.OuvrirCoffre(); // âœ… MÃ©thode spÃ©cifique Ã  Voiture // ========================================== // MÃªme chose pour la moto // ========================================== moto.Demarrer(); // âœ… MÃ©thode hÃ©ritÃ©e moto.FaireWheeling(); // âœ… MÃ©thode spÃ©cifique Ã  Moto // ========================================== // Et le camion // ========================================== camion.Demarrer(); // âœ… MÃ©thode hÃ©ritÃ©e camion.Charger(15); // âœ… MÃ©thode spÃ©cifique Ã  Camion } } Affichage :\nConstructeur de Vehicule appelÃ©\rConstructeur de Voiture appelÃ©\rConstructeur de Vehicule appelÃ©\rConstructeur de Moto appelÃ©\rConstructeur de Vehicule appelÃ©\rLe vÃ©hicule Toyota Camry dÃ©marre.\rParcouru 150 km. Total: 150 km\r=== Toyota Camry ===\rAnnÃ©e: 2023\rKilomÃ©trage: 150 km\rCoffre ouvert\r... 8.4 Le Mot-ClÃ© base Le mot-clÃ© base permet dâ€™accÃ©der aux membres de la classe parent.\npublic class Animal { protected string _nom; protected int _age; public Animal(string nom, int age) { _nom = nom; _age = age; Console.WriteLine($\"Animal {nom} crÃ©Ã©\"); } public void Manger() { Console.WriteLine($\"{_nom} mange.\"); } public virtual void Dormir() { Console.WriteLine($\"{_nom} dort paisiblement.\"); } } public class Chien : Animal { private string _race; // ========================================== // UTILISATION 1 de 'base' : Appeler le constructeur parent // ========================================== public Chien(string nom, int age, string race) : base(nom, age) // Appelle Animal(nom, age) { _race = race; Console.WriteLine($\"Chien de race {race} crÃ©Ã©\"); } // ========================================== // UTILISATION 2 de 'base' : Appeler une mÃ©thode du parent // ========================================== public override void Dormir() { Console.WriteLine($\"{_nom} le chien cherche un endroit confortable\"); base.Dormir(); // Appelle la mÃ©thode Dormir() de Animal Console.WriteLine(\"...et ronfle un peu\"); } public void AfficherTout() { // ========================================== // UTILISATION 3 de 'base' : AccÃ©der Ã  un membre parent // ========================================== Console.WriteLine($\"Nom: {_nom}\"); // Attribut hÃ©ritÃ© Console.WriteLine($\"Ã‚ge: {_age}\"); // Attribut hÃ©ritÃ© Console.WriteLine($\"Race: {_race}\"); // Attribut propre base.Manger(); // Appelle explicitement la mÃ©thode du parent } } // Utilisation Chien chien = new Chien(\"Rex\", 5, \"Labrador\"); chien.Dormir(); Affichage :\nAnimal Rex crÃ©Ã©\rChien de race Labrador crÃ©Ã©\rRex le chien cherche un endroit confortable\rRex dort paisiblement.\r...et ronfle un peu 8.5 HiÃ©rarchie Multi-Niveaux Lâ€™hÃ©ritage peut avoir plusieurs niveaux.\n// ========================================== // NIVEAU 1 : Classe de base // ========================================== public class EtreVivant { public bool EstVivant { get; set; } = true; public void Respirer() { Console.WriteLine(\"Respire...\"); } } // ========================================== // NIVEAU 2 : DÃ©rive de EtreVivant // ========================================== public class Animal : EtreVivant { public void SeDeplacer() { Console.WriteLine(\"Se dÃ©place\"); } } // ========================================== // NIVEAU 3 : DÃ©rive de Animal // ========================================== public class Mammifere : Animal { public void Allaiter() { Console.WriteLine(\"Allaite ses petits\"); } } // ========================================== // NIVEAU 4 : DÃ©rive de Mammifere // ========================================== public class Chien : Mammifere { public void Aboyer() { Console.WriteLine(\"Wouf wouf!\"); } } // Utilisation Chien chien = new Chien(); // Le chien hÃ©rite de TOUS ses ancÃªtres chien.Respirer(); // âœ… De EtreVivant (arriÃ¨re-arriÃ¨re-grand-parent) chien.SeDeplacer(); // âœ… De Animal (arriÃ¨re-grand-parent) chien.Allaiter(); // âœ… De Mammifere (grand-parent) chien.Aboyer(); // âœ… De Chien (lui-mÃªme) HiÃ©rarchie :\nEtreVivant\râ†“ hÃ©rite\rAnimal\râ†“ hÃ©rite\rMammifere\râ†“ hÃ©rite\rChien 8.6 Relations â€œEst-Unâ€ (Is-A) Lâ€™hÃ©ritage modÃ©lise une relation â€œest unâ€.\npublic class Vehicule { } public class Voiture : Vehicule { } // Une Voiture \"est un\" Vehicule âœ… // Un Vehicule \"est une\" Voiture âŒ (faux) Voiture v = new Voiture(); // v est une Voiture âœ… // v est aussi un Vehicule âœ… (par hÃ©ritage) Test mental : Si vous pouvez dire â€œX est un Yâ€, alors X peut hÃ©riter de Y.\nUn chien est un animal âœ… Une voiture est un vÃ©hicule âœ… Un Ã©tudiant est une personne âœ… Une maison est un bÃ¢timent âœ… Contre-exemples (mauvais hÃ©ritage) :\nUne maison est un toit âŒ (une maison a un toit â†’ composition, pas hÃ©ritage) Un Ã©tudiant est un cours âŒ Une voiture est un moteur âŒ (une voiture a un moteur) 8.7 Restrictions de lâ€™HÃ©ritage en C# Important : En C#, une classe ne peut hÃ©riter que dâ€™UNE SEULE classe (pas dâ€™hÃ©ritage multiple de classes).\npublic class A { } public class B { } // âŒ ERREUR - Pas d'hÃ©ritage multiple en C# public class C : A, B { } // âœ… OK - HÃ©ritage simple public class C : A { } Cependant : Une classe peut implÃ©menter plusieurs interfaces (voir section sur les interfaces).\n9. Le Polymorphisme 9.1 DÃ©finition Approfondie Le polymorphisme (du grec â€œpolyâ€ = plusieurs, â€œmorpheâ€ = forme) est la capacitÃ© pour des objets de types diffÃ©rents de rÃ©pondre Ã  la mÃªme interface ou au mÃªme appel de mÃ©thode, mais avec des comportements diffÃ©rents.\nAnalogie du monde rÃ©el : Imaginez un bouton â€œDÃ©marrerâ€ :\nSur une voiture : DÃ©marre le moteur Sur un ordinateur : Lance le systÃ¨me dâ€™exploitation Sur une cafetiÃ¨re : Commence Ã  infuser le cafÃ© MÃªme action (â€œDÃ©marrerâ€), comportements diffÃ©rents Pourquoi le polymorphisme ?\nFlexibilitÃ© : Ã‰crire du code qui fonctionne avec diffÃ©rents types ExtensibilitÃ© : Ajouter de nouveaux types sans modifier le code existant Abstraction : Manipuler des objets sans connaÃ®tre leur type exact Code rÃ©utilisable : Une mÃªme fonction pour plusieurs types 9.2 Types de Polymorphisme Il existe deux types principaux :\nPolymorphisme de compilation (surcharge de mÃ©thodes) Polymorphisme dâ€™exÃ©cution (redÃ©finition de mÃ©thodes) La Programmation OrientÃ©e Objet (POO) est un paradigme de programmation basÃ© sur le concept dâ€™objets qui contiennent des donnÃ©es (attributs) et du code (mÃ©thodes).\nLes 4 piliers de la POO : Encapsulation : Regrouper les donnÃ©es et mÃ©thodes, cacher les dÃ©tails internes HÃ©ritage : CrÃ©er de nouvelles classes Ã  partir de classes existantes Polymorphisme : Utiliser une interface commune pour des types diffÃ©rents Abstraction : Simplifier la complexitÃ© en cachant les dÃ©tails dâ€™implÃ©mentation 2. Les Classes et les Objets Quâ€™est-ce quâ€™une classe ? Une classe est un modÃ¨le ou un plan qui dÃ©finit la structure et le comportement dâ€™objets.\nQuâ€™est-ce quâ€™un objet ? Un objet est une instance dâ€™une classe, câ€™est une entitÃ© concrÃ¨te crÃ©Ã©e Ã  partir du modÃ¨le.\nSyntaxe de base // DÃ©finition d'une classe public class Personne { // Attributs (champs) public string Nom; public string Prenom; public int Age; // MÃ©thode public void SePresenter() { Console.WriteLine($\"Bonjour, je m'appelle {Prenom} {Nom} et j'ai {Age} ans.\"); } } // Utilisation class Program { static void Main() { // CrÃ©ation d'un objet (instance) Personne personne1 = new Personne(); personne1.Nom = \"Tremblay\"; personne1.Prenom = \"Marie\"; personne1.Age = 25; personne1.SePresenter(); // Affiche: Bonjour, je m'appelle Marie Tremblay et j'ai 25 ans. } } 3. Lâ€™Encapsulation Lâ€™encapsulation consiste Ã  protÃ©ger les donnÃ©es dâ€™une classe et Ã  contrÃ´ler lâ€™accÃ¨s via des propriÃ©tÃ©s.\nModificateurs dâ€™accÃ¨s Modificateur Description public Accessible partout private Accessible uniquement dans la classe protected Accessible dans la classe et ses dÃ©rivÃ©es internal Accessible dans le mÃªme assembly protected internal Combinaison de protected et internal PropriÃ©tÃ©s (Properties) public class Compte { // Champs privÃ©s private string _numeroCompte; private decimal _solde; // PropriÃ©tÃ© avec get et set public string NumeroCompte { get { return _numeroCompte; } set { _numeroCompte = value; } } // PropriÃ©tÃ© avec logique de validation public decimal Solde { get { return _solde; } private set // set privÃ© : lecture publique, Ã©criture privÃ©e { if (value \u003e= 0) _solde = value; } } // PropriÃ©tÃ© auto-implÃ©mentÃ©e (C# 3.0+) public string Titulaire { get; set; } // PropriÃ©tÃ© en lecture seule (C# 6.0+) public DateTime DateCreation { get; } = DateTime.Now; public void Deposer(decimal montant) { if (montant \u003e 0) Solde += montant; } public bool Retirer(decimal montant) { if (montant \u003e 0 \u0026\u0026 montant \u003c= Solde) { Solde -= montant; return true; } return false; } } 4. Les Constructeurs Un constructeur est une mÃ©thode spÃ©ciale appelÃ©e lors de la crÃ©ation dâ€™un objet.\nTypes de constructeurs public class Voiture { public string Marque { get; set; } public string Modele { get; set; } public int Annee { get; set; } // Constructeur par dÃ©faut (sans paramÃ¨tres) public Voiture() { Marque = \"Inconnue\"; Modele = \"Inconnu\"; Annee = 2020; } // Constructeur avec paramÃ¨tres public Voiture(string marque, string modele) { Marque = marque; Modele = modele; Annee = DateTime.Now.Year; } // Constructeur complet public Voiture(string marque, string modele, int annee) { Marque = marque; Modele = modele; Annee = annee; } // ChaÃ®nage de constructeurs avec 'this' public Voiture(string marque) : this(marque, \"Standard\", DateTime.Now.Year) { } } // Utilisation var voiture1 = new Voiture(); var voiture2 = new Voiture(\"Toyota\", \"Camry\"); var voiture3 = new Voiture(\"Honda\", \"Civic\", 2023); var voiture4 = new Voiture(\"Ford\"); 5. Lâ€™HÃ©ritage Lâ€™hÃ©ritage permet Ã  une classe (classe dÃ©rivÃ©e) dâ€™hÃ©riter des membres dâ€™une autre classe (classe de base).\nSyntaxe de base // Classe de base (parent) public class Animal { public string Nom { get; set; } public int Age { get; set; } public virtual void Manger() { Console.WriteLine($\"{Nom} est en train de manger.\"); } public virtual void Dormir() { Console.WriteLine($\"{Nom} dort.\"); } } // Classe dÃ©rivÃ©e (enfant) public class Chien : Animal { public string Race { get; set; } // Nouvelle mÃ©thode spÃ©cifique au chien public void Aboyer() { Console.WriteLine($\"{Nom} aboie: Wouf wouf!\"); } // RedÃ©finition (override) d'une mÃ©thode public override void Manger() { Console.WriteLine($\"{Nom} le chien mange des croquettes.\"); } } // Autre classe dÃ©rivÃ©e public class Chat : Animal { public bool EstDomestique { get; set; } public void Miauler() { Console.WriteLine($\"{Nom} miaule: Miaou!\"); } public override void Manger() { Console.WriteLine($\"{Nom} le chat mange du poisson.\"); } } // Utilisation var chien = new Chien { Nom = \"Rex\", Age = 5, Race = \"Labrador\" }; chien.Manger(); // Affiche: Rex le chien mange des croquettes. chien.Aboyer(); // Affiche: Rex aboie: Wouf wouf! chien.Dormir(); // Affiche: Rex dort. Le mot-clÃ© base public class Employe { public string Nom { get; set; } public decimal SalaireBase { get; set; } public Employe(string nom, decimal salaire) { Nom = nom; SalaireBase = salaire; } public virtual decimal CalculerSalaire() { return SalaireBase; } } public class Manager : Employe { public decimal Prime { get; set; } // Appel du constructeur de base avec 'base' public Manager(string nom, decimal salaire, decimal prime) : base(nom, salaire) { Prime = prime; } // Utilisation de la mÃ©thode de base avec 'base' public override decimal CalculerSalaire() { return base.CalculerSalaire() + Prime; } } Modificateur sealed Le mot-clÃ© sealed empÃªche lâ€™hÃ©ritage dâ€™une classe ou la redÃ©finition dâ€™une mÃ©thode.\n// Classe scellÃ©e - ne peut pas Ãªtre hÃ©ritÃ©e public sealed class ClasseFinale { public void Methode() { } } // ERREUR: Impossible d'hÃ©riter d'une classe sealed // public class Derivee : ClasseFinale { } public class ClasseAvecMethodeScelle : Animal { // MÃ©thode scellÃ©e - ne peut plus Ãªtre redÃ©finie dans les classes dÃ©rivÃ©es public sealed override void Manger() { Console.WriteLine(\"ImplÃ©mentation finale\"); } } 6. Le Polymorphisme Le polymorphisme permet Ã  des objets de diffÃ©rentes classes dâ€™Ãªtre traitÃ©s de maniÃ¨re uniforme via une interface commune.\nPolymorphisme par hÃ©ritage public class Forme { public virtual double CalculerAire() { return 0; } public virtual void Dessiner() { Console.WriteLine(\"Dessiner une forme gÃ©nÃ©rique\"); } } public class Cercle : Forme { public double Rayon { get; set; } public Cercle(double rayon) { Rayon = rayon; } public override double CalculerAire() { return Math.PI * Rayon * Rayon; } public override void Dessiner() { Console.WriteLine($\"Dessiner un cercle de rayon {Rayon}\"); } } public class Rectangle : Forme { public double Longueur { get; set; } public double Largeur { get; set; } public Rectangle(double longueur, double largeur) { Longueur = longueur; Largeur = largeur; } public override double CalculerAire() { return Longueur * Largeur; } public override void Dessiner() { Console.WriteLine($\"Dessiner un rectangle {Longueur}x{Largeur}\"); } } // Utilisation du polymorphisme class Program { static void Main() { // Tableau polymorphe Forme[] formes = new Forme[] { new Cercle(5), new Rectangle(4, 6), new Cercle(3) }; // MÃªme code, comportements diffÃ©rents foreach (Forme forme in formes) { forme.Dessiner(); Console.WriteLine($\"Aire: {forme.CalculerAire():F2}\"); Console.WriteLine(); } } } Mots-clÃ©s virtual, override, new public class ClasseBase { public virtual void MethodeVirtuelle() { Console.WriteLine(\"MÃ©thode virtuelle de base\"); } public void MethodeNormale() { Console.WriteLine(\"MÃ©thode normale de base\"); } } public class ClasseDerivee : ClasseBase { // Override: redÃ©finition polymorphique public override void MethodeVirtuelle() { Console.WriteLine(\"MÃ©thode redÃ©finie\"); } // New: masquage (non polymorphique) public new void MethodeNormale() { Console.WriteLine(\"MÃ©thode masquÃ©e\"); } } // Test ClasseBase obj1 = new ClasseDerivee(); obj1.MethodeVirtuelle(); // Affiche: MÃ©thode redÃ©finie (polymorphisme) obj1.MethodeNormale(); // Affiche: MÃ©thode normale de base (pas de polymorphisme) ClasseDerivee obj2 = new ClasseDerivee(); obj2.MethodeVirtuelle(); // Affiche: MÃ©thode redÃ©finie obj2.MethodeNormale(); // Affiche: MÃ©thode masquÃ©e 7. Les Classes Abstraites Une classe abstraite est une classe incomplÃ¨te qui ne peut pas Ãªtre instanciÃ©e directement. Elle sert de modÃ¨le pour dâ€™autres classes.\nCaractÃ©ristiques DÃ©clarÃ©e avec le mot-clÃ© abstract Peut contenir des mÃ©thodes abstraites (sans implÃ©mentation) et concrÃ¨tes (avec implÃ©mentation) Ne peut pas Ãªtre instanciÃ©e Les classes dÃ©rivÃ©es doivent implÃ©menter toutes les mÃ©thodes abstraites // Classe abstraite public abstract class Vehicule { public string Marque { get; set; } public string Modele { get; set; } // Constructeur (oui, les classes abstraites peuvent avoir des constructeurs) public Vehicule(string marque, string modele) { Marque = marque; Modele = modele; } // MÃ©thode abstraite (sans implÃ©mentation) public abstract void Demarrer(); // MÃ©thode abstraite public abstract double CalculerConsommation(double distance); // MÃ©thode concrÃ¨te (avec implÃ©mentation) public void AfficherInfo() { Console.WriteLine($\"VÃ©hicule: {Marque} {Modele}\"); } // MÃ©thode virtuelle (peut Ãªtre redÃ©finie) public virtual void Klaxonner() { Console.WriteLine(\"Beep beep!\"); } } // Classe dÃ©rivÃ©e - doit implÃ©menter toutes les mÃ©thodes abstraites public class Voiture : Vehicule { public int NombrePortes { get; set; } public Voiture(string marque, string modele, int portes) : base(marque, modele) { NombrePortes = portes; } // ImplÃ©mentation obligatoire public override void Demarrer() { Console.WriteLine($\"La voiture {Marque} {Modele} dÃ©marre avec la clÃ©.\"); } // ImplÃ©mentation obligatoire public override double CalculerConsommation(double distance) { return distance * 0.07; // 7L/100km } } public class Moto : Vehicule { public bool ASidecar { get; set; } public Moto(string marque, string modele) : base(marque, modele) { } public override void Demarrer() { Console.WriteLine($\"La moto {Marque} {Modele} dÃ©marre avec le kick.\"); } public override double CalculerConsommation(double distance) { return distance * 0.04; // 4L/100km } public override void Klaxonner() { Console.WriteLine(\"Beep beep! (son de moto)\"); } } // Utilisation // var v = new Vehicule(\"Test\", \"Test\"); // ERREUR: impossible d'instancier une classe abstraite var voiture = new Voiture(\"Toyota\", \"Corolla\", 4); voiture.AfficherInfo(); voiture.Demarrer(); Console.WriteLine($\"Consommation sur 100km: {voiture.CalculerConsommation(100)}L\"); var moto = new Moto(\"Harley\", \"Davidson\"); moto.Demarrer(); Exemple avancÃ© : SystÃ¨me de paiement public abstract class MoyenPaiement { public string Titulaire { get; set; } public DateTime DateTransaction { get; protected set; } public abstract bool Payer(decimal montant); public abstract bool Verifier(); public virtual void AfficherRecu(decimal montant) { Console.WriteLine($\"ReÃ§u - {Titulaire}\"); Console.WriteLine($\"Montant: {montant:C}\"); Console.WriteLine($\"Date: {DateTransaction}\"); } } public class CarteCredit : MoyenPaiement { public string Numero { get; set; } public DateTime DateExpiration { get; set; } public decimal LimiteCredit { get; set; } private decimal _soldeUtilise; public override bool Verifier() { return DateExpiration \u003e DateTime.Now; } public override bool Payer(decimal montant) { if (!Verifier()) { Console.WriteLine(\"Carte expirÃ©e\"); return false; } if (_soldeUtilise + montant \u003e LimiteCredit) { Console.WriteLine(\"Limite de crÃ©dit dÃ©passÃ©e\"); return false; } _soldeUtilise += montant; DateTransaction = DateTime.Now; Console.WriteLine($\"Paiement de {montant:C} effectuÃ© par carte de crÃ©dit\"); return true; } } public class Paypal : MoyenPaiement { public string Email { get; set; } public decimal Solde { get; private set; } public void Recharger(decimal montant) { Solde += montant; } public override bool Verifier() { return !string.IsNullOrEmpty(Email) \u0026\u0026 Email.Contains(\"@\"); } public override bool Payer(decimal montant) { if (!Verifier()) { Console.WriteLine(\"Email invalide\"); return false; } if (Solde \u003c montant) { Console.WriteLine(\"Solde insuffisant\"); return false; } Solde -= montant; DateTransaction = DateTime.Now; Console.WriteLine($\"Paiement de {montant:C} effectuÃ© via PayPal\"); return true; } } 8. Les Interfaces Une interface dÃ©finit un contrat que les classes doivent respecter. Elle ne contient que des signatures de mÃ©thodes, propriÃ©tÃ©s, Ã©vÃ©nements ou indexeurs (pas dâ€™implÃ©mentation).\nCaractÃ©ristiques DÃ©clarÃ©e avec le mot-clÃ© interface Tous les membres sont publics par dÃ©faut Une classe peut implÃ©menter plusieurs interfaces (contrairement Ã  lâ€™hÃ©ritage) Pas de champs, pas de constructeurs Convention de nommage : prÃ©fixe I (ex: IComparable) // DÃ©finition d'interfaces public interface IVolant { void Voler(); double AltitudeMax { get; } } public interface INageant { void Nager(); double ProfondeurMax { get; } } public interface IMarchant { void Marcher(); } // Classe implÃ©mentant une interface public class Oiseau : IVolant, IMarchant { public string Nom { get; set; } // ImplÃ©mentation de IVolant public double AltitudeMax { get; set; } = 1000; public void Voler() { Console.WriteLine($\"{Nom} vole dans le ciel.\"); } // ImplÃ©mentation de IMarchant public void Marcher() { Console.WriteLine($\"{Nom} marche sur le sol.\"); } } public class Canard : IVolant, INageant, IMarchant { public string Nom { get; set; } public double AltitudeMax { get; set; } = 500; public double ProfondeurMax { get; set; } = 10; public void Voler() { Console.WriteLine($\"{Nom} le canard vole.\"); } public void Nager() { Console.WriteLine($\"{Nom} le canard nage.\"); } public void Marcher() { Console.WriteLine($\"{Nom} le canard marche.\"); } } public class Poisson : INageant { public string Nom { get; set; } public double ProfondeurMax { get; set; } = 100; public void Nager() { Console.WriteLine($\"{Nom} le poisson nage sous l'eau.\"); } } // Utilisation polymorphe des interfaces class Program { static void FaireVoler(IVolant volant) { volant.Voler(); Console.WriteLine($\"Altitude maximale: {volant.AltitudeMax}m\"); } static void FaireNager(INageant nageant) { nageant.Nager(); Console.WriteLine($\"Profondeur maximale: {nageant.ProfondeurMax}m\"); } static void Main() { var oiseau = new Oiseau { Nom = \"Aigle\" }; var canard = new Canard { Nom = \"Donald\" }; var poisson = new Poisson { Nom = \"Nemo\" }; FaireVoler(oiseau); FaireVoler(canard); FaireNager(canard); FaireNager(poisson); // Collection polymorphe List\u003cINageant\u003e animauxAquatiques = new List\u003cINageant\u003e { canard, poisson }; foreach (var animal in animauxAquatiques) { animal.Nager(); } } } Interfaces vs Classes Abstraites Aspect Interface Classe Abstraite HÃ©ritage multiple âœ… Oui (une classe peut implÃ©menter plusieurs interfaces) âŒ Non (une classe ne peut hÃ©riter que dâ€™une seule classe) ImplÃ©mentation âŒ Aucune (sauf depuis C# 8.0 avec implÃ©mentation par dÃ©faut) âœ… Peut contenir des mÃ©thodes implÃ©mentÃ©es Champs âŒ Non âœ… Oui Constructeurs âŒ Non âœ… Oui Modificateurs dâ€™accÃ¨s Tous publics Peut varier Utilisation DÃ©finir un contrat/comportement DÃ©finir une base commune avec du code partagÃ© Exemple pratique : SystÃ¨me de notification public interface INotifiable { void EnvoyerNotification(string message); bool EstActif { get; set; } } public interface IConfigurable { void Configurer(Dictionary\u003cstring, string\u003e parametres); Dictionary\u003cstring, string\u003e ObtenirConfiguration(); } public class NotificationEmail : INotifiable, IConfigurable { public bool EstActif { get; set; } = true; public string AdresseEmail { get; set; } public string ServeurSMTP { get; set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"ğŸ“§ Email envoyÃ© Ã  {AdresseEmail}: {message}\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"email\")) AdresseEmail = parametres[\"email\"]; if (parametres.ContainsKey(\"smtp\")) ServeurSMTP = parametres[\"smtp\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"email\", AdresseEmail }, { \"smtp\", ServeurSMTP } }; } } public class NotificationSMS : INotifiable, IConfigurable { public bool EstActif { get; set; } = true; public string NumeroTelephone { get; set; } public string FournisseurSMS { get; set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"ğŸ“± SMS envoyÃ© au {NumeroTelephone}: {message}\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"telephone\")) NumeroTelephone = parametres[\"telephone\"]; if (parametres.ContainsKey(\"fournisseur\")) FournisseurSMS = parametres[\"fournisseur\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"telephone\", NumeroTelephone }, { \"fournisseur\", FournisseurSMS } }; } } public class GestionnaireNotifications { private List\u003cINotifiable\u003e _canaux = new List\u003cINotifiable\u003e(); public void AjouterCanal(INotifiable canal) { _canaux.Add(canal); } public void EnvoyerATous(string message) { foreach (var canal in _canaux) { canal.EnvoyerNotification(message); } } } ImplÃ©mentation explicite dâ€™interface UtilisÃ©e pour Ã©viter les conflits de noms entre plusieurs interfaces.\npublic interface IAnimal { void Manger(); } public interface IRobot { void Manger(); // MÃªme nom de mÃ©thode } public class CyberChien : IAnimal, IRobot { // ImplÃ©mentation explicite de IAnimal.Manger void IAnimal.Manger() { Console.WriteLine(\"Le cyber-chien mange de la vraie nourriture\"); } // ImplÃ©mentation explicite de IRobot.Manger void IRobot.Manger() { Console.WriteLine(\"Le cyber-chien recharge ses batteries\"); } // MÃ©thode publique normale public void SeReposer() { Console.WriteLine(\"Le cyber-chien se met en veille\"); } } // Utilisation var cyberChien = new CyberChien(); // cyberChien.Manger(); // ERREUR: ambiguÃ¯tÃ© IAnimal animal = cyberChien; animal.Manger(); // Appelle IAnimal.Manger IRobot robot = cyberChien; robot.Manger(); // Appelle IRobot.Manger cyberChien.SeReposer(); // OK 9. Concepts AvancÃ©s 9.1 Membres statiques Les membres statiques appartiennent Ã  la classe plutÃ´t quâ€™Ã  une instance.\npublic class Compteur { // Champ statique (partagÃ© par toutes les instances) private static int _nombreInstances = 0; // PropriÃ©tÃ© statique public static int NombreInstances { get { return _nombreInstances; } } // Champ d'instance public int Id { get; private set; } // Constructeur public Compteur() { _nombreInstances++; Id = _nombreInstances; } // MÃ©thode statique public static void Reinitialiser() { _nombreInstances = 0; } // MÃ©thode d'instance public void AfficherInfo() { Console.WriteLine($\"Instance #{Id} - Total: {NombreInstances}\"); } } // Constructeur statique (appelÃ© une seule fois avant la premiÃ¨re utilisation) public class Configuration { public static string CheminFichier { get; private set; } static Configuration() { Console.WriteLine(\"Initialisation de la configuration...\"); CheminFichier = \"config.json\"; } } // Utilisation var c1 = new Compteur(); // NombreInstances = 1 var c2 = new Compteur(); // NombreInstances = 2 var c3 = new Compteur(); // NombreInstances = 3 Console.WriteLine(Compteur.NombreInstances); // 3 c2.AfficherInfo(); // Instance #2 - Total: 3 9.2 Classes statiques Une classe statique ne peut contenir que des membres statiques et ne peut pas Ãªtre instanciÃ©e.\npublic static class Utilitaires { public static double CalculerMoyenne(params double[] nombres) { if (nombres.Length == 0) return 0; return nombres.Average(); } public static string FormaterMonnaie(decimal montant) { return $\"{montant:C}\"; } public static T Max\u003cT\u003e(T a, T b) where T : IComparable\u003cT\u003e { return a.CompareTo(b) \u003e 0 ? a : b; } } // Utilisation double moyenne = Utilitaires.CalculerMoyenne(10, 20, 30, 40); string prix = Utilitaires.FormaterMonnaie(99.99m); int maximum = Utilitaires.Max(5, 10); 9.3 Classes partielles (Partial Classes) Permettent de diviser la dÃ©finition dâ€™une classe en plusieurs fichiers.\n// Fichier: Personne.cs public partial class Personne { public string Nom { get; set; } public string Prenom { get; set; } partial void OnNomChanged(); } // Fichier: Personne.Methodes.cs public partial class Personne { public void SePresenter() { Console.WriteLine($\"Je suis {Prenom} {Nom}\"); } partial void OnNomChanged() { Console.WriteLine(\"Le nom a Ã©tÃ© modifiÃ©\"); } } 9.4 DÃ©lÃ©guÃ©s et Ã‰vÃ©nements (aperÃ§u) // DÃ©lÃ©guÃ© (type pointeur de fonction) public delegate void NotificationHandler(string message); public class Compte { // Ã‰vÃ©nement public event NotificationHandler SoldeModifie; private decimal _solde; public decimal Solde { get { return _solde; } set { _solde = value; // DÃ©clencher l'Ã©vÃ©nement SoldeModifie?.Invoke($\"Nouveau solde: {_solde:C}\"); } } } // Utilisation var compte = new Compte(); compte.SoldeModifie += (msg) =\u003e Console.WriteLine($\"Notification: {msg}\"); compte.Solde = 100; // DÃ©clenche l'Ã©vÃ©nement 9.5 GÃ©nÃ©riques (Generics) // Classe gÃ©nÃ©rique public class Boite\u003cT\u003e { private T _contenu; public void Ranger(T item) { _contenu = item; } public T Recuperer() { return _contenu; } } // Utilisation var boiteEntiers = new Boite\u003cint\u003e(); boiteEntiers.Ranger(42); int nombre = boiteEntiers.Recuperer(); var boiteTexte = new Boite\u003cstring\u003e(); boiteTexte.Ranger(\"Bonjour\"); string texte = boiteTexte.Recuperer(); // Classe gÃ©nÃ©rique avec contraintes public class Repository\u003cT\u003e where T : class, new() { private List\u003cT\u003e _items = new List\u003cT\u003e(); public void Ajouter(T item) { _items.Add(item); } public T Creer() { return new T(); // Possible grÃ¢ce Ã  la contrainte 'new()' } } 9.6 Extension Methods // Classe statique pour les mÃ©thodes d'extension public static class StringExtensions { // MÃ©thode d'extension (noter le 'this' devant le premier paramÃ¨tre) public static bool EstEmail(this string texte) { return texte.Contains(\"@\") \u0026\u0026 texte.Contains(\".\"); } public static string Inverser(this string texte) { char[] chars = texte.ToCharArray(); Array.Reverse(chars); return new string(chars); } public static int CompterMots(this string texte) { return texte.Split(new[] { ' ', '\\t', '\\n' }, StringSplitOptions.RemoveEmptyEntries).Length; } } // Utilisation string email = \"test@example.com\"; bool valide = email.EstEmail(); // true string mot = \"Bonjour\"; string inverse = mot.Inverser(); // \"ruojnoB\" string phrase = \"Ceci est une phrase\"; int mots = phrase.CompterMots(); // 4 9.7 Records (C# 9.0+) Les records sont des types de rÃ©fÃ©rence immuables optimisÃ©s pour stocker des donnÃ©es.\n// Record simple public record Personne(string Nom, string Prenom, int Age); // Utilisation var p1 = new Personne(\"Tremblay\", \"Marie\", 25); var p2 = new Personne(\"Tremblay\", \"Marie\", 25); Console.WriteLine(p1 == p2); // true (Ã©galitÃ© par valeur) // Expression 'with' pour crÃ©er une copie modifiÃ©e var p3 = p1 with { Age = 26 }; // Record avec propriÃ©tÃ©s additionnelles public record Employe(string Nom, string Prenom, decimal Salaire) { public string Departement { get; init; } = \"Non assignÃ©\"; public decimal CalculerSalaireAnnuel() =\u003e Salaire * 12; } RÃ©sumÃ© des concepts clÃ©s Quand utiliser quoi ? Concept Utilisation Classe normale Objets avec Ã©tat et comportement Classe abstraite Base commune avec implÃ©mentation partielle Interface Contrat sans implÃ©mentation, hÃ©ritage multiple Classe statique MÃ©thodes utilitaires sans Ã©tat Record DonnÃ©es immuables Sealed class EmpÃªcher lâ€™hÃ©ritage Partial class Diviser une classe en plusieurs fichiers Modificateurs dâ€™accÃ¨s (du plus au moins restrictif) private - Classe uniquement protected - Classe et dÃ©rivÃ©es internal - Assembly actuel protected internal - Assembly ou dÃ©rivÃ©es public - Partout Principes SOLID Single Responsibility: Une classe = une responsabilitÃ© Open/Closed: Ouvert Ã  lâ€™extension, fermÃ© Ã  la modification Liskov Substitution: Les sous-classes doivent pouvoir remplacer leurs classes de base Interface Segregation: Interfaces petites et spÃ©cifiques Dependency Inversion: DÃ©pendre des abstractions, pas des implÃ©mentations concrÃ¨tes Exercices pratiques Exercice 1 : CrÃ©er une hiÃ©rarchie de comptes bancaires CrÃ©ez une classe de base CompteBancaire et des classes dÃ©rivÃ©es CompteEpargne et CompteCourant avec des comportements diffÃ©rents.\nExercice 2 : SystÃ¨me de formes gÃ©omÃ©triques CrÃ©ez une classe abstraite Forme avec des mÃ©thodes pour calculer lâ€™aire et le pÃ©rimÃ¨tre. ImplÃ©mentez des classes concrÃ¨tes comme Cercle, Carre, Triangle.\nExercice 3 : Gestion dâ€™une bibliothÃ¨que Utilisez des interfaces IEmpruntable, IReservable pour crÃ©er un systÃ¨me de gestion de livres, DVD, magazines.\nExercice 4 : Simulateur de zoo CrÃ©ez une hiÃ©rarchie dâ€™animaux avec des interfaces pour diffÃ©rents comportements (voler, nager, grimper).",
    "description": "Table des matiÃ¨res Introduction Ã  la POO Les Classes et les Objets Les Attributs (Champs) Les PropriÃ©tÃ©s (Properties) Lâ€™Encapsulation Les MÃ©thodes Les Constructeurs Lâ€™HÃ©ritage Le Polymorphisme 1. Introduction Ã  la POO 1.1 Quâ€™est-ce que la Programmation OrientÃ©e Objet ? La Programmation OrientÃ©e Objet (POO) est un paradigme de programmation qui organise le code autour du concept dâ€™objets plutÃ´t que de fonctions et de logique. Un objet combine des donnÃ©es (ce quâ€™il possÃ¨de) et des comportements (ce quâ€™il peut faire).",
    "tags": [],
    "title": "Programmation orientÃ©e objet - partie 1",
    "uri": "/420-413/poo/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Table des matiÃ¨res Le mot-clÃ© Virtual Le mot-clÃ© Abstract Le mot-clÃ© Sealed Les Classes Abstraites Les Interfaces Membres Statiques Cours POO C# - Partie 2 : Concepts AvancÃ©s 10. Le mot-clÃ© Virtual 10.1 DÃ©finition Le mot-clÃ© virtual permet de dÃ©clarer une mÃ©thode qui peut Ãªtre redÃ©finie (override) dans les classes dÃ©rivÃ©es. Câ€™est la base du polymorphisme dâ€™exÃ©cution en C#.\nConcepts clÃ©s :\nUne mÃ©thode virtual a une implÃ©mentation dans la classe de base Les classes dÃ©rivÃ©es peuvent (mais ne sont pas obligÃ©es) la redÃ©finir Si elles ne la redÃ©finissent pas, elles utilisent lâ€™implÃ©mentation de base Analogie : Câ€™est comme une recette de base que vous pouvez personnaliser. La recette originale existe et fonctionne, mais vous pouvez lâ€™adapter Ã  votre goÃ»t.\n10.2 Syntaxe et Utilisation // ========================================== // CLASSE DE BASE avec mÃ©thode virtual // ========================================== public class Animal { protected string _nom; public Animal(string nom) { _nom = nom; } // ========================================== // MÃ‰THODE VIRTUAL - Peut Ãªtre redÃ©finie // ========================================== public virtual void EmettreS on() { Console.WriteLine($\"{_nom} Ã©met un son gÃ©nÃ©rique.\"); } // ========================================== // MÃ‰THODE NORMALE (non-virtual) - Ne peut PAS Ãªtre redÃ©finie polymorphiquement // ========================================== public void Dormir() { Console.WriteLine($\"{_nom} dort.\"); } } // ========================================== // CLASSE DÃ‰RIVÃ‰E - RedÃ©finit la mÃ©thode virtual // ========================================== public class Chien : Animal { public Chien(string nom) : base(nom) { } // ========================================== // OVERRIDE - RedÃ©finition de la mÃ©thode virtual // ========================================== public override void EmettreSound() { Console.WriteLine($\"{_nom} aboie: Wouf wouf!\"); } } public class Chat : Animal { public Chat(string nom) : base(nom) { } public override void EmettreSound() { Console.WriteLine($\"{_nom} miaule: Miaou!\"); } } public class Vache : Animal { public Vache(string nom) : base(nom) { } public override void EmettreSound() { Console.WriteLine($\"{_nom} meugle: Meuh!\"); } } // ========================================== // DÃ‰MONSTRATION DU POLYMORPHISME // ========================================== class Program { static void Main() { // CrÃ©ation d'objets de types diffÃ©rents Animal animal1 = new Chien(\"Rex\"); Animal animal2 = new Chat(\"FÃ©lix\"); Animal animal3 = new Vache(\"Marguerite\"); Animal animal4 = new Animal(\"CrÃ©ature\"); // ========================================== // POLYMORPHISME EN ACTION // MÃªme appel de mÃ©thode, comportements diffÃ©rents // ========================================== animal1.EmettreSound(); // Rex aboie: Wouf wouf! animal2.EmettreSound(); // FÃ©lix miaule: Miaou! animal3.EmettreSound(); // Marguerite meugle: Meuh! animal4.EmettreSound(); // CrÃ©ature Ã©met un son gÃ©nÃ©rique. // ========================================== // UTILISATION PRATIQUE : Tableau polymorphe // ========================================== Animal[] animaux = new Animal[] { new Chien(\"Max\"), new Chat(\"Minou\"), new Vache(\"Bella\"), new Chien(\"Rocky\") }; Console.WriteLine(\"\\n=== Concert animalier ===\"); foreach (Animal animal in animaux) { animal.EmettreSound(); // Appelle la bonne version automatiquement } } } Affichage :\nRex aboie: Wouf wouf!\rFÃ©lix miaule: Miaou!\rMarguerite meugle: Meuh!\rCrÃ©ature Ã©met un son gÃ©nÃ©rique.\r=== Concert animalier ===\rMax aboie: Wouf wouf!\rMinou miaule: Miaou!\rBella meugle: Meuh!\rRocky aboie: Wouf wouf! 10.3 Exemple Complet : SystÃ¨me de Calcul de Salaire public class Employe { public string Nom { get; set; } public decimal SalaireBase { get; set; } public Employe(string nom, decimal salaireBase) { Nom = nom; SalaireBase = salaireBase; } // ========================================== // MÃ‰THODE VIRTUAL - Calcul de base // ========================================== public virtual decimal CalculerSalaire() { Console.WriteLine($\"[Employe] Calcul standard pour {Nom}\"); return SalaireBase; } public virtual void AfficherDetails() { Console.WriteLine($\"\\n=== {Nom} ===\"); Console.WriteLine($\"Type: EmployÃ©\"); Console.WriteLine($\"Salaire de base: {SalaireBase:C}\"); Console.WriteLine($\"Salaire total: {CalculerSalaire():C}\"); } } public class Manager : Employe { public decimal Prime { get; set; } public Manager(string nom, decimal salaireBase, decimal prime) : base(nom, salaireBase) { Prime = prime; } // ========================================== // OVERRIDE - RedÃ©finition pour Manager // ========================================== public override decimal CalculerSalaire() { Console.WriteLine($\"[Manager] Calcul avec prime pour {Nom}\"); return SalaireBase + Prime; } public override void AfficherDetails() { base.AfficherDetails(); // Appelle la version de base Console.WriteLine($\"Prime: {Prime:C}\"); } } public class Vendeur : Employe { public decimal CommissionPourcentage { get; set; } public decimal VentesTotales { get; set; } public Vendeur(string nom, decimal salaireBase, decimal commission) : base(nom, salaireBase) { CommissionPourcentage = commission; } public override decimal CalculerSalaire() { Console.WriteLine($\"[Vendeur] Calcul avec commission pour {Nom}\"); decimal commission = VentesTotales * (CommissionPourcentage / 100); return SalaireBase + commission; } public override void AfficherDetails() { base.AfficherDetails(); Console.WriteLine($\"Commission: {CommissionPourcentage}%\"); Console.WriteLine($\"Ventes: {VentesTotales:C}\"); } } public class Stagiaire : Employe { public int HeuresTravaillees { get; set; } public decimal TauxHoraire { get; set; } public Stagiaire(string nom, decimal tauxHoraire) : base(nom, 0) // Pas de salaire de base { TauxHoraire = tauxHoraire; } public override decimal CalculerSalaire() { Console.WriteLine($\"[Stagiaire] Calcul horaire pour {Nom}\"); return HeuresTravaillees * TauxHoraire; } public override void AfficherDetails() { Console.WriteLine($\"\\n=== {Nom} ===\"); Console.WriteLine($\"Type: Stagiaire\"); Console.WriteLine($\"Taux horaire: {TauxHoraire:C}\"); Console.WriteLine($\"Heures travaillÃ©es: {HeuresTravaillees}h\"); Console.WriteLine($\"Salaire total: {CalculerSalaire():C}\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // ========================================== // CrÃ©ation d'employÃ©s de diffÃ©rents types // ========================================== Employe e1 = new Employe(\"Alice\", 3000); Manager m1 = new Manager(\"Bob\", 4000, 1000); Vendeur v1 = new Vendeur(\"Charlie\", 2500, 5) { VentesTotales = 50000 }; Stagiaire s1 = new Stagiaire(\"David\", 15) { HeuresTravaillees = 120 }; // ========================================== // POLYMORPHISME : Liste hÃ©tÃ©rogÃ¨ne // ========================================== List\u003cEmploye\u003e employes = new List\u003cEmploye\u003e { e1, m1, v1, s1 }; Console.WriteLine(\"=== CALCUL DES SALAIRES ===\\n\"); decimal masseSalariale = 0; foreach (Employe employe in employes) { // Appelle la bonne version de CalculerSalaire() // automatiquement selon le type rÃ©el decimal salaire = employe.CalculerSalaire(); masseSalariale += salaire; employe.AfficherDetails(); } Console.WriteLine($\"\\n=== TOTAL ===\"); Console.WriteLine($\"Masse salariale totale: {masseSalariale:C}\"); } } 10.4 RÃ¨gles Importantes de virtual et override public class ClasseBase { // âœ… MÃ©thode virtual - Peut Ãªtre redÃ©finie public virtual void Methode1() { } // âœ… MÃ©thode normale - Ne peut pas Ãªtre redÃ©finie polymorphiquement public void Methode2() { } // âœ… PropriÃ©tÃ© virtual public virtual string Propriete { get; set; } } public class ClasseDerivee : ClasseBase { // âœ… OK - Override d'une mÃ©thode virtual public override void Methode1() { } // âŒ ERREUR - Ne peut pas override une mÃ©thode non-virtual // public override void Methode2() { } // âœ… OK - Override d'une propriÃ©tÃ© virtual public override string Propriete { get; set; } // âš ï¸ ATTENTION - Masquage avec 'new' (pas polymorphique) public new void Methode2() { // Ceci n'est PAS du polymorphisme // C'est du \"masquage\" (hiding) } } DiffÃ©rence entre override et new :\npublic class Base { public virtual void Afficher() { Console.WriteLine(\"Base.Afficher()\"); } } public class Derivee1 : Base { public override void Afficher() // OVERRIDE { Console.WriteLine(\"Derivee1.Afficher()\"); } } public class Derivee2 : Base { public new void Afficher() // NEW (masquage) { Console.WriteLine(\"Derivee2.Afficher()\"); } } // Test Base b1 = new Derivee1(); b1.Afficher(); // \"Derivee1.Afficher()\" - POLYMORPHISME âœ… Base b2 = new Derivee2(); b2.Afficher(); // \"Base.Afficher()\" - PAS de polymorphisme âš ï¸ Derivee2 d2 = new Derivee2(); d2.Afficher(); // \"Derivee2.Afficher()\" - Appelle la version masquÃ©e 11. Le mot-clÃ© Abstract 11.1 DÃ©finition Le mot-clÃ© abstract permet de dÃ©clarer :\nDes classes abstraites : Classes incomplÃ¨tes qui ne peuvent pas Ãªtre instanciÃ©es Des mÃ©thodes abstraites : MÃ©thodes sans implÃ©mentation qui DOIVENT Ãªtre redÃ©finies dans les classes dÃ©rivÃ©es DiffÃ©rence avec virtual :\nvirtual : MÃ©thode avec implÃ©mentation, redÃ©finition optionnelle abstract : MÃ©thode sans implÃ©mentation, redÃ©finition obligatoire Analogie :\nUne classe abstraite est comme un plan architectural incomplet Elle dÃ©finit la structure mais certaines parties doivent Ãªtre complÃ©tÃ©es Vous ne pouvez pas habiter dans un plan, vous devez construire la maison complÃ¨te 11.2 MÃ©thodes Abstraites public abstract class Forme { protected string _nom; protected string _couleur; public Forme(string nom, string couleur) { _nom = nom; _couleur = couleur; } // ========================================== // MÃ‰THODE ABSTRAITE - Pas d'implÃ©mentation // DOIT Ãªtre redÃ©finie dans les classes dÃ©rivÃ©es // ========================================== public abstract double CalculerAire(); public abstract double CalculerPerimetre(); // ========================================== // MÃ‰THODE CONCRÃˆTE - A une implÃ©mentation // ========================================== public void AfficherInfos() { Console.WriteLine($\"\\n{_nom} ({_couleur})\"); Console.WriteLine($\"Aire: {CalculerAire():F2}\"); Console.WriteLine($\"PÃ©rimÃ¨tre: {CalculerPerimetre():F2}\"); } } // ========================================== // CLASSE DÃ‰RIVÃ‰E - DOIT implÃ©menter les mÃ©thodes abstraites // ========================================== public class Cercle : Forme { private double _rayon; public Cercle(double rayon, string couleur) : base(\"Cercle\", couleur) { _rayon = rayon; } // ========================================== // IMPLÃ‰MENTATION OBLIGATOIRE // ========================================== public override double CalculerAire() { return Math.PI * _rayon * _rayon; } public override double CalculerPerimetre() { return 2 * Math.PI * _rayon; } } public class Rectangle : Forme { private double _longueur; private double _largeur; public Rectangle(double longueur, double largeur, string couleur) : base(\"Rectangle\", couleur) { _longueur = longueur; _largeur = largeur; } public override double CalculerAire() { return _longueur * _largeur; } public override double CalculerPerimetre() { return 2 * (_longueur + _largeur); } } // ========================================== // SI on oublie d'implÃ©menter une mÃ©thode abstraite â†’ ERREUR // ========================================== /* public class Triangle : Forme // âŒ ERREUR DE COMPILATION { // Erreur: Triangle ne redÃ©finit pas les mÃ©thodes abstraites } */ // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // âŒ ERREUR - Impossible d'instancier une classe abstraite // Forme f = new Forme(\"Test\", \"Rouge\"); // âœ… OK - Instanciation des classes concrÃ¨tes Forme cercle = new Cercle(5, \"Rouge\"); Forme rectangle = new Rectangle(4, 6, \"Bleu\"); // Polymorphisme cercle.AfficherInfos(); rectangle.AfficherInfos(); // Liste polymorphe List\u003cForme\u003e formes = new List\u003cForme\u003e { new Cercle(3, \"Vert\"), new Rectangle(5, 2, \"Jaune\"), new Cercle(7, \"Orange\") }; double aireTotal e = 0; foreach (Forme forme in formes) { aireTotal += forme.CalculerAire(); } Console.WriteLine($\"\\nAire totale: {aireTotal:F2}\"); } } 11.3 PropriÃ©tÃ©s Abstraites Les propriÃ©tÃ©s peuvent aussi Ãªtre abstraites.\npublic abstract class Vehicule { // ========================================== // PROPRIÃ‰TÃ‰ ABSTRAITE // ========================================== public abstract int NombreRoues { get; } public abstract string TypeCarburant { get; set; } public void AfficherInfos() { Console.WriteLine($\"VÃ©hicule Ã  {NombreRoues} roues\"); Console.WriteLine($\"Carburant: {TypeCarburant}\"); } } public class Voiture : Vehicule { public override int NombreRoues { get { return 4; } } private string _typeCarburant; public override string TypeCarburant { get { return _typeCarburant; } set { _typeCarburant = value; } } public Voiture() { _typeCarburant = \"Essence\"; } } public class Moto : Vehicule { public override int NombreRoues { get { return 2; } } public override string TypeCarburant { get; set; } = \"Essence\"; } 11.4 Combinaison de Virtual et Abstract Une classe abstraite peut contenir un mÃ©lange de mÃ©thodes abstraites, virtuelles et concrÃ¨tes.\npublic abstract class Animal { protected string _nom; public Animal(string nom) { _nom = nom; } // ========================================== // MÃ‰THODE ABSTRAITE - ImplÃ©mentation obligatoire // ========================================== public abstract void EmettreSound(); // ========================================== // MÃ‰THODE VIRTUELLE - RedÃ©finition optionnelle // ========================================== public virtual void Manger() { Console.WriteLine($\"{_nom} mange.\"); } // ========================================== // MÃ‰THODE CONCRÃˆTE - ImplÃ©mentation finale // ========================================== public void Dormir() { Console.WriteLine($\"{_nom} dort.\"); } } public class Chien : Animal { public Chien(string nom) : base(nom) { } // OBLIGATOIRE - MÃ©thode abstraite public override void EmettreSound() { Console.WriteLine($\"{_nom} aboie!\"); } // OPTIONNEL - MÃ©thode virtuelle public override void Manger() { Console.WriteLine($\"{_nom} dÃ©vore ses croquettes!\"); } // Dormir() est hÃ©ritÃ© tel quel } 12. Le mot-clÃ© Sealed 12.1 DÃ©finition Le mot-clÃ© sealed empÃªche lâ€™hÃ©ritage ou la redÃ©finition :\nClasse sealed : Aucune classe ne peut en hÃ©riter MÃ©thode sealed : Aucune classe dÃ©rivÃ©e ne peut la redÃ©finir Pourquoi utiliser sealed ?\nSÃ©curitÃ© : EmpÃªcher les modifications non dÃ©sirÃ©es Performance : Optimisations possibles par le compilateur Design : Indiquer quâ€™une classe est â€œcomplÃ¨teâ€ et finale Analogie : Câ€™est comme sceller un document avec de la cire. Une fois scellÃ©, il ne peut plus Ãªtre modifiÃ©.\n12.2 Classe Sealed // ========================================== // CLASSE SEALED - Ne peut pas Ãªtre hÃ©ritÃ©e // ========================================== public sealed class MathUtils { public static double CalculerMoyenne(params double[] nombres) { return nombres.Average(); } public static int Max(int a, int b) { return a \u003e b ? a : b; } } // âŒ ERREUR DE COMPILATION - Impossible d'hÃ©riter d'une classe sealed /* public class MesUtils : MathUtils { // Erreur: cannot derive from sealed type 'MathUtils' } */ Exemples de classes sealed dans .NET :\nString : sealed (impossible dâ€™hÃ©riter de string) Int32, Double, etc. : sealed DateTime : sealed // âŒ Impossible // public class MaChaine : String { } // âœ… Utilisation normale string texte = \"Bonjour\"; 12.3 MÃ©thode Sealed Une mÃ©thode sealed empÃªche sa redÃ©finition dans les classes dÃ©rivÃ©es ultÃ©rieures.\nImportant : Une mÃ©thode ne peut Ãªtre sealed que si elle override dÃ©jÃ  une mÃ©thode.\npublic class Animal { public virtual void EmettreSound() { Console.WriteLine(\"Son animal\"); } } public class Mammifere : Animal { // ========================================== // OVERRIDE + SEALED // Cette version est finale, ne peut plus Ãªtre redÃ©finie // ========================================== public sealed override void EmettreSound() { Console.WriteLine(\"Son de mammifÃ¨re\"); } } public class Chien : Mammifere { // âŒ ERREUR - Ne peut pas override une mÃ©thode sealed /* public override void EmettreSound() { Console.WriteLine(\"Wouf!\"); } */ // âœ… OK - MÃ©thode diffÃ©rente (pas un override) public void Aboyer() { Console.WriteLine(\"Wouf!\"); } } 12.4 Cas dâ€™Usage de Sealed Exemple 1 : Classe Utilitaire ComplÃ¨te // Classe utilitaire qui ne devrait jamais Ãªtre modifiÃ©e public sealed class ConfigurationManager { private static ConfigurationManager _instance; private Dictionary\u003cstring, string\u003e _settings; private ConfigurationManager() { _settings = new Dictionary\u003cstring, string\u003e(); ChargerConfiguration(); } public static ConfigurationManager Instance { get { if (_instance == null) _instance = new ConfigurationManager(); return _instance; } } private void ChargerConfiguration() { // Chargement de la configuration } public string ObtenirValeur(string cle) { return _settings.ContainsKey(cle) ? _settings[cle] : null; } } // Impossible d'hÃ©riter pour modifier le comportement Exemple 2 : MÃ©thode Sealed pour la SÃ©curitÃ© public class SystemeSÃ©curitÃ© { public virtual bool VerifierAcces(string utilisateur) { Console.WriteLine(\"VÃ©rification de base\"); return true; } } public class SystemeAvance : SystemeSÃ©curitÃ© { // Version finale de la vÃ©rification - ne doit plus Ãªtre modifiÃ©e public sealed override bool VerifierAcces(string utilisateur) { Console.WriteLine(\"VÃ©rification avancÃ©e (FINALE)\"); // Logique critique de sÃ©curitÃ© bool accesBase = base.VerifierAcces(utilisateur); bool verification2FA = Verifier2FA(utilisateur); bool verificationBiometrique = VerifierBiometrie(utilisateur); return accesBase \u0026\u0026 verification2FA \u0026\u0026 verificationBiometrique; } private bool Verifier2FA(string utilisateur) { return true; } private bool VerifierBiometrie(string utilisateur) { return true; } } // Aucune classe dÃ©rivÃ©e ne peut affaiblir la sÃ©curitÃ© public class SystemeTresAvance : SystemeAvance { // âŒ Ne peut pas override VerifierAcces // La sÃ©curitÃ© est garantie } 13. Les Classes Abstraites 13.1 DÃ©finition ComplÃ¨te Une classe abstraite est une classe dÃ©clarÃ©e avec le mot-clÃ© abstract qui :\nNe peut pas Ãªtre instanciÃ©e directement Peut contenir des mÃ©thodes abstraites (sans implÃ©mentation) ET des mÃ©thodes concrÃ¨tes (avec implÃ©mentation) Peut avoir des constructeurs (appelÃ©s par les classes dÃ©rivÃ©es) Peut avoir des attributs, propriÃ©tÃ©s, etc. Sert de modÃ¨le ou de base pour dâ€™autres classes Quand utiliser une classe abstraite ?\nQuand vous voulez dÃ©finir un comportement commun pour un groupe de classes Quand certaines mÃ©thodes doivent Ãªtre implÃ©mentÃ©es diffÃ©remment par chaque classe dÃ©rivÃ©e Quand vous voulez partager du code entre classes similaires Quand la classe reprÃ©sente un concept abstrait qui ne devrait pas exister seul 13.2 Anatomie ComplÃ¨te dâ€™une Classe Abstraite public abstract class Vehicule { // ========================================== // 1. ATTRIBUTS (comme une classe normale) // ========================================== protected string _marque; protected string _modele; private int _annee; protected double _kilometrage; // ========================================== // 2. PROPRIÃ‰TÃ‰S // ========================================== public string Marque { get { return _marque; } } public string Modele { get { return _modele; } } public int Annee { get { return _annee; } } public double Kilometrage { get { return _kilometrage; } } // ========================================== // 3. CONSTRUCTEUR (Oui, les classes abstraites peuvent en avoir!) // ========================================== protected Vehicule(string marque, string modele, int annee) { _marque = marque; _modele = modele; _annee = annee; _kilometrage = 0; Console.WriteLine($\"Constructeur de Vehicule appelÃ© pour {marque} {modele}\"); } // ========================================== // 4. MÃ‰THODES ABSTRAITES - ImplÃ©mentation obligatoire // ========================================== public abstract void Demarrer(); public abstract double CalculerConsommation(double distance); public abstract string ObtenirTypeCarburant(); // ========================================== // 5. MÃ‰THODES VIRTUELLES - RedÃ©finition optionnelle // ========================================== public virtual void Accelerer(int vitesse) { Console.WriteLine($\"Le vÃ©hicule accÃ©lÃ¨re Ã  {vitesse} km/h\"); } public virtual void Klaxonner() { Console.WriteLine(\"Beep beep!\"); } // ========================================== // 6. MÃ‰THODES CONCRÃˆTES - HÃ©ritÃ©es telles quelles // ========================================== public void Rouler(double distance) { _kilometrage += distance; double consommation = CalculerConsommation(distance); // Appelle la mÃ©thode abstraite Console.WriteLine($\"Parcouru {distance} km. Consommation: {consommation:F2}L\"); Console.WriteLine($\"KilomÃ©trage total: {_kilometrage} km\"); } public void AfficherInfos() { Console.WriteLine($\"\\n=== {_marque} {_modele} ({_annee}) ===\"); Console.WriteLine($\"Type de carburant: {ObtenirTypeCarburant()}\"); Console.WriteLine($\"KilomÃ©trage: {_kilometrage} km\"); } // ========================================== // 7. PROPRIÃ‰TÃ‰S ABSTRAITES // ========================================== public abstract int NombreRoues { get; } } 13.3 ImplÃ©mentation de la Classe Abstraite // ========================================== // CLASSE CONCRÃˆTE 1 : Voiture // ========================================== public class Voiture : Vehicule { private string _typeCarburant; private double _consommationAu100; private int _nombrePortes; public Voiture(string marque, string modele, int annee, int portes, string carburant, double consommation) : base(marque, modele, annee) // Appelle le constructeur abstrait { _nombrePortes = portes; _typeCarburant = carburant; _consommationAu100 = consommation; } // ImplÃ©mentation obligatoire des mÃ©thodes abstraites public override void Demarrer() { Console.WriteLine($\"La voiture {_marque} {_modele} dÃ©marre avec la clÃ©.\"); } public override double CalculerConsommation(double distance) { return (distance / 100) * _consommationAu100; } public override string ObtenirTypeCarburant() { return _typeCarburant; } // ImplÃ©mentation de la propriÃ©tÃ© abstraite public override int NombreRoues { get { return 4; } } // RedÃ©finition optionnelle d'une mÃ©thode virtuelle public override void Klaxonner() { Console.WriteLine(\"La voiture klaxonne: BEEP BEEP!\"); } // Nouvelle mÃ©thode spÃ©cifique public void OuvrirCoffre() { Console.WriteLine(\"Coffre ouvert\"); } } // ========================================== // CLASSE CONCRÃˆTE 2 : Moto // ========================================== public class Moto : Vehicule { private bool _aSidecar; private double _consommationAu100; public Moto(string marque, string modele, int annee, bool sidecar, double consommation) : base(marque, modele, annee) { _aSidecar = sidecar; _consommationAu100 = consommation; } public override void Demarrer() { Console.WriteLine($\"La moto {_marque} {_modele} dÃ©marre avec le bouton start.\"); } public override double CalculerConsommation(double distance) { double consommation = (distance / 100) * _consommationAu100; if (_aSidecar) consommation *= 1.2; // 20% de plus avec sidecar return consommation; } public override string ObtenirTypeCarburant() { return \"Essence\"; } public override int NombreRoues { get { return _aSidecar ? 3 : 2; } } // Utilise la mÃ©thode virtuelle hÃ©ritÃ©e (pas de redÃ©finition) // Donc Klaxonner() sera \"Beep beep!\" de la classe de base } // ========================================== // CLASSE CONCRÃˆTE 3 : Camion // ========================================== public class Camion : Vehicule { private double _capaciteChargeTonnes; private double _consommationAu100; private double _chargeActuelle; public Camion(string marque, string modele, int annee, double capacite, double consommation) : base(marque, modele, annee) { _capaciteChargeTonnes = capacite; _consommationAu100 = consommation; _chargeActuelle = 0; } public override void Demarrer() { Console.WriteLine($\"Le camion {_marque} {_modele} dÃ©marre avec un vrombissement.\"); } public override double CalculerConsommation(double distance) { double baseConsommation = (distance / 100) * _consommationAu100; // Consommation augmente avec la charge double facteurCharge = 1 + (_chargeActuelle / _capaciteChargeTonnes) * 0.5; return baseConsommation * facteurCharge; } public override string ObtenirTypeCarburant() { return \"Diesel\"; } public override int NombreRoues { get { return 18; } } public void Charger(double poids) { if (_chargeActuelle + poids \u003c= _capaciteChargeTonnes) { _chargeActuelle += poids; Console.WriteLine($\"Chargement de {poids}t. Charge totale: {_chargeActuelle}t\"); } else { Console.WriteLine($\"Impossible! CapacitÃ© dÃ©passÃ©e.\"); } } } 13.4 Utilisation Polymorphe class Program { static void Main() { // âŒ IMPOSSIBLE - Classe abstraite // Vehicule v = new Vehicule(\"Test\", \"Test\", 2020); // âœ… OK - Classes concrÃ¨tes Vehicule voiture = new Voiture(\"Toyota\", \"Camry\", 2023, 4, \"Essence\", 7.5); Vehicule moto = new Moto(\"Harley\", \"Davidson\", 2022, false, 4.5); Vehicule camion = new Camion(\"Volvo\", \"FH16\", 2021, 25, 30); // ========================================== // POLYMORPHISME EN ACTION // ========================================== List\u003cVehicule\u003e parc = new List\u003cVehicule\u003e { voiture, moto, camion }; Console.WriteLine(\"=== DÃ‰MARRAGE DE TOUS LES VÃ‰HICULES ===\\n\"); foreach (Vehicule vehicule in parc) { vehicule.Demarrer(); // Appelle la bonne version } Console.WriteLine(\"\\n=== TRAJET DE 100 KM ===\\n\"); foreach (Vehicule vehicule in parc) { vehicule.Rouler(100); vehicule.AfficherInfos(); } // ========================================== // UTILISATION SPÃ‰CIFIQUE // ========================================== if (camion is Camion c) { c.Charger(10); c.Rouler(50); // Consommation affectÃ©e par la charge } } } 13.5 Exemple Complet : SystÃ¨me de Paiement // ========================================== // CLASSE ABSTRAITE : Moyen de Paiement // ========================================== public abstract class MoyenPaiement { protected string _titulaire; protected DateTime _dateTransaction; public string Titulaire { get { return _titulaire; } } public DateTime DateTransaction { get { return _dateTransaction; } } protected MoyenPaiement(string titulaire) { _titulaire = titulaire; } // MÃ©thodes abstraites public abstract bool Payer(decimal montant); public abstract bool Verifier(); public abstract string ObtenirType(); // MÃ©thode virtuelle public virtual void AfficherRecu(decimal montant) { Console.WriteLine($\"\\n====== REÃ‡U DE PAIEMENT ======\"); Console.WriteLine($\"Titulaire: {_titulaire}\"); Console.WriteLine($\"Type: {ObtenirType()}\"); Console.WriteLine($\"Montant: {montant:C}\"); Console.WriteLine($\"Date: {_dateTransaction:F}\"); Console.WriteLine($\"==============================\\n\"); } // MÃ©thode concrÃ¨te protected void EnregistrerTransaction() { _dateTransaction = DateTime.Now; Console.WriteLine($\"[LOG] Transaction enregistrÃ©e pour {_titulaire}\"); } } // Classes concrÃ¨tes... // (voir continuation dans le message suivant) public class CarteCredit : MoyenPaiement { private string _numero; private DateTime _dateExpiration; private decimal _limiteCredit; private decimal _soldeUtilise; public CarteCredit(string titulaire, string numero, DateTime expiration, decimal limite) : base(titulaire) { _numero = numero; _dateExpiration = expiration; _limiteCredit = limite; _soldeUtilise = 0; } public override bool Verifier() { if (_dateExpiration \u003c DateTime.Now) { Console.WriteLine(\"âŒ Carte expirÃ©e\"); return false; } return true; } public override bool Payer(decimal montant) { if (!Verifier()) return false; if (_soldeUtilise + montant \u003e _limiteCredit) { Console.WriteLine($\"âŒ Limite de crÃ©dit dÃ©passÃ©e ({_limiteCredit:C})\"); return false; } _soldeUtilise += montant; EnregistrerTransaction(); Console.WriteLine($\"âœ… Paiement de {montant:C} effectuÃ© par carte de crÃ©dit\"); Console.WriteLine($\" Solde disponible: {_limiteCredit - _soldeUtilise:C}\"); return true; } public override string ObtenirType() { return \"Carte de CrÃ©dit\"; } } public class CompteBancaire : MoyenPaiement { private string _numeroCompte; private decimal _solde; public CompteBancaire(string titulaire, string numero, decimal soldeInitial) : base(titulaire) { _numeroCompte = numero; _solde = soldeInitial; } public override bool Verifier() { return true; // Toujours valide } public override bool Payer(decimal montant) { if (_solde \u003c montant) { Console.WriteLine($\"âŒ Solde insuffisant (Disponible: {_solde:C})\"); return false; } _solde -= montant; EnregistrerTransaction(); Console.WriteLine($\"âœ… Paiement de {montant:C} effectuÃ© par compte bancaire\"); Console.WriteLine($\" Nouveau solde: {_solde:C}\"); return true; } public override string ObtenirType() { return \"Compte Bancaire\"; } } // Utilisation List\u003cMoyenPaiement\u003e moyensPaiement = new List\u003cMoyenPaiement\u003e { new CarteCredit(\"Alice Martin\", \"1234-5678-9012-3456\", DateTime.Now.AddYears(2), 5000), new CompteBancaire(\"Bob Gagnon\", \"CA123456\", 2000) }; foreach (var moyen in moyensPaiement) { if (moyen.Payer(150)) { moyen.AfficherRecu(150); } } 14. Les Interfaces 14.1 DÃ©finition Approfondie Une interface est un contrat qui dÃ©finit un ensemble de membres (mÃ©thodes, propriÃ©tÃ©s, Ã©vÃ©nements) que les classes doivent implÃ©menter, sans fournir dâ€™implÃ©mentation.\nDiffÃ©rences clÃ©s : Interface vs Classe Abstraite\nAspect Interface Classe Abstraite ImplÃ©mentation Aucune (contrat pur) Peut contenir du code HÃ©ritage multiple âœ… Oui âŒ Non Constructeurs âŒ Non âœ… Oui Champs âŒ Non âœ… Oui Modificateurs dâ€™accÃ¨s Tous public VariÃ©s (private, protected, etc.) But DÃ©finir un comportement Partager du code commun Quand utiliser une interface ?\nDÃ©finir un comportement commun Ã  des classes sans relation hiÃ©rarchique Permettre lâ€™hÃ©ritage multiple de comportements CrÃ©er des contrats que diffÃ©rentes classes doivent respecter Favoriser le couplage faible dans votre architecture Analogie : Une interface est comme un certificat de compÃ©tence :\nUn pilote peut avoir : certificat voiture, certificat moto, certificat avion Chaque certificat garantit certaines compÃ©tences DiffÃ©rentes personnes peuvent avoir diffÃ©rentes combinaisons de certificats 14.2 DÃ©claration dâ€™une Interface // ========================================== // CONVENTION : PrÃ©fixe 'I' pour les interfaces // ========================================== public interface IVolant { // ========================================== // MÃ‰THODES (pas d'implÃ©mentation) // ========================================== void Voler(); void Atterrir(); // ========================================== // PROPRIÃ‰TÃ‰S (seulement les signatures) // ========================================== double AltitudeMaximale { get; } double Vitesse { get; set; } // ========================================== // TOUS les membres sont PUBLIC par dÃ©faut // Pas besoin de spÃ©cifier 'public' // ========================================== } public interface INageant { void Nager(); void Plonger(double profondeur); double ProfondeurMaximale { get; } } public interface IMarchant { void Marcher(); void Courir(); int VitesseMarche { get; } } 14.3 ImplÃ©mentation dâ€™Interfaces // ========================================== // Une classe peut implÃ©menter PLUSIEURS interfaces // ========================================== public class Canard : IVolant, INageant, IMarchant { private double _altitudeActuelle; private double _profondeurActuelle; // ========================================== // ImplÃ©mentation de IVolant // ========================================== public double AltitudeMaximale { get { return 1000; } } public double Vitesse { get; set; } public void Voler() { _altitudeActuelle = 100; Console.WriteLine($\"Le canard vole Ã  {_altitudeActuelle}m\"); } public void Atterrir() { _altitudeActuelle = 0; Console.WriteLine(\"Le canard atterrit\"); } // ========================================== // ImplÃ©mentation de INageant // ========================================== public double ProfondeurMaximale { get { return 5; } } public void Nager() { Console.WriteLine(\"Le canard nage Ã  la surface\"); } public void Plonger(double profondeur) { if (profondeur \u003c= ProfondeurMaximale) { _profondeurActuelle = profondeur; Console.WriteLine($\"Le canard plonge Ã  {profondeur}m\"); } else { Console.WriteLine(\"Trop profond!\"); } } // ========================================== // ImplÃ©mentation de IMarchant // ========================================== public int VitesseMarche { get { return 5; } } public void Marcher() { Console.WriteLine(\"Le canard se dandine\"); } public void Courir() { Console.WriteLine(\"Le canard court maladroitement\"); } } // ========================================== // Autre classe avec un sous-ensemble d'interfaces // ========================================== public class Avion : IVolant { public double AltitudeMaximale { get { return 12000; } } public double Vitesse { get; set; } public void Voler() { Console.WriteLine($\"L'avion vole Ã  {Vitesse} km/h\"); } public void Atterrir() { Console.WriteLine(\"L'avion atterrit sur la piste\"); } } public class Poisson : INageant { public double ProfondeurMaximale { get { return 500; } } public void Nager() { Console.WriteLine(\"Le poisson nage gracieusement\"); } public void Plonger(double profondeur) { Console.WriteLine($\"Le poisson plonge Ã  {profondeur}m\"); } } 14.4 Polymorphisme avec Interfaces class Program { static void Main() { // ========================================== // Collections polymorphes basÃ©es sur les interfaces // ========================================== // Tous les Ãªtres volants List\u003cIVolant\u003e volants = new List\u003cIVolant\u003e { new Canard(), new Avion { Vitesse = 800 }, new Canard() }; Console.WriteLine(\"=== DÃ‰COLLAGE ===\"); foreach (IVolant volant in volants) { volant.Voler(); // Polymorphisme! } // Tous les Ãªtres nageants List\u003cINageant\u003e nageants = new List\u003cINageant\u003e { new Canard(), new Poisson() }; Console.WriteLine(\"\\n=== PLONGÃ‰E ===\"); foreach (INageant nageant in nageants) { nageant.Nager(); nageant.Plonger(3); } // ========================================== // Le canard peut Ãªtre utilisÃ© comme 3 types diffÃ©rents // ========================================== Canard donald = new Canard(); IVolant v = donald; // RÃ©fÃ©rence comme IVolant INageant n = donald; // RÃ©fÃ©rence comme INageant IMarchant m = donald; // RÃ©fÃ©rence comme IMarchant v.Voler(); n.Nager(); m.Marcher(); } } 14.5 VÃ©rification de Type avec Interfaces public void TraiterAnimal(object animal) { // ========================================== // Test avec 'is' // ========================================== if (animal is IVolant) { Console.WriteLine(\"Cet animal peut voler!\"); } if (animal is INageant) { Console.WriteLine(\"Cet animal peut nager!\"); } // ========================================== // Cast avec 'as' // ========================================== IVolant volant = animal as IVolant; if (volant != null) { volant.Voler(); } // ========================================== // Pattern matching (C# 7+) // ========================================== if (animal is IVolant v) { Console.WriteLine($\"Altitude max: {v.AltitudeMaximale}m\"); v.Voler(); } } 14.6 ImplÃ©mentation Explicite dâ€™Interface UtilisÃ©e pour rÃ©soudre les conflits quand deux interfaces ont des membres avec le mÃªme nom.\npublic interface IAnimal { void Manger(); string Nom { get; } } public interface IRobot { void Manger(); // MÃªme nom! string Nom { get; } } public class CyberChien : IAnimal, IRobot { private string _nom; public CyberChien(string nom) { _nom = nom; } // ========================================== // IMPLÃ‰MENTATION EXPLICITE pour IAnimal // ========================================== void IAnimal.Manger() { Console.WriteLine($\"{_nom} mange de la nourriture organique\"); } string IAnimal.Nom { get { return $\"{_nom} (animal)\"; } } // ========================================== // IMPLÃ‰MENTATION EXPLICITE pour IRobot // ========================================== void IRobot.Manger() { Console.WriteLine($\"{_nom} recharge ses batteries\"); } string IRobot.Nom { get { return $\"{_nom} (robot)\"; } } // ========================================== // MÃ©thode publique normale // ========================================== public void SeReposer() { Console.WriteLine($\"{_nom} se met en veille\"); } } // Utilisation CyberChien cyber = new CyberChien(\"RoboDog\"); // âŒ ERREUR - AmbiguÃ¯tÃ© // cyber.Manger(); // âœ… OK - Cast explicite IAnimal animal = cyber; animal.Manger(); // Nourriture organique Console.WriteLine(animal.Nom); IRobot robot = cyber; robot.Manger(); // Recharge batteries Console.WriteLine(robot.Nom); cyber.SeReposer(); // âœ… OK - MÃ©thode publique 14.7 Exemple Complet : SystÃ¨me de Notifications // ========================================== // INTERFACES // ========================================== public interface INotifiable { void EnvoyerNotification(string message); bool EstActif { get; set; } } public interface IConfigurable { void Configurer(Dictionary\u003cstring, string\u003e parametres); Dictionary\u003cstring, string\u003e ObtenirConfiguration(); } public interface IPrioritaire { int Priorite { get; set; } } // ========================================== // CLASSES D'IMPLÃ‰MENTATION // ========================================== public class NotificationEmail : INotifiable, IConfigurable { public bool EstActif { get; set; } = true; public string AdresseEmail { get; private set; } public string ServeurSMTP { get; private set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"ğŸ“§ [EMAIL] Ã€: {AdresseEmail}\"); Console.WriteLine($\" Message: {message}\"); Console.WriteLine($\" Via: {ServeurSMTP}\\n\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"email\")) AdresseEmail = parametres[\"email\"]; if (parametres.ContainsKey(\"smtp\")) ServeurSMTP = parametres[\"smtp\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"email\", AdresseEmail }, { \"smtp\", ServeurSMTP } }; } } public class NotificationSMS : INotifiable, IConfigurable, IPrioritaire { public bool EstActif { get; set; } = true; public int Priorite { get; set; } = 1; public string NumeroTelephone { get; private set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"ğŸ“± [SMS] Au: {NumeroTelephone}\"); Console.WriteLine($\" Message: {message}\"); Console.WriteLine($\" PrioritÃ©: {Priorite}\\n\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"telephone\")) NumeroTelephone = parametres[\"telephone\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"telephone\", NumeroTelephone } }; } } public class NotificationPush : INotifiable, IPrioritaire { public bool EstActif { get; set; } = true; public int Priorite { get; set; } = 2; public string DeviceId { get; set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"ğŸ”” [PUSH] Device: {DeviceId}\"); Console.WriteLine($\" Message: {message}\"); Console.WriteLine($\" PrioritÃ©: {Priorite}\\n\"); } } } // ========================================== // GESTIONNAIRE // ========================================== public class GestionnaireNotifications { private List\u003cINotifiable\u003e _canaux = new List\u003cINotifiable\u003e(); public void AjouterCanal(INotifiable canal) { _canaux.Add(canal); Console.WriteLine($\"âœ… Canal ajoutÃ©: {canal.GetType().Name}\"); } public void EnvoyerATous(string message) { Console.WriteLine($\"\\n{'='.ToString().PadLeft(50, '=')}\"); Console.WriteLine($\"ENVOI Ã€ TOUS LES CANAUX\"); Console.WriteLine($\"{'='.ToString().PadLeft(50, '=')}\\n\"); foreach (INotifiable canal in _canaux) { canal.EnvoyerNotification(message); } } public void EnvoyerParPriorite(string message, int prioriteMin) { Console.WriteLine($\"\\n{'='.ToString().PadLeft(50, '=')}\"); Console.WriteLine($\"ENVOI PRIORITAIRE (\u003e= {prioriteMin})\"); Console.WriteLine($\"{'='.ToString().PadLeft(50, '=')}\\n\"); foreach (INotifiable canal in _canaux) { // VÃ©rifie si le canal supporte IPrioritaire if (canal is IPrioritaire prioritaire) { if (prioritaire.Priorite \u003e= prioriteMin) { canal.EnvoyerNotification(message); } } } } public void ConfigurerCanaux() { foreach (INotifiable canal in _canaux) { if (canal is IConfigurable configurable) { Console.WriteLine($\"\\nConfiguration de {canal.GetType().Name}:\"); var config = configurable.ObtenirConfiguration(); foreach (var param in config) { Console.WriteLine($\" {param.Key}: {param.Value}\"); } } } } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { GestionnaireNotifications gestionnaire = new GestionnaireNotifications(); // CrÃ©ation et configuration des canaux var email = new NotificationEmail(); email.Configurer(new Dictionary\u003cstring, string\u003e { { \"email\", \"user@example.com\" }, { \"smtp\", \"smtp.example.com\" } }); var sms = new NotificationSMS { Priorite = 3 }; sms.Configurer(new Dictionary\u003cstring, string\u003e { { \"telephone\", \"+1-514-555-0123\" } }); var push = new NotificationPush { DeviceId = \"ABC123\", Priorite = 2 }; // Ajout des canaux gestionnaire.AjouterCanal(email); gestionnaire.AjouterCanal(sms); gestionnaire.AjouterCanal(push); // Envoi de notifications gestionnaire.EnvoyerATous(\"Bienvenue dans le systÃ¨me!\"); gestionnaire.EnvoyerParPriorite(\"ALERTE: ActivitÃ© suspecte dÃ©tectÃ©e!\", 2); // Affichage de la configuration gestionnaire.ConfigurerCanaux(); } } 14.8 Interfaces vs Classes Abstraites : Quand Utiliser Quoi ? Utilisez une INTERFACE quand :\nVous dÃ©finissez un comportement que des classes sans relation peuvent partager Vous voulez permettre lâ€™hÃ©ritage multiple de comportements Vous crÃ©ez un plugin system ou une architecture dÃ©couplÃ©e Les implÃ©mentations seront trÃ¨s diffÃ©rentes Exemples dâ€™interfaces : IComparable, IDisposable, IEnumerable\nUtilisez une CLASSE ABSTRAITE quand :\nVous voulez partager du code entre classes liÃ©es Vous avez une hiÃ©rarchie â€œest-unâ€ claire Vous voulez fournir une implÃ©mentation par dÃ©faut Les classes dÃ©rivÃ©es ont beaucoup en commun Exemples : Stream, DbConnection, Control (UI)\nExemple combinÃ© :\n// Interface pour le comportement public interface IPayable { bool EffectuerPaiement(decimal montant); } // Classe abstraite pour le code commun public abstract class MoyenPaiement : IPayable { protected string _titulaire; protected MoyenPaiement(string titulaire) { _titulaire = titulaire; } // ImplÃ©mentation commune public void AfficherTitulaire() { Console.WriteLine($\"Titulaire: {_titulaire}\"); } // ImplÃ©mentation de l'interface (peut Ãªtre virtual ou abstract) public abstract bool EffectuerPaiement(decimal montant); } public class CarteCredit : MoyenPaiement { public CarteCredit(string titulaire) : base(titulaire) { } public override bool EffectuerPaiement(decimal montant) { Console.WriteLine($\"Paiement de {montant:C} par carte\"); return true; } } 15. Membres Statiques 15.1 DÃ©finition Les membres statiques (attributs, mÃ©thodes, propriÃ©tÃ©s) appartiennent Ã  la classe elle-mÃªme plutÃ´t quâ€™aux instances individuelles de la classe.\nAnalogie :\nMembres dâ€™instance = CaractÃ©ristiques personnelles (votre Ã¢ge, votre nom) Membres statiques = CaractÃ©ristiques partagÃ©es (le nombre total dâ€™Ãªtres humains sur Terre) CaractÃ©ristiques :\nUn seul exemplaire existe pour toute la classe PartagÃ© entre toutes les instances Accessible via le nom de la classe (pas via une instance) Existe mÃªme sans aucune instance crÃ©Ã©e 15.2 Attributs Statiques public class Compteur { // ========================================== // ATTRIBUT STATIQUE - PartagÃ© par toutes les instances // ========================================== private static int _nombreInstances = 0; // ========================================== // ATTRIBUT D'INSTANCE - Unique pour chaque objet // ========================================== private int _id; public int Id { get { return _id; } } // ========================================== // PROPRIÃ‰TÃ‰ STATIQUE // ========================================== public static int NombreInstances { get { return _nombreInstances; } } // ========================================== // CONSTRUCTEUR // ========================================== public Compteur() { _nombreInstances++; // Modifie la variable STATIQUE _id = _nombreInstances; // Assigne un ID unique basÃ© sur le compteur Console.WriteLine($\"Instance #{_id} crÃ©Ã©e. Total: {_nombreInstances}\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { Console.WriteLine($\"Instances au dÃ©part: {Compteur.NombreInstances}\"); // 0 Compteur c1 = new Compteur(); // Instance #1 crÃ©Ã©e. Total: 1 Compteur c2 = new Compteur(); // Instance #2 crÃ©Ã©e. Total: 2 Compteur c3 = new Compteur(); // Instance #3 crÃ©Ã©e. Total: 3 Console.WriteLine($\"\\nTotal d'instances: {Compteur.NombreInstances}\"); // 3 Console.WriteLine($\"ID de c1: {c1.Id}\"); // 1 Console.WriteLine($\"ID de c2: {c2.Id}\"); // 2 Console.WriteLine($\"ID de c3: {c3.Id}\"); // 3 // ========================================== // Le compteur est PARTAGÃ‰ // ========================================== Compteur c4 = new Compteur(); // Instance #4 crÃ©Ã©e. Total: 4 Console.WriteLine($\"\\nTotal aprÃ¨s c4: {Compteur.NombreInstances}\"); // 4 } } 15.3 MÃ©thodes Statiques public class CalculatriceMath { // ========================================== // MÃ‰THODES STATIQUES - Pas besoin d'instance // ========================================== public static double CalculerAireRectangle(double longueur, double largeur) { return longueur * largeur; } public static double CalculerAireCercle(double rayon) { return Math.PI * rayon * rayon; } public static int CalculerFactorielle(int n) { if (n \u003c= 1) return 1; return n * CalculerFactorielle(n - 1); } public static bool EstPremier(int nombre) { if (nombre \u003c 2) return false; for (int i = 2; i \u003c= Math.Sqrt(nombre); i++) { if (nombre % i == 0) return false; } return true; } } // Utilisation - SANS crÃ©er d'objet double aire = CalculatriceMath.CalculerAireRectangle(5, 3); // 15 double cercle = CalculatriceMath.CalculerAireCercle(4); // ~50.27 int fact = CalculatriceMath.CalculerFactorielle(5); // 120 bool premier = CalculatriceMath.EstPremier(17); // true 15.4 Classes Statiques Une classe entiÃ¨rement statique ne peut contenir que des membres statiques et ne peut pas Ãªtre instanciÃ©e.\n// ========================================== // CLASSE STATIQUE - Ne peut pas Ãªtre instanciÃ©e // ========================================== public static class Convertisseur { // Toutes les mÃ©thodes doivent Ãªtre statiques public static double CelsiusVersFahrenheit(double celsius) { return (celsius * 9 / 5) + 32; } public static double FahrenheitVersCelsius(double fahrenheit) { return (fahrenheit - 32) * 5 / 9; } public static double KilometresVersMiles(double km) { return km * 0.621371; } public static double MilesVersKilometres(double miles) { return miles / 0.621371; } } // Utilisation double fahrenheit = Convertisseur.CelsiusVersFahrenheit(25); // 77 double miles = Convertisseur.KilometresVersMiles(100); // 62.14 // âŒ ERREUR - Impossible d'instancier // Convertisseur conv = new Convertisseur(); Exemples de classes statiques dans .NET :\nConsole Math File Directory Environment 15.5 Constructeur Statique Un constructeur statique est exÃ©cutÃ© une seule fois, avant la premiÃ¨re utilisation de la classe.\npublic class Configuration { public static string CheminFichier { get; private set; } public static DateTime DateInitialisation { get; private set; } public static Dictionary\u003cstring, string\u003e Parametres { get; private set; } // ========================================== // CONSTRUCTEUR STATIQUE // AppelÃ© automatiquement avant la premiÃ¨re utilisation // ========================================== static Configuration() { Console.WriteLine(\"Initialisation de la configuration...\"); CheminFichier = \"config.json\"; DateInitialisation = DateTime.Now; Parametres = new Dictionary\u003cstring, string\u003e { { \"version\", \"1.0\" }, { \"langue\", \"fr\" } }; Console.WriteLine($\"Configuration initialisÃ©e Ã  {DateInitialisation}\"); } public static void AfficherConfiguration() { Console.WriteLine($\"\\nConfiguration:\"); Console.WriteLine($\" Fichier: {CheminFichier}\"); Console.WriteLine($\" InitialisÃ©e: {DateInitialisation}\"); foreach (var param in Parametres) { Console.WriteLine($\" {param.Key}: {param.Value}\"); } } } // Utilisation class Program { static void Main() { Console.WriteLine(\"DÃ©but du programme\\n\"); // Le constructeur statique est appelÃ© ici (premiÃ¨re utilisation) Configuration.AfficherConfiguration(); // DeuxiÃ¨me utilisation - constructeur statique PAS rappelÃ© Configuration.AfficherConfiguration(); } } Affichage :\nDÃ©but du programme\rInitialisation de la configuration...\rConfiguration initialisÃ©e Ã  01/02/2026 10:30:00\rConfiguration:\rFichier: config.json\rInitialisÃ©e: 01/02/2026 10:30:00\rversion: 1.0\rlangue: fr\rConfiguration:\rFichier: config.json\rInitialisÃ©e: 01/02/2026 10:30:00\rversion: 1.0\rlangue: fr 15.6 Exemple Complet : Gestionnaire de Base de DonnÃ©es public class GestionnaireDB { // ========================================== // MEMBRES STATIQUES - PartagÃ©s // ========================================== private static string _chaine Connexion; private static int _nombreConnexionsActives = 0; private static int _nombreConnexionsTotales = 0; public static int NombreConnexionsActives { get { return _nombreConnexionsActives; } } public static int NombreConnexionsTotales { get { return _nombreConnexionsTotales; } } // ========================================== // MEMBRES D'INSTANCE - Uniques Ã  chaque connexion // ========================================== private int _id; private bool _estConnecte; private DateTime _dateConnexion; public int Id { get { return _id; } } public bool EstConnecte { get { return _estConnecte; } } // ========================================== // CONSTRUCTEUR STATIQUE // ========================================== static GestionnaireDB() { Console.WriteLine(\"[STATIC] Initialisation du gestionnaire DB\"); _chaineConnexion = \"Server=localhost;Database=test;\"; } // ========================================== // CONSTRUCTEUR D'INSTANCE // ========================================== public GestionnaireDB() { _nombreConnexionsTotales++; _id = _nombreConnexionsTotales; Console.WriteLine($\"[INSTANCE #{_id}] CrÃ©Ã©e\"); } // ========================================== // MÃ‰THODE D'INSTANCE // ========================================== public void Connecter() { if (!_estConnecte) { _estConnecte = true; _dateConnexion = DateTime.Now; _nombreConnexionsActives++; Console.WriteLine($\"[INSTANCE #{_id}] ConnectÃ©e. Actives: {_nombreConnexionsActives}\"); } } public void Deconnecter() { if (_estConnecte) { _estConnecte = false; _nombreConnexionsActives--; Console.WriteLine($\"[INSTANCE #{_id}] DÃ©connectÃ©e. Actives: {_nombreConnexionsActives}\"); } } // ========================================== // MÃ‰THODE STATIQUE // ========================================== public static void AfficherStatistiques() { Console.WriteLine($\"\\n=== STATISTIQUES DB ===\"); Console.WriteLine($\"ChaÃ®ne de connexion: {_chaineConnexion}\"); Console.WriteLine($\"Connexions actives: {_nombreConnexionsActives}\"); Console.WriteLine($\"Total crÃ©Ã©es: {_nombreConnexionsTotales}\"); Console.WriteLine($\"=======================\\n\"); } } // Utilisation class Program { static void Main() { GestionnaireDB.AfficherStatistiques(); // DÃ©clenche le constructeur statique GestionnaireDB db1 = new GestionnaireDB(); GestionnaireDB db2 = new GestionnaireDB(); GestionnaireDB db3 = new GestionnaireDB(); db1.Connecter(); db2.Connecter(); db3.Connecter(); GestionnaireDB.AfficherStatistiques(); db1.Deconnecter(); db2.Deconnecter(); GestionnaireDB.AfficherStatistiques(); } } 15.7 RÃ¨gles Importantes public class Exemple { private static int _compteurStatique = 0; private int _compteurInstance = 0; // ========================================== // MÃ‰THODE STATIQUE // ========================================== public static void MethodeStatique() { // âœ… OK - AccÃ¨s Ã  membre statique _compteurStatique++; // âŒ ERREUR - Pas d'accÃ¨s aux membres d'instance // _compteurInstance++; // ERREUR! // this._compteurInstance++; // ERREUR! // âœ… OK - Appel d'autre mÃ©thode statique AutreMethodeStatique(); // âŒ ERREUR - Pas d'appel de mÃ©thode d'instance // MethodeInstance(); // ERREUR! } // ========================================== // MÃ‰THODE D'INSTANCE // ========================================== public void MethodeInstance() { // âœ… OK - AccÃ¨s aux membres d'instance _compteurInstance++; // âœ… OK - AccÃ¨s aux membres statiques aussi _compteurStatique++; // âœ… OK - Appel de mÃ©thodes statiques MethodeStatique(); AutreMethodeStatique(); } private static void AutreMethodeStatique() { } } RÃ©sumÃ© Final Tableau RÃ©capitulatif des Concepts Concept DÃ©finition Exemple dâ€™Usage virtual MÃ©thode avec implÃ©mentation, redÃ©finition optionnelle Comportement par dÃ©faut modifiable abstract MÃ©thode sans implÃ©mentation, redÃ©finition obligatoire Forcer les dÃ©rivÃ©es Ã  implÃ©menter sealed EmpÃªche lâ€™hÃ©ritage ou la redÃ©finition Classe/mÃ©thode finale override RedÃ©finit une mÃ©thode virtual ou abstract Polymorphisme new Masque un membre de la classe de base Ã‰viter, prÃ©fÃ©rer override base AccÃ¨de aux membres de la classe parent Appeler la version parente this RÃ©fÃ©rence Ã  lâ€™instance actuelle Distinguer attributs/paramÃ¨tres static Membre appartenant Ã  la classe Utilitaires, compteurs partagÃ©s interface Contrat sans implÃ©mentation DÃ©finir comportements multiples abstract class Classe incomplÃ¨te avec code partagÃ© Base commune avec implÃ©mentation HiÃ©rarchie ComplÃ¨te dâ€™Exemple // Interface public interface IVolant { void Voler(); } // Classe abstraite public abstract class Animal { protected string _nom; public Animal(string nom) { _nom = nom; } // MÃ©thode abstraite public abstract void EmettreSound(); // MÃ©thode virtuelle public virtual void Dormir() { Console.WriteLine($\"{_nom} dort\"); } // MÃ©thode concrÃ¨te public void Respirer() { Console.WriteLine($\"{_nom} respire\"); } } // Classe concrÃ¨te public class Oiseau : Animal, IVolant { public Oiseau(string nom) : base(nom) { } // ImplÃ©mentation obligatoire (abstract) public override void EmettreSound() { Console.WriteLine($\"{_nom} chante\"); } // RedÃ©finition optionnelle (virtual) public override void Dormir() { Console.WriteLine($\"{_nom} dort dans un nid\"); } // ImplÃ©mentation d'interface public void Voler() { Console.WriteLine($\"{_nom} vole\"); } } // Classe sealed public sealed class Pingouin : Oiseau { public Pingouin(string nom) : base(nom) { } // Sealed override public sealed override void Dormir() { Console.WriteLine($\"{_nom} dort en groupe\"); } // Les pingouins ne volent pas, mais implÃ©mentent quand mÃªme IVolant public new void Voler() { Console.WriteLine($\"{_nom} ne peut pas voler!\"); } } // âŒ Impossible d'hÃ©riter de Pingouin (sealed) // public class SuperPingouin : Pingouin { }",
    "description": "Table des matiÃ¨res Le mot-clÃ© Virtual Le mot-clÃ© Abstract Le mot-clÃ© Sealed Les Classes Abstraites Les Interfaces Membres Statiques Cours POO C# - Partie 2 : Concepts AvancÃ©s 10. Le mot-clÃ© Virtual 10.1 DÃ©finition Le mot-clÃ© virtual permet de dÃ©clarer une mÃ©thode qui peut Ãªtre redÃ©finie (override) dans les classes dÃ©rivÃ©es. Câ€™est la base du polymorphisme dâ€™exÃ©cution en C#.",
    "tags": [],
    "title": "Programmation orientÃ©e objet - partie 2",
    "uri": "/420-413/poo_2/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Mini-Projets : Programmation OrientÃ©e Objet en C# Progression recommandÃ©e Niveau Projets DÃ©butant Projet 8 (Formes), Projet 5 (TÃ¢ches) IntermÃ©diaire Projet 1 (Banque), Projet 2 (BibliothÃ¨que), Projet 6 (Zoo) AvancÃ© Projet 3 (RPG), Projet 4 (Restaurant), Projet 7 (HÃ´tel) Table des matiÃ¨res Projet 1 : SystÃ¨me de Gestion Bancaire Projet 2 : Gestion dâ€™une BibliothÃ¨que Projet 3 : Jeu de Combat RPG Projet 4 : SystÃ¨me de Commandes Restaurant Projet 5 : Gestionnaire de TÃ¢ches Projet 6 : Simulateur de Zoo Projet 7 : SystÃ¨me de RÃ©servation HÃ´tel Projet 8 : Calculatrice de Formes GÃ©omÃ©triques Projet 1 : SystÃ¨me de Gestion Bancaire ğŸ“‹ Objectif CrÃ©er un systÃ¨me de gestion de comptes bancaires avec diffÃ©rents types de comptes et opÃ©rations.\nğŸ¯ Concepts utilisÃ©s HÃ©ritage Encapsulation Polymorphisme Classes abstraites ğŸ“ SpÃ©cifications CrÃ©er :\nUne classe abstraite CompteBancaire avec :\nPropriÃ©tÃ©s : NumeroCompte, Titulaire, Solde, DateOuverture MÃ©thodes abstraites : CalculerInterets() MÃ©thodes concrÃ¨tes : Deposer(), Retirer(), AfficherReleve() Classe CompteEpargne hÃ©ritant de CompteBancaire :\nPropriÃ©tÃ© : TauxInteret (ex: 2.5%) Minimum de retrait : 10$ ImplÃ©mente CalculerInterets() Classe CompteCourant hÃ©ritant de CompteBancaire :\nPropriÃ©tÃ© : DecouvertAutorise (ex: -500$) Frais mensuels : 5$ Peut retirer jusquâ€™Ã  atteindre le dÃ©couvert Classe CompteJeune hÃ©ritant de CompteEpargne :\nPour les moins de 18 ans Bonus annuel de 50$ si solde \u003e 500$ Limite de retrait : 200$ par transaction ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; namespace GestionBancaire { // Classe abstraite de base public abstract class CompteBancaire { // TODO: Ajouter les propriÃ©tÃ©s // TODO: Ajouter le constructeur public virtual bool Deposer(decimal montant) { // TODO: ImplÃ©menter return false; } public abstract bool Retirer(decimal montant); public abstract decimal CalculerInterets(); public virtual void AfficherReleve() { // TODO: ImplÃ©menter } } // TODO: CrÃ©er la classe CompteEpargne // TODO: CrÃ©er la classe CompteCourant // TODO: CrÃ©er la classe CompteJeune // Classe de gestion public class Banque { private List\u003cCompteBancaire\u003e _comptes = new List\u003cCompteBancaire\u003e(); public void AjouterCompte(CompteBancaire compte) { // TODO: ImplÃ©menter } public void AppliquerIntÃ©rets() { // TODO: Parcourir tous les comptes et appliquer les intÃ©rÃªts } public void AfficherTousLesComptes() { // TODO: ImplÃ©menter } } class Program { static void Main(string[] args) { // TODO: CrÃ©er des comptes et tester Console.WriteLine(\"=== SystÃ¨me Bancaire ===\"); // CrÃ©er une banque Banque banque = new Banque(); // CrÃ©er diffÃ©rents types de comptes // ... // Effectuer des opÃ©rations // ... // Appliquer les intÃ©rÃªts // ... // Afficher tous les comptes // ... } } } âœ… CritÃ¨res de rÃ©ussite Impossible de retirer plus que le solde (sauf compte courant avec dÃ©couvert) Les intÃ©rÃªts sont correctement calculÃ©s Le polymorphisme fonctionne (mÃªme mÃ©thode, comportements diffÃ©rents) Les encapsulations protÃ¨gent les donnÃ©es sensibles Projet 2 : Gestion dâ€™une BibliothÃ¨que ğŸ“‹ Objectif CrÃ©er un systÃ¨me de gestion de bibliothÃ¨que avec emprunts et rÃ©servations.\nğŸ¯ Concepts utilisÃ©s Interfaces HÃ©ritage Collections Ã‰numÃ©rations ğŸ“ SpÃ©cifications CrÃ©er :\nInterface IEmpruntable :\nMÃ©thodes : Emprunter(string emprunteur), Retourner() PropriÃ©tÃ© : EstDisponible Interface IReservable :\nMÃ©thodes : Reserver(string utilisateur), AnnulerReservation() Classe abstraite Document :\nPropriÃ©tÃ©s : Titre, Auteur, AnneePublication, Cote MÃ©thode abstraite : AfficherDetails() Classe Livre hÃ©ritant de Document et implÃ©mentant IEmpruntable, IReservable :\nPropriÃ©tÃ©s supplÃ©mentaires : ISBN, NombrePages, Genre DurÃ©e dâ€™emprunt : 21 jours Classe DVD hÃ©ritant de Document et implÃ©mentant IEmpruntable :\nPropriÃ©tÃ©s supplÃ©mentaires : Duree (en minutes), Genre DurÃ©e dâ€™emprunt : 7 jours Classe Magazine hÃ©ritant de Document et implÃ©mentant IEmpruntable :\nPropriÃ©tÃ©s supplÃ©mentaires : NumeroEdition, Mois DurÃ©e dâ€™emprunt : 14 jours Ne peut pas Ãªtre rÃ©servÃ© Ã‰numÃ©ration GenreLivre : Fiction, NonFiction, ScienceFiction, Romance, Thriller, etc.\nClasse Bibliotheque :\nCollection de documents MÃ©thodes : AjouterDocument(), RechercherParTitre(), RechercherParAuteur(), ListerDocumentsDisponibles() ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; using System.Linq; namespace GestionBibliotheque { public interface IEmpruntable { // TODO: DÃ©finir l'interface } public interface IReservable { // TODO: DÃ©finir l'interface } public enum GenreLivre { Fiction, NonFiction, ScienceFiction, Romance, Thriller, Biographie, Histoire } public abstract class Document { // TODO: PropriÃ©tÃ©s communes public abstract void AfficherDetails(); } public class Livre : Document, IEmpruntable, IReservable { // TODO: ImplÃ©menter } public class DVD : Document, IEmpruntable { // TODO: ImplÃ©menter } public class Magazine : Document, IEmpruntable { // TODO: ImplÃ©menter } public class Bibliotheque { private List\u003cDocument\u003e _documents = new List\u003cDocument\u003e(); public void AjouterDocument(Document document) { // TODO: ImplÃ©menter } public List\u003cDocument\u003e RechercherParTitre(string titre) { // TODO: ImplÃ©menter return null; } public void ListerDocumentsDisponibles() { // TODO: ImplÃ©menter } public void ListerEmprunts() { // TODO: Afficher tous les documents empruntÃ©s } } class Program { static void Main(string[] args) { Bibliotheque biblio = new Bibliotheque(); // TODO: Ajouter des documents // TODO: Tester les emprunts // TODO: Tester les rÃ©servations // TODO: Tester les recherches } } } âœ… CritÃ¨res de rÃ©ussite Impossible dâ€™emprunter un document dÃ©jÃ  empruntÃ© Les rÃ©servations fonctionnent uniquement pour les livres La recherche fonctionne correctement Lâ€™affichage des dÃ©tails est polymorphe Projet 3 : Jeu de Combat RPG ğŸ“‹ Objectif CrÃ©er un mini-jeu de combat avec diffÃ©rentes classes de personnages.\nğŸ¯ Concepts utilisÃ©s HÃ©ritage Polymorphisme Classes abstraites Interfaces ğŸ“ SpÃ©cifications CrÃ©er :\nClasse abstraite Personnage :\nPropriÃ©tÃ©s : Nom, PointsDeVie, PointsDeVieMax, Force, Defense, Niveau MÃ©thode abstraite : AttaqueSpeciale() MÃ©thodes concrÃ¨tes : Attaquer(Personnage cible), RecevoirDegats(int degats), EstVivant(), Guerir(int points) Classe Guerrier hÃ©ritant de Personnage :\nCompÃ©tence : Coup Puissant (2x la force, mais perd 10 PV) Bonus : +5 dÃ©fense Classe Mage hÃ©ritant de Personnage :\nPropriÃ©tÃ© supplÃ©mentaire : Mana CompÃ©tence : Boule de Feu (3x la force, coÃ»te 30 mana) Peut se rÃ©gÃ©nÃ©rer (rÃ©cupÃ¨re 20 mana par tour) Classe Archer hÃ©ritant de Personnage :\nPropriÃ©tÃ© supplÃ©mentaire : Precision (%) CompÃ©tence : Tir Critique (chance de critique basÃ©e sur prÃ©cision) Attaque Ã  distance (peut Ã©viter les contre-attaques) Classe Paladin hÃ©ritant de Personnage :\nPeut se soigner (50% de la force en soins) CompÃ©tence : Bouclier SacrÃ© (augmente dÃ©fense de 50% pour 3 tours) Bonus : RÃ©gÃ©nÃ©ration passive (5 PV par tour) Interface IInventaire :\nMÃ©thodes : AjouterObjet(), UtiliserObjet(), AfficherInventaire() Classe Objet :\nTypes : Potion (restore PV), PotionMana, ElixirForce (augmente force temporairement) ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; namespace JeuCombatRPG { public abstract class Personnage { public string Nom { get; set; } public int PointsDeVie { get; protected set; } public int PointsDeVieMax { get; protected set; } public int Force { get; protected set; } public int Defense { get; protected set; } public int Niveau { get; protected set; } protected Personnage(string nom, int pv, int force, int defense) { // TODO: Initialiser } public virtual int Attaquer(Personnage cible) { // TODO: Calculer les dÃ©gÃ¢ts (Force - Defense de la cible) // Minimum 1 dÃ©gÃ¢t return 0; } public void RecevoirDegats(int degats) { // TODO: RÃ©duire les PV } public abstract void AttaqueSpeciale(Personnage cible); public bool EstVivant() { return PointsDeVie \u003e 0; } public void AfficherStats() { // TODO: Afficher nom, PV, Force, DÃ©fense } } public class Guerrier : Personnage { public Guerrier(string nom) : base(nom, 150, 25, 15) { } public override void AttaqueSpeciale(Personnage cible) { // TODO: Coup Puissant } } // TODO: CrÃ©er les autres classes (Mage, Archer, Paladin) public class Combat { public void Duel(Personnage p1, Personnage p2) { Console.WriteLine($\"=== COMBAT: {p1.Nom} VS {p2.Nom} ===\\n\"); int tour = 1; while (p1.EstVivant() \u0026\u0026 p2.EstVivant()) { Console.WriteLine($\"--- Tour {tour} ---\"); // TODO: p1 attaque p2 if (!p2.EstVivant()) { Console.WriteLine($\"\\nğŸ† {p1.Nom} remporte le combat!\"); break; } // TODO: p2 attaque p1 if (!p1.EstVivant()) { Console.WriteLine($\"\\nğŸ† {p2.Nom} remporte le combat!\"); break; } tour++; Console.WriteLine(); } } } class Program { static void Main(string[] args) { // TODO: CrÃ©er des personnages // TODO: Lancer des combats // TODO: Tester les attaques spÃ©ciales } } } âœ… CritÃ¨res de rÃ©ussite Chaque classe a une attaque spÃ©ciale unique Le systÃ¨me de combat est Ã©quilibrÃ© Les statistiques sont correctement affichÃ©es Le polymorphisme permet des combats entre diffÃ©rents types ğŸ® Extensions possibles Ajouter un systÃ¨me dâ€™expÃ©rience et de montÃ©e de niveau ImplÃ©menter un inventaire dâ€™objets CrÃ©er un mode tournoi avec plusieurs combattants Ajouter des effets de statut (poison, paralysie, etc.) Projet 4 : SystÃ¨me de Commandes Restaurant ğŸ“‹ Objectif CrÃ©er un systÃ¨me de gestion de commandes pour un restaurant.\nğŸ¯ Concepts utilisÃ©s HÃ©ritage Interfaces Collections Ã‰numÃ©rations ğŸ“ SpÃ©cifications CrÃ©er :\nÃ‰numÃ©ration CategoriePlat : Entree, PlatPrincipal, Dessert, Boisson\nClasse abstraite Article :\nPropriÃ©tÃ©s : Nom, Prix, Description, Categorie MÃ©thode abstraite : CalculerPrix() (pour gÃ©rer les options/supplÃ©ments) Classe Plat hÃ©ritant de Article :\nPropriÃ©tÃ©s : Ingredients (liste), TempsPreparation, EstVegetarien Peut avoir des supplÃ©ments (fromage +2$, bacon +3$) Classe Boisson hÃ©ritant de Article :\nPropriÃ©tÃ©s : Taille (Petit, Moyen, Grand), EstGazeuse Prix varie selon la taille Interface IPersonnalisable :\nMÃ©thodes : AjouterOption(string option, decimal prix), RetirerIngredient(string ingredient) Classe Menu :\nContient une entrÃ©e, un plat principal, un dessert et une boisson Prix rÃ©duit de 15% par rapport aux articles sÃ©parÃ©s Classe Commande :\nPropriÃ©tÃ©s : NumeroCommande, Client, Articles, DateHeure, Statut MÃ©thodes : AjouterArticle(), RetirerArticle(), CalculerTotal(), CalculerTaxes(), AfficherFacture() Ã‰numÃ©ration StatutCommande : EnAttente, EnPreparation, Prete, Livree, Annulee\nğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; using System.Linq; namespace SystemeRestaurant { public enum CategoriePlat { Entree, PlatPrincipal, Dessert, Boisson } public enum StatutCommande { EnAttente, EnPreparation, Prete, Livree, Annulee } public enum TailleBoisson { Petit, Moyen, Grand } public interface IPersonnalisable { void AjouterOption(string option, decimal prix); void RetirerIngredient(string ingredient); } public abstract class Article { public string Nom { get; set; } public decimal PrixBase { get; set; } public string Description { get; set; } public CategoriePlat Categorie { get; set; } public abstract decimal CalculerPrix(); public virtual void AfficherDetails() { Console.WriteLine($\"{Nom} - {PrixBase:C}\"); Console.WriteLine($\" {Description}\"); } } public class Plat : Article, IPersonnalisable { public List\u003cstring\u003e Ingredients { get; set; } public int TempsPreparation { get; set; } // en minutes public bool EstVegetarien { get; set; } private Dictionary\u003cstring, decimal\u003e _options = new Dictionary\u003cstring, decimal\u003e(); public Plat() { Ingredients = new List\u003cstring\u003e(); } public void AjouterOption(string option, decimal prix) { // TODO: ImplÃ©menter } public void RetirerIngredient(string ingredient) { // TODO: ImplÃ©menter } public override decimal CalculerPrix() { // TODO: Prix de base + options return 0; } public override void AfficherDetails() { base.AfficherDetails(); Console.WriteLine($\" Temps de prÃ©paration: {TempsPreparation} min\"); Console.WriteLine($\" VÃ©gÃ©tarien: {(EstVegetarien ? \"Oui\" : \"Non\")}\"); Console.WriteLine($\" IngrÃ©dients: {string.Join(\", \", Ingredients)}\"); } } public class Boisson : Article { public TailleBoisson Taille { get; set; } public bool EstGazeuse { get; set; } public override decimal CalculerPrix() { // TODO: Ajuster le prix selon la taille // Petit: 100%, Moyen: 130%, Grand: 160% return 0; } } public class Menu { public Plat Entree { get; set; } public Plat PlatPrincipal { get; set; } public Article Dessert { get; set; } public Boisson Boisson { get; set; } public decimal CalculerPrix() { // TODO: Calculer avec rÃ©duction de 15% return 0; } public void AfficherMenu() { // TODO: Afficher tous les Ã©lÃ©ments du menu } } public class Commande { private static int _compteurCommandes = 0; public int NumeroCommande { get; private set; } public string Client { get; set; } public List\u003cArticle\u003e Articles { get; private set; } public DateTime DateHeure { get; private set; } public StatutCommande Statut { get; set; } public Commande(string client) { NumeroCommande = ++_compteurCommandes; Client = client; Articles = new List\u003cArticle\u003e(); DateHeure = DateTime.Now; Statut = StatutCommande.EnAttente; } public void AjouterArticle(Article article) { // TODO: ImplÃ©menter } public decimal CalculerSousTotal() { // TODO: Sommer tous les articles return 0; } public decimal CalculerTaxes() { // TODO: Calculer TPS (5%) + TVQ (9.975%) return 0; } public decimal CalculerTotal() { return CalculerSousTotal() + CalculerTaxes(); } public void AfficherFacture() { // TODO: Afficher facture dÃ©taillÃ©e } } public class Restaurant { public string Nom { get; set; } private List\u003cArticle\u003e _carte = new List\u003cArticle\u003e(); private List\u003cCommande\u003e _commandes = new List\u003cCommande\u003e(); public void AjouterAuMenu(Article article) { _carte.Add(article); } public void AfficherCarte() { // TODO: Afficher par catÃ©gorie } public Commande CreerCommande(string client) { var commande = new Commande(client); _commandes.Add(commande); return commande; } public void AfficherCommandesEnCours() { // TODO: Afficher commandes non terminÃ©es } } class Program { static void Main(string[] args) { Restaurant resto = new Restaurant { Nom = \"Chez Claude\" }; // TODO: CrÃ©er des plats et les ajouter au menu // TODO: CrÃ©er une commande // TODO: Personnaliser des plats // TODO: Afficher la facture Console.WriteLine(\"\\n=== BIENVENUE CHEZ CLAUDE ===\\n\"); // Exemple de crÃ©ation de plats var poutine = new Plat { Nom = \"Poutine Classique\", PrixBase = 12.99m, Description = \"Frites, sauce brune et fromage en grains\", Categorie = CategoriePlat.PlatPrincipal, Ingredients = new List\u003cstring\u003e { \"Frites\", \"Sauce brune\", \"Fromage en grains\" }, TempsPreparation = 15, EstVegetarien = true }; // ... crÃ©er d'autres plats } } } âœ… CritÃ¨res de rÃ©ussite Les prix sont calculÃ©s correctement avec les options Les taxes sont appliquÃ©es correctement La facture sâ€™affiche proprement Les menus offrent une rÃ©duction Projet 5 : Gestionnaire de TÃ¢ches ğŸ“‹ Objectif CrÃ©er une application de gestion de tÃ¢ches avec diffÃ©rents types de tÃ¢ches et prioritÃ©s.\nğŸ¯ Concepts utilisÃ©s HÃ©ritage Interfaces DÃ©lÃ©guÃ©s et Ã©vÃ©nements PropriÃ©tÃ©s ğŸ“ SpÃ©cifications CrÃ©er :\nÃ‰numÃ©ration Priorite : Basse, Normale, Haute, Critique\nÃ‰numÃ©ration StatutTache : AFaire, EnCours, Terminee, Annulee\nInterface INotifiable :\nÃ‰vÃ©nement : TacheModifiee MÃ©thode : NotifierChangement() Classe abstraite Tache :\nPropriÃ©tÃ©s : Id, Titre, Description, DateCreation, DateEcheance, Priorite, Statut MÃ©thodes abstraites : Executer(), EstEnRetard() Classe TacheSimple hÃ©ritant de Tache\nClasse TacheRecurrente hÃ©ritant de Tache :\nPropriÃ©tÃ© : Frequence (Quotidien, Hebdomadaire, Mensuel) MÃ©thode : CreerProchaineTache() Classe TacheAvecSousTaches hÃ©ritant de Tache :\nListe de sous-tÃ¢ches Calcul de progression (%) Classe ProjetTaches :\nCollection de tÃ¢ches MÃ©thodes : AjouterTache(), SupprimerTache(), ObtenirTachesParPriorite(), ObtenirTachesEnRetard() ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; using System.Linq; namespace GestionnaireTaches { public enum Priorite { Basse, Normale, Haute, Critique } public enum StatutTache { AFaire, EnCours, Terminee, Annulee } public enum FrequenceRecurrence { Quotidien, Hebdomadaire, Mensuel } public interface INotifiable { event EventHandler\u003cstring\u003e TacheModifiee; void NotifierChangement(string message); } public abstract class Tache : INotifiable { private static int _compteur = 0; public int Id { get; private set; } public string Titre { get; set; } public string Description { get; set; } public DateTime DateCreation { get; private set; } public DateTime? DateEcheance { get; set; } public Priorite Priorite { get; set; } public StatutTache Statut { get; set; } public event EventHandler\u003cstring\u003e TacheModifiee; protected Tache(string titre) { Id = ++_compteur; Titre = titre; DateCreation = DateTime.Now; Statut = StatutTache.AFaire; Priorite = Priorite.Normale; } public abstract void Executer(); public virtual bool EstEnRetard() { // TODO: VÃ©rifier si la date d'Ã©chÃ©ance est dÃ©passÃ©e return false; } public void NotifierChangement(string message) { TacheModifiee?.Invoke(this, message); } public virtual void AfficherDetails() { // TODO: Afficher toutes les infos } } public class TacheSimple : Tache { public TacheSimple(string titre) : base(titre) { } public override void Executer() { // TODO: Marquer comme terminÃ©e } } public class TacheRecurrente : Tache { public FrequenceRecurrence Frequence { get; set; } public TacheRecurrente(string titre, FrequenceRecurrence frequence) : base(titre) { Frequence = frequence; } public override void Executer() { // TODO: Marquer comme terminÃ©e et crÃ©er la prochaine occurrence } public TacheRecurrente CreerProchaineTache() { // TODO: CrÃ©er une nouvelle tÃ¢che avec date d'Ã©chÃ©ance ajustÃ©e return null; } } public class TacheAvecSousTaches : Tache { public List\u003cTache\u003e SousTaches { get; private set; } public TacheAvecSousTaches(string titre) : base(titre) { SousTaches = new List\u003cTache\u003e(); } public void AjouterSousTache(Tache tache) { // TODO: ImplÃ©menter } public double CalculerProgression() { // TODO: Calculer % de sous-tÃ¢ches terminÃ©es return 0; } public override void Executer() { // TODO: Marquer toutes les sous-tÃ¢ches comme terminÃ©es } public override void AfficherDetails() { base.AfficherDetails(); Console.WriteLine($\"Progression: {CalculerProgression():P0}\"); Console.WriteLine(\"Sous-tÃ¢ches:\"); // TODO: Afficher les sous-tÃ¢ches } } public class ProjetTaches { public string Nom { get; set; } private List\u003cTache\u003e _taches = new List\u003cTache\u003e(); public ProjetTaches(string nom) { Nom = nom; } public void AjouterTache(Tache tache) { _taches.Add(tache); tache.TacheModifiee += OnTacheModifiee; } private void OnTacheModifiee(object sender, string message) { Console.WriteLine($\"[NOTIFICATION] {message}\"); } public List\u003cTache\u003e ObtenirTachesParPriorite(Priorite priorite) { // TODO: Filtrer par prioritÃ© return null; } public List\u003cTache\u003e ObtenirTachesEnRetard() { // TODO: Retourner les tÃ¢ches en retard return null; } public void AfficherResume() { // TODO: Afficher statistiques (nombre total, terminÃ©es, en retard, etc.) } public void AfficherTachesParStatut() { // TODO: Grouper et afficher par statut } } class Program { static void Main(string[] args) { ProjetTaches projet = new ProjetTaches(\"DÃ©veloppement Application\"); // TODO: CrÃ©er diffÃ©rents types de tÃ¢ches // TODO: Afficher les tÃ¢ches // TODO: Marquer des tÃ¢ches comme terminÃ©es // TODO: Afficher les statistiques } } } âœ… CritÃ¨res de rÃ©ussite Les Ã©vÃ©nements notifient correctement les changements Les tÃ¢ches rÃ©currentes crÃ©ent de nouvelles instances La progression des tÃ¢ches avec sous-tÃ¢ches est correcte Les filtres fonctionnent correctement Projet 6 : Simulateur de Zoo ğŸ“‹ Objectif CrÃ©er un simulateur de zoo avec diffÃ©rents types dâ€™animaux et comportements.\nğŸ¯ Concepts utilisÃ©s HÃ©ritage multiple (interfaces) Polymorphisme Classes abstraites Collections ğŸ“ SpÃ©cifications CrÃ©er :\nInterfaces de comportements :\nIVolant : Voler(), AltitudeMaximale INageant : Nager(), ProfondeurMaximale IGrimpant : Grimper(), Agilite ICarnivore : Chasser(Animal proie) IHerbivore : Brouter() Classe abstraite Animal :\nPropriÃ©tÃ©s : Nom, Espece, Age, Poids, Sante, Faim MÃ©thodes : Manger(), Dormir(), SeReproduire(), AfficherInfos() Classes dâ€™animaux implÃ©mentant les bonnes interfaces :\nLion : ICarnivore Aigle : IVolant, ICarnivore Dauphin : INageant, ICarnivore Singe : IGrimpant, IHerbivore Elephant : IHerbivore Pingouin : INageant (ne vole pas!) Canard : IVolant, INageant Classe Enclos :\nType (Terrestre, Aquatique, Aerien, Mixte) Capacite maximale Liste dâ€™animaux MÃ©thode : AjouterAnimal(), RetirerAnimal(), NourririAnimaux() Classe Zoo :\nNom du zoo Collection dâ€™enclos MÃ©thodes : AjouterEnclos(), FaireVisiter(), RapportJournalier(), NourrirTousLesAnimaux() ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; using System.Linq; namespace SimulateurZoo { public interface IVolant { void Voler(); double AltitudeMaximale { get; } } public interface INageant { void Nager(); double ProfondeurMaximale { get; } } public interface IGrimpant { void Grimper(); int Agilite { get; } // Sur 10 } public interface ICarnivore { void Chasser(Animal proie); string RegimeAlimentaire { get; } } public interface IHerbivore { void Brouter(); string VegetationPreferee { get; } } public enum TypeEnclos { Terrestre, Aquatique, Aerien, Mixte } public abstract class Animal { public string Nom { get; set; } public string Espece { get; protected set; } public int Age { get; set; } public double Poids { get; set; } public int Sante { get; protected set; } // 0-100 public int Faim { get; protected set; } // 0-100 protected Animal(string nom, int age, double poids) { Nom = nom; Age = age; Poids = poids; Sante = 100; Faim = 50; } public virtual void Manger() { Faim = Math.Max(0, Faim - 30); Console.WriteLine($\"{Nom} mange. Faim: {Faim}%\"); } public void Dormir() { Sante = Math.Min(100, Sante + 10); Console.WriteLine($\"{Nom} dort. SantÃ©: {Sante}%\"); } public abstract void EmettreSon(); public virtual void AfficherInfos() { Console.WriteLine($\"=== {Nom} ===\"); Console.WriteLine($\"EspÃ¨ce: {Espece}\"); Console.WriteLine($\"Ã‚ge: {Age} ans\"); Console.WriteLine($\"Poids: {Poids} kg\"); Console.WriteLine($\"SantÃ©: {Sante}%\"); Console.WriteLine($\"Faim: {Faim}%\"); } } // TODO: CrÃ©er la classe Lion public class Lion : Animal, ICarnivore { public string RegimeAlimentaire { get; } = \"Carnivore strict\"; public Lion(string nom, int age, double poids) : base(nom, age, poids) { Espece = \"Lion\"; } public void Chasser(Animal proie) { // TODO: ImplÃ©menter } public override void EmettreSon() { Console.WriteLine($\"{Nom} rugit: ROARRR!\"); } } // TODO: CrÃ©er les autres classes d'animaux public class Enclos { private static int _compteur = 0; public int Numero { get; private set; } public string Nom { get; set; } public TypeEnclos Type { get; set; } public int CapaciteMax { get; set; } public List\u003cAnimal\u003e Animaux { get; private set; } public Enclos(string nom, TypeEnclos type, int capacite) { Numero = ++_compteur; Nom = nom; Type = type; CapaciteMax = capacite; Animaux = new List\u003cAnimal\u003e(); } public bool AjouterAnimal(Animal animal) { // TODO: VÃ©rifier capacitÃ© et compatibilitÃ© return false; } public void NourrirAnimaux() { // TODO: Nourrir tous les animaux } public void AfficherContenu() { // TODO: Afficher infos de l'enclos } } public class Zoo { public string Nom { get; set; } public string Ville { get; set; } private List\u003cEnclos\u003e _enclos = new List\u003cEnclos\u003e(); public Zoo(string nom, string ville) { Nom = nom; Ville = ville; } public void AjouterEnclos(Enclos enclos) { _enclos.Add(enclos); } public void NourrirTousLesAnimaux() { // TODO: Parcourir tous les enclos } public void FaireVisiter() { // TODO: Afficher tous les enclos } public void RapportJournalier() { // TODO: Statistiques (nombre animaux, par type, santÃ© moyenne, etc.) } public List\u003cAnimal\u003e RechercherAnimauxParCapacite(Type interfaceType) { // TODO: Trouver tous les animaux qui implÃ©mentent une interface donnÃ©e // Ex: tous les IVolant return null; } } class Program { static void Main(string[] args) { Zoo zoo = new Zoo(\"Zoo de MontrÃ©al\", \"MontrÃ©al\"); // TODO: CrÃ©er des enclos // TODO: CrÃ©er des animaux // TODO: Placer les animaux dans les enclos // TODO: Faire une visite // TODO: Nourrir les animaux // TODO: GÃ©nÃ©rer un rapport } } } âœ… CritÃ¨res de rÃ©ussite Les animaux ont les bonnes capacitÃ©s (nager, voler, etc.) Les enclos acceptent seulement les animaux compatibles Le polymorphisme fonctionne pour les comportements Les statistiques sont correctes Projet 7 : SystÃ¨me de RÃ©servation HÃ´tel ğŸ“‹ Objectif CrÃ©er un systÃ¨me de rÃ©servation pour un hÃ´tel avec diffÃ©rents types de chambres.\nğŸ¯ Concepts utilisÃ©s HÃ©ritage Interfaces PropriÃ©tÃ©s calculÃ©es Ã‰numÃ©rations ğŸ“ SpÃ©cifications CrÃ©er :\nÃ‰numÃ©rations :\nTypeChambre : Simple, Double, Suite, Penthouse StatutReservation : Confirmee, EnAttente, Annulee, Terminee Interface IAnnulable :\nMÃ©thode : Annuler(), ObtenirFraisAnnulation() Classe abstraite Chambre :\nPropriÃ©tÃ©s : Numero, Type, PrixParNuit, NombrePersonnesMax, Superficie, EstDisponible MÃ©thode abstraite : CalculerPrix(int nuits) Classes de chambres :\nChambreSimple : 1 personne, prix de base ChambreDouble : 2 personnes, prix + 30% Suite : 4 personnes, prix + 80%, inclut petit-dÃ©jeuner Penthouse : 6 personnes, prix + 150%, tous services inclus Classe Service :\nTypes : PetitDejeuner, Spa, Parking, RoomService Prix par service Classe Reservation implÃ©mentant IAnnulable :\nPropriÃ©tÃ©s : NumeroReservation, Client, Chambre, DateArrivee, DateDepart, Services, Statut MÃ©thodes : AjouterService(), CalculerCoutTotal(), CalculerDuree() Classe Hotel :\nGestion des chambres et rÃ©servations MÃ©thodes : RechercherChambresDisponibles(), CreerReservation(), AfficherOccupation() ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; using System.Linq; namespace SystemeHotel { public enum TypeChambre { Simple, Double, Suite, Penthouse } public enum StatutReservation { Confirmee, EnAttente, Annulee, Terminee } public enum TypeService { PetitDejeuner, Spa, Parking, RoomService, Wifi } public interface IAnnulable { bool Annuler(); decimal ObtenirFraisAnnulation(); } public abstract class Chambre { public int Numero { get; set; } public TypeChambre Type { get; protected set; } public decimal PrixParNuit { get; set; } public int NombrePersonnesMax { get; protected set; } public double Superficie { get; set; } public bool EstDisponible { get; set; } public List\u003cstring\u003e Equipements { get; protected set; } protected Chambre(int numero, decimal prixParNuit) { Numero = numero; PrixParNuit = prixParNuit; EstDisponible = true; Equipements = new List\u003cstring\u003e(); } public abstract decimal CalculerPrix(int nuits); public virtual void AfficherDetails() { Console.WriteLine($\"Chambre #{Numero} - {Type}\"); Console.WriteLine($\"Prix par nuit: {PrixParNuit:C}\"); Console.WriteLine($\"CapacitÃ©: {NombrePersonnesMax} personne(s)\"); Console.WriteLine($\"Superficie: {Superficie}mÂ²\"); Console.WriteLine($\"Disponible: {(EstDisponible ? \"Oui\" : \"Non\")}\"); } } // TODO: CrÃ©er ChambreSimple // TODO: CrÃ©er ChambreDouble // TODO: CrÃ©er Suite // TODO: CrÃ©er Penthouse public class Service { public TypeService Type { get; set; } public string Description { get; set; } public decimal Prix { get; set; } public Service(TypeService type, string description, decimal prix) { Type = type; Description = description; Prix = prix; } } public class Reservation : IAnnulable { private static int _compteur = 0; public int NumeroReservation { get; private set; } public string NomClient { get; set; } public string EmailClient { get; set; } public Chambre Chambre { get; set; } public DateTime DateArrivee { get; set; } public DateTime DateDepart { get; set; } public List\u003cService\u003e Services { get; private set; } public StatutReservation Statut { get; set; } public DateTime DateReservation { get; private set; } public Reservation(string nomClient, string email, Chambre chambre, DateTime arrivee, DateTime depart) { NumeroReservation = ++_compteur; NomClient = nomClient; EmailClient = email; Chambre = chambre; DateArrivee = arrivee; DateDepart = depart; Services = new List\u003cService\u003e(); Statut = StatutReservation.Confirmee; DateReservation = DateTime.Now; } public int CalculerDuree() { // TODO: Calculer nombre de nuits return 0; } public void AjouterService(Service service) { // TODO: ImplÃ©menter } public decimal CalculerCoutTotal() { // TODO: Chambre + services return 0; } public bool Annuler() { // TODO: VÃ©rifier si annulation possible et appliquer frais return false; } public decimal ObtenirFraisAnnulation() { // TODO: Calculer frais selon date d'annulation // Moins de 48h avant: 100% // Moins d'une semaine: 50% // Plus d'une semaine: 25% return 0; } public void AfficherDetails() { // TODO: Afficher tous les dÃ©tails } } public class Hotel { public string Nom { get; set; } public string Adresse { get; set; } private List\u003cChambre\u003e _chambres = new List\u003cChambre\u003e(); private List\u003cReservation\u003e _reservations = new List\u003cReservation\u003e(); public Hotel(string nom, string adresse) { Nom = nom; Adresse = adresse; } public void AjouterChambre(Chambre chambre) { _chambres.Add(chambre); } public List\u003cChambre\u003e RechercherChambresDisponibles(DateTime arrivee, DateTime depart) { // TODO: Filtrer les chambres disponibles pour ces dates return null; } public List\u003cChambre\u003e RechercherParType(TypeChambre type) { // TODO: Filtrer par type return null; } public Reservation CreerReservation(string client, string email, int numeroChambre, DateTime arrivee, DateTime depart) { // TODO: CrÃ©er et ajouter la rÃ©servation return null; } public void AfficherOccupation() { // TODO: Statistiques d'occupation } public decimal CalculerRevenuTotal() { // TODO: Sommer toutes les rÃ©servations confirmÃ©es return 0; } } class Program { static void Main(string[] args) { Hotel hotel = new Hotel(\"Grand HÃ´tel\", \"123 Rue Principale, MontrÃ©al\"); // TODO: Ajouter des chambres // TODO: CrÃ©er des rÃ©servations // TODO: Ajouter des services // TODO: Afficher l'occupation // TODO: Tester les annulations } } } âœ… CritÃ¨res de rÃ©ussite Les prix varient selon le type de chambre et les services Les frais dâ€™annulation sont calculÃ©s correctement Impossible de rÃ©server une chambre dÃ©jÃ  rÃ©servÃ©e Les statistiques sont exactes Projet 8 : Calculatrice de Formes GÃ©omÃ©triques ğŸ“‹ Objectif CrÃ©er un systÃ¨me pour calculer lâ€™aire, le pÃ©rimÃ¨tre et dâ€™autres propriÃ©tÃ©s de formes gÃ©omÃ©triques.\nğŸ¯ Concepts utilisÃ©s Classes abstraites Polymorphisme MÃ©thodes virtuelles Interfaces ğŸ“ SpÃ©cifications CrÃ©er :\nInterface IDessinable :\nMÃ©thode : Dessiner() Classe abstraite Forme :\nPropriÃ©tÃ©s : Nom, Couleur MÃ©thodes abstraites : CalculerAire(), CalculerPerimetre() MÃ©thode virtuelle : AfficherInfos() Classes de formes 2D :\nCercle : rayon Rectangle : longueur, largeur Carre : cÃ´tÃ© Triangle : base, hauteur Polygone : nombre de cÃ´tÃ©s, longueur des cÃ´tÃ©s Classe abstraite Forme3D hÃ©ritant de Forme :\nMÃ©thode abstraite supplÃ©mentaire : CalculerVolume() Classes de formes 3D :\nSphere : rayon Cube : cÃ´tÃ© Cylindre : rayon, hauteur Cone : rayon base, hauteur Classe Calculateur :\nMÃ©thodes statiques pour comparer des formes, trier par aire, etc. ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; using System.Linq; namespace CalculatriceFormes { public interface IDessinable { void Dessiner(); } public abstract class Forme { public string Nom { get; set; } public string Couleur { get; set; } public abstract double CalculerAire(); public abstract double CalculerPerimetre(); public virtual void AfficherInfos() { Console.WriteLine($\"=== {Nom} ===\"); Console.WriteLine($\"Couleur: {Couleur}\"); Console.WriteLine($\"Aire: {CalculerAire():F2}\"); Console.WriteLine($\"PÃ©rimÃ¨tre: {CalculerPerimetre():F2}\"); } } public class Cercle : Forme, IDessinable { public double Rayon { get; set; } public Cercle(double rayon, string couleur = \"Noir\") { Rayon = rayon; Couleur = couleur; Nom = \"Cercle\"; } public override double CalculerAire() { // TODO: Ï€ Ã— rÂ² return 0; } public override double CalculerPerimetre() { // TODO: 2 Ã— Ï€ Ã— r return 0; } public void Dessiner() { Console.WriteLine($\"Dessin d'un cercle de rayon {Rayon} en {Couleur}\"); Console.WriteLine(\" *** \"); Console.WriteLine(\" * * \"); Console.WriteLine(\" * * \"); Console.WriteLine(\" * * \"); Console.WriteLine(\" *** \"); } } // TODO: CrÃ©er Rectangle // TODO: CrÃ©er Carre // TODO: CrÃ©er Triangle public abstract class Forme3D : Forme { public abstract double CalculerVolume(); public override void AfficherInfos() { base.AfficherInfos(); Console.WriteLine($\"Volume: {CalculerVolume():F2}\"); } } // TODO: CrÃ©er Sphere // TODO: CrÃ©er Cube // TODO: CrÃ©er Cylindre public static class Calculateur { public static Forme TrouverPlusGrandeAire(List\u003cForme\u003e formes) { // TODO: Retourner la forme avec la plus grande aire return null; } public static double CalculerAireTotale(List\u003cForme\u003e formes) { // TODO: Sommer toutes les aires return 0; } public static List\u003cForme\u003e TrierParAire(List\u003cForme\u003e formes) { // TODO: Trier par aire croissante return null; } public static void ComparerFormes(Forme f1, Forme f2) { // TODO: Comparer aires et pÃ©rimÃ¨tres } } class Program { static void Main(string[] args) { List\u003cForme\u003e formes = new List\u003cForme\u003e(); // TODO: CrÃ©er diffÃ©rentes formes // TODO: Afficher les infos // TODO: Utiliser le calculateur // TODO: Dessiner les formes qui sont IDessinable } } } Conseils pour rÃ©ussir les projets ğŸ¯ MÃ©thodologie Lire attentivement les spÃ©cifications Planifier la structure avant de coder Tester frÃ©quemment chaque nouvelle fonctionnalitÃ© Refactoriser le code pour amÃ©liorer la qualitÃ© Documenter avec des commentaires clairs ğŸ” Points de contrÃ´le Pour chaque projet, vÃ©rifiez :\nâœ… Respect de lâ€™encapsulation (propriÃ©tÃ©s privÃ©es/publiques appropriÃ©es) âœ… Utilisation correcte de lâ€™hÃ©ritage âœ… Polymorphisme fonctionnel âœ… Interfaces bien implÃ©mentÃ©es âœ… Gestion des cas dâ€™erreur âœ… Code lisible et bien organisÃ©",
    "description": "Mini-Projets : Programmation OrientÃ©e Objet en C# Progression recommandÃ©e Niveau Projets DÃ©butant Projet 8 (Formes), Projet 5 (TÃ¢ches) IntermÃ©diaire Projet 1 (Banque), Projet 2 (BibliothÃ¨que), Projet 6 (Zoo) AvancÃ© Projet 3 (RPG), Projet 4 (Restaurant), Projet 7 (HÃ´tel) Table des matiÃ¨res Projet 1 : SystÃ¨me de Gestion Bancaire Projet 2 : Gestion dâ€™une BibliothÃ¨que Projet 3 : Jeu de Combat RPG Projet 4 : SystÃ¨me de Commandes Restaurant Projet 5 : Gestionnaire de TÃ¢ches Projet 6 : Simulateur de Zoo Projet 7 : SystÃ¨me de RÃ©servation HÃ´tel Projet 8 : Calculatrice de Formes GÃ©omÃ©triques Projet 1 : SystÃ¨me de Gestion Bancaire ğŸ“‹ Objectif CrÃ©er un systÃ¨me de gestion de comptes bancaires avec diffÃ©rents types de comptes et opÃ©rations.",
    "tags": [],
    "title": "Exercices - POO",
    "uri": "/420-413/poo_exos/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Plans de cours ğŸ“‹ Samuel FostinÃ© : Plan de cours\nHoraire et disponibilitÃ©s des enseignants âœ”ï¸ Samuel FostinÃ© : Lien vers mon horaire et mes disponibilitÃ©s\nSamuel FostinÃ© Nom de lâ€™Ã©valuation PondÃ©ration Semaine de lâ€™Ã©valuation 10 quiz (8 meilleures notes) 15 % Semaine 2 Ã  14 Examen 1 20% Semaine 4 Examen 2 25 % Semaine 12 Projet remise 1 5 % Semaine 6 Projet remise 2 5 % Semaine 8 Projet remise 3 5 % Semaine 10 Projet remise 4 5 % Semaine 13 Projet remise final 20 % Semaine 15",
    "description": "Plans de cours ğŸ“‹ Samuel FostinÃ© : Plan de cours\nHoraire et disponibilitÃ©s des enseignants âœ”ï¸ Samuel FostinÃ© : Lien vers mon horaire et mes disponibilitÃ©s\nSamuel FostinÃ© Nom de lâ€™Ã©valuation PondÃ©ration Semaine de lâ€™Ã©valuation 10 quiz (8 meilleures notes) 15 % Semaine 2 Ã  14 Examen 1 20% Semaine 4 Examen 2 25 % Semaine 12 Projet remise 1 5 % Semaine 6 Projet remise 2 5 % Semaine 8 Projet remise 3 5 % Semaine 10 Projet remise 4 5 % Semaine 13 Projet remise final 20 % Semaine 15",
    "tags": [],
    "title": "DÃ©veloppement d'applications pour entreprise",
    "uri": "/420-413/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-413/categories/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-413/tags/index.html"
  }
]
