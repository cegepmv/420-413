var relearn_searchindex = [
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "1. Introduction √† Visual Studio 2022 Qu‚Äôest-ce que Visual Studio ? Visual Studio 2022 est l‚ÄôEnvironnement de D√©veloppement Int√©gr√© (IDE) de Microsoft d√©di√© au d√©veloppement d‚Äôapplications sur les plateformes .NET. Il offre un ensemble complet d‚Äôoutils pour coder, tester, d√©boguer, d√©ployer et collaborer efficacement.\nLes √©ditions de Visual Studio 2022 √âdition Public cible Community Gratuit : √©tudiants, d√©veloppeurs open source et particuliers. Professional D√©veloppeurs professionnels et petites √©quipes. Enterprise Grandes √©quipes : outils avanc√©s de test, performance et int√©gration continue. 2. Installation et Configuration √âtapes d‚Äôinstallation T√©l√©chargement : Se rendre sur visualstudio.microsoft.com/fr pour choisir sa version. S√©lection des charges de travail : Pour le d√©veloppement C# (Windows Forms ou WPF), il est imp√©ratif de s√©lectionner .NET Desktop Development. Si vous disposez d√©j√† de Visual Studio, vous pouvez ajouter la charge de travail de d√©veloppement de bureau .NET comme suit :\nLancez Visual Studio Installer. Si vous y √™tes invit√©, autorisez le programme d‚Äôinstallation √† se mettre √† jour. Si une mise √† jour pour Visual Studio est disponible, un bouton Mettre √† jour s‚Äôaffiche. S√©lectionnez-la pour la mettre √† jour avant de modifier l‚Äôinstallation. Recherchez votre installation de Visual Studio et s√©lectionnez le bouton Modifier . S‚Äôil n‚Äôest pas d√©j√† s√©lectionn√©, s√©lectionnez la charge de travail de d√©veloppement du bureau .NET , puis s√©lectionnez le bouton Modifier . Sinon, fermez simplement la fen√™tre de dialogue. Personnalisation L‚Äôinterface est enti√®rement personnalisable : th√®mes, raccourcis clavier et extensions. Pour un environnement complet, il est recommand√© d‚Äôinstaller Git pour la gestion de versions.\nCaution Note sur l‚ÄôIA : Des outils comme GitHub Copilot sont disponibles, mais ils ne doivent pas √™tre utilis√©s dans le cadre de ce cours afin de ne pas nuire √† l‚Äôapprentissage des concepts fondamentaux.\n3. Fonctionnalit√©s principales Source : https://learn.microsoft.com/fr-fr/visualstudio/get-started/media/visual-studio-overview.png?view=vs-2022\nL‚Äô√©diteur de texte L‚Äô√©diteur de texte de Visual Studio est un puissant outil permettant de saisir le code de l‚Äôapplication.\nVoici quelques fonctionnalit√©s de l‚Äô√©diteur de texte:\nLes mots-cl√©s et les types sont color√©s pour faciliter la lecture et la compr√©hension du code. La qualit√© du document en cours de visualisation est annonc√©e gr√¢ce √† l‚Äôic√¥ne en bas du document pour indiquer s‚Äôil contient des suggestions, des avertissements ou des erreurs. L‚Äôintellisense permet d‚Äôafficher les classes et leurs membres en rapport avec le code saisi ainsi que les param√®tres et les surcharges possibles pour les m√©thodes L‚Äôintellicode vous permet d‚Äôassurer la pr√©cision et la coh√©rence de l‚Äôex√©cution du code qui peut remplir une ligne enti√®re √† la fois. L‚ÄôIA d√©tecte votre contexte de code, notamment les noms de variables, les fonctions et le type de code que vous √©crivez, pour vous donner les meilleures suggestions. Encore mieux¬†: IntelliCode s‚Äôex√©cute sur votre ordinateur, ce qui garantit que votre code priv√© reste priv√©. Autres outils de Visual Studio Code 2022 Gestion de builds : Cr√©ation de configurations adapt√©es aux environnements de d√©veloppement ou de production.\nD√©bogage et tests : D√©bogueur int√©gr√© pour l‚Äôex√©cution pas √† pas et outils de tests unitaires (NUnit, xUnit). Le mode d√©bogage peut √™tre lanc√© en allant sur D√©boguer -\u003e D√©marrer le d√©bogage ou juste F5\nCollaboration : Int√©gration native de Git/GitHub et support de Live Share pour le d√©veloppement collaboratif en temps r√©el.\n4. Exploration de l‚Äôinterface Lors du lancement, la fen√™tre de d√©marrage propose quatre options principales:\nClone a repository : R√©cup√©rer du code depuis GitHub ou Azure DevOps. Open a project or solution : Ouvrir un fichier projet local. Open a local folder : Naviguer et √©diter du code dans n‚Äôimporte quel dossier. Create a new project : Commencer √† partir d‚Äôun mod√®le pr√©d√©fini. ` 5. Projets et Solutions Cr√©er votre solution et projet D√©marrez Visual Studio et s√©lectionnez Cr√©er un projet. Dans la fen√™tre Cr√©er un projet, recherchez et s√©lectionnez un mod√®le d‚Äôapplication console C#, puis s√©lectionnez Suivant.. Configurez votre projet (nom, emplacement). √Ä cette √©tape, vous pouvez d√©cidez de placer la solution .sln et le projet .csproj. Puis s√©lectionnez Suivant. Dans la fen√™tre Informations suppl√©mentaires , v√©rifiez que .NET 8.0 appara√Æt dans le menu d√©roulant Framework, puis s√©lectionnez Cr√©er. Diff√©rences fondamentales entre projet et solution Un projet est un ensemble de fichiers qui seront compil√©s en un seul assemblage. Une solution est un ensemble d‚Äôun ou plusieurs projets. Un projet d‚Äôapplication ex√©cutable poss√®de un point d‚Äôentr√©e. C‚Äôest la m√©thode Main. Cette m√©thode doit √™tre publique et statique en utilisant les mots-cl√©s public et static, qui sp√©cifient respectivement que la m√©thode est accessible depuis l‚Äôapplication et en dehors, que la m√©thode est globale et que la classe n‚Äôa pas besoin d‚Äô√™tre instanci√©e pour pouvoir l‚Äôappeler. Une solution poss√®de aussi un projet de d√©marrage. Ce projet est identifiable dans l‚Äôexplorateur de solutions, car son nom est en gras. Pour modifier cette propri√©t√©, un clic droit sur le projet permet de s√©lectionner D√©finir en tant que projet de d√©marrage dans le menu contextuel. Le point d‚Äôentr√©e (M√©thode Main) Un projet ex√©cutable poss√®de une m√©thode Main. Elle doit √™tre d√©finie comme suit:\npublic : Accessible depuis l‚Äôapplication et l‚Äôext√©rieur. static : La m√©thode est globale et la classe n‚Äôa pas besoin d‚Äô√™tre instanci√©e pour l‚Äôappeler. Projet de d√©marrage : Dans une solution, le projet de d√©marrage appara√Æt en gras dans l‚Äôexplorateur de solutions. On peut le modifier via un clic droit -\u003e D√©finir en tant que projet de d√©marrage.\n6. Ex√©cution et D√©bogage Lancement : Cliquez sur la fl√®che verte ou appuyez sur F5. Points d‚Äôarr√™t (Breakpoints) : Permettent d‚Äôinterrompre l‚Äôex√©cution pour examiner l‚Äô√©tat des variables √† des endroits pr√©cis.\nLes diff√©rents fichiers compris dans la solution Le fichier program.cs qui contient le code qui est compil√© et ex√©cut√© Quand on fait un clic droit sur le projet, ensuite on choisit ‚ÄúOuvrir le dossier dans l‚ÄôExplorateur de fichiers‚Äù,¬†on peut voir le fichier du projet dont l‚Äôextension est csproj. Un niveau plus haut, on voit le fichier de la solution dont l‚Äôextension est sln. Plus bas, dans le dossier bin -\u003e Debug -\u003e net8.0, on peut voir le fichier ex√©cutable .exe qui est l‚Äôapplication qui vient d‚Äô√™tre cr√©√©e. Si on double-clique sur l‚Äôex√©cutable, on ouvre l‚Äôapplication. On peut aussi ouvrir la ligne de commande cmd et ex√©cuter l‚Äôapplication en¬†tapant le nom de l‚Äôex√©cutable. Ressources suppl√©mentaires Documentation Visual Studio Documentation IntelliCode",
    "description": "1. Introduction √† Visual Studio 2022 Qu‚Äôest-ce que Visual Studio ? Visual Studio 2022 est l‚ÄôEnvironnement de D√©veloppement Int√©gr√© (IDE) de Microsoft d√©di√© au d√©veloppement d‚Äôapplications sur les plateformes .NET. Il offre un ensemble complet d‚Äôoutils pour coder, tester, d√©boguer, d√©ployer et collaborer efficacement.",
    "tags": [],
    "title": "Intro √† Visual Studio 2022",
    "uri": "/420-413/intro/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Introduction √† .NET .NET : Un √©cosyst√®me pour le d√©veloppement d ºapplications qui prend en charge plusieurs langages, dont C#, F#, et VB.NET. Il fournit des outils, des biblioth√®ques, et un environnement d ºex√©cution pour faciliter le d√©veloppement d‚Äôapplications.\nLa plateforme .NET La plateforme .NET repose sur une architecture en couches qui permet l‚Äôex√©cution de code √©crit dans diff√©rents langages (C#, F#, VB.NET) de mani√®re unifi√©e et performante.\n1. Les composants fondamentaux L‚Äôarchitecture s‚Äôappuie principalement sur deux piliers :\nCLR (Common Language Runtime) : C‚Äôest le moteur/coeur d‚Äôex√©cution. Il g√®re l‚Äôex√©cution des programmes, la m√©moire (Garbage Collector), la s√©curit√© et la compilation √† la vol√©e (JIT). Moteur d‚Äôex√©cution : Le CLR est responsable de charger et ex√©cuter des programmes .NET et assure la gestion de la m√©moire, la s√©curit√©, et la gestion des exceptions. Conversion IL -\u003e Code natif : Le code C# est d‚Äôabord compil√© en Intermediate Language (IL), puis converti en code machine natif par le CLR. Gestion de la m√©moire : Le CLR g√®re automatiquement la m√©moire via la garbage collection (collecte des objets non utilis√©s). S√©curit√© : Le CLR applique des r√®gles de s√©curit√© pour ex√©cuter les programmes de mani√®re s√©curis√©e. BCL (Base Class Library) : Une immense biblioth√®que de classes r√©utilisables qui fournit les fonctionnalit√©s de base (gestion des fichiers, r√©seau, dates, collections, etc.). 2. Le M√©canisme de Compilation du Code Source C# Code source C# : Lorsqu‚Äôun programme C# est √©crit, le code source est d‚Äôabord compil√© en IL (Intermediate Language). Le compilateur C# s‚Äôappelle Roslyn Le CIL (Common Intermediate Language) : Le compilateur ne cr√©e pas tout de suite un programme fini. Il traduit votre C# en un langage interm√©diaire (autrefois appel√© MSIL). Pourquoi ? Parce que ce langage est universel au sein de l‚Äô√©cosyst√®me .NET. Que vous √©criviez en C#, F# ou VB.NET, tout finit en CIL. Cela permet √† diff√©rents langages de fonctionner ensemble.\nEn plus du code IL, le compilateur g√©n√®re des informations cruciales :\nM√©tadonn√©es : Une description de chaque classe, m√©thode et variable d√©finie dans votre code.\nManifeste : La ‚Äúcarte d‚Äôidentit√©‚Äù du programme (nom, version, biblioth√®ques externes n√©cessaires).\nAssembly : Le code et les ressources sont stock√©s dans un fichier assembly (g√©n√©ralement avec l‚Äôextension .dll ou .exe). Un assembly contient un manifeste qui d√©crit ses types, sa version, et ses m√©tadonn√©es. Compilation Just-In-Time (JIT) : Lorsque le programme est ex√©cut√©, le CLR charge l ºassembly, et le code IL est compil√© en code natif via la compilation JIT. Particularit√© : Le JIT ne compile que les morceaux de code au fur et √† mesure qu‚Äôils sont appel√©s (‚ÄúJuste √† temps‚Äù). Si une fonction n‚Äôest jamais utilis√©e pendant une session, elle n‚Äôest jamais compil√©e en code machine, ce qui √©conomise des ressources.",
    "description": "Introduction √† .NET .NET : Un √©cosyst√®me pour le d√©veloppement d ºapplications qui prend en charge plusieurs langages, dont C#, F#, et VB.NET. Il fournit des outils, des biblioth√®ques, et un environnement d ºex√©cution pour faciliter le d√©veloppement d‚Äôapplications.\nLa plateforme .NET La plateforme .NET repose sur une architecture en couches qui permet l‚Äôex√©cution de code √©crit dans diff√©rents langages (C#, F#, VB.NET) de mani√®re unifi√©e et performante.",
    "tags": [],
    "title": "Architecture .NET",
    "uri": "/420-413/architecture/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Introduction √† C# C# (prononc√© ‚ÄúC Sharp‚Äù) est un langage de programmation moderne, orient√© objet et fortement typ√©. C# est d√©velopp√© par Microsoft en 2000 et est principalement utilis√© pour le d√©veloppement d ºapplications sous la plateforme .NET. La syntaxe de C# est influenc√©e par C, C++ et Java, mais elle pr√©sente certaines sp√©cificit√©s qui lui sont propres.\nC# est un langage sensible √† la casse.\nL‚Äôextension des fichiers C# est .cs\nCaract√©ristiques principales: Orient√© objet: tout est bas√© sur des classes et des objets Typ√© statiquement: les types de variables doivent √™tre d√©clar√©s G√©r√©: la m√©moire est g√©r√©e automatiquement par le garbage collector Polyvalent: applications desktop, web, mobile, jeux vid√©o (Unity) Moderne: syntaxe claire et √©volutive Domaines d‚Äôutilisation: Avec C#, on peut cr√©er :\nüñ•Ô∏è des applications console\nüñ•Ô∏è Applications Windows (WPF, WinForms)\nüåê des sites Web et des API\nüì± des applications mobiles\nüéÆ des jeux (Unity utilise C#)\nüëâ Bref : un langage, plusieurs carri√®res possibles.\nStructure de base d‚Äôun programme C# Un programme C# est compos√© de plusieurs √©l√©ments cl√©s : l‚Äôespace de noms (namespace), les classes, et la m√©thode Main, qui est le point d‚Äôentr√©e de l‚Äôapplication.\nusing System; // Importation des biblioth√®ques namespace MyProgram // D√©finition de l'espace de noms { class Program // D√©finition de la classe { static void Main(string[] args) // M√©thode Main, point d'entr√©e du programme { Console.WriteLine(\"Hello, World!\"); // Affichage d'un message et aller √† la prochaine ligne } } } using : Utilis√© pour importer des biblioth√®ques externes (par exemple, System contient des classes utiles comme Console). namespace : Un conteneur logique pour les classes et autres types. En d‚Äôautres termes, c‚Äôest une fa√ßon d‚Äôorganiser le code. Pense √† un namespace comme : un dossier une section ou un casier pour ranger des classes. Sans namespaces, ce serait le chaos total üò±. Imagine des milliers de classes, toutes avec des noms simples comme Console, List, Button. Sans namespace : üí• conflits de noms üí• code impossible √† lire üí• d√©veloppeurs en d√©pression class : Un mod√®le pour cr√©er des objets. Tout programme C# doit contenir au moins une classe. Main : La m√©thode Main est le point de d√©part d‚Äôune application C#. C‚Äôest ici que l‚Äôex√©cution du programme commence. Les identifiants ou les identificateurs Ce sont les noms donn√©s aux classes et √† leurs membres. Un identifiant doit √™tre compos√© d‚Äôun seul mot commen√ßant par une lettre ou un caract√®re underscore (_). Mais, il peut contenir aussi un chiffre qui ne doit pas se placer au d√©but de l‚Äôidentifiant. Ils peuvent √™tre compos√©s de lettres majuscules et minuscules, mais le langage C# √©tant sensible √† la casse, les majuscules et minuscules doivent √™tre respect√©es pour faire r√©f√©rence au bon identifiant Par exemple: les identifiants suivants ne sont pas les m√™mes monIdentifiant et MonIdentifiant. Les mots-cl√©s Les mots cl√©s sont des noms r√©serv√©s par le langage C#, qui ont des significations sp√©cifiques pour le compilateur. Ils ne peuvent pas √™tre utilis√©s comme identifiants dans votre programme, sauf s‚Äôils incluent @ comme pr√©fixe. Par exemple, @if est un identifiant valide, mais pas if, car if est un mot cl√©.\nPar d√©faut, les mots-cl√©s sont color√©s en bleu dans l‚Äô√©diteur de Visual Studio. Le caract√®re @ peut √©galement pr√©fixer des identifiants qui n‚Äôont aucun conflit avec les mots-cl√©s. Ainsi @monIdentifiant et monIdentifiant seront interpr√©t√©s de la m√™me mani√®re (la m√™me variable). Les commentaires C# prend en charge deux formes diff√©rentes de commentaires:\nLes commentaires sur une seule ligne commencent par // et se terminent √† la fin de cette ligne de code. Les commentaires multilignes commencent par /* et se terminent par */ Le commentaire sur plusieurs lignes peut √©galement √™tre utilis√© pour ins√©rer du texte dans une ligne de code. √âtant donn√© que ces commentaires ont un caract√®re de fermeture explicite, vous pouvez inclure plus de code ex√©cutable apr√®s le commentaire:\npublic static int additioner(int nombre1, int nombre2) { return nombre1 /* premi√®re op√©rande */ + nombre2 /* deuxi√®me op√©rande*/; } Le commentaire sur une seule ligne peut appara√Ætre apr√®s le code ex√©cutable sur la m√™me ligne. Le commentaire se termine √† la fin de la ligne de texte :\nfloat temperature = 34.4f; // Si nous n'ajoutons pas le f ou le F apr√®s la valeur, nous obtiendrons une erreur",
    "description": "Introduction √† C# C# (prononc√© ‚ÄúC Sharp‚Äù) est un langage de programmation moderne, orient√© objet et fortement typ√©. C# est d√©velopp√© par Microsoft en 2000 et est principalement utilis√© pour le d√©veloppement d ºapplications sous la plateforme .NET. La syntaxe de C# est influenc√©e par C, C++ et Java, mais elle pr√©sente certaines sp√©cificit√©s qui lui sont propres.",
    "tags": [],
    "title": "Intro et syntaxe du C#",
    "uri": "/420-413/intro_syntaxe_c_sharp/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "1. D√©claration de variables et types de donn√©es C# est un langage fortement typ√©, ce qui signifie que chaque variable doit √™tre d√©clar√©e avec un type sp√©cifique. Voici quelques types de base :\nint age = 25; // Entier double price = 19.99; // Nombre √† virgule flottante char grade = 'A'; // Caract√®re unique string name = \"John\"; // Cha√Æne de caract√®res bool isActive = true; // Bool√©en (vrai ou faux) Une variable peut √™tre d√©clar√©e et initialis√©e avec la m√™me instruction.\nstring salutation = \"Bonjour tout le monde!\";\nIl est √©galement possible de d√©clarer et d‚Äôinitier plusieurs variables en une seule instruction, √† la condition qu‚Äôelles soient du m√™me type. Dans ce cas, les variables sont s√©par√©es par une virgule. bool joyeux = true, content = true;\nUne variable peut √©galement √™tre marqu√©e par le mot-cl√© const qui sp√©cifie que la valeur de la variable ne peut pas √™tre modifi√©e pendant l‚Äôex√©cution. C‚Äôest une variable en lecture seule. const double Pi = 3.14;\nL‚Äôinf√©rence de type (var) : Le mot-cl√© var permet au compilateur de deviner le type de la variable lors de l‚Äôinitialisation. Attention : le type reste fixe apr√®s l‚Äôassignation.\nvar total = 15.5; // Le compilateur d√©duit 'double'\nüí° Voici quelques conventions de codage applicables aux variables : La r√®gle d‚Äôor : Camel Case Pour les variables locales (celles d√©finies √† l‚Äôint√©rieur d‚Äôune m√©thode), la convention universelle en C# est le camelCase. Par exemple¬†:¬†string thisIsCamelCase;. Le premier mot commence par une lettre minuscule.\nChaque mot suivant commence par une lettre majuscule.\nOn ne doit pas utiliser de chiffres au d√©but du nom.\nLe trait de soulignement (_) est proscrit pour le moment.\nint nombreEtudiants; // Correct\tstring codePermanent; // Correct double soldeBanque;\t// Correct int NombreEtudiants; // (PascalCase) Incorrect (ou non conventionnel) string code_permanent; // (snake_case) non conventionnel) double soldebanque; // (tout en minuscule) Incorrect (ou non conventionnel) S√©mantique (Donner du sens)\nUne variable doit d√©crire son contenu sans ambigu√Øt√©. En programmation professionnelle, on √©vite les noms d‚Äôune seule lettre.\n√âvitez : string s = \"Informatique\";\nPrivil√©giez : string nomProgramme = \"Informatique\";\nTableau r√©capitulatif des conventions de nommage C# √âl√©ment Convention Exemple Variable locale camelCase uniteDisponible Param√®tre de m√©thode camelCase (int quantiteItems) Constante PascalCase TauxTaxeFederale Classe PascalCase GestionnaireEtudiant M√©thode PascalCase CalculerSalaire() 2. Les types de base Les types de donn√©es permettent de stocker des valeurs dans l‚Äôapplication. Les langages .NET √©tant fortement typ√©s, il n‚Äôest pas toujours possible de convertir un type de donn√©es √† un autre. Les conversions permettent de convertir les types de donn√©es. Cela est possible, car tous les types du Framework .NET d√©rivent du type Object qui est le type de case de tous les autres types Les types num√©riques Les types num√©riques sont d√©compos√©s en deux parties: Les entiers et les d√©cimaux. Chacun dispose d‚Äôun ensemble de types pour repr√©senter les donn√©es de la mani√®re la plus judicieuse en fonction des besoins.\nLes entiers Une valeur peut √™tre assign√©e √† un entier avec une notation d√©cimale:\nint nombre = 10; //Notation d√©cimale La notation hexad√©cimale peut √™tre utilis√©e et elle doit √™tre pr√©c√©d√©e du pr√©fixe 0x:\nint nombre = 0x4B; // Notation hexad√©cimale √©quivalente √† 75 La notation binaire peut √™tre utilis√©e et elle doit √™tre pr√©c√©d√©e du pr√©fixe 0b:\nint nombre = 0b1101; // Notation binaire √©quivalente √† 13 Les d√©cimaux Les bool√©ens Un bool√©en est un type qui permet de repr√©senter une valeur qui est soit true, soit false. Le type .NET correspondant est System.Boolean et son nom C# est bool. Il est possible d‚Äôassigner √† un bool√©en le r√©sultat d‚Äôune comparaison:\nint nombre = 8; bool estPair = nombre % 2 == 0; Les cha√Ænes de caract√®res Le type System.String (string) est un type de r√©f√©rence qui repr√©sente une s√©rie de types System.Char (char)\nUne variable de type char est assign√©e avec un caract√®re plac√© entre guillemets simples:\nchar premiereLettre = 'a'; Une variable de type string est assign√©e avec une cha√Æne de caract√®re plac√©e entre des guillemets doubles\nstring salutation = \"Bonjour tout le monde!\"; La propri√©t√© Length permet de savoir quelle est la longueur d‚Äôun string\nConsole.WriteLine(\"Hello\".Length); // R√©sultat: 5 D√©claration des chaines de caract√®res // D√©clarer sans initialiser. string message1; // Initialiser √† null. string message2 = null; // Initialise comme une cha√Æne vide (empty string). // Utilise la constante Empty au lieu de \"\". string message3 = System.String.Empty; // Initialiser avec une cha√Æne de caract√®res normale. string vieuxChemin = \"c:\\\\Program Files\\\\Microsoft Visual Studio 8.0\"; // Initialiser avec un litt√©ral de cha√Æne verbatim (pratique pour les chemins). string nouveauChemin = @\"c:\\Program Files\\Microsoft Visual Studio 9.0\"; // Utilisez System.String si vous pr√©f√©rez. System.String salutation = \"Hello World!\"; // Dans les variables locales (c'est-√†-dire dans le corps d'une m√©thode), // vous pouvez utiliser le typage implicite. var temporaire = \"I'm still a strongly-typed System.String!\"; // Utilisez une cha√Æne const pour emp√™cher la variable de stocker une autre valeur. const string MessagePermanent = \"Tu ne peux pas te d√©barrasser de moi!\"; // Utilisez le constructeur String uniquement lors de la cr√©ation // d'une cha√Æne √† partir d'un char*, char[] ou sbyte*. char[] lettres = { 'A', 'B', 'C' }; string alphabet = new string(lettres); Quelques propri√©t√©s et m√©thodes de la classe string Soit la variable suivante¬†: string salutation = \"Bonjour tout le monde!\";\nLa nombre de caract√®re:\nint nombreCaractere = salutation.Length; // 22 Convertir tous les caract√®res de la cha√Æne en majuscule:\nstring salutationMajuscule = salutation.ToUpper(); //¬†BONJOUR TOUT LE MONDE! Convertir tous les caract√®res de la cha√Æne en lettre minuscule\nstring¬†salutationMinuscule = salutation.ToLower(); // bonjour tout le monde! V√©rifier si le string contient une sous-cha√Æne de caract√®re ou un mot\nbool contientBonjour = salutation.Contains(\"bonjour\"); contientBonjour = salutation.Contains(\"Bonjour\");¬†//true Remplacer toutes les occurrences d‚Äôun caract√®re dans la cha√Æne par un autre\nstring salut =¬†salutation.Replace(\"Bonjour\", \"Salut\") //¬†Salut tout le monde! Retourne une partie de la chaine, le 0 est l‚Äôindex du d√©but, et le 7 est le¬†nombre de caract√®re √† consid√©rer\nstring bonjour =¬†salutation.Substring(0, 7); // Bonjour Admettons que j‚Äôajoute un autre string, pour Concat√©ner les strings\nstring question = \"Comment allez-vous?\"; String¬†nouvelleSalutation¬†=¬†string.Concat(salutation, \" \", question);¬†//Bonjour tout le monde!¬†Comment allez-vous? Formatter la chaine de caract√®re pour remplacer les expressions de type {0}, {1}, {2}, {3}, etc. Pr√©sentes dans la cha√Æne par les valeurs pass√©es en param√®tres lors de l‚Äôappel de la fonction.\nstring firstName = \"Sara\"; int count = 25; float temperature = 34.4f; Console.WriteLine(\"Bonjour, {0}! Tu as {1} messages dans ta bo√Æte. La temp√©rature est {2} celsius.\", prenom, count, temperature); L‚Äôinterpolation de string Soit les variables suivantes:\nstring nom = \"Samuel\"; int age = 28; On aimerait cr√©er le string: Je m‚Äôappelle Marc, j‚Äôai 20 ans. Si on utilise l‚Äôaddition des cha√Ænes de caract√®res, on aurait:\nstring presentation = \"Je m'appelle \" + nom + \", j'ai \" +¬†age + \" ans.\"; En utilisant la m√©thode string.format:\nstring presentation = string.Format(\"Je m'appelle {0}, j'ai {1} ans. \",¬†nom, age); En utilisant l‚Äôinterpolation:\nstring presentation = $\"Je m'appelle {nom}, j'ai {age} ans. \"; Convertir une cha√Æne de caract√®res aux autres types Utiliser la m√©thode Parse pour convertir un string vers un autre type\nint age = int.Parse(\"35\");¬†bool vrai = bool.Parse(\"true\"); Il se peut qu‚Äôon essaie de convertir une valeur incorrecte. Par exemple, si on essaie de convertir la cha√Æne de caract√®re ‚ÄúSamuel‚Äù en int. On aura une erreur lors de l‚Äôex√©cution. Pour √©viter d‚Äôavoir une erreur, on utilise TryParse pour v√©rifier si la cha√Æne de caract√®re peut se convertir¬†au type d√©sir√© Type implicite et explicite Jusqu‚Äô√† maintenant, on a vu diff√©rents types explicites qui existent, par exemple : int, double, bool, string, etc. Depuis C# 3, C# permet d‚Äôutiliser un type implicite. De ce fait, le programmeur demande √† C# de trouver le type associ√© √† la variable.\nOn utilise le mot-cl√© var pour d√©finir une variable implicite\nvar nombre = 6; // C# sait que c'est un int var content = true; // C# sait que c'est un bool√©en var¬†salutation = \"Bonjour\"; // sait que c'est un string Par contre, si on d√©clare une variable implicite sans l‚Äôinitialiser, C# donnera une erreur de compilation.\n// ‚ùå Erreur de compilation : \"Implicitly-typed variables must be initialized\" var message; // ‚úÖ Correct : Le compilateur voit \"Bonjour\" et d√©duit que 'message' est de type string var message = \"Bonjour\"; Avec string message;, vous dites explicitement au compilateur : ‚ÄúR√©serve une bo√Æte pour du texte‚Äù. Avec var message;, vous ne lui donnez aucun indice. Le compilateur refuse de deviner ou de laisser la variable ‚Äúsans type‚Äù jusqu‚Äô√† plus tard.*",
    "description": "1. D√©claration de variables et types de donn√©es C# est un langage fortement typ√©, ce qui signifie que chaque variable doit √™tre d√©clar√©e avec un type sp√©cifique. Voici quelques types de base :\nint age = 25; // Entier double price = 19.99; // Nombre √† virgule flottante char grade = 'A'; // Caract√®re unique string name = \"John\"; // Cha√Æne de caract√®res bool isActive = true; // Bool√©en (vrai ou faux) Une variable peut √™tre d√©clar√©e et initialis√©e avec la m√™me instruction.\nstring salutation = \"Bonjour tout le monde!\";",
    "tags": [],
    "title": "Variables",
    "uri": "/420-413/variables/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Les op√©rateurs Op√©rateurs Arithm√©tiques en C# Op√©rateur Nom Description Exemple R√©sultat + Addition Somme de deux valeurs int x = 10 + 5; 15 - Soustraction Diff√©rence entre deux valeurs int x = 20 - 8; 12 * Multiplication Produit de deux valeurs double x = 5.5 * 2; 11.0 / Division Quotient de la division int x = 10 / 3; 3 (Entier) % Modulo Reste de la division enti√®re int x = 10 % 3; 1 Op√©rateurs d‚Äôincr√©mentation et de d√©cr√©mentation Op√©rateur Nom Position Description Exemple R√©sultat (x) ++x Pr√©-incr√©mentation Avant Incr√©mente, puis retourne la valeur int y = ++x; Augment√© de 1 x++ Post-incr√©mentation Apr√®s Retourne la valeur, puis incr√©mente int y = x++; Augment√© de 1 --x Pr√©-d√©cr√©mentation Avant D√©cr√©mente, puis retourne la valeur int y = --x; Diminu√© de 1 x-- Post-d√©cr√©mentation Apr√®s Retourne la valeur, puis d√©cr√©mente int y = x--; Diminu√© de 1 Pourquoi la position est-elle importante ? La diff√©rence r√©side dans la valeur retourn√©e par l‚Äôexpression au moment de l‚Äôex√©cution :\nPr√© (++x) : C‚Äôest le mode ‚ÄúMise √† jour d‚Äôabord‚Äù. On change la valeur et on utilise le nouveau r√©sultat tout de suite. Post (x++) : C‚Äôest le mode ‚ÄúUtilisation d‚Äôabord‚Äù. On utilise la valeur actuelle dans le calcul, et l‚Äôajout de 1 se fait juste apr√®s. Exemple de comparaison : int a = 10; int b = 10; int resultatA = ++a; // a devient 11, puis resultatA re√ßoit 11. int resultatB = b++; // resultatB re√ßoit 10, puis b devient 11. // √Ä la fin : // a est 11, resultatA est 11 // b est 11, resultatB est 10 Op√©rateurs Logiques en C# Les op√©rateurs logiques permettent de tester plusieurs conditions √† la fois et retournent toujours une valeur bool√©enne (true ou false).\nOp√©rateur Nom Description Exemple \u0026\u0026 ET (AND) Retourne true si toutes les conditions sont vraies. (age \u003e= 18 \u0026\u0026 aPermis) || OU (OR) Retourne true si au moins une des conditions est vraie. (estSamedi || estDimanche) ! NON (NOT) Inverse l‚Äô√©tat logique (vrai devient faux et inversement). !estConnecte ^ OU exclusif (XOR) Retourne true si une seule des deux conditions est vraie. (estOptionA ^ estOptionB) Tables de v√©rit√© (R√©sum√©) A B A \u0026\u0026 B A || B A ^ B !A true true true true false false true false false true true false false true false true true true false false false false false true Le concept de ‚ÄúCourt-circuit‚Äù (Short-circuit) Les op√©rateurs \u0026\u0026 et || sont dits ‚Äúintelligents‚Äù en C# :\nAvec \u0026\u0026 : Si la premi√®re condition est fausse, C# n‚Äô√©value m√™me pas la deuxi√®me (car le r√©sultat sera forc√©ment faux). Avec || : Si la premi√®re condition est vraie, C# s‚Äôarr√™te l√† (car le r√©sultat sera forc√©ment vrai). Astuce : Placez toujours la condition la plus ‚Äúlourde‚Äù ou risqu√©e en deuxi√®me position pour profiter du court-circuit.\nOp√©rateurs logiques : Court-circuit vs √âvaluation compl√®te Il existe deux variantes pour les op√©rateurs ET et OU. La diff√©rence r√©side dans la gestion de la deuxi√®me condition.\nType ET OU Comportement Court-circuit \u0026\u0026 || √âvalue la 2e condition uniquement si n√©cessaire. √âvaluation compl√®te \u0026 | √âvalue toujours les deux conditions, sans exception. Pourquoi utiliser l‚Äô√©valuation compl√®te (\u0026 et |) ? L‚Äôutilisation de \u0026 et | sur des bool√©ens est plus rare, mais elle est n√©cessaire si la deuxi√®me condition contient un effet de bord (une action qui doit absolument se produire, comme une incr√©mentation ou l‚Äôappel d‚Äôune m√©thode).\nExemple de diff√©rence : int compteur = 0; bool conditionFausse = false; // Cas 1 : Court-circuit (\u0026\u0026) if (conditionFausse \u0026\u0026 ++compteur \u003e 0) { /* ... */ } Console.WriteLine(compteur); // Affiche 0 (le ++ n'a jamais √©t√© ex√©cut√©) // Cas 2 : √âvaluation compl√®te (\u0026) if (conditionFausse \u0026 ++compteur \u003e 0) { /* ... */ } Console.WriteLine(compteur); // Affiche 1 (le ++ a √©t√© ex√©cut√© malgr√© le faux) Op√©rateurs de comparaison en C# Les op√©rateurs de comparaison permettent de v√©rifier la relation entre deux expressions. Le r√©sultat est toujours une valeur bool√©enne (true ou false).\nOp√©rateur Nom Description Exemple R√©sultat == √âgalit√© true si les valeurs sont identiques 5 == 5 true != In√©galit√© true si les valeurs sont diff√©rentes 5 != 3 true \u003e Plus grand que true si la gauche est strictement sup√©rieure 10 \u003e 5 true \u003c Plus petit que true si la gauche est strictement inf√©rieure 2 \u003c 1 false \u003e= Plus grand ou √©gal true si la gauche est sup√©rieure ou √©gale 5 \u003e= 5 true \u003c= Plus petit ou √©gal true si la gauche est inf√©rieure ou √©gale 4 \u003c= 3 false Confusion entre = et == C‚Äôest l‚Äôerreur la plus fr√©quente chez les d√©butants :\n= est l‚Äôop√©rateur d‚Äôassignation (on donne une valeur √† une variable). == est l‚Äôop√©rateur de comparaison (on v√©rifie si deux valeurs sont √©gales). Comparaison de cha√Ænes de caract√®res (string) En C#, l‚Äôop√©rateur == fonctionne pour comparer le contenu des cha√Ænes de caract√®res. Attention : la comparaison est sensible √† la casse.\nstring nomUn = \"Bob\"; string nomDeux = \"bob\"; bool sontEgaux = (nomUn == nomDeux); // R√©sultat: false",
    "description": "Les op√©rateurs Op√©rateurs Arithm√©tiques en C# Op√©rateur Nom Description Exemple R√©sultat + Addition Somme de deux valeurs int x = 10 + 5; 15 - Soustraction Diff√©rence entre deux valeurs int x = 20 - 8; 12 * Multiplication Produit de deux valeurs double x = 5.5 * 2; 11.0 / Division Quotient de la division int x = 10 / 3; 3 (Entier) % Modulo Reste de la division enti√®re int x = 10 % 3; 1 Op√©rateurs d‚Äôincr√©mentation et de d√©cr√©mentation Op√©rateur Nom Position Description Exemple R√©sultat (x) ++x Pr√©-incr√©mentation Avant Incr√©mente, puis retourne la valeur int y = ++x; Augment√© de 1 x++ Post-incr√©mentation Apr√®s Retourne la valeur, puis incr√©mente int y = x++; Augment√© de 1 --x Pr√©-d√©cr√©mentation Avant D√©cr√©mente, puis retourne la valeur int y = --x; Diminu√© de 1 x-- Post-d√©cr√©mentation Apr√®s Retourne la valeur, puis d√©cr√©mente int y = x--; Diminu√© de 1 Pourquoi la position est-elle importante ? La diff√©rence r√©side dans la valeur retourn√©e par l‚Äôexpression au moment de l‚Äôex√©cution :",
    "tags": [],
    "title": "Op√©rateurs",
    "uri": "/420-413/operateurs/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "1. Structures Conditionnelles 1.1 If-Else Similitudes avec Java : La syntaxe de base est identique.\n// Calcul de rabais selon la quantit√© et le montant int quantite = 15; double montantTotal = 250.50; double rabais = 0.0; if (quantite \u003e= 20 \u0026\u0026 montantTotal \u003e= 500) { rabais = 0.20; // 20% pour commandes importantes } else if (quantite \u003e= 10 || montantTotal \u003e= 200) { rabais = 0.10; // 10% pour commandes moyennes } else { rabais = 0.0; // Pas de rabais } double montantFinal = montantTotal * (1 - rabais); Console.WriteLine($\"Montant final: {montantFinal} $\"); ‚úÖ Bonne pratique - Accolades obligatoires\nint stock = 5; int quantite = 10; // ‚úÖ BIEN - Toujours utiliser des accolades if (quantite \u003e stock) { Console.WriteLine(\"Stock insuffisant\"); } // ‚ùå √âVITER - M√™me si syntaxiquement valide if (quantite \u003e stock) Console.WriteLine(\"Stock insuffisant\"); 1.2 Op√©rateur Ternaire Identique √† Java, mais C# encourage son utilisation judicieuse.\n// Calcul de frais d'exp√©dition // Calcul des frais d'exp√©dition double montantCommande = 45.00; double fraisExpedition = montantCommande \u003e= 50 ? 0.0 : 5.99; Console.WriteLine($\"Frais d'exp√©dition : {fraisExpedition:C}\"); // D√©termination du statut de paiement int joursRetard = 15; string statutPaiement = joursRetard \u003e 0 ? \"En retard\" : \"√Ä jour\"; Console.WriteLine($\"Statut : {statutPaiement}\"); ‚úÖ Bonne pratique - Ternaires imbriqu√©s\nint noteExamen = 85; // ‚úÖ Acceptable pour des cas simples (Logique lin√©aire) string mention = noteExamen \u003e= 90 ? \"A\" : noteExamen \u003e= 80 ? \"B\" : noteExamen \u003e= 70 ? \"C\" : noteExamen \u003e= 60 ? \"D\" : \"F\"; Console.WriteLine($\"R√©sultat : {mention}\"); // ‚ùå √Ä √âVITER - Trop complexe, rend le d√©bogage difficile int heuresTravaillees = 45; int heuresSupplementaires = 5; bool estWeekend = true; // Cette structure imbriqu√©e est une \"dette technique\" imm√©diate double tauxHoraire = heuresTravaillees \u003e 40 ? (estWeekend ? 30.0 : 25.0) : (heuresSupplementaires \u003e 0 ? 22.0 : 20.0); // Difficile √† lire et √† maintenir ! 1.3 Switch Statement Diff√©rence majeure avec Java : Pas de ‚Äúfall-through‚Äù implicite en C#.\nint jour = 3; switch (jour) { case 1: Console.WriteLine(\"Lundi\"); break; // break obligatoire case 2: Console.WriteLine(\"Mardi\"); break; case 3: Console.WriteLine(\"Mercredi\"); break; case 4: Console.WriteLine(\"Jeudi\"); break; case 5: Console.WriteLine(\"Vendredi\"); break; default: Console.WriteLine(\"Weekend ou invalide\"); break; } Fall-through explicite en C#\nint jour = 6; switch (jour) { case 6: case 7: Console.WriteLine(\"Weekend\"); break; // Un seul break pour les deux cas case 1: case 2: case 3: case 4: case 5: Console.WriteLine(\"Jour de semaine\"); break; default: Console.WriteLine(\"Jour invalide\"); break; } ‚úÖ Bonne pratique - Switch avec char et string\n// Switch avec char char noteLettre = 'B'; switch (noteLettre) { case 'A': Console.WriteLine(\"Excellent\"); break; case 'B': Console.WriteLine(\"Tr√®s bien\"); break; case 'C': Console.WriteLine(\"Bien\"); break; default: Console.WriteLine(\"√Ä am√©liorer\"); break; } // Switch avec string string commande = \"start\"; switch (commande) { case \"start\": Console.WriteLine(\"D√©marrage...\"); break; case \"stop\": Console.WriteLine(\"Arr√™t...\"); break; case \"pause\": Console.WriteLine(\"Pause...\"); break; default: Console.WriteLine(\"Commande inconnue\"); break; } 1.4 Switch Expression (C# 8.0+) Nouveaut√© C#\n// Syntaxe concise et fonctionnelle int numeroDuJour = 3; string nomJour = numeroDuJour switch { 1 =\u003e \"Lundi\", 2 =\u003e \"Mardi\", 3 =\u003e \"Mercredi\", 4 =\u003e \"Jeudi\", 5 =\u003e \"Vendredi\", 6 =\u003e \"Weekend\", 7 =\u003e \"Weekend\", _ =\u003e \"Invalide\" }; Console.WriteLine(nomJour); ‚úÖ Bonne pratique - Switch expression pour calculer des valeurs\n// Utilisation de valeurs discr√®tes (cas pr√©cis) int numeroJour = 3; string typeJour = numeroJour switch { 1 or 2 =\u003e \"D√©but de semaine\", 3 or 4 =\u003e \"Milieu de semaine\", 5 =\u003e \"Fin de semaine\", 6 or 7 =\u003e \"Weekend\", _ =\u003e \"Invalide\" }; Console.WriteLine(typeJour); // Pour les comparaisons de ranges, utiliser if-else iint age = 25; double prixBillet; if (age \u003c 5) prixBillet = 0.0; else if (age \u003c 18) prixBillet = 8.50; else if (age \u003c 65) prixBillet = 12.00; else prixBillet = 9.00; Console.WriteLine($\"Prix du billet : {prixBillet} $\"); ‚úÖ Bonne pratique - Switch expression avec valeurs multiples\nchar lettre = 'e'; // ‚úÖ Version optimis√©e (C# 9+) : Plus lisible et moins de r√©p√©titions bool estUneVoyelle = lettre switch { 'a' or 'e' or 'i' or 'o' or 'u' or 'A' or 'E' or 'I' or 'O' or 'U' =\u003e true, _ =\u003e false }; Console.WriteLine($\"Est une voyelle : {estUneVoyelle}\"); ‚úÖ Bonne pratique - Quand utiliser switch vs if-else\nint note = 85; // La switch expression agit comme une \"table de correspondance\" string mention = note switch { \u003e= 90 =\u003e \"A\", \u003e= 80 =\u003e \"B\", \u003e= 70 =\u003e \"C\", \u003e= 60 =\u003e \"D\", _ =\u003e \"F\" // Le discard (_) est obligatoire pour couvrir tous les cas }; Console.WriteLine($\"Mention obtenue : {mention}\"); double solde = 1500.50; int nombreTransactions = 25; bool aUnDecouvert = false; double fraisMensuels = 0.0; // Logique d√©cisionnelle bas√©e sur plusieurs crit√®res if (solde \u003e= 5000 \u0026\u0026 nombreTransactions \u003e 50) { fraisMensuels = 0.0; // Compte premium gratuit } else if (solde \u003e= 1000 || nombreTransactions \u003c= 10) { fraisMensuels = 5.0; // Frais r√©duits (fid√©lit√© ou faible usage) } else if (aUnDecouvert) { fraisMensuels = 25.0; // P√©nalit√© pour d√©couvert } else { fraisMensuels = 12.0; // Frais standards } // Utilisation du format mon√©taire :C (tr√®s pratique en .NET 8) Console.WriteLine($\"Frais mensuels : {fraisMensuels:C}\"); 2. Structures It√©ratives 2.1 Boucle While Identique √† Java.\nint i = 0; while (i \u003c 5) { Console.WriteLine(i); i++; } ‚úÖ Bonne pratique - While avec condition claire\nint somme = 0; int nombre = 1; while (somme \u003c 100) { somme += number; nombre++; } Console.WriteLine($\"Somme: {somme}, Dernier nombre: {nombre}\"); ‚úÖ Bonne pratique - √âviter les boucles infinies\n// ‚ùå DANGEREUX // while (true) // { // // Sans condition de sortie claire // } // ‚úÖ MIEUX - Avec limite de s√©curit√© int maxTentatives = 10; int tentatives = 0; bool succes = false; // ‚úÖ Utilisation d'une boucle While avec deux conditions de sortie while (tentatives \u003c maxTentatives \u0026\u0026 !succes) { Console.Write(\"Entrez un nombre entre 1 et 10 : \"); string saisie = Console.ReadLine(); // ‚úÖ int.TryParse √©vite que le programme plante si l'utilisateur tape du texte // Le \"out int nombre\" d√©clare la variable uniquement si la conversion r√©ussit if (int.TryParse(saisie, out int nombre) \u0026\u0026 nombre \u003e= 1 \u0026\u0026 nombre \u003c= 10) { succes = true; Console.WriteLine(\"Valide !\"); } else { tentatives++; Console.WriteLine($\"Invalide. Tentatives restantes : {maxTentatives - tentatives}\"); } } 2.2 Boucle Do-While Identique √† Java.\nint i = 0; do { Console.WriteLine(i); i++; } while (i \u003c 5); ‚úÖ Bonne pratique - Utiliser do-while pour validation Utilisation pour la validation de saisie : Cette structure garantit que l‚Äôutilisateur verra le message au moins une fois.\nint nombre; string saisie; do { Console.Write(\"Entrez un nombre positif : \"); saisie = Console.ReadLine(); // On boucle tant que la saisie n'est pas un entier OU que le nombre est \u003c= 0 } while (!int.TryParse(saisie, out nombre) || nombre \u003c= 0); Console.WriteLine($\"Vous avez entr√© : {nombre}\"); Exemple - Menu simple\nint choix; do { Console.WriteLine(\"\\n--- MENU ---\"); Console.WriteLine(\"1. Addition\"); Console.WriteLine(\"2. Soustraction\"); Console.WriteLine(\"3. Quitter\"); Console.Write(\"Votre choix : \"); //si l'utilisateur ne tape pas un chiffre et que la conversion ne fonction pas, choix va avoir la valeur par d√©faut 0 int.TryParse(Console.ReadLine(), out choix); switch (choix) { case 1: Console.WriteLine(\"Addition s√©lectionn√©e\"); break; case 2: Console.WriteLine(\"Soustraction s√©lectionn√©e\"); break; case 3: Console.WriteLine(\"Au revoir !\"); break; default: Console.WriteLine(\"Choix invalide, veuillez recommencer.\"); break; } // La boucle continue tant que l'utilisateur n'a pas choisi de quitter (3) } while (choix != 3); 2.3 Boucle For Identique √† Java.\nfor (int i = 0; i \u003c 10; i++) { Console.WriteLine(i); } ‚úÖ Bonne pratique - D√©clarer la variable dans la boucle\n// ‚úÖ BIEN - Port√©e limit√©e for (int i = 0; i \u003c 10; i++) { Console.WriteLine(i); } // i n'existe plus ici // ‚ùå √âVITER - Port√©e trop large int j; for (j = 0; j \u003c 10; j++) { Console.WriteLine(j); } // j existe encore ici It√©rer sur un tableau\nLa boucle for est privil√©gi√©e lorsque l‚Äôindexation est n√©cessaire ou pour manipuler des structures multidimensionnelles.\nint[] nombres = { 10, 20, 30, 40, 50 }; // Calcul de la somme int somme = 0; for (int i = 0; i \u003c nombres.Length; i++) { somme += nombres[i]; } Console.WriteLine($\"Somme : {somme}\"); // Recherche d'un √©l√©ment int valeurRecherchee = 30; int indexTrouve = -1; for (int i = 0; i \u003c nombres.Length; i++) { if (nombres[i] == valeurRecherchee) { indexTrouve = i; break; // On quitte la boucle d√®s qu'on a trouv√© } } if (indexTrouve != -1) { Console.WriteLine($\"Trouv√© √† l'index {indexTrouve}\"); } ‚úÖ Bonne pratique - √âviter de modifier le compteur dans la boucle\nint[] values = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // ‚ùå MAUVAIS - Difficile √† comprendre for (int i = 0; i \u003c values.Length; i++) { Console.WriteLine(values[i]); if (values[i] % 2 == 0) i++; // Modifie le flux de contr√¥le - confus! } // ‚úÖ MIEUX - Intention claire for (int i = 0; i \u003c values.Length; i++) { Console.WriteLine(values[i]); if (values[i] % 2 == 0 \u0026\u0026 i + 1 \u003c values.Length) { i++; // Saute le prochain si pair } } Boucles imbriqu√©es - Tableaux 2D\nint[,] matrice = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; // Affichage de la matrice ligne par ligne for (int ligne = 0; ligne \u003c 3; ligne++) { for (int col = 0; col \u003c 3; col++) { Console.Write($\"{matrice[ligne, col]} \"); } Console.WriteLine(); // Saut de ligne apr√®s chaque rang√©e } 2.4 Boucle Foreach Diff√©rence avec Java : Mot-cl√© foreach au lieu de for. C‚Äôest l‚Äôoutil le plus s√ªr car il √©limine les erreurs de d√©passement d‚Äôindex (le fameux IndexOutOfRangeException).\n// Java: for (String name : names) // C#: string[] noms = { \"Alice\", \"Bob\", \"Charlie\" }; foreach (string nom in noms) { Console.WriteLine(nom); } ‚úÖ Bonne pratique - Pr√©f√©rer foreach quand appropri√©\niint[] nombres = { 1, 2, 3, 4, 5 }; // ‚úÖ BIEN - Plus lisible, id√©al pour le calcul ou l'affichage int somme = 0; foreach (int n in nombres) { somme += n; } Console.WriteLine($\"Somme : {somme}\"); // ‚ùå √Ä √âVITER - Sauf si vous avez besoin de l'index 'i' (ex: modification) int sommeAlternative = 0; for (int i = 0; i \u003c nombres.Length; i++) { sommeAlternative += nombres[i]; } Exemples pratiques avec foreach\n// Affichage de prix format√©s (Symbole $ au lieu de :C) double[] prixUnitaires = { 19.99, 29.99, 39.99, 49.99 }; foreach (double p in prixUnitaires) { Console.WriteLine($\"Prix : {p} $\"); } // Comptage avec condition (Filtrage simple) int[] scores = { 45, 78, 92, 65, 88, 54, 91 }; int reussites = 0; foreach (int s in scores) { if (s \u003e= 60) { reussites++; } } Console.WriteLine($\"{reussites} √©tudiants ont r√©ussi.\"); // Recherche du maximum int[] valeurs = { 23, 67, 12, 89, 45, 34 }; int maximum = valeurs[0]; foreach (int v in valeurs) { if (v \u003e maximum) { maximum = v; } } Console.WriteLine($\"Valeur maximale : {maximum}\"); ‚ö†Ô∏è Important - Foreach est read-only\nIl est impossible de modifier directement l‚Äô√©l√©ment de la collection √† l‚Äôint√©rieur d‚Äôun foreach. Le compilateur .NET 8 bloquera le code.\nint[] chiffres = { 1, 2, 3 }; // ‚ùå ERREUR DE COMPILATION - On ne peut pas modifier 'c' /* foreach (int c in chiffres) { c = c * 2; } */ // ‚úÖ SOLUTION - Utiliser 'for' pour modifier le contenu du tableau for (int i = 0; i \u003c chiffres.Length; i++) { chiffres[i] = chiffres[i] * 2; } // V√©rification (Lecture simple via foreach) foreach (int c in chiffres) { Console.WriteLine(c); // Affiche : 2, 4, 6 } Foreach avec tableaux multidimensionnels\nint[,] matrice = { { 1, 2, 3 }, { 4, 5, 6 } }; // Foreach parcourt automatiquement toutes les lignes et colonnes foreach (int valeur in matrice) { Console.Write($\"{valeur} \"); } // R√©sultat : 1 2 3 4 5 6 3. Instructions de Contr√¥le de Flux 3.1 Break Identique √† Java - Sort de la boucle ou du switch.\n// Recherche d'un √©l√©ment dans un tableau int[] nombres = { 5, 12, 8, 3, 19, 7 }; int cible = 19; int position = -1; for (int i = 0; i \u003c nombres.Length; i++) { if (nombres[i] == cible) { position = i; break; // ‚úÖ Succ√®s : On arr√™te de chercher pour √©conomiser des ressources } } if (position != -1) { Console.WriteLine($\"Trouv√© √† la position {position}\"); } else { Console.WriteLine(\"L'√©l√©ment n'a pas √©t√© trouv√©.\"); } Break dans switch\nint operation = 2; int nombre1 = 10; int nombre2 = 5; int resultat = 0; switch (operation) { case 1: resultat = nombre1 + nombre2; break; // Sort du switch apr√®s l'addition case 2: resultat = nombre1 - nombre2; break; // Sort du switch apr√®s la soustraction case 3: resultat = nombre1 * nombre2; break; // Sort du switch apr√®s la multiplication default: Console.WriteLine(\"Op√©ration invalide\"); break; } Console.WriteLine($\"R√©sultat : {resultat}\"); 3.2 Continue Identique √† Java - Passe √† l‚Äôit√©ration suivante.\n// Afficher seulement les nombres impairs for (int i = 0; i \u003c 10; i++) { if (i % 2 == 0) continue; // Saute les nombres pairs Console.WriteLine(i); } // Affiche: 1, 3, 5, 7, 9 Continue pour filtrage simple\nint[] notes = { 45, 78, 0, 92, -1, 65, 88 }; // ‚úÖ BIEN - Utilisation de continue pour filtrer (Style \"Guard Clause\") foreach (int note in notes) { // Si la note est hors limite, on l'ignore imm√©diatement if (note \u003c 0 || note \u003e 100) continue; // Le code principal reste ici, sans √™tre cach√© dans un bloc 'if' Console.WriteLine($\"Note valide : {note}\"); } Exemple - Somme conditionnelle\nint[] nombres = { 5, -3, 12, 0, 8, -7, 15 }; int sommePositifs = 0; foreach (int n in nombres) { // Si le nombre est n√©gatif ou nul, on passe directement au suivant if (n \u003c= 0) continue; // On ne traite que les valeurs qui nous int√©ressent sommePositifs += n; } Console.WriteLine($\"Somme des nombres positifs : {sommePositifs}\"); 4. Gestion des Exceptions 4.1 Try-Catch-Finally Tr√®s similaire √† Java.\ntry { int result = 10 / 0; // G√©n√®re une exception } catch (DivideByZeroException ex) { Console.WriteLine($\"Erreur: {ex.Message}\"); } catch (Exception ex) { Console.WriteLine($\"Erreur g√©n√©rale: {ex.Message}\"); } finally { Console.WriteLine(\"Toujours ex√©cut√©\"); }",
    "description": "1. Structures Conditionnelles 1.1 If-Else Similitudes avec Java : La syntaxe de base est identique.\n// Calcul de rabais selon la quantit√© et le montant int quantite = 15; double montantTotal = 250.50; double rabais = 0.0; if (quantite \u003e= 20 \u0026\u0026 montantTotal \u003e= 500) { rabais = 0.20; // 20% pour commandes importantes } else if (quantite \u003e= 10 || montantTotal \u003e= 200) { rabais = 0.10; // 10% pour commandes moyennes } else { rabais = 0.0; // Pas de rabais } double montantFinal = montantTotal * (1 - rabais); Console.WriteLine($\"Montant final: {montantFinal} $\"); ‚úÖ Bonne pratique - Accolades obligatoires",
    "tags": [],
    "title": "Structures de contr√¥les",
    "uri": "/420-413/structures_de_controles/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "En C#, on distingue deux grandes familles pour stocker des groupes de donn√©es : les Tableaux (taille fixe) et les Collections (taille dynamique).\nLes tableaux (Array) Un tableau est une structure de donn√©es de taille fixe stock√©e de mani√®re contigu√´ en m√©moire.\n1. D√©claration et initialisation Syntaxe de base // D√©claration d'un tableau int[] nombres; // D√©claration avec initialisation de la taille int[] nombres = new int[5]; // D√©claration avec initialisation des valeurs int[] nombres = new int[] { 10, 20, 30, 40, 50 }; // Syntaxe courte (recommand√©e) int[] nombres = { 10, 20, 30, 40, 50 }; Le pi√®ge de l‚Äôimmuabilit√© : Si vous cr√©ez int[] tab = new int[3], vous ne pourrez jamais y mettre un 4e √©l√©ment. Pour ‚Äúagrandir‚Äù un tableau, il faut en cr√©er un nouveau, copier les donn√©es, puis ajouter le nouvel √©l√©ment. C‚Äôest pourquoi nous utilisons les Collections pour les donn√©es dynamiques.\nPoints importants √† retenir Les tableaux ont une taille fixe d√©finie √† la cr√©ation Les collections (comme List\u003cT\u003e) peuvent changer de taille dynamiquement Les propri√©t√©s en C# (comme .Length, .Count) n‚Äôont pas de parenth√®ses C# offre LINQ (Language Integrated Query) pour manipuler les collections facilement Les collections sont dans le namespace System.Collections.Generic 2. Exemples pratiques Exemple 1 : Gestion des notes d‚Äô√©tudiants using System; class GestionNotes { static void Main() { // D√©claration d'un tableau de notes double[] notesEtudiants = { 85.5, 92.0, 78.5, 88.0, 95.5 }; // Afficher toutes les notes Console.WriteLine(\"=== Notes des √©tudiants ===\"); for (int i = 0; i \u003c notesEtudiants.Length; i++) { Console.WriteLine($\"√âtudiant {i + 1}: {notesEtudiants[i]}%\"); } // Calculer la moyenne double somme = 0; foreach (double note in notesEtudiants) { somme += note; } double moyenne = somme / notesEtudiants.Length; Console.WriteLine($\"\\nMoyenne de la classe: {moyenne:F2}%\"); } } Sortie :\n=== Notes des √©tudiants ===\r√âtudiant 1: 85.5%\r√âtudiant 2: 92%\r√âtudiant 3: 78.5%\r√âtudiant 4: 88%\r√âtudiant 5: 95.5%\rMoyenne de la classe: 87.90% Exemple 2 : Tableau de cha√Ænes de caract√®res using System; class GestionPrenoms { static void Main() { // Tableau de pr√©noms string[] prenoms = { \"Alice\", \"Bernard\", \"Catherine\", \"David\", \"√âmilie\" }; // Afficher les pr√©noms avec leur longueur Console.WriteLine(\"=== Liste des pr√©noms ===\"); foreach (string prenom in prenoms) { Console.WriteLine($\"{prenom} - {prenom.Length} lettres\"); } // Trouver le pr√©nom le plus long string prenomPlusLong = prenoms[0]; foreach (string prenom in prenoms) { if (prenom.Length \u003e prenomPlusLong.Length) { prenomPlusLong = prenom; } } Console.WriteLine($\"\\nPr√©nom le plus long: {prenomPlusLong}\"); } } 3. Tableaux multidimensionnels Tableau √† deux dimensions (matrice) using System; class Matrice { static void Main() { // D√©claration d'une matrice 3x3 int[,] matrice = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; // Affichage de la matrice Console.WriteLine(\"=== Matrice 3x3 ===\"); for (int ligne = 0; ligne \u003c 3; ligne++) { for (int colonne = 0; colonne \u003c 3; colonne++) { Console.Write($\"{matrice[ligne, colonne]}\\t\"); } Console.WriteLine(); } // Calculer la somme de chaque ligne Console.WriteLine(\"\\n=== Somme par ligne ===\"); for (int ligne = 0; ligne \u003c 3; ligne++) { int somme = 0; for (int colonne = 0; colonne \u003c 3; colonne++) { somme += matrice[ligne, colonne]; } Console.WriteLine($\"Ligne {ligne + 1}: {somme}\"); } } } Tableau dentel√© (jagged array) using System; class TableauDentele { static void Main() { // Tableau o√π chaque ligne peut avoir une longueur diff√©rente int[][] notesParCours = new int[3][]; notesParCours[0] = new int[] { 85, 90, 78 }; // 3 notes notesParCours[1] = new int[] { 92, 88 }; // 2 notes notesParCours[2] = new int[] { 95, 87, 91, 89 }; // 4 notes // Affichage Console.WriteLine(\"=== Notes par cours ===\"); for (int cours = 0; cours \u003c notesParCours.Length; cours++) { Console.Write($\"Cours {cours + 1}: \"); foreach (int note in notesParCours[cours]) { Console.Write($\"{note} \"); } Console.WriteLine(); } } } 4. M√©thodes utiles pour les tableaux using System; class MethodesTableaux { static void Main() { int[] nombres = { 45, 12, 78, 34, 90, 23, 67 }; // Longueur du tableau Console.WriteLine($\"Nombre d'√©l√©ments: {nombres.Length}\"); // Trier le tableau Array.Sort(nombres); Console.WriteLine(\"\\nTableau tri√©:\"); AfficherTableau(nombres); // Inverser l'ordre Array.Reverse(nombres); Console.WriteLine(\"\\nTableau invers√©:\"); AfficherTableau(nombres); // Rechercher un √©l√©ment int valeurRecherchee = 78; int index = Array.IndexOf(nombres, valeurRecherchee); Console.WriteLine($\"\\nIndex de {valeurRecherchee}: {index}\"); // Copier un tableau int[] copie = new int[nombres.Length]; Array.Copy(nombres, copie, nombres.Length); Console.WriteLine(\"\\nCopie du tableau:\"); AfficherTableau(copie); } static void AfficherTableau(int[] tableau) { foreach (int nombre in tableau) { Console.Write($\"{nombre} \"); } Console.WriteLine(); } } Les Collections Les collections en C# offrent plus de flexibilit√© que les tableaux. Elles peuvent changer de taille dynamiquement et offrent des m√©thodes pratiques pour manipuler les donn√©es.\n1. List - La collection la plus utilis√©e Syntaxe de base using System; using System.Collections.Generic; class ExempleList { static void Main() { // Cr√©ation d'une liste vide List fruits = new List(); // Cr√©ation avec valeurs initiales List nombres = new List { 1, 2, 3, 4, 5 }; // Ajout d'√©l√©ments fruits.Add(\"Pomme\"); fruits.Add(\"Banane\"); fruits.Add(\"Orange\"); // Affichage Console.WriteLine(\"=== Liste de fruits ===\"); foreach (string fruit in fruits) { Console.WriteLine(fruit); } // Nombre d'√©l√©ments Console.WriteLine($\"\\nNombre de fruits: {fruits.Count}\"); } } Exemple 2 : Gestion d‚Äôun inventaire simple using System; using System.Collections.Generic; class GestionInventaire { static void Main() { // Cr√©ation de listes pour stocker les informations List nomsProduits = new List(); List prixProduits = new List(); List quantitesProduits = new List(); // Ajout de produits nomsProduits.Add(\"Ordinateur portable\"); prixProduits.Add(1299.99); quantitesProduits.Add(15); nomsProduits.Add(\"Souris sans fil\"); prixProduits.Add(29.99); quantitesProduits.Add(50); nomsProduits.Add(\"Clavier m√©canique\"); prixProduits.Add(149.99); quantitesProduits.Add(25); // Affichage de l'inventaire Console.WriteLine(\"=== INVENTAIRE ===\"); for (int i = 0; i \u003c nomsProduits.Count; i++) { Console.WriteLine($\"{nomsProduits[i]} - {prixProduits[i]:C} - Qt√©: {quantitesProduits[i]}\"); } // Calculer la valeur totale de l'inventaire double valeurTotale = 0; for (int i = 0; i \u003c nomsProduits.Count; i++) { valeurTotale += prixProduits[i] * quantitesProduits[i]; } Console.WriteLine($\"\\nValeur totale de l'inventaire: {valeurTotale:C}\"); } } M√©thodes importantes de List using System; using System.Collections.Generic; class MethodesList { static void Main() { List etudiants = new List { \"Alice\", \"Bernard\", \"Catherine\", \"David\" }; // Add - Ajouter un √©l√©ment √† la fin etudiants.Add(\"√âmilie\"); // Insert - Ins√©rer √† une position sp√©cifique etudiants.Insert(1, \"Fran√ßois\"); // Remove - Retirer un √©l√©ment sp√©cifique etudiants.Remove(\"Bernard\"); // RemoveAt - Retirer √† un index sp√©cifique etudiants.RemoveAt(0); // Contains - V√©rifier si un √©l√©ment existe bool existe = etudiants.Contains(\"Catherine\"); Console.WriteLine($\"Catherine est dans la liste: {existe}\"); // IndexOf - Trouver l'index d'un √©l√©ment int index = etudiants.IndexOf(\"David\"); Console.WriteLine($\"Index de David: {index}\"); // Clear - Vider la liste // etudiants.Clear(); // Sort - Trier la liste etudiants.Sort(); // Reverse - Inverser l'ordre etudiants.Reverse(); // Count - Nombre d'√©l√©ments Console.WriteLine($\"Nombre d'√©tudiants: {etudiants.Count}\"); // Affichage final Console.WriteLine(\"\\n=== Liste finale ===\"); foreach (string etudiant in etudiants) { Console.WriteLine(etudiant); } } } 2. Dictionary\u003cTKey, TValue\u003e - Paires cl√©-valeur using System; using System.Collections.Generic; class ExempleDictionnaire { static void Main() { // Cr√©ation d'un dictionnaire pour stocker des codes postaux Dictionary codesPostaux = new Dictionary(); // Ajout d'√©l√©ments codesPostaux.Add(\"Montr√©al\", \"H1A\"); codesPostaux.Add(\"Qu√©bec\", \"G1A\"); codesPostaux.Add(\"Laval\", \"H7A\"); codesPostaux.Add(\"Gatineau\", \"J8T\"); // Acc√®s √† une valeur Console.WriteLine($\"Code postal de Montr√©al: {codesPostaux[\"Montr√©al\"]}\"); // V√©rifier si une cl√© existe if (codesPostaux.ContainsKey(\"Qu√©bec\")) { Console.WriteLine($\"Code postal de Qu√©bec: {codesPostaux[\"Qu√©bec\"]}\"); } // Parcourir le dictionnaire Console.WriteLine(\"\\n=== Tous les codes postaux ===\"); foreach (KeyValuePair paire in codesPostaux) { Console.WriteLine($\"{paire.Key}: {paire.Value}\"); } // Modifier une valeur codesPostaux[\"Montr√©al\"] = \"H2X\"; // Retirer un √©l√©ment codesPostaux.Remove(\"Gatineau\"); Console.WriteLine($\"\\nNombre de villes: {codesPostaux.Count}\"); } } Exemple pratique : Syst√®me de notes using System; using System.Collections.Generic; class SystemeNotes { static void Main() { // Dictionnaire: nom de l'√©tudiant -\u003e liste de notes Dictionary\u003e notesEtudiants = new Dictionary\u003e(); // Ajout des √©tudiants et leurs notes notesEtudiants.Add(\"Alice\", new List { 85.5, 92.0, 88.5 }); notesEtudiants.Add(\"Bernard\", new List { 78.0, 82.5, 80.0 }); notesEtudiants.Add(\"Catherine\", new List { 95.0, 93.5, 97.0 }); // Afficher les notes et moyennes Console.WriteLine(\"=== NOTES ET MOYENNES ===\\n\"); foreach (KeyValuePair\u003e etudiant in notesEtudiants) { string nom = etudiant.Key; List notes = etudiant.Value; Console.WriteLine($\"√âtudiant: {nom}\"); Console.Write(\"Notes: \"); foreach (double note in notes) { Console.Write($\"{note}% \"); } // Calculer la moyenne double somme = 0; foreach (double note in notes) { somme += note; } double moyenne = somme / notes.Count; Console.WriteLine($\"\\nMoyenne: {moyenne:F2}%\\n\"); } } } 3. Queue - File d‚Äôattente (FIFO) using System; using System.Collections.Generic; class ExempleQueue { static void Main() { // Cr√©ation d'une file d'attente Queue fileAttente = new Queue(); // Enqueue - Ajouter √† la fin de la file fileAttente.Enqueue(\"Client 1\"); fileAttente.Enqueue(\"Client 2\"); fileAttente.Enqueue(\"Client 3\"); fileAttente.Enqueue(\"Client 4\"); Console.WriteLine($\"Nombre de clients: {fileAttente.Count}\"); // Peek - Voir le premier √©l√©ment sans le retirer string premier = fileAttente.Peek(); Console.WriteLine($\"Prochain client √† servir: {premier}\"); // Dequeue - Retirer et retourner le premier √©l√©ment Console.WriteLine(\"\\n=== Service des clients ===\"); while (fileAttente.Count \u003e 0) { string client = fileAttente.Dequeue(); Console.WriteLine($\"Servir: {client}\"); } Console.WriteLine($\"\\nClients restants: {fileAttente.Count}\"); } } 4. Stack - Pile (LIFO) using System; using System.Collections.Generic; class ExempleStack { static void Main() { // Cr√©ation d'une pile Stack historiqueNavigation = new Stack(); // Push - Ajouter au sommet de la pile historiqueNavigation.Push(\"Page d'accueil\"); historiqueNavigation.Push(\"Page de recherche\"); historiqueNavigation.Push(\"Page de r√©sultats\"); historiqueNavigation.Push(\"Page de d√©tails\"); Console.WriteLine($\"Nombre de pages visit√©es: {historiqueNavigation.Count}\"); // Peek - Voir le sommet sans retirer string pageActuelle = historiqueNavigation.Peek(); Console.WriteLine($\"Page actuelle: {pageActuelle}\"); // Pop - Retirer et retourner l'√©l√©ment du sommet Console.WriteLine(\"\\n=== Navigation arri√®re ===\"); while (historiqueNavigation.Count \u003e 0) { string page = historiqueNavigation.Pop(); Console.WriteLine($\"Retour √†: {page}\"); } } } 5. HashSet - Ensemble (pas de doublons) using System; using System.Collections.Generic; class ExempleHashSet { static void Main() { // Cr√©ation d'un ensemble HashSet tagsUniques = new HashSet(); // Add - Ajouter un √©l√©ment (ignore les doublons) tagsUniques.Add(\"programmation\"); tagsUniques.Add(\"csharp\"); tagsUniques.Add(\"collections\"); tagsUniques.Add(\"csharp\"); // Sera ignor√© (doublon) tagsUniques.Add(\"dotnet\"); Console.WriteLine($\"Nombre de tags uniques: {tagsUniques.Count}\"); // Affichage Console.WriteLine(\"\\n=== Tags ===\"); foreach (string tag in tagsUniques) { Console.WriteLine($\"- {tag}\"); } // Contains - V√©rifier l'existence bool existe = tagsUniques.Contains(\"csharp\"); Console.WriteLine($\"\\nLe tag 'csharp' existe: {existe}\"); // Op√©rations sur les ensembles HashSet autresTags = new HashSet { \"csharp\", \"java\", \"python\" }; // Union tagsUniques.UnionWith(autresTags); Console.WriteLine($\"\\nApr√®s union: {tagsUniques.Count} tags\"); // Intersection HashSet langages = new HashSet { \"csharp\", \"java\", \"python\" }; HashSet appris = new HashSet { \"csharp\", \"javascript\" }; langages.IntersectWith(appris); Console.WriteLine(\"\\n=== Langages en commun ===\"); foreach (string langage in langages) { Console.WriteLine(langage); } } }",
    "description": "En C#, on distingue deux grandes familles pour stocker des groupes de donn√©es : les Tableaux (taille fixe) et les Collections (taille dynamique).\nLes tableaux (Array) Un tableau est une structure de donn√©es de taille fixe stock√©e de mani√®re contigu√´ en m√©moire.\n1. D√©claration et initialisation Syntaxe de base // D√©claration d'un tableau int[] nombres; // D√©claration avec initialisation de la taille int[] nombres = new int[5]; // D√©claration avec initialisation des valeurs int[] nombres = new int[] { 10, 20, 30, 40, 50 }; // Syntaxe courte (recommand√©e) int[] nombres = { 10, 20, 30, 40, 50 }; Le pi√®ge de l‚Äôimmuabilit√© : Si vous cr√©ez int[] tab = new int[3], vous ne pourrez jamais y mettre un 4e √©l√©ment. Pour ‚Äúagrandir‚Äù un tableau, il faut en cr√©er un nouveau, copier les donn√©es, puis ajouter le nouvel √©l√©ment. C‚Äôest pourquoi nous utilisons les Collections pour les donn√©es dynamiques.",
    "tags": [],
    "title": "Tableaux et collections",
    "uri": "/420-413/tableaux_collections/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Table des mati√®res Introduction Syntaxe de base Param√®tres de m√©thodes Param√®tres par r√©f√©rence (ref) Param√®tres de sortie (out) Param√®tres optionnels Surcharge de m√©thodes Port√©e des variables Exercices Introduction Les m√©thodes (aussi appel√©es fonctions) sont des blocs de code r√©utilisables qui effectuent une t√¢che sp√©cifique. Elles permettent de :\nOrganiser le code de mani√®re logique √âviter la r√©p√©tition de code Faciliter la maintenance et la lecture du programme Diviser un probl√®me complexe en sous-probl√®mes plus simples Avantages des m√©thodes R√©utilisabilit√© : √âcrire une fois, utiliser plusieurs fois Lisibilit√© : Code plus clair et organis√© Maintenance : Plus facile de corriger ou modifier le code Tests : Plus facile de tester des petites unit√©s de code Syntaxe de base Structure d‚Äôune m√©thode modificateurAcces [static] typeRetour NomMethode(typeParam1 param1, typeParam2 param2) { // Corps de la m√©thode // Instructions √† ex√©cuter return valeur; // Si la m√©thode retourne une valeur } Composantes :\nmodificateurAcces : Contr√¥le la visibilit√© de la m√©thode (public, private, protected, internal) static : Indique que la m√©thode appartient √† la classe, pas √† une instance (obligatoire pour l‚Äôinstant) typeRetour : Le type de donn√©es que la m√©thode retourne (int, string, double, void, etc.) NomMethode : Le nom de la m√©thode (convention : commence par une majuscule en C#) Param√®tres : Les donn√©es d‚Äôentr√©e (optionnels) Corps : Le code qui s‚Äôex√©cute quand la m√©thode est appel√©e return : Retourne une valeur (sauf si void) Les modificateurs d‚Äôacc√®s Modificateur Description Utilisation public Accessible partout Pour les m√©thodes utilis√©es par d‚Äôautres classes private Accessible seulement dans la classe actuelle Pour les m√©thodes internes (par d√©faut) protected Accessible dans la classe et ses classes d√©riv√©es Pour l‚Äôh√©ritage (POO) internal Accessible dans le m√™me assembly Pour les m√©thodes partag√©es dans un projet Note : Pour l‚Äôinstant, nous utilisons principalement static avec nos m√©thodes car nous ne travaillons pas encore avec la programmation orient√©e objet. Les m√©thodes static peuvent √™tre appel√©es directement sans cr√©er d‚Äôobjet.\nExemples de d√©clarations de m√©thodes // M√©thode publique statique qui retourne un entier public static int CalculerSomme(int a, int b) { return a + b; } // M√©thode priv√©e statique qui ne retourne rien (void) private static void AfficherMessage() { Console.WriteLine(\"Message priv√©\"); } // M√©thode publique statique avec plusieurs param√®tres public static double CalculerMoyenne(double note1, double note2, double note3) { return (note1 + note2 + note3) / 3; } // M√©thode publique statique sans param√®tres public static void AfficherBienvenue() { Console.WriteLine(\"Bienvenue!\"); } Exemple simple : M√©thode sans param√®tres using System; class Programme { public static void AfficherMessage() { Console.WriteLine(\"Bonjour du C√âGEP!\"); Console.WriteLine(\"Bienvenue dans le cours de C#\"); } static void Main() { AfficherMessage(); // Appel de la m√©thode AfficherMessage(); // On peut l'appeler plusieurs fois } } Sortie :\nBonjour du C√âGEP!\rBienvenue dans le cours de C#\rBonjour du C√âGEP!\rBienvenue dans le cours de C# Exemple : M√©thode avec retour using System; class Programme { public static int ObtenirAnneeActuelle() { return 2024; } static void Main() { int annee = ObtenirAnneeActuelle(); Console.WriteLine($\"Nous sommes en {annee}\"); } } Param√®tres de m√©thodes Les param√®tres permettent de passer des donn√©es √† une m√©thode.\nPassage par valeur (comportement par d√©faut) Quand vous passez une variable √† une m√©thode, C# cr√©e une copie de la valeur. Les modifications dans la m√©thode n‚Äôaffectent pas la variable originale.\nusing System; class Programme { public static void AugmenterNombre(int nombre) { nombre = nombre + 10; Console.WriteLine($\"Dans la m√©thode: {nombre}\"); } static void Main() { int valeur = 5; Console.WriteLine($\"Avant l'appel: {valeur}\"); AugmenterNombre(valeur); Console.WriteLine($\"Apr√®s l'appel: {valeur}\"); } } Sortie :\nAvant l'appel: 5\rDans la m√©thode: 15\rApr√®s l'appel: 5 Explication : La variable valeur n‚Äôa pas chang√© car la m√©thode a travaill√© avec une copie.\nExemple : Calculer l‚Äôaire d‚Äôun rectangle using System; class Programme { public static double CalculerAireRectangle(double longueur, double largeur) { double aire = longueur * largeur; return aire; } static void Main() { double resultat = CalculerAireRectangle(5.5, 3.2); Console.WriteLine($\"L'aire du rectangle est: {resultat:F2} m¬≤\"); // Appel avec d'autres valeurs resultat = CalculerAireRectangle(10.0, 7.5); Console.WriteLine($\"L'aire du rectangle est: {resultat:F2} m¬≤\"); } } Exemple : M√©thode avec plusieurs param√®tres using System; class Programme { public static void AfficherInfoEtudiant(string nom, string prenom, int age, double moyenne) { Console.WriteLine(\"=== FICHE √âTUDIANT ===\"); Console.WriteLine($\"Nom: {nom}\"); Console.WriteLine($\"Pr√©nom: {prenom}\"); Console.WriteLine($\"√Çge: {age} ans\"); Console.WriteLine($\"Moyenne: {moyenne:F1}%\"); Console.WriteLine(\"=====================\"); } static void Main() { AfficherInfoEtudiant(\"Tremblay\", \"Alice\", 19, 87.5); AfficherInfoEtudiant(\"Lavoie\", \"Bernard\", 20, 82.3); } } Param√®tres par r√©f√©rence (ref) Le mot-cl√© ref permet de passer une variable par r√©f√©rence plut√¥t que par valeur. Cela signifie que la m√©thode travaille directement avec la variable originale, pas avec une copie.\nCaract√©ristiques de ref La variable DOIT √™tre initialis√©e avant l‚Äôappel Les modifications dans la m√©thode affectent la variable originale Le mot-cl√© ref doit appara√Ætre √† la d√©finition ET √† l‚Äôappel de la m√©thode Syntaxe public static void NomMethode(ref int parametre) { parametre = parametre * 2; } // Appel int nombre = 10; NomMethode(ref nombre); // Utiliser 'ref' lors de l'appel Exemple : √âchanger deux valeurs using System; class Programme { public static void EchangerValeurs(ref int a, ref int b) { int temporaire = a; a = b; b = temporaire; Console.WriteLine($\"Dans la m√©thode - a: {a}, b: {b}\"); } static void Main() { int x = 10; int y = 20; Console.WriteLine($\"Avant l'√©change - x: {x}, y: {y}\"); EchangerValeurs(ref x, ref y); Console.WriteLine($\"Apr√®s l'√©change - x: {x}, y: {y}\"); } } Sortie :\nAvant l'√©change - x: 10, y: 20\rDans la m√©thode - a: 20, b: 10\rApr√®s l'√©change - x: 20, y: 10 Exemple : Doubler une valeur using System; class Programme { public static void DoublerValeur(ref int nombre) { nombre = nombre * 2; } static void Main() { int valeur = 15; Console.WriteLine($\"Valeur initiale: {valeur}\"); DoublerValeur(ref valeur); Console.WriteLine($\"Valeur apr√®s doublement: {valeur}\"); } } Sortie :\nValeur initiale: 15\rValeur apr√®s doublement: 30 Exemple : Modifier plusieurs valeurs using System; class Programme { public static void AppliquerTaxes(ref double prix, double tauxTPS, double tauxTVQ) { double tps = prix * tauxTPS; double tvq = prix * tauxTVQ; prix = prix + tps + tvq; } static void Main() { double prixProduit = 100.00; Console.WriteLine($\"Prix avant taxes: {prixProduit:C}\"); AppliquerTaxes(ref prixProduit, 0.05, 0.09975); Console.WriteLine($\"Prix apr√®s taxes: {prixProduit:C}\"); } } Param√®tres de sortie (out) Le mot-cl√© out est similaire √† ref, mais avec des diff√©rences importantes :\nDiff√©rences entre ref et out Caract√©ristique ref out Initialisation avant appel REQUISE Pas n√©cessaire Assignation dans la m√©thode Optionnelle OBLIGATOIRE Utilisation principale Modifier une valeur existante Retourner plusieurs valeurs Caract√©ristiques de out La variable N‚ÄôA PAS BESOIN d‚Äô√™tre initialis√©e avant l‚Äôappel La m√©thode DOIT assigner une valeur au param√®tre out Utilis√© principalement pour retourner plusieurs valeurs d‚Äôune m√©thode Le mot-cl√© out doit appara√Ætre √† la d√©finition ET √† l‚Äôappel Syntaxe public static void CalculerStatistiques(int[] nombres, out double moyenne, out int maximum) { // La m√©thode DOIT assigner des valeurs √† moyenne et maximum moyenne = ...; maximum = ...; } // Appel double moy; int max; CalculerStatistiques(tableau, out moy, out max); Exemple : Retourner plusieurs valeurs using System; class Programme { public static void CalculerRectangle(double longueur, double largeur, out double aire, out double perimetre) { aire = longueur * largeur; perimetre = 2 * (longueur + largeur); } static void Main() { double surfaceResultat; double perimetreResultat; CalculerRectangle(5.0, 3.0, out surfaceResultat, out perimetreResultat); Console.WriteLine($\"Aire: {surfaceResultat} m¬≤\"); Console.WriteLine($\"P√©rim√®tre: {perimetreResultat} m\"); } } Sortie :\nAire: 15 m¬≤\rP√©rim√®tre: 16 m D√©claration inline (C# 7.0+) Depuis C# 7.0, vous pouvez d√©clarer les variables out directement dans l‚Äôappel :\nusing System; class Programme { public static void DiviserAvecReste(int dividende, int diviseur, out int quotient, out int reste) { quotient = dividende / diviseur; reste = dividende % diviseur; } static void Main() { // D√©claration inline - plus concis! DiviserAvecReste(17, 5, out int q, out int r); Console.WriteLine($\"17 √∑ 5 = {q} reste {r}\"); } } Exemple : Statistiques d‚Äôun tableau using System; class Programme { public static void CalculerStatistiques(int[] nombres, out double moyenne, out int minimum, out int maximum) { // Calcul de la somme et moyenne int somme = 0; foreach (int nombre in nombres) { somme += nombre; } moyenne = (double)somme / nombres.Length; // Trouver min et max minimum = nombres[0]; maximum = nombres[0]; foreach (int nombre in nombres) { if (nombre \u003c minimum) minimum = nombre; if (nombre \u003e maximum) maximum = nombre; } } static void Main() { int[] notes = { 85, 92, 78, 95, 88, 76, 90 }; CalculerStatistiques(notes, out double moy, out int min, out int max); Console.WriteLine(\"=== STATISTIQUES DES NOTES ===\"); Console.WriteLine($\"Moyenne: {moy:F2}%\"); Console.WriteLine($\"Note minimale: {min}%\"); Console.WriteLine($\"Note maximale: {max}%\"); } } Exemple : Validation d‚Äôentr√©e avec TryParse La m√©thode TryParse utilise out pour retourner le r√©sultat de la conversion :\nusing System; class Programme { static void Main() { Console.Write(\"Entrez votre √¢ge: \"); string entree = Console.ReadLine(); // TryParse retourne true si la conversion r√©ussit // et met le r√©sultat dans la variable 'age' if (int.TryParse(entree, out int age)) { Console.WriteLine($\"Votre √¢ge est: {age} ans\"); if (age \u003e= 18) Console.WriteLine(\"Vous √™tes majeur\"); else Console.WriteLine(\"Vous √™tes mineur\"); } else { Console.WriteLine(\"Entr√©e invalide!\"); } } } Exemple : Analyse de cha√Æne using System; class Programme { public static bool ExtraireNomPrenom(string nomComplet, out string nom, out string prenom) { string[] parties = nomComplet.Split(' '); if (parties.Length \u003e= 2) { prenom = parties[0]; nom = parties[1]; return true; } else { nom = \"\"; prenom = \"\"; return false; } } static void Main() { string nomComplet = \"Alice Tremblay\"; if (ExtraireNomPrenom(nomComplet, out string n, out string p)) { Console.WriteLine($\"Pr√©nom: {p}\"); Console.WriteLine($\"Nom: {n}\"); } else { Console.WriteLine(\"Format invalide\"); } } } Param√®tres optionnels Les param√®tres optionnels ont des valeurs par d√©faut et peuvent √™tre omis lors de l‚Äôappel.\nR√®gles Les param√®tres optionnels doivent √™tre √† la fin de la liste de param√®tres Vous devez fournir une valeur par d√©faut Si omis lors de l‚Äôappel, la valeur par d√©faut est utilis√©e Syntaxe public static void NomMethode(int obligatoire, int optionnel = 10) { // Corps de la m√©thode } // Appels possibles NomMethode(5); // optionnel = 10 (valeur par d√©faut) NomMethode(5, 20); // optionnel = 20 Exemple : Afficher un message personnalis√© using System; class Programme { public static void AfficherBienvenue(string nom, string titre = \"√âtudiant\") { Console.WriteLine($\"Bonjour {titre} {nom}!\"); } static void Main() { AfficherBienvenue(\"Alice\"); // Utilise \"√âtudiant\" par d√©faut AfficherBienvenue(\"Bernard\", \"Professeur\"); // Utilise \"Professeur\" AfficherBienvenue(\"Catherine\", \"Directrice\"); } } Sortie :\nBonjour √âtudiant Alice!\rBonjour Professeur Bernard!\rBonjour Directrice Catherine! Exemple : Calcul avec taux par d√©faut using System; class Programme { public static double CalculerPrixTotal(double prixBase, double tauxTaxe = 0.15) { return prixBase * (1 + tauxTaxe); } static void Main() { // Utilise le taux par d√©faut (15%) double total1 = CalculerPrixTotal(100.00); Console.WriteLine($\"Prix avec taxe par d√©faut: {total1:C}\"); // Sp√©cifie un taux diff√©rent double total2 = CalculerPrixTotal(100.00, 0.20); Console.WriteLine($\"Prix avec 20% de taxe: {total2:C}\"); } } Exemple : Affichage format√© using System; class Programme { public static void AfficherLigne(string texte, char caractere = '-', int longueur = 40) { Console.WriteLine(texte); Console.WriteLine(new string(caractere, longueur)); } static void Main() { AfficherLigne(\"Titre 1\"); // - et 40 par d√©faut AfficherLigne(\"Titre 2\", '='); // = et 40 AfficherLigne(\"Titre 3\", '*', 30); // * et 30 } } Sortie :\nTitre 1\r----------------------------------------\rTitre 2\r========================================\rTitre 3\r****************************** Surcharge de m√©thodes La surcharge (overloading) permet d‚Äôavoir plusieurs m√©thodes avec le m√™me nom mais des signatures diff√©rentes.\nQu‚Äôest-ce qu‚Äôune signature? La signature d‚Äôune m√©thode inclut :\nLe nom de la m√©thode Le nombre de param√®tres Le type des param√®tres L‚Äôordre des param√®tres Note : Le type de retour ne fait PAS partie de la signature.\nExemple : Calculer l‚Äôaire de diff√©rentes formes using System; class Programme { // Aire d'un carr√© public static double CalculerAire(double cote) { return cote * cote; } // Aire d'un rectangle public static double CalculerAire(double longueur, double largeur) { return longueur * largeur; } // Aire d'un cercle public static double CalculerAire(double rayon, bool estCercle) { return Math.PI * rayon * rayon; } static void Main() { double aireCarre = CalculerAire(5.0); Console.WriteLine($\"Aire du carr√©: {aireCarre:F2} m¬≤\"); double aireRectangle = CalculerAire(5.0, 3.0); Console.WriteLine($\"Aire du rectangle: {aireRectangle:F2} m¬≤\"); double aireCercle = CalculerAire(4.0, true); Console.WriteLine($\"Aire du cercle: {aireCercle:F2} m¬≤\"); } } Exemple : Afficher diff√©rents types using System; class Programme { public static void Afficher(int nombre) { Console.WriteLine($\"Nombre entier: {nombre}\"); } public static void Afficher(double nombre) { Console.WriteLine($\"Nombre d√©cimal: {nombre:F2}\"); } public static void Afficher(string texte) { Console.WriteLine($\"Texte: {texte}\"); } public static void Afficher(int[] tableau) { Console.Write(\"Tableau: \"); foreach (int n in tableau) { Console.Write($\"{n} \"); } Console.WriteLine(); } static void Main() { Afficher(42); Afficher(3.14159); Afficher(\"Bonjour!\"); Afficher(new int[] { 1, 2, 3, 4, 5 }); } } Exemple : Cr√©er un message de bienvenue using System; class Programme { // Version simple public static string CreerBienvenue(string nom) { return $\"Bienvenue {nom}!\"; } // Version avec pr√©nom et nom public static string CreerBienvenue(string prenom, string nom) { return $\"Bienvenue {prenom} {nom}!\"; } // Version avec titre public static string CreerBienvenue(string prenom, string nom, string titre) { return $\"Bienvenue {titre} {prenom} {nom}!\"; } static void Main() { Console.WriteLine(CreerBienvenue(\"Alice\")); Console.WriteLine(CreerBienvenue(\"Alice\", \"Tremblay\")); Console.WriteLine(CreerBienvenue(\"Alice\", \"Tremblay\", \"Dr.\")); } } Port√©e des variables La port√©e (scope) d‚Äôune variable d√©termine o√π elle peut √™tre utilis√©e dans le code.\nVariables locales Les variables d√©clar√©es √† l‚Äôint√©rieur d‚Äôune m√©thode sont locales √† cette m√©thode.\nusing System; class Programme { public static void Methode1() { int x = 10; // Variable locale √† Methode1 Console.WriteLine($\"Dans Methode1: x = {x}\"); } public static void Methode2() { int x = 20; // Variable diff√©rente, locale √† Methode2 Console.WriteLine($\"Dans Methode2: x = {x}\"); } static void Main() { Methode1(); Methode2(); // Console.WriteLine(x); // ERREUR: x n'existe pas ici } } Port√©e de bloc Les variables d√©clar√©es dans un bloc { } ne sont visibles que dans ce bloc.\nusing System; class Programme { static void Main() { int nombre = 10; if (nombre \u003e 5) { int resultat = nombre * 2; // Variable locale au bloc if Console.WriteLine($\"R√©sultat: {resultat}\"); } // Console.WriteLine(resultat); // ERREUR: resultat n'existe plus for (int i = 0; i \u003c 3; i++) // i existe seulement dans le for { Console.WriteLine($\"i = {i}\"); } // Console.WriteLine(i); // ERREUR: i n'existe plus } } Exemple : Port√©e et m√©thodes using System; class Programme { public static int CalculerCarre(int nombre) { int resultat = nombre * nombre; // Variable locale return resultat; } static void Main() { int valeur = 5; int carre = CalculerCarre(valeur); Console.WriteLine($\"Le carr√© de {valeur} est {carre}\"); // Console.WriteLine(resultat); // ERREUR: resultat est local √† CalculerCarre } } Bonnes pratiques 1. Nommage des m√©thodes Utilisez des verbes qui d√©crivent l‚Äôaction Commencez par une majuscule (convention C#) Soyez descriptif // Bon public static void CalculerMoyenne() public static bool VerifierAge() public static string ObtenirNomComplet() // √Ä √©viter public static void calc() public static bool check() public static string get() 2. Une m√©thode = une t√¢che Chaque m√©thode devrait faire une seule chose et la faire bien.\n// Bon - une m√©thode par t√¢che public static double CalculerMoyenne(int[] notes) { // Calcule seulement la moyenne } public static void AfficherResultats(double moyenne) { // Affiche seulement les r√©sultats } // Moins bon - fait trop de choses public static void CalculerEtAfficher(int[] notes) { // Calcule ET affiche } 3. Limiter le nombre de param√®tres Si une m√©thode a trop de param√®tres (plus de 4-5), consid√©rez regrouper les donn√©es.\n// Peut devenir difficile √† g√©rer public static void CreerEtudiant(string nom, string prenom, int age, string adresse, string telephone, string courriel) { // Beaucoup de param√®tres! } 4. Utiliser des noms de param√®tres significatifs // Bon public static double CalculerPrixTotal(double prixBase, double tauxTaxe) { return prixBase * (1 + tauxTaxe); } // Moins clair public static double Calculer(double p, double t) { return p * (1 + t); } R√©capitulatif : ref vs out Utilisez ref quand : Vous voulez modifier une valeur existante La variable doit √™tre initialis√©e avant l‚Äôappel Vous voulez que les changements affectent la variable originale Utilisez out quand : Vous voulez retourner plusieurs valeurs d‚Äôune m√©thode La variable n‚Äôa pas besoin d‚Äô√™tre initialis√©e avant l‚Äôappel La m√©thode va cr√©er/calculer une nouvelle valeur Tableau comparatif Aspect Passage par valeur ref out Initialisation requise Non Oui Non Modifie l‚Äôoriginal Non Oui Oui Doit assigner dans m√©thode Non Non Oui Usage principal Donner des donn√©es Modifier des donn√©es Retourner plusieurs valeurs Exercices Exercice 1 : M√©thode simple Difficult√© : Facile\nCr√©ez une m√©thode AfficherTableMultiplication qui prend un nombre en param√®tre et affiche sa table de multiplication de 1 √† 10.\nExemple de sortie pour le nombre 5 :\n5 x 1 = 5\r5 x 2 = 10\r5 x 3 = 15\r...\r5 x 10 = 50 Exercice 2 : M√©thode avec retour Difficult√© : Facile\nCr√©ez une m√©thode EstPair qui prend un nombre entier en param√®tre et retourne true s‚Äôil est pair, false sinon.\nIndice : Un nombre est pair si nombre % 2 == 0\nExercice 3 : M√©thode avec plusieurs param√®tres Difficult√© : Facile\nCr√©ez une m√©thode CalculerMoyenne qui prend trois notes (double) en param√®tres et retourne leur moyenne.\nExercice 4 : Utilisation de ref Difficult√© : Moyenne\nCr√©ez une m√©thode AugmenterDe10Pourcent qui prend un prix en param√®tre (ref double) et l‚Äôaugmente de 10%.\nTestez avec un prix initial de 100.00$ et v√©rifiez que la variable originale est bien modifi√©e.\nExercice 5 : Utilisation de out - Division Difficult√© : Moyenne\nCr√©ez une m√©thode DiviserEntiers qui prend deux entiers (dividende et diviseur) et retourne le quotient ET le reste en utilisant des param√®tres out.\nExemple : 17 divis√© par 5 donne quotient = 3 et reste = 2\nIndice : Utilisez les op√©rateurs / pour le quotient et % pour le reste.\nExercice 6 : Utilisation de out - Statistiques Difficult√© : Moyenne\nCr√©ez une m√©thode AnalyserTableau qui prend un tableau d‚Äôentiers et retourne (via out) :\nLa somme de tous les √©l√©ments La moyenne Le nombre d‚Äô√©l√©ments Testez avec le tableau : {10, 20, 30, 40, 50}\nExercice 7 : Param√®tres optionnels Difficult√© : Moyenne\nCr√©ez une m√©thode AfficherFacture qui prend :\nLe montant (obligatoire) Le taux de TPS (optionnel, d√©faut = 0.05) Le taux de TVQ (optionnel, d√©faut = 0.09975) La m√©thode calcule et affiche le montant avant taxes, les taxes, et le total.\nExercice 8 : Surcharge de m√©thodes Difficult√© : Moyenne\nCr√©ez trois versions surcharg√©es d‚Äôune m√©thode CalculerVolume :\nVolume d‚Äôun cube : CalculerVolume(double cote) Volume d‚Äôun parall√©l√©pip√®de : CalculerVolume(double longueur, double largeur, double hauteur) Volume d‚Äôun cylindre : CalculerVolume(double rayon, double hauteur, bool estCylindre) Formules :\nCube : c√¥t√©¬≥ Parall√©l√©pip√®de : longueur √ó largeur √ó hauteur Cylindre : œÄ √ó rayon¬≤ √ó hauteur Exercice 9 : Validation avec TryParse Difficult√© : Moyenne\nCr√©ez un programme qui demande √† l‚Äôutilisateur d‚Äôentrer un nombre. Utilisez int.TryParse avec un param√®tre out pour valider l‚Äôentr√©e. Si l‚Äôentr√©e est valide, affichez le carr√© du nombre. Sinon, affichez un message d‚Äôerreur.\nExercice 10 : Calculatrice simple Difficult√© : Difficile\nCr√©ez les m√©thodes suivantes pour une calculatrice :\nAdditionner(double a, double b) - retourne a + b Soustraire(double a, double b) - retourne a - b Multiplier(double a, double b) - retourne a √ó b Diviser(double a, double b, out bool succes) - retourne a √∑ b et indique si la division a r√©ussi (pas de division par z√©ro) Cr√©ez un menu qui permet √† l‚Äôutilisateur de choisir une op√©ration et d‚Äôentrer deux nombres.\nExercice 11 : Analyse de texte Difficult√© : Difficile\nCr√©ez une m√©thode AnalyserTexte qui prend une cha√Æne de caract√®res et retourne (via out) :\nLe nombre de caract√®res Le nombre de mots Le nombre de voyelles Indice : Utilisez .Split(' ') pour s√©parer les mots, et une boucle pour compter les voyelles (a, e, i, o, u).\nExercice 12 : Conversion de temp√©rature Difficult√© : Difficile\nCr√©ez les m√©thodes suivantes avec surcharge :\nConvertirTemperature(double celsius) - convertit Celsius ‚Üí Fahrenheit ConvertirTemperature(double fahrenheit, bool versCelsius) - convertit Fahrenheit ‚Üí Celsius Puis cr√©ez une m√©thode ConvertirAvecValidation qui utilise un param√®tre out bool pour indiquer si la temp√©rature est physiquement possible (au-dessus du z√©ro absolu : -273.15¬∞C ou -459.67¬∞F).\nFormules :\nC ‚Üí F : (C √ó 9/5) + 32 F ‚Üí C : (F - 32) √ó 5/9 Conclusion Les m√©thodes sont un outil fondamental en programmation. Vous avez appris :\n‚úÖ Syntaxe de base : Comment cr√©er et appeler des m√©thodes\n‚úÖ Param√®tres : Passage par valeur vs passage par r√©f√©rence\n‚úÖ ref : Modifier des variables existantes\n‚úÖ out : Retourner plusieurs valeurs\n‚úÖ Param√®tres optionnels : Valeurs par d√©faut\n‚úÖ Surcharge : Plusieurs m√©thodes avec le m√™me nom\n‚úÖ Port√©e : O√π les variables sont accessibles\nConcepts cl√©s √† retenir Une m√©thode = une t√¢che : Gardez vos m√©thodes simples et cibl√©es Nommage clair : Le nom doit d√©crire ce que fait la m√©thode ref pour modifier, out pour retourner : Choisissez selon votre besoin R√©utilisabilit√© : √âcrivez une fois, utilisez plusieurs fois",
    "description": "Table des mati√®res Introduction Syntaxe de base Param√®tres de m√©thodes Param√®tres par r√©f√©rence (ref) Param√®tres de sortie (out) Param√®tres optionnels Surcharge de m√©thodes Port√©e des variables Exercices Introduction Les m√©thodes (aussi appel√©es fonctions) sont des blocs de code r√©utilisables qui effectuent une t√¢che sp√©cifique. Elles permettent de :",
    "tags": [],
    "title": "Les m√©thodes en c#",
    "uri": "/420-413/methodes/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Premi√®re partie 1 : Calculatrice Simple Concepts pratiqu√©s : Variables, op√©rateurs arithm√©tiques, types num√©riques\nDescription : Cr√©ez un programme qui demande √† l‚Äôutilisateur deux nombres et une op√©ration (+, -, *, /), puis affiche le r√©sultat.\nFonctionnalit√©s requises :\nDemander deux nombres d√©cimaux √† l‚Äôutilisateur Demander l‚Äôop√©ration souhait√©e Effectuer le calcul appropri√© Afficher le r√©sultat avec 2 d√©cimales G√©rer la division par z√©ro Exemple d‚Äôex√©cution :\nEntrez le premier nombre : 15.5\rEntrez le deuxi√®me nombre : 3.2\rChoisissez l'op√©ration (+, -, *, /) : *\rR√©sultat : 15.5 * 3.2 = 49.60 2 : Convertisseur de Temp√©rature Concepts pratiqu√©s : Variables, op√©rateurs, formules math√©matiques, casting\nDescription : D√©veloppez un convertisseur qui transforme une temp√©rature de Celsius vers Fahrenheit et Kelvin.\nFonctionnalit√©s requises :\nDemander une temp√©rature en Celsius Calculer l‚Äô√©quivalent en Fahrenheit : F = (C √ó 9/5) + 32 Calculer l‚Äô√©quivalent en Kelvin : K = C + 273.15 Afficher les trois temp√©ratures avec 2 d√©cimales Exemple d‚Äôex√©cution :\nEntrez la temp√©rature en Celsius : 25\r25.00¬∞C = 77.00¬∞F = 298.15K 3 : V√©rificateur de Nombre Pair ou Impair Concepts pratiqu√©s : Variables, op√©rateur modulo, structure if/else\nDescription : Cr√©ez un programme qui d√©termine si un nombre entier est pair ou impair.\nFonctionnalit√©s requises :\nDemander un nombre entier √† l‚Äôutilisateur Utiliser l‚Äôop√©rateur modulo (%) pour v√©rifier la parit√© Afficher si le nombre est pair ou impair Bonus : indiquer si le nombre est positif, n√©gatif ou z√©ro Exemple d‚Äôex√©cution :\nEntrez un nombre entier : 42\rLe nombre 42 est pair et positif. 4 : Calculateur d‚ÄôIMC (Indice de Masse Corporelle) Concepts pratiqu√©s : Variables, op√©rateurs, structures de contr√¥le if/else if\nDescription : D√©veloppez un calculateur d‚ÄôIMC qui cat√©gorise le r√©sultat selon les normes de sant√©.\nFonctionnalit√©s requises :\nDemander le poids en kg et la taille en m√®tres Calculer l‚ÄôIMC : IMC = poids / (taille √ó taille) Cat√©goriser le r√©sultat : Moins de 18.5 : Insuffisance pond√©rale 18.5 √† 24.9 : Poids normal 25 √† 29.9 : Surpoids 30 ou plus : Ob√©sit√© Afficher l‚ÄôIMC et la cat√©gorie Exemple d‚Äôex√©cution :\nEntrez votre poids (kg) : 70\rEntrez votre taille (m) : 1.75\rVotre IMC est de 22.86 - Poids normal 5 : Jeu du Plus ou Moins Concepts pratiqu√©s : Variables, Random, boucles while, structures if/else\nDescription : Cr√©ez un jeu o√π l‚Äôordinateur choisit un nombre al√©atoire entre 1 et 100, et l‚Äôutilisateur doit le deviner.\nFonctionnalit√©s requises :\nG√©n√©rer un nombre al√©atoire entre 1 et 100 Utiliser une boucle pour permettre plusieurs tentatives Indiquer si la proposition est trop haute ou trop basse Compter le nombre de tentatives Afficher un message de victoire avec le nombre de coups Exemple d‚Äôex√©cution :\nJ'ai choisi un nombre entre 1 et 100. Devinez !\rVotre proposition : 50\rTrop bas !\rVotre proposition : 75\rTrop haut !\rVotre proposition : 63\rBravo ! Vous avez trouv√© en 3 coups ! 6 : Calculateur de Facture avec Pourboire Concepts pratiqu√©s : Variables, op√©rateurs, types d√©cimaux, formatage\nDescription : D√©veloppez un programme qui calcule le montant total d‚Äôune facture incluant taxes et pourboire.\nFonctionnalit√©s requises :\nDemander le montant de base de la facture Demander le pourcentage de taxes (ex: 15%) Demander le pourcentage de pourboire (ex: 18%) Calculer le montant des taxes Calculer le montant du pourboire (sur le sous-total avec taxes) Afficher le d√©tail complet de la facture Exemple d‚Äôex√©cution :\nMontant de base : 50.00$\rPourcentage de taxes : 15\rPourcentage de pourboire : 18\r--- Facture d√©taill√©e ---\rMontant de base : 50.00$\rTaxes (15%) : 7.50$\rSous-total : 57.50$\rPourboire (18%) : 10.35$\rTOTAL √Ä PAYER : 67.85$ 7 : Validateur de Mot de Passe Concepts pratiqu√©s : Variables string, op√©rateurs logiques, structures if/else, m√©thodes de string\nDescription : Cr√©ez un validateur qui v√©rifie si un mot de passe respecte certains crit√®res de s√©curit√©.\nFonctionnalit√©s requises :\nDemander un mot de passe √† l‚Äôutilisateur V√©rifier que le mot de passe : Contient au moins 8 caract√®res Contient au moins une majuscule Contient au moins une minuscule Contient au moins un chiffre Afficher si le mot de passe est valide ou non Lister les crit√®res non respect√©s Exemple d‚Äôex√©cution :\nEntrez un mot de passe : Hello123\r‚úì Au moins 8 caract√®res\r‚úì Contient une majuscule\r‚úì Contient une minuscule\r‚úì Contient un chiffre\rMot de passe valide ! 8 : Chronom√©treur de Temps de R√©action Concepts pratiqu√©s : Variables, Random, DateTime, boucles, op√©rateurs de comparaison\nDescription : D√©veloppez un mini-jeu qui teste le temps de r√©action de l‚Äôutilisateur.\nFonctionnalit√©s requises :\nAfficher ‚ÄúPr√©parez-vous‚Ä¶‚Äù Attendre un d√©lai al√©atoire (2 √† 5 secondes) Afficher ‚ÄúMAINTENANT !‚Äù et enregistrer l‚Äôheure Attendre que l‚Äôutilisateur appuie sur Entr√©e Calculer et afficher le temps de r√©action en millisecondes Proposer de rejouer Exemple d‚Äôex√©cution :\nPr√©parez-vous...\rMAINTENANT !\r[utilisateur appuie sur Entr√©e]\rVotre temps de r√©action : 342 ms\rExcellent !\rVoulez-vous rejouer ? (o/n) 9 : Convertisseur de Devises Concepts pratiqu√©s : Variables, op√©rateurs, switch/case, types d√©cimaux\nDescription : Cr√©ez un convertisseur qui transforme un montant en dollars canadiens vers diff√©rentes devises.\nFonctionnalit√©s requises :\nDemander un montant en CAD Proposer plusieurs devises (USD, EUR, GBP, JPY) Utiliser un switch pour s√©lectionner le taux de change appropri√© Calculer et afficher la conversion Utiliser des taux de change r√©alistes Exemple d‚Äôex√©cution :\nMontant en CAD : 100\rChoisissez la devise :\r1. USD (Dollar am√©ricain)\r2. EUR (Euro)\r3. GBP (Livre sterling)\r4. JPY (Yen japonais)\rVotre choix : 1\r100.00 CAD = 72.50 USD 10 : Calculateur de Note Finale Concepts pratiqu√©s : Variables, op√©rateurs, structures if/else, moyenne pond√©r√©e\nDescription : D√©veloppez un programme qui calcule la note finale d‚Äôun √©tudiant selon diff√©rents crit√®res pond√©r√©s.\nFonctionnalit√©s requises :\nDemander les notes pour : Examens (40% de la note finale) Devoirs (30% de la note finale) Participation (10% de la note finale) final (20% de la note finale) Calculer la note finale pond√©r√©e D√©terminer la cote (A+, A, B+, B, C+, C, D, E) Indiquer si l‚Äô√©tudiant a r√©ussi (60% et plus) Exemple d‚Äôex√©cution :\nNote des examens (sur 100) : 85\rNote des devoirs (sur 100) : 78\rNote de participation (sur 100) : 92\rNote du final (sur 100) : 88\r--- R√©sultat final ---\rNote finale : 84.2 / 100\rCote : A\rStatut : R√©ussite 11 : Simulateur de D√©s Concepts pratiqu√©s : Variables, Random, boucles for, op√©rateurs\nDescription : Cr√©ez un simulateur qui lance plusieurs d√©s et calcule des statistiques.\nFonctionnalit√©s requises :\nDemander le nombre de d√©s √† lancer (1-10) Demander le nombre de faces par d√© (4, 6, 8, 12, 20) Lancer tous les d√©s Afficher le r√©sultat de chaque d√© Calculer et afficher la somme totale Afficher le r√©sultat minimum et maximum obtenu Exemple d‚Äôex√©cution :\nNombre de d√©s : 3\rNombre de faces : 6\rLancer des d√©s...\rD√© 1 : 4\rD√© 2 : 6\rD√© 3 : 2\rSomme totale : 12\rMinimum : 2\rMaximum : 6 12 : Compteur de Voyelles et Consonnes Concepts pratiqu√©s : Variables string, boucles foreach, switch/case, op√©rateurs\nDescription : D√©veloppez un programme qui analyse une phrase et compte les voyelles et consonnes.\nFonctionnalit√©s requises :\nDemander une phrase √† l‚Äôutilisateur Parcourir chaque caract√®re de la phrase Compter les voyelles (a, e, i, o, u, y - majuscules et minuscules) Compter les consonnes Compter les espaces et caract√®res sp√©ciaux Afficher les statistiques compl√®tes Exemple d‚Äôex√©cution :\nEntrez une phrase : Bonjour le monde!\r--- Analyse ---\rVoyelles : 6\rConsonnes : 8\rEspaces : 2\rAutres caract√®res : 1\rTotal de caract√®res : 17 13 : G√©n√©rateur de Tables de Multiplication Concepts pratiqu√©s : Variables, boucles for imbriqu√©es, op√©rateurs, formatage\nDescription : Cr√©ez un programme qui g√©n√®re et affiche des tables de multiplication.\nFonctionnalit√©s requises :\nDemander quel nombre de table l‚Äôutilisateur veut voir (1-12) Demander jusqu‚Äô√† quel multiplicateur (g√©n√©ralement 10 ou 12) Utiliser une boucle pour g√©n√©rer la table Afficher la table de mani√®re format√©e et lisible Bonus : afficher plusieurs tables c√¥te √† c√¥te Exemple d‚Äôex√©cution :\nTable de multiplication de : 7\rJusqu'√† : 10\r7 x 1 = 7\r7 x 2 = 14\r7 x 3 = 21\r7 x 4 = 28\r7 x 5 = 35\r7 x 6 = 42\r7 x 7 = 49\r7 x 8 = 56\r7 x 9 = 63\r7 x 10 = 70 14 : Calculateur d‚Äô√Çge Pr√©cis Concepts pratiqu√©s : Variables, DateTime, op√©rateurs, structures if/else\nDescription : D√©veloppez un programme qui calcule l‚Äô√¢ge pr√©cis d‚Äôune personne en ann√©es, mois et jours.\nFonctionnalit√©s requises :\nDemander la date de naissance (jour, mois, ann√©e) Utiliser DateTime pour les calculs Calculer l‚Äô√¢ge en ann√©es, mois et jours Calculer le nombre total de jours v√©cus Calculer le jour de la semaine de la naissance Afficher le prochain anniversaire Exemple d‚Äôex√©cution :\nDate de naissance\rJour : 15\rMois : 3\rAnn√©e : 2005\rVous avez 20 ans, 10 mois et 15 jours\rTotal de jours v√©cus : 7625 jours\rVous √™tes n√©(e) un mardi\rProchain anniversaire : dans 136 jours 15 : D√©tecteur de Nombre Premier Concepts pratiqu√©s : Variables, boucles for, op√©rateurs, structures if/else\nDescription : Cr√©ez un programme qui d√©termine si un nombre est premier et trouve tous les nombres premiers dans une plage.\nFonctionnalit√©s requises :\nDemander un nombre √† l‚Äôutilisateur V√©rifier s‚Äôil est premier (divisible seulement par 1 et lui-m√™me) Afficher tous les diviseurs du nombre Option : afficher tous les nombres premiers jusqu‚Äô√† ce nombre Optimiser l‚Äôalgorithme (v√©rifier jusqu‚Äô√† la racine carr√©e) Exemple d‚Äôex√©cution :\nEntrez un nombre : 17\rLe nombre 17 est PREMIER\rDiviseurs : 1, 17\rVoulez-vous voir tous les nombres premiers jusqu'√† 17 ? (o/n) : o\r2, 3, 5, 7, 11, 13, 17\rTotal : 7 nombres premiers 16 : Simulateur de Distributeur Bancaire Concepts pratiqu√©s : Variables, switch/case, boucles while, op√©rateurs\nDescription : D√©veloppez un simulateur de guichet automatique avec un menu et des op√©rations bancaires de base.\nFonctionnalit√©s requises :\nD√©finir un solde initial (ex: 1000$) Cr√©er un menu avec options : Consulter le solde D√©poser de l‚Äôargent Retirer de l‚Äôargent Quitter V√©rifier que les retraits n‚Äôexc√®dent pas le solde Utiliser une boucle pour r√©p√©ter le menu Afficher l‚Äôhistorique des transactions Exemple d‚Äôex√©cution :\n=== Guichet Automatique ===\r1. Consulter le solde\r2. D√©poser\r3. Retirer\r4. Quitter\rVotre choix : 3\rMontant √† retirer : 50\rRetrait effectu√©. Nouveau solde : 950.00$ 17 : Convertisseur Binaire/D√©cimal Concepts pratiqu√©s : Variables, boucles while, op√©rateurs, types num√©riques\nDescription : Cr√©ez un convertisseur bidirectionnel entre nombres d√©cimaux et binaires.\nFonctionnalit√©s requises :\nProposer deux options : D√©cimal vers binaire Binaire vers d√©cimal Pour d√©cimal vers binaire : utiliser la division successive par 2 Pour binaire vers d√©cimal : utiliser les puissances de 2 Afficher les √©tapes de conversion Valider que l‚Äôentr√©e binaire contient seulement 0 et 1 Exemple d‚Äôex√©cution :\n1. D√©cimal vers Binaire\r2. Binaire vers D√©cimal\rVotre choix : 1\rEntrez un nombre d√©cimal : 42\rConversion de 42 en binaire :\r42 √∑ 2 = 21 reste 0\r21 √∑ 2 = 10 reste 1\r10 √∑ 2 = 5 reste 0\r5 √∑ 2 = 2 reste 1\r2 √∑ 2 = 1 reste 0\r1 √∑ 2 = 0 reste 1\rR√©sultat : 42 (d√©cimal) = 101010 (binaire) 18 : Jeu de Pierre-Papier-Ciseaux Concepts pratiqu√©s : Variables, Random, switch/case, structures de contr√¥le, boucles\nDescription : D√©veloppez le jeu classique Pierre-Papier-Ciseaux contre l‚Äôordinateur avec score.\nFonctionnalit√©s requises :\nCr√©er un menu avec les 3 choix possibles G√©n√©rer un choix al√©atoire pour l‚Äôordinateur D√©terminer le gagnant selon les r√®gles : Pierre bat Ciseaux Ciseaux bat Papier Papier bat Pierre Tenir un score (victoires, d√©faites, √©galit√©s) Permettre de jouer plusieurs parties Afficher le score final Exemple d‚Äôex√©cution :\n=== Pierre-Papier-Ciseaux ===\r1. Pierre\r2. Papier\r3. Ciseaux\rVotre choix : 1\rVous : Pierre\rOrdinateur : Ciseaux\rVous gagnez !\rScore - Vous: 1 | Ordi: 0 | √âgalit√©s: 0\rRejouer ? (o/n) 19 : Calculateur de Moyenne Mobile Concepts pratiqu√©s : Variables, boucles for, op√©rateurs, types num√©riques\nDescription : Cr√©ez un programme qui calcule la moyenne d‚Äôune s√©rie de nombres entr√©s par l‚Äôutilisateur.\nFonctionnalit√©s requises :\nDemander combien de nombres l‚Äôutilisateur veut entrer Utiliser une boucle pour saisir chaque nombre Calculer la moyenne, le minimum et le maximum Calculer l‚Äô√©cart-type (bonus) Afficher tous les nombres au-dessus et en-dessous de la moyenne Exemple d‚Äôex√©cution :\nCombien de nombres : 5\rNombre 1 : 12\rNombre 2 : 15\rNombre 3 : 8\rNombre 4 : 20\rNombre 5 : 10\r--- Statistiques ---\rMoyenne : 13.00\rMinimum : 8\rMaximum : 20\rNombres au-dessus de la moyenne : 15, 20\rNombres en-dessous de la moyenne : 12, 8, 10 20 : G√©n√©rateur de Calendrier Mensuel Concepts pratiqu√©s : Variables, DateTime, boucles, structures if/else, formatage\nDescription : D√©veloppez un programme qui affiche le calendrier d‚Äôun mois donn√©.\nFonctionnalit√©s requises :\nDemander le mois et l‚Äôann√©e D√©terminer le premier jour du mois (lundi, mardi, etc.) Calculer le nombre de jours dans le mois Afficher le calendrier format√© avec les jours de la semaine Mettre en √©vidence le jour actuel si c‚Äôest le mois en cours Bonus : marquer les fins de semaine diff√©remment Exemple d‚Äôex√©cution :\nMois (1-12) : 2\rAnn√©e : 2026\rF√©vrier 2026\rDim Lun Mar Mer Jeu Ven Sam\r1 2 3 4 5 6 7\r8 9 10 11 12 13 14\r15 16 17 18 19 20 21\r22 23 24 25 26 27 28 s Avanc√©s Ces s int√®grent tableaux, collections (List, Dictionary), m√©thodes et tous les concepts pr√©c√©dents.\n21 : Gestionnaire de Liste de Courses Concepts pratiqu√©s : List, m√©thodes, boucles, switch/case\nDescription : Cr√©ez une application compl√®te pour g√©rer une liste de courses avec ajout, suppression et affichage.\nFonctionnalit√©s requises :\nCr√©er une List pour stocker les articles Menu avec options : Ajouter un article Supprimer un article Afficher la liste Rechercher un article Vider la liste Compter les articles Quitter Cr√©er des m√©thodes pour chaque fonctionnalit√© √âviter les doublons Trier la liste alphab√©tiquement (option) Structure sugg√©r√©e :\nstatic List\u003cstring\u003e listeDesCourses = new List\u003cstring\u003e(); static void AjouterArticle() static void SupprimerArticle() static void AfficherListe() static void RechercherArticle() Exemple d‚Äôex√©cution :\n=== Liste de Courses ===\r1. Ajouter un article\r2. Supprimer un article\r3. Afficher la liste\r4. Rechercher un article\r5. Vider la liste\r6. Quitter\rChoix : 1\rArticle √† ajouter : Lait\rArticle ajout√© ! Total : 1 article(s) 22 : Carnet d‚ÄôAdresses Concepts pratiqu√©s : Dictionary, m√©thodes, structures (ou classes), collections\nDescription : D√©veloppez un carnet d‚Äôadresses qui stocke nom, t√©l√©phone et courriel de plusieurs contacts.\nFonctionnalit√©s requises :\nUtiliser un Dictionary\u003cstring, Contact\u003e (nom comme cl√©) Cr√©er une structure Contact avec propri√©t√©s : Nom T√©l√©phone Courriel M√©thodes pour : Ajouter un contact Modifier un contact Supprimer un contact Rechercher un contact Afficher tous les contacts Afficher les contacts par ordre alphab√©tique Structure sugg√©r√©e :\nstruct Contact { public string Nom; public string Telephone; public string Courriel; } static Dictionary\u003cstring, Contact\u003e carnet = new Dictionary\u003cstring, Contact\u003e(); static void AjouterContact() static Contact RechercherContact(string nom) Exemple d‚Äôex√©cution :\n=== Carnet d'Adresses ===\r1. Ajouter un contact\r2. Rechercher\r3. Afficher tous\r4. Quitter\rChoix : 1\rNom : Jean Tremblay\rT√©l√©phone : 514-555-1234\rCourriel : jean@email.com\rContact ajout√© ! 23 : Analyseur de Texte Avanc√© Concepts pratiqu√©s : Tableaux, string methods, Dictionary, m√©thodes, LINQ\nDescription : Cr√©ez un analyseur qui effectue des statistiques d√©taill√©es sur un texte.\nFonctionnalit√©s requises :\nDemander un texte √† l‚Äôutilisateur (plusieurs phrases) Cr√©er des m√©thodes pour : Compter les mots Compter les phrases Calculer la longueur moyenne des mots Trouver le mot le plus long Compter la fr√©quence de chaque mot (Dictionary) Afficher les 5 mots les plus fr√©quents Ignorer la ponctuation et la casse pour le comptage M√©thodes sugg√©r√©es :\nstatic int CompterMots(string texte) static int CompterPhrases(string texte) static double LongueurMoyenneMots(string texte) static string TrouverMotLePlusLong(string texte) static Dictionary\u003cstring, int\u003e CompterFrequenceMots(string texte) static void AfficherTopMots(Dictionary\u003cstring, int\u003e frequences, int top) Exemple d‚Äôex√©cution :\nEntrez votre texte :\rLe chat est sur le tapis. Le chat dort.\r--- Analyse ---\rNombre de mots : 9\rNombre de phrases : 2\rLongueur moyenne des mots : 3.33 lettres\rMot le plus long : tapis (5 lettres)\rMots les plus fr√©quents :\r1. le (3 fois)\r2. chat (2 fois)\r3. est (1 fois)\r4. sur (1 fois)\r5. tapis (1 fois) 24 : Jeu du Pendu Concepts pratiqu√©s : Tableaux char, List, m√©thodes, string manipulation, Random\nDescription : D√©veloppez le jeu classique du pendu avec une banque de mots et gestion des vies.\nFonctionnalit√©s requises :\nCr√©er un tableau de mots √† deviner Choisir un mot al√©atoirement Utiliser un tableau de char pour le mot masqu√© G√©rer une List pour les lettres d√©j√† propos√©es Compter les erreurs (maximum 6) Cr√©er des m√©thodes pour : Afficher le mot masqu√© V√©rifier si une lettre est dans le mot Afficher le dessin du pendu selon les erreurs V√©rifier si le jeu est gagn√©/perdu M√©thodes sugg√©r√©es :\nstatic string[] banqueDeMots = { \"programmation\", \"ordinateur\", \"clavier\" }; static List\u003cchar\u003e lettresProposees = new List\u003cchar\u003e(); static string ChoisirMotAleatoire() static void AfficherMotMasque(string mot) static bool VerifierLettre(string mot, char lettre) static void DessinerPendu(int erreurs) static bool EstMotTrouve(string mot) Exemple d‚Äôex√©cution :\n=== Jeu du Pendu ===\rMot √† deviner : _ _ _ _ _ _ _ _ _ _ _ (11 lettres)\rErreurs : 0/6\rProposez une lettre : e\rBien jou√© !\rMot : _ _ _ _ _ _ _ _ _ _ e 25 : Gestionnaire de Notes d‚Äô√âtudiants Concepts pratiqu√©s : Dictionary, List, m√©thodes, structures/classes, calculs statistiques\nDescription : Cr√©ez un syst√®me complet pour g√©rer les notes de plusieurs √©tudiants dans plusieurs mati√®res.\nFonctionnalit√©s requises :\nUtiliser un Dictionary\u003cstring, Etudiant\u003e Cr√©er une classe/struct Etudiant avec : Nom Dictionary\u003cstring, double\u003e pour les notes par mati√®re M√©thodes pour : Ajouter un √©tudiant Ajouter une note pour une mati√®re Calculer la moyenne d‚Äôun √©tudiant Calculer la moyenne de classe pour une mati√®re Afficher le bulletin d‚Äôun √©tudiant Trouver le meilleur √©tudiant Afficher les statistiques g√©n√©rales Structure sugg√©r√©e :\nclass Etudiant { public string Nom { get; set; } public Dictionary\u003cstring, double\u003e Notes { get; set; } public double CalculerMoyenne() public void AfficherBulletin() } static Dictionary\u003cstring, Etudiant\u003e etudiants = new Dictionary\u003cstring, Etudiant\u003e(); static void AjouterEtudiant() static void AjouterNote() static double CalculerMoyenneClasse(string matiere) Exemple d‚Äôex√©cution :\n=== Gestionnaire de Notes ===\r1. Ajouter √©tudiant\r2. Ajouter note\r3. Bulletin √©tudiant\r4. Statistiques classe\r5. Quitter\rChoix : 3\rNom de l'√©tudiant : Marie Dubois\r--- Bulletin de Marie Dubois ---\rMath√©matiques : 85\rFran√ßais : 92\rSciences : 78\rMoyenne g√©n√©rale : 85.0 26 : Syst√®me de Playlist Musicale Concepts pratiqu√©s : List, m√©thodes, Random, manipulation de listes\nDescription : D√©veloppez un gestionnaire de playlist musicale avec lecture al√©atoire et r√©p√©tition.\nFonctionnalit√©s requises :\nCr√©er une List pour stocker les chansons M√©thodes pour : Ajouter une chanson Supprimer une chanson Afficher toute la playlist Lire la playlist en ordre Lire en mode al√©atoire (shuffle) Rechercher une chanson D√©placer une chanson (changer l‚Äôordre) Afficher le nombre total de chansons Vider la playlist Simuler la lecture avec un compteur de chansons jou√©es M√©thodes sugg√©r√©es :\nstatic List\u003cstring\u003e playlist = new List\u003cstring\u003e(); static Random rand = new Random(); static void AjouterChanson() static void SupprimerChanson() static void AfficherPlaylist() static void LireEnOrdre() static void LireAleatoire() static void DeplacerChanson(int indexDepart, int indexArrivee) Exemple d‚Äôex√©cution :\n=== Gestionnaire de Playlist ===\r1. Ajouter chanson\r2. Supprimer chanson\r3. Afficher playlist\r4. Lire en ordre\r5. Lire al√©atoire\r6. Quitter\rChoix : 3\r--- Ma Playlist (4 chansons) ---\r1. Bohemian Rhapsody - Queen\r2. Imagine - John Lennon\r3. Hotel California - Eagles\r4. Stairway to Heaven - Led Zeppelin\rChoix : 5\rMode lecture al√©atoire activ√©...\r‚ô™ Lecture : Hotel California - Eagles\r‚ô™ Lecture : Bohemian Rhapsody - Queen\r‚ô™ Lecture : Stairway to Heaven - Led Zeppelin\r‚ô™ Lecture : Imagine - John Lennon\rPlaylist termin√©e ! 27 : G√©n√©rateur et Analyseur de Statistiques Concepts pratiqu√©s : Tableaux, m√©thodes math√©matiques, Random, tri, calculs statistiques\nDescription : Cr√©ez un programme qui g√©n√®re des donn√©es al√©atoires et effectue des analyses statistiques compl√®tes.\nFonctionnalit√©s requises :\nG√©n√©rer un tableau de N nombres al√©atoires (10-100) Cr√©er des m√©thodes pour calculer : Moyenne M√©diane (valeur centrale apr√®s tri) Mode (valeur la plus fr√©quente) √âcart-type Minimum et maximum Premier et troisi√®me quartile Afficher un histogramme simple en console Cr√©er une m√©thode pour trier le tableau M√©thodes sugg√©r√©es :\nstatic double[] GenererDonnees(int taille, int min, int max) static double CalculerMoyenne(double[] donnees) static double CalculerMediane(double[] donnees) static double CalculerMode(double[] donnees) static double CalculerEcartType(double[] donnees) static void AfficherHistogramme(double[] donnees) static double[] TrierTableau(double[] donnees) Exemple d‚Äôex√©cution :\nG√©n√©ration de 20 nombres entre 1 et 100...\rDonn√©es g√©n√©r√©es : 45, 23, 78, 45, 12, ...\r--- Statistiques ---\rMoyenne : 48.5\rM√©diane : 46.0\rMode : 45 (appara√Æt 3 fois)\r√âcart-type : 24.3\rMin : 12\rMax : 98\rPremier quartile : 28.5\rTroisi√®me quartile : 71.0\r--- Histogramme ---\r0-20: *** (3)\r21-40: ***** (5)\r41-60: ******* (7)\r61-80: **** (4)\r81-100: * (1) 28 : Simulateur de Loto et Statistiques Concepts pratiqu√©s : Tableaux, List, Random, m√©thodes, comparaison\nDescription : Cr√©ez un simulateur de loterie qui g√©n√®re des num√©ros et v√©rifie les gains.\nFonctionnalit√©s requises :\nDemander √† l‚Äôutilisateur de choisir 6 num√©ros entre 1 et 49 G√©n√©rer un tirage al√©atoire de 6 num√©ros (sans r√©p√©tition) Comparer les num√©ros du joueur avec le tirage Calculer le gain selon le nombre de num√©ros correspondants : 6 num√©ros : Jackpot (1 000 000$) 5 num√©ros : 10 000$ 4 num√©ros : 500$ 3 num√©ros : 20$ 2 num√©ros : 5$ M√©thodes pour : G√©n√©rer des num√©ros al√©atoires uniques Valider les choix de l‚Äôutilisateur (pas de doublons, dans la plage) Comparer deux listes de num√©ros Calculer le gain Afficher les statistiques apr√®s plusieurs parties M√©thodes sugg√©r√©es :\nstatic int[] numeros_joueur = new int[6]; static int[] numeros_gagnants = new int[6]; static void ChoisirNumeros() static int[] GenererTirage() static int CompterNumerosCorrespondants() static double CalculerGain(int correspondants) static bool ContiendreNumero(int[] tableau, int numero) static void TrierTableau(int[] tableau) Exemple d‚Äôex√©cution :\n=== Simulateur de Loto 6/49 ===\rChoisissez 6 num√©ros entre 1 et 49 :\rNum√©ro 1 : 7\rNum√©ro 2 : 14\rNum√©ro 3 : 21\rNum√©ro 4 : 28\rNum√©ro 5 : 35\rNum√©ro 6 : 42\rVos num√©ros : 7, 14, 21, 28, 35, 42\rTirage en cours...\rNum√©ros gagnants : 12, 14, 23, 28, 35, 41\rNum√©ros correspondants : 14, 28, 35\rTotal : 3 num√©ros\rVous gagnez : 20.00$ !\rRejouer ? (o/n) 29 : Gestion d‚ÄôInventaire de Magasin Concepts pratiqu√©s : Tableaux parall√®les, m√©thodes, recherche, tri\nDescription : Cr√©ez un syst√®me de gestion d‚Äôinventaire avec produits, quantit√©s et prix en utilisant des tableaux parall√®les.\nFonctionnalit√©s requises :\nUtiliser 4 tableaux parall√®les pour stocker : string[] codes (codes produits) string[] noms (noms des produits) int[] quantites (quantit√©s en stock) double[] prix (prix unitaires) M√©thodes pour : Ajouter un produit Modifier un produit Supprimer un produit Rechercher par code ou nom Afficher tous les produits Afficher les produits en rupture de stock (quantit√© = 0) Calculer la valeur totale de l‚Äôinventaire Vendre un produit (diminuer quantit√©) Trier les produits par prix M√©thodes sugg√©r√©es :\nstatic string[] codes = new string[100]; static string[] noms = new string[100]; static int[] quantites = new int[100]; static double[] prix = new double[100]; static int nombreProduits = 0; static void AjouterProduit() static int RechercherParCode(string code) static void AfficherInventaire() static void ProduitsEnRupture() static double ValeurTotaleInventaire() static void VendreProduit(string code, int quantite) Exemple d‚Äôex√©cution :\n=== Gestion d'Inventaire ===\r1. Ajouter produit\r2. Vendre\r3. Rechercher\r4. Afficher inventaire\r5. Ruptures de stock\r6. Valeur totale\r7. Quitter\rChoix : 4\r--- Inventaire (3 produits) ---\rCode Nom Qt√© Prix Valeur\rP001 Clavier USB 25 29.99 749.75\rP002 Souris sans fil 12 19.99 239.88\rP003 √âcran 24\" 0 299.99 0.00\rTotal produits : 3\rValeur totale : 989.63$ 30 : Convertisseur d‚ÄôUnit√©s Universel Concepts pratiqu√©s : Dictionary, m√©thodes, conversions, switch/case\nDescription : D√©veloppez un convertisseur complet pour diff√©rentes cat√©gories d‚Äôunit√©s.\nFonctionnalit√©s requises :\nCat√©gories de conversion : Longueur (m, km, cm, mm, miles, yards, pieds, pouces) Poids (kg, g, mg, livres, onces) Temp√©rature (Celsius, Fahrenheit, Kelvin) Volume (L, mL, gallons, pintes) Utiliser des Dictionary pour les facteurs de conversion M√©thodes pour chaque cat√©gorie de conversion Menu pour s√©lectionner la cat√©gorie Afficher toutes les conversions possibles depuis l‚Äôunit√© saisie M√©thodes sugg√©r√©es :\nstatic Dictionary\u003cstring, double\u003e facteursLongueur = new Dictionary\u003cstring, double\u003e { { \"m\", 1 }, { \"km\", 1000 }, { \"cm\", 0.01 }, // etc. }; static double ConvertirLongueur(double valeur, string deUnite, string versUnite) static double ConvertirTemperature(double valeur, string deUnite, string versUnite) static void AfficherToutesConversions(double valeur, string unite, string categorie) Exemple d‚Äôex√©cution :\n=== Convertisseur d'Unit√©s ===\r1. Longueur\r2. Poids\r3. Temp√©rature\r4. Volume\r5. Quitter\rChoix : 1\rValeur : 5\rUnit√© de d√©part : m\r5 m√®tres =\r- 5000 millim√®tres\r- 500 centim√®tres\r- 0.005 kilom√®tres\r- 5.468 yards\r- 16.404 pieds\r- 196.850 pouces\r- 0.003 miles 31 : G√©n√©rateur de Mots de Passe S√©curis√©s Concepts pratiqu√©s : Tableaux, Random, m√©thodes, string manipulation, validation\nDescription : Cr√©ez un g√©n√©rateur de mots de passe avec options de personnalisation et v√©rification de force.\nFonctionnalit√©s requises :\nOptions configurables : Longueur du mot de passe (8-50 caract√®res) Inclure majuscules (A-Z) Inclure minuscules (a-z) Inclure chiffres (0-9) Inclure symboles (!@#$%^\u0026*) G√©n√©rer plusieurs mots de passe √† la fois Cr√©er une m√©thode pour √©valuer la force du mot de passe (faible/moyen/fort) √âviter les caract√®res ambigus (0/O, 1/l/I) Permettre de sauvegarder les mots de passe g√©n√©r√©s dans une List M√©thodes sugg√©r√©es :\nstatic char[] majuscules = \"ABCDEFGHJKLMNPQRSTUVWXYZ\".ToCharArray(); static char[] minuscules = \"abcdefghijkmnopqrstuvwxyz\".ToCharArray(); static char[] chiffres = \"23456789\".ToCharArray(); static char[] symboles = \"!@#$%^\u0026*\".ToCharArray(); static string GenererMotDePasse(int longueur, bool maj, bool min, bool chif, bool sym) static string EvaluerForce(string motDePasse) static List\u003cchar\u003e CreerPoolDeCaracteres(bool maj, bool min, bool chif, bool sym) Exemple d‚Äôex√©cution :\n=== G√©n√©rateur de Mots de Passe ===\rLongueur (8-50) : 16\rInclure majuscules ? (o/n) : o\rInclure minuscules ? (o/n) : o\rInclure chiffres ? (o/n) : o\rInclure symboles ? (o/n) : o\rMots de passe g√©n√©r√©s :\r1. kT8#mPq2nL9@wXz5 (Force: Fort)\r2. Vy3$bNr7hK4\u0026qWm2 (Force: Fort)\r3. Jp6%dGt8sM3!xZn9 (Force: Fort)\rG√©n√©rer d'autres mots de passe ? (o/n) 32 : Calculatrice de Pr√™t Hypoth√©caire Concepts pratiqu√©s : M√©thodes, calculs financiers, tableaux, formatage, boucles\nDescription : D√©veloppez une calculatrice qui calcule les paiements mensuels et g√©n√®re un tableau d‚Äôamortissement.\nFonctionnalit√©s requises :\nDemander : Montant du pr√™t Taux d‚Äôint√©r√™t annuel Dur√©e en ann√©es Calculer le paiement mensuel avec la formule : M = P[r(1+r)^n]/[(1+r)^n-1] M = paiement mensuel P = montant principal r = taux mensuel n = nombre de paiements Utiliser des tableaux pour stocker : double[] paiements double[] interets double[] capital double[] soldes Afficher les premiers et derniers mois Calculer le total des int√©r√™ts pay√©s Option : comparer diff√©rents sc√©narios M√©thodes sugg√©r√©es :\nstatic double CalculerPaiementMensuel(double montant, double tauxAnnuel, int annees) static void GenererTableauAmortissement(double montant, double tauxAnnuel, int annees, out double[] paiements, out double[] interets, out double[] capital, out double[] soldes) static void AfficherLigneTableau(int mois, double paiement, double interet, double cap, double solde) static double CalculerTotalInterets(double[] interets) Exemple d‚Äôex√©cution :\n=== Calculatrice Hypoth√©caire ===\rMontant du pr√™t : 300000\rTaux d'int√©r√™t annuel (%) : 3.5\rDur√©e (ann√©es) : 25\rPaiement mensuel : 1498.88$\rTotal des int√©r√™ts : 149664.00$\rTotal √† rembourser : 449664.00$\r--- Tableau d'amortissement (premiers mois) ---\rMois Paiement Int√©r√™ts Capital Solde\r1 1498.88 875.00 623.88 299376.12\r2 1498.88 873.18 625.70 298750.42\r3 1498.88 871.36 627.52 298122.90\r4 1498.88 869.53 629.35 297493.55\r5 1498.88 867.69 631.19 296862.36\r...\rAfficher tous les mois ? (o/n) 33 : Syst√®me de Quiz avec Banque de Questions Concepts pratiqu√©s : Tableaux parall√®les, m√©thodes, Random, score, validation\nDescription : Cr√©ez un syst√®me de quiz interactif avec diff√©rentes cat√©gories et suivi des r√©sultats.\nFonctionnalit√©s requises :\nUtiliser des tableaux parall√®les pour stocker les questions : string[] questions string[] choixA, choixB, choixC, choixD int[] bonnesReponses (1-4) string[] categories Cr√©er une banque d‚Äôau moins 15 questions M√©thodes pour : S√©lectionner des questions al√©atoires Afficher une question avec ses choix Valider la r√©ponse de l‚Äôutilisateur Calculer le score Afficher les statistiques finales Filtrer par cat√©gorie M√©langer l‚Äôordre des questions Emp√™cher les doublons dans un m√™me quiz M√©thodes sugg√©r√©es :\nstatic string[] questions = new string[50]; static string[] choixA = new string[50]; static string[] choixB = new string[50]; static string[] choixC = new string[50]; static string[] choixD = new string[50]; static int[] bonnesReponses = new int[50]; static string[] categories = new string[50]; static int nombreQuestions = 0; static void InitialiserQuestions() static int[] SelectionnerQuestionsAleatoires(int nombre) static void AfficherQuestion(int index) static bool VerifierReponse(int index, int reponseUtilisateur) static void AfficherResultats(int bonnes, int totales) Exemple d‚Äôex√©cution :\n=== Quiz C# ===\rCat√©gories disponibles :\r1. Programmation C#\r2. Math√©matiques\r3. Culture g√©n√©rale\r4. Toutes cat√©gories\rChoix : 1\rNombre de questions : 5\r--- Question 1/5 ---\rCat√©gorie : Programmation C#\rQuel est le r√©sultat de 5 % 2 en C# ?\r1. 2.5\r2. 1\r3. 2\r4. 0\rVotre r√©ponse : 2\r‚úì Correct !\rScore actuel : 1/1\r--- Question 2/5 ---\r...\r=== R√©sultats finaux ===\rBonnes r√©ponses : 4/5 (80%)\rMauvaises r√©ponses : 1/5 (20%)\rNote : B+ 34 : Simulateur de Compte Bancaire avec Historique Concepts pratiqu√©s : List, m√©thodes, DateTime, formatage, validation\nDescription : D√©veloppez un simulateur de compte bancaire complet avec transactions et historique d√©taill√©.\nFonctionnalit√©s requises :\nVariables globales pour le compte : string numeroCompte string titulaire double solde Utiliser des List pour l‚Äôhistorique : List typesTransactions (Depot, Retrait, etc.) List montants List dates List soldesApres List descriptions M√©thodes pour : D√©poser (ajouter √† l‚Äôhistorique) Retirer (avec v√©rification solde, ajouter √† l‚Äôhistorique) Afficher l‚Äôhistorique complet Afficher les d√©p√¥ts seulement Afficher les retraits seulement Calculer solde moyen sur une p√©riode Afficher les transactions d‚Äôun mois sp√©cifique Calculer des int√©r√™ts mensuels (bonus) M√©thodes sugg√©r√©es :\nstatic string numeroCompte = \"12345-67890\"; static string titulaire = \"Jean Tremblay\"; static double solde = 1000.00; static List\u003cstring\u003e typesTransactions = new List\u003cstring\u003e(); static List\u003cdouble\u003e montants = new List\u003cdouble\u003e(); static List\u003cDateTime\u003e dates = new List\u003cDateTime\u003e(); static List\u003cdouble\u003e soldesApres = new List\u003cdouble\u003e(); static List\u003cstring\u003e descriptions = new List\u003cstring\u003e(); static bool Deposer(double montant, string description) static bool Retirer(double montant, string description) static void AfficherHistorique() static void FiltrerParType(string type) static void FiltrerParMois(int mois, int annee) static double CalculerSoldeMoyen() Exemple d‚Äôex√©cution :\n=== Compte Bancaire - Jean Tremblay ===\rNum√©ro : 12345-67890\rSolde actuel : 1500.00$\r1. D√©poser\r2. Retirer\r3. Historique complet\r4. Voir d√©p√¥ts uniquement\r5. Voir retraits uniquement\r6. Statistiques\r7. Quitter\rChoix : 3\r--- Historique des transactions ---\rDate Type Montant Solde Description\r2026-01-15 10:30 D√©p√¥t +500.00 1500.00 Paie janvier\r2026-01-16 14:20 Retrait -50.00 1450.00 √âpicerie\r2026-01-18 09:15 D√©p√¥t +200.00 1650.00 Remboursement\r2026-01-20 16:45 Retrait -150.00 1500.00 Facture t√©l√©phone\rTotal transactions : 4\rSolde moyen : 1537.50$ 35 : Simulateur de Machine √† Sous (Slot Machine) Concepts pratiqu√©s : Random, tableaux, m√©thodes, boucles, calculs\nDescription : Cr√©ez un jeu de machine √† sous avec 3 rouleaux et diff√©rentes combinaisons gagnantes.\nFonctionnalit√©s requises :\nD√©finir les symboles possibles : üçí (Cerise), üçã (Citron), üçä (Orange), üçá (Raisin), üíé (Diamant), 7Ô∏è‚É£ (Sept) Utiliser un tableau de string pour les symboles Variables pour : Solde du joueur Mise actuelle M√©thodes pour : Tourner les 3 rouleaux (g√©n√©rer 3 symboles al√©atoires) Afficher les rouleaux V√©rifier les combinaisons gagnantes : 3 identiques : Jackpot (mise √ó 50) 3 Sept : Super Jackpot (mise √ó 100) 2 identiques : Petit gain (mise √ó 5) 3 Diamants : Gros gain (mise √ó 25) Calculer les gains G√©rer le solde du joueur Historique des gains et pertes M√©thodes sugg√©r√©es :\nstatic string[] symboles = { \"üçí\", \"üçã\", \"üçä\", \"üçá\", \"üíé\", \"7Ô∏è‚É£\" }; static Random rand = new Random(); static double solde = 100.00; static string[] TournerRouleaux() static void AfficherRouleaux(string[] rouleaux) static double CalculerGain(string[] rouleaux, double mise) static bool VerifierTroisIdentiques(string[] rouleaux) static bool VerifierDeuxIdentiques(string[] rouleaux) Exemple d‚Äôex√©cution :\n=== Machine √† Sous üé∞ ===\rSolde : 100.00$\rSymboles :\rüçí Cerise üçã Citron üçä Orange\rüçá Raisin üíé Diamant 7Ô∏è‚É£ Sept\rEntrez votre mise (min 1$, max 10$) : 5\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ üçí ‚îÇ üçí ‚îÇ üçã ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\rDeux cerises ! Vous gagnez 25.00$ !\rSolde : 120.00$\rRejouer ? (o/n) : o\rEntrez votre mise : 10\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ üíé ‚îÇ üíé ‚îÇ üíé ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\rJACKPOT ! Trois diamants !\rVous gagnez 250.00$ !\rSolde : 360.00$ 36 : Planificateur de T√¢ches avec Priorit√©s Concepts pratiqu√©s : List, tableaux parall√®les, m√©thodes, tri, DateTime\nDescription : D√©veloppez une application de gestion de t√¢ches avec cat√©gories, priorit√©s et √©ch√©ances.\nFonctionnalit√©s requises :\nUtiliser des List pour stocker les t√¢ches : List titres List descriptions List priorites (1=Basse, 2=Moyenne, 3=Haute, 4=Urgente) List categories List datesEcheance List statuts (1=√Ä faire, 2=En cours, 3=Termin√©e) M√©thodes pour : Ajouter une t√¢che Modifier une t√¢che Marquer comme termin√©e Supprimer une t√¢che Afficher toutes les t√¢ches Filtrer par priorit√©, cat√©gorie ou statut Trier par date d‚Äô√©ch√©ance ou priorit√© Afficher les t√¢ches en retard Statistiques (nombre par statut, taux de compl√©tion) M√©thodes sugg√©r√©es :\nstatic List\u003cstring\u003e titres = new List\u003cstring\u003e(); static List\u003cstring\u003e descriptions = new List\u003cstring\u003e(); static List\u003cint\u003e priorites = new List\u003cint\u003e(); static List\u003cstring\u003e categories = new List\u003cstring\u003e(); static List\u003cDateTime\u003e datesEcheance = new List\u003cDateTime\u003e(); static List\u003cint\u003e statuts = new List\u003cint\u003e(); static void AjouterTache() static void AfficherTaches() static void FiltrerParPriorite(int priorite) static void AfficherTachesEnRetard() static void AfficherStatistiques() static string ObtenirNomPriorite(int priorite) static string ObtenirNomStatut(int statut) static int CalculerJoursRestants(DateTime dateEcheance) Exemple d‚Äôex√©cution :\n=== Planificateur de T√¢ches ===\r1. Ajouter t√¢che\r2. Voir toutes les t√¢ches\r3. Filtrer\r4. Marquer termin√©e\r5. T√¢ches en retard\r6. Statistiques\r7. Quitter\rChoix : 2\r--- Toutes les t√¢ches ---\r[1] [URGENTE] Terminer C# - Cat√©gorie: √âcole\r√âch√©ance: 2026-02-05 (6 jours) - Statut: En cours\rDescription: Compl√©ter les 40 mini-s\r[2] [HAUTE] R√©viser pour examen - Cat√©gorie: √âcole\r√âch√©ance: 2026-02-10 (11 jours) - Statut: √Ä faire\rDescription: R√©viser chapitres 1 √† 5\r[3] [MOYENNE] Faire l'√©picerie - Cat√©gorie: Personnel\r√âch√©ance: 2026-02-01 (2 jours) - Statut: √Ä faire\rDescription: Acheter fruits et l√©gumes 37 : Syst√®me de Sondage et Analyse Concepts pratiqu√©s : List, Dictionary, m√©thodes, statistiques, pourcentages\nDescription : Cr√©ez un syst√®me pour cr√©er des sondages, collecter des r√©ponses et analyser les r√©sultats.\nFonctionnalit√©s requises :\nUtiliser des List pour stocker les questions : List questions List option1, option2, option3, option4 Utiliser Dictionary\u003cstring, int\u003e pour compter les r√©ponses Cl√© : ‚ÄúQuestion1_Option1‚Äù, ‚ÄúQuestion1_Option2‚Äù, etc. M√©thodes pour : Cr√©er un sondage (ajouter questions et options) R√©pondre au sondage (un participant √† la fois) Afficher les r√©sultats : Calculer les pourcentages pour chaque option Afficher un graphique en mode texte (barres ASCII) Trouver l‚Äôoption la plus populaire Calculer le nombre total de participants R√©initialiser les r√©sultats M√©thodes sugg√©r√©es :\nstatic List\u003cstring\u003e questions = new List\u003cstring\u003e(); static List\u003cstring\u003e option1 = new List\u003cstring\u003e(); static List\u003cstring\u003e option2 = new List\u003cstring\u003e(); static List\u003cstring\u003e option3 = new List\u003cstring\u003e(); static List\u003cstring\u003e option4 = new List\u003cstring\u003e(); static Dictionary\u003cstring, int\u003e reponses = new Dictionary\u003cstring, int\u003e(); static int nombreParticipants = 0; static void CreerSondage() static void RemplirSondage() static void AnalyserResultats() static void AfficherGraphique(int questionIndex) static double CalculerPourcentage(int nbReponses, int total) static string GenererBarre(double pourcentage) Exemple d‚Äôex√©cution :\n=== Syst√®me de Sondage ===\r1. Cr√©er sondage\r2. R√©pondre √† un sondage\r3. Voir r√©sultats\r4. Quitter\rChoix : 3\rSondage : Satisfaction des √©tudiants\rParticipants : 20\rQuestion 1: Comment √©valuez-vous la qualit√© du cours ?\rExcellent : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 45% (9 r√©ponses)\rBon : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 30% (6 r√©ponses)\rMoyen : ‚ñà‚ñà‚ñà‚ñà 15% (3 r√©ponses)\rFaible : ‚ñà‚ñà 10% (2 r√©ponses)\rQuestion 2: Recommanderiez-vous ce cours ?\rOui, certainement : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 60% (12 r√©ponses)\rProbablement oui : ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà 25% (5 r√©ponses)\rProbablement non : ‚ñà‚ñà‚ñà‚ñà 10% (2 r√©ponses)\rNon, certainement pas : ‚ñà‚ñà 5% (1 r√©ponse)\rOption la plus populaire : \"Oui, certainement\" 38 : Jeu de M√©moire avec Cartes Concepts pratiqu√©s : Tableaux, List, m√©thodes, Random, logique de jeu, temps\nDescription : D√©veloppez un jeu de m√©moire simplifi√© o√π il faut retrouver les paires de nombres identiques.\nFonctionnalit√©s requises :\nCr√©er un tableau de 16 cartes (8 paires de nombres de 1 √† 8) Utiliser des tableaux pour g√©rer l‚Äô√©tat : int[] valeurs (contient les nombres 1-8 en double) bool[] estVisible (true si carte retourn√©e) bool[] estTrouvee (true si paire trouv√©e) M√©langer les cartes au d√©but M√©thodes pour : Initialiser et m√©langer les cartes Afficher toutes les cartes (cach√©es sauf visibles et trouv√©es) Retourner une carte (par sa position 0-15) V√©rifier si deux cartes forment une paire Compter le nombre de coups V√©rifier si toutes les paires sont trouv√©es Emp√™cher de retourner plus de 2 cartes √† la fois Afficher le temps √©coul√© M√©thodes sugg√©r√©es :\nstatic int[] valeurs = new int[16]; static bool[] estVisible = new bool[16]; static bool[] estTrouvee = new bool[16]; static Random rand = new Random(); static int nombreCoups = 0; static void InitialiserJeu() static void MelangerCartes() static void AfficherCartes() static void RetournerCarte(int position) static bool VerifierPaire(int pos1, int pos2) static bool JeuTermine() Exemple d‚Äôex√©cution :\n=== Jeu de M√©moire üé¥ ===\rPositions : 0 √† 15\r0 1 2 3 4 5 6 7\r[?] [?] [?] [?] [?] [?] [?] [?]\r8 9 10 11 12 13 14 15\r[?] [?] [?] [?] [?] [?] [?] [?]\rPaires trouv√©es : 0/8\rCoups : 0\rPremi√®re carte (0-15) : 3\r0 1 2 3 4 5 6 7\r[?] [?] [?] [5] [?] [?] [?] [?]\rDeuxi√®me carte (0-15) : 11\r0 1 2 3 4 5 6 7\r[?] [?] [?] [5] [?] [?] [?] [?]\r8 9 10 11 12 13 14 15\r[?] [?] [?] [3] [?] [?] [?] [?]\rPas de paire ! Cartes cach√©es...\rPaires trouv√©es : 0/8\rCoups : 1 39 : Calculatrice de Budget Personnel Concepts pratiqu√©s : List, Dictionary, m√©thodes, calculs financiers, DateTime\nDescription : Cr√©ez une application compl√®te pour g√©rer un budget personnel avec revenus, d√©penses et analyse.\nFonctionnalit√©s requises :\nUtiliser des List pour stocker les transactions : List types (‚ÄúRevenu‚Äù ou ‚ÄúDepense‚Äù) List montants List categories (Salaire, √âpicerie, Transport, Loisirs, etc.) List dates List descriptions Utiliser un Dictionary\u003cstring, double\u003e pour les budgets pr√©vus par cat√©gorie M√©thodes pour : Ajouter revenu/d√©pense Afficher le r√©sum√© mensuel Calculer solde actuel Afficher d√©penses par cat√©gorie (avec pourcentages) Comparer budget pr√©vu vs r√©el Afficher graphique en barres des d√©penses Identifier les plus grosses d√©penses Filtrer par mois M√©thodes sugg√©r√©es :\nstatic List\u003cstring\u003e types = new List\u003cstring\u003e(); static List\u003cdouble\u003e montants = new List\u003cdouble\u003e(); static List\u003cstring\u003e categories = new List\u003cstring\u003e(); static List\u003cDateTime\u003e dates = new List\u003cDateTime\u003e(); static List\u003cstring\u003e descriptions = new List\u003cstring\u003e(); static Dictionary\u003cstring, double\u003e budgetsPrevus = new Dictionary\u003cstring, double\u003e(); static void AjouterTransaction() static double CalculerRevenusMois(int mois, int annee) static double CalculerDepensesMois(int mois, int annee) static Dictionary\u003cstring, double\u003e DepensesParCategorie(int mois, int annee) static void AfficherResumeMensuel(int mois, int annee) static void AfficherGraphiqueDepenses(Dictionary\u003cstring, double\u003e depenses, double total) static string GenererBarre(double pourcentage) Exemple d‚Äôex√©cution :\n=== Budget Personnel - Janvier 2026 ===\rRevenus totaux : 3200.00$\rD√©penses totales : 2450.00$\rSolde : +750.00$\r--- D√©penses par cat√©gorie ---\rLoyer : 1200.00$ (49%) ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\r√âpicerie : 450.00$ (18%) ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà\rTransport : 200.00$ (8%) ‚ñà‚ñà‚ñà\rLoisirs : 300.00$ (12%) ‚ñà‚ñà‚ñà‚ñà‚ñà\rT√©l√©phone : 80.00$ (3%) ‚ñà\rAutres : 220.00$ (9%) ‚ñà‚ñà‚ñà‚ñà\r--- Budget pr√©vu vs r√©el ---\r√âpicerie : 450$ / 500$ (sous budget de 50$)\rTransport : 200$ / 150$ (d√©passement de 50$)\rLoisirs : 300$ / 250$ (d√©passement de 50$)\rPlus grosses d√©penses du mois :\r1. Loyer - 1200.00$ (2026-01-01)\r2. √âpicerie Costco - 180.00$ (2026-01-15)\r3. Restaurant - 120.00$ (2026-01-20) 40 : Simulateur de Tournoi Sportif (Round-Robin) Concepts pratiqu√©s : List, tableaux parall√®les, m√©thodes, algorithmes, tri\nDescription : D√©veloppez un syst√®me pour g√©rer un tournoi sportif o√π chaque √©quipe affronte toutes les autres.\nFonctionnalit√©s requises :\nUtiliser des tableaux/listes parall√®les pour stocker les √©quipes : List nomsEquipes List victoires List defaites List nulles List pointsMarques List pointsEncaisses Cr√©er des List pour les matches : List equipe1 List equipe2 List score1 List score2 List rondes M√©thodes pour : Ajouter des √©quipes G√©n√©rer le calendrier complet (round-robin) Simuler un match (al√©atoire ou saisie manuelle) Enregistrer les r√©sultats Mettre √† jour les classements Afficher le classement actuel Afficher les matches √† venir Calculer les statistiques (diff√©rentiel de points, taux de victoire) M√©thodes sugg√©r√©es :\nstatic List\u003cstring\u003e nomsEquipes = new List\u003cstring\u003e(); static List\u003cint\u003e victoires = new List\u003cint\u003e(); static List\u003cint\u003e defaites = new List\u003cint\u003e(); static List\u003cint\u003e nulles = new List\u003cint\u003e(); static List\u003cint\u003e pointsMarques = new List\u003cint\u003e(); static List\u003cint\u003e pointsEncaisses = new List\u003cint\u003e(); static List\u003cstring\u003e matchEquipe1 = new List\u003cstring\u003e(); static List\u003cstring\u003e matchEquipe2 = new List\u003cstring\u003e(); static List\u003cint\u003e matchScore1 = new List\u003cint\u003e(); static List\u003cint\u003e matchScore2 = new List\u003cint\u003e(); static void AjouterEquipe(string nom) static void GenererCalendrier() static void SimulerMatch(int indexMatch) static void EnregistrerResultat(string equipe1, string equipe2, int score1, int score2) static void AfficherClassement() static int TrouverIndexEquipe(string nom) static double CalculerTauxVictoire(int index) static int CalculerPoints(int index) // Victoire = 3pts, Nulle = 1pt Exemple d‚Äôex√©cution :\n=== Tournoi de Hockey Round-Robin ===\rParticipants : 6 √©quipes\rNombre total de matches : 15\r--- Classement apr√®s ronde 3 ---\rPos √âquipe Pts V N D PM PE Diff\r1 Canadiens MTL 9 3 0 0 15 8 +7\r2 Maple Leafs TOR 6 2 0 1 12 10 +2\r3 Bruins BOS 6 2 0 1 10 9 +1\r4 Senators OTT 3 1 0 2 9 11 -2\r5 Sabres BUF 3 1 0 2 7 10 -3\r6 Red Wings DET 0 0 0 3 5 10 -5\r--- Prochaine ronde (Ronde 4) ---\rCanadiens MTL vs Senators OTT\rMaple Leafs TOR vs Red Wings DET\rBruins BOS vs Sabres BUF\r1. Simuler ronde suivante\r2. Entrer r√©sultats manuellement\r3. Afficher statistiques\r4. Quitter Bonnes Pratiques Nommage : Utilisez des noms descriptifs (camelCase pour variables, PascalCase pour m√©thodes) Commentaires : Expliquez les parties complexes de votre code Validation : V√©rifiez toujours les entr√©es utilisateur Gestion d‚Äôerreurs : Utilisez try-catch pour les op√©rations risqu√©es Modularit√© : Divisez votre code en m√©thodes r√©utilisables Tests : Testez tous les sc√©narios possibles Deuxi√®me partie 1. Le Distributeur de Breuvages Intelligent Sc√©nario : Vous g√©rez une machine qui vend du Caf√© (2.50$), du Th√© (2.00$) et du Chocolat (3.00$). Exigences : Cr√©er une m√©thode AfficherMenu() qui montre les choix et les prix. L‚Äôutilisateur entre un montant. Si le montant est insuffisant, redemander de l‚Äôargent ou annuler. Calculer la monnaie √† rendre en utilisant le moins de pi√®ces possible (pi√®ces de 2$, 1$, 0.25$, 0.10$). Notions : while, switch, op√©rateurs modulo %. 2. Analyseur de Donn√©es M√©t√©o (Statistiques) Sc√©nario : Un centre m√©t√©o a besoin d‚Äôanalyser les temp√©ratures d‚Äôune semaine. Exigences : Stocker 7 valeurs double dans un tableau. M√©thode CalculerMoyenne(double[] temp) : retourne la moyenne. M√©thode TrouverExtremes(double[] temp) : affiche la plus haute et la plus basse sans Max() ou Min(). Afficher un histogramme simple dans la console (ex: 22¬∞C = **********). Notions : Boucles for, algorithme de recherche de minimum/maximum. 3. Gestionnaire de Contacts avec Recherche Floue Sc√©nario : Une liste de noms simple mais interactive. Exigences : Utiliser une List\u003cstring\u003e pour stocker les noms. Menu : 1. Ajouter, 2. Supprimer par nom, 3. Rechercher, 4. Quitter. La recherche doit afficher tous les noms qui contiennent la lettre ou la syllabe saisie (ex: ‚Äúan‚Äù trouve ‚ÄúAndr√©‚Äù et ‚ÄúChantal‚Äù). Notions : List\u003cT\u003e, m√©thode string.Contains(), foreach. 4. Syst√®me de Facturation de Magasin Sc√©nario : Calculer le total d‚Äôun panier d‚Äôachat avec taxes. Exigences : L‚Äôutilisateur saisit des prix jusqu‚Äô√† ce qu‚Äôil entre -1. G√©rer un tableau de ‚Äúrabais‚Äù : si le prix \u003e 100$, appliquer 10% de r√©duction avant taxes. M√©thode CalculerTaxes(double total) : retourne le montant des taxes (TPS 5%, TVQ 9.975%). Notions : Accumulateurs, constantes, m√©thodes de calcul. 5. Jeu du Pendu : Le D√©fi des Caract√®res Sc√©nario : Deviner un mot cach√© lettre par lettre. Exigences : Le mot secret est un char[]. Cr√©er un second char[] rempli de _. L‚Äô√©tudiant doit comparer la lettre saisie avec chaque caract√®re du mot secret. G√©rer un maximum de 6 erreurs. Notions : Tableaux de caract√®res, manipulation d‚Äôindex. 6. Bureau de Scrutin Virtuel Sc√©nario : Compter les votes pour une √©lection √† 3 candidats. Exigences : Utiliser un Dictionary\u003cstring, int\u003e o√π la cl√© est le nom du candidat. Boucle de vote : l‚Äôutilisateur tape le nom ou le num√©ro du candidat. M√©thode AfficherGagnant() : parcourt le dictionnaire pour trouver la valeur la plus √©lev√©e. Notions : Dictionnaires, it√©ration sur paires Cl√©/Valeur. 7. Validateur de Complexit√© de Mot de Passe Sc√©nario : S√©curiser la cr√©ation de compte. Exigences : Cr√©er une m√©thode VerifierForce(string mdp) qui retourne un score de 1 √† 5. Crit√®res : +1 si \u003e 8 car., +1 si majuscule, +1 si chiffre, +1 si symbole (#, !, $), +1 si \u003e 12 car. Utiliser des boucles pour inspecter chaque caract√®re. Notions : char.IsUpper, char.IsDigit, char.IsPunctuation. 8. Convertisseur de Devises avec Historique Sc√©nario : Changer de l‚Äôargent et garder une trace des transactions. Exigences : Utiliser un tableau double[] fixe pour les taux (USD, EUR, GBP). Chaque conversion effectu√©e est ajout√©e sous forme de cha√Æne (ex: ‚Äú10 CAD -\u003e 7 USD‚Äù) dans une List\u003cstring\u003e. Option pour afficher l‚Äôhistorique complet √† la fin. Notions : Tableaux, listes, formatage de texte. 9. Bataille Navale : Tactique 1D Sc√©nario : D√©truire des navires cach√©s dans une ligne de 10 cases. Exigences : Un tableau bool[10] o√π 3 cases al√©atoires sont true. L‚Äôutilisateur choisit un index. Afficher ‚ÄúTouch√©‚Äù ou ‚Äú√Ä l‚Äôeau‚Äù. Le jeu s‚Äôarr√™te quand les 3 bateaux sont coul√©s. Notions : Random, do-while, tableaux de bool√©ens. 10. Calculateur de Moyennes Multidimensionnel Sc√©nario : G√©rer les notes d‚Äôune classe de 3 √©tudiants ayant chacun 4 examens. Exigences : D√©clarer un double[3, 4]. Remplir le tableau via des saisies utilisateur. M√©thode MoyenneEtudiant(int index) : calcule la moyenne d‚Äôune ligne. M√©thode MoyenneExamen(int index) : calcule la moyenne d‚Äôune colonne. Notions : Tableaux 2D, boucles imbriqu√©es. 11. Simulateur de File d‚ÄôAttente (Banque) Sc√©nario : G√©rer l‚Äôordre de passage des clients. Exigences : Une List\u003cstring\u003e simulant une file d‚Äôattente. Options : ‚ÄúNouveau client‚Äù, ‚ÄúServir prochain‚Äù, ‚ÄúAfficher file‚Äù. ‚ÄúServir prochain‚Äù doit afficher le nom et retirer le premier √©l√©ment (index 0). Notions : List.Add(), List.RemoveAt(). 12. Cr√©ateur de Deck de Cartes et M√©langeur Sc√©nario : G√©n√©rer et m√©langer un jeu de 52 cartes. Exigences : Deux tableaux : couleurs (Pique, Coeur‚Ä¶) et valeurs (As, 2, 3‚Ä¶). G√©n√©rer les 52 combinaisons dans une List\u003cstring\u003e. Algorithme de m√©lange : √©changer chaque carte avec une autre √† un index al√©atoire. Notions : Boucles imbriqu√©es, algorithme de permutation (Swap). 13. D√©tecteur de Palindromes et de ‚ÄúMirroring‚Äù Sc√©nario : Analyser si un mot est identique √† l‚Äôenvers. Exigences : Saisir un mot. Cr√©er une m√©thode EstPalindrome(string mot). Inverser la cha√Æne manuellement dans un tableau de caract√®res pour comparer. Ne pas utiliser Array.Reverse(). Notions : Boucle for d√©croissante, manipulation de cha√Ænes. 14. Inventaire de Magasin (Tableaux Dentel√©s) Sc√©nario : G√©rer des rayons de diff√©rentes tailles. Exigences : Un tableau dentel√© string[][] rayons = new string[3][]. Rayon 1 : 2 produits, Rayon 2 : 5 produits, Rayon 3 : 3 produits. L‚Äôutilisateur peut modifier un produit en sp√©cifiant [rayon, index]. Notions : Jagged Arrays, gestion des limites de tableaux. 15. Le Juste Prix (Multi-joueurs) Sc√©nario : Deviner un prix secret g√©n√©r√© al√©atoirement. Exigences : Le programme g√©n√®re un nombre entre 1 et 1000. Plusieurs joueurs entrent leur nom. Chacun joue √† tour de r√¥le. Le programme indique ‚ÄúC‚Äôest plus !‚Äù ou ‚ÄúC‚Äôest moins !‚Äù. Notions : Random, listes de noms, boucle de jeu. 16. Syst√®me de Login avec Blocage Sc√©nario : S√©curiser l‚Äôacc√®s √† une console. Exigences : Stocker les utilisateurs/mots de passe dans deux tableaux parall√®les ou un dictionnaire. L‚Äôutilisateur a 3 tentatives. Apr√®s 3 erreurs, le programme se verrouille (utilise Thread.Sleep pour simuler une attente). Notions : Compteurs, conditions logiques, s√©curit√© de base. 17. Analyseur de Texte : Compteur de Mots Sc√©nario : Analyser la structure d‚Äôun paragraphe. Exigences : L‚Äôutilisateur entre un long texte. Compter le nombre de mots (d√©limit√©s par des espaces). Compter l‚Äôoccurrence d‚Äôune lettre sp√©cifique demand√©e √† l‚Äôutilisateur. Notions : string.Split(), foreach, compteurs. 18. Calculateur d‚ÄôIMC Professionnel Sc√©nario : Sant√© et nutrition. Exigences : Saisir le nom, le poids et la taille de plusieurs patients. Calculer l‚ÄôIMC ($poids / taille^2$). M√©thode InterpreterIMC(double imc) : retourne une cha√Æne (Maigreur, Normal, Ob√®se). Notions : M√©thodes de retour, formules math√©matiques. 19. Gestionnaire de T√¢ches avec Priorit√© Sc√©nario : Une To-Do List intelligente. Exigences : Stocker les t√¢ches dans une liste. L‚Äôutilisateur peut ajouter une t√¢che avec un niveau d‚Äôimportance (Haute, Moyenne, Basse). Afficher les t√¢ches filtr√©es manuellement : d‚Äôabord toutes les ‚ÄúHaute‚Äù, ensuite les autres. Notions : Filtrage par boucles, comparaisons de cha√Ænes. 20. Le Carr√© Magique (Validation de Grille) Sc√©nario : V√©rifier si une grille 3x3 est un carr√© magique. Exigences : L‚Äôutilisateur entre 9 nombres dans un tableau int[3, 3]. Le programme doit calculer la somme de chaque ligne, chaque colonne et des deux diagonales. Si toutes les sommes sont √©gales, c‚Äôest un carr√© magique ! Notions : Algorithmique avanc√©e sur tableaux 2D.",
    "description": "Premi√®re partie 1 : Calculatrice Simple Concepts pratiqu√©s : Variables, op√©rateurs arithm√©tiques, types num√©riques\nDescription : Cr√©ez un programme qui demande √† l‚Äôutilisateur deux nombres et une op√©ration (+, -, *, /), puis affiche le r√©sultat.\nFonctionnalit√©s requises :\nDemander deux nombres d√©cimaux √† l‚Äôutilisateur Demander l‚Äôop√©ration souhait√©e Effectuer le calcul appropri√© Afficher le r√©sultat avec 2 d√©cimales G√©rer la division par z√©ro Exemple d‚Äôex√©cution :",
    "tags": [],
    "title": "S√©rie d'exercices 1",
    "uri": "/420-413/serie_exos_1/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Table des mati√®res Introduction √† la POO Les Classes et les Objets Les Attributs (Champs) Les Propri√©t√©s (Properties) L‚ÄôEncapsulation Les M√©thodes Les Constructeurs L‚ÄôH√©ritage Le Polymorphisme 1. Introduction √† la POO 1.1 Qu‚Äôest-ce que la Programmation Orient√©e Objet ? La Programmation Orient√©e Objet (POO) est un paradigme de programmation qui organise le code autour du concept d‚Äôobjets plut√¥t que de fonctions et de logique. Un objet combine des donn√©es (ce qu‚Äôil poss√®de) et des comportements (ce qu‚Äôil peut faire).\nüåç Analogie du monde r√©el Pensez √† une voiture dans le monde r√©el :\nDonn√©es : couleur, marque, mod√®le, vitesse actuelle, niveau d‚Äôessence Comportements : d√©marrer, acc√©l√©rer, freiner, tourner, klaxonner En POO, nous mod√©lisons ces concepts du monde r√©el dans notre code.\n1.2 Pourquoi utiliser la POO ? Avant la POO (Programmation proc√©durale) :\n// Variables dispers√©es string voitureMarque = \"Toyota\"; string voitureModele = \"Camry\"; int voitureVitesse = 0; // Fonctions s√©par√©es void DemarrerVoiture() { /* ... */ } void AccelererVoiture(int vitesse) { /* ... */ } Avec la POO :\n// Tout est regroup√© logiquement class Voiture { string marque; string modele; int vitesse; void Demarrer() { /* ... */ } void Accelerer(int increment) { /* ... */ } } Avantages de la POO :\nOrganisation : Le code est structur√© et logique R√©utilisabilit√© : Les classes peuvent √™tre r√©utilis√©es Maintenabilit√© : Plus facile √† maintenir et modifier Modularit√© : Chaque classe a une responsabilit√© claire Abstraction : Cache la complexit√© interne 1.3 Les 4 Piliers Fondamentaux de la POO 1Ô∏è‚É£ Encapsulation Regrouper les donn√©es et les m√©thodes ensemble, et contr√¥ler l‚Äôacc√®s aux donn√©es.\nExemple concret : Un compte bancaire\nVous ne pouvez pas modifier directement le solde Vous devez passer par des m√©thodes (d√©poser, retirer) Cela prot√®ge l‚Äôint√©grit√© des donn√©es 2Ô∏è‚É£ H√©ritage Cr√©er de nouvelles classes bas√©es sur des classes existantes.\nExemple concret : V√©hicules\nClasse de base : Vehicule (propri√©t√©s communes : marque, mod√®le) Classes d√©riv√©es : Voiture, Moto, Camion (ajoutent leurs sp√©cificit√©s) 3Ô∏è‚É£ Polymorphisme Utiliser une m√™me interface pour des types diff√©rents.\nExemple concret : Animaux\nTous peuvent ‚Äú√©mettre un son‚Äù Le chien aboie, le chat miaule, l‚Äôoiseau chante M√™me m√©thode, comportements diff√©rents 4Ô∏è‚É£ Abstraction Montrer seulement l‚Äôessentiel, cacher les d√©tails complexes.\nExemple concret : Conduire une voiture\nVous utilisez le volant, les p√©dales Vous n‚Äôavez pas besoin de comprendre le moteur interne 2. Les Classes et les Objets 2.1 Qu‚Äôest-ce qu‚Äôune Classe ? Une classe est un plan ou un mod√®le qui d√©finit la structure et le comportement d‚Äôobjets. C‚Äôest comme un plan d‚Äôarchitecte pour construire une maison.\nM√©taphore :\nUne classe est comme un moule √† biscuits üç™ Les objets sont les biscuits cr√©√©s avec ce moule Tous les biscuits ont la m√™me forme (structure), mais peuvent avoir des diff√©rences (valeurs) 2.2 Qu‚Äôest-ce qu‚Äôun Objet ? Un objet est une instance d‚Äôune classe. C‚Äôest une entit√© concr√®te cr√©√©e √† partir du mod√®le d√©fini par la classe.\n2.3 Anatomie d‚Äôune Classe // D√©claration d'une classe public class Personne { // ========================================== // ATTRIBUTS (CHAMPS) - Ce que l'objet poss√®de // ========================================== private string nom; private string prenom; private int age; // ========================================== // PROPRI√âT√âS - Interface contr√¥l√©e pour les attributs // ========================================== public string Nom { get { return nom; } set { nom = value; } } // ========================================== // CONSTRUCTEUR - Comment cr√©er l'objet // ========================================== public Personne(string nom, string prenom, int age) { this.nom = nom; this.prenom = prenom; this.age = age; } // ========================================== // M√âTHODES - Ce que l'objet peut faire // ========================================== public void SePresenter() { Console.WriteLine($\"Bonjour, je suis {prenom} {nom}, {age} ans.\"); } } 2.4 Cr√©ation et Utilisation d‚ÄôObjets class Program { static void Main() { // ========================================== // CR√âATION D'OBJETS (INSTANCIATION) // ========================================== // Syntaxe : Type nomVariable = new Constructeur(); Personne personne1 = new Personne(\"Tremblay\", \"Marie\", 25); Personne personne2 = new Personne(\"Gagnon\", \"Jean\", 30); Personne personne3 = new Personne(\"Roy\", \"Sophie\", 28); // Chaque objet est UNIQUE et IND√âPENDANT // personne1, personne2, personne3 sont 3 objets diff√©rents // ========================================== // UTILISATION DES OBJETS // ========================================== personne1.SePresenter(); // Affiche: Bonjour, je suis Marie Tremblay, 25 ans. personne2.SePresenter(); // Affiche: Bonjour, je suis Jean Gagnon, 30 ans. // Acc√®s aux propri√©t√©s Console.WriteLine(personne1.Nom); // Affiche: Tremblay } } 2.5 Comprendre la M√©moire : R√©f√©rence vs Valeur // Les CLASSES sont des types R√âF√âRENCE Personne p1 = new Personne(\"Dubois\", \"Luc\", 35); Personne p2 = p1; // p2 pointe vers le M√äME objet que p1 p2.Nom = \"Martin\"; // Modifie l'objet Console.WriteLine(p1.Nom); // Affiche: Martin Console.WriteLine(p2.Nom); // Affiche: Martin // p1 et p2 pointent vers le m√™me objet en m√©moire ! Illustration :\nM√©moire:\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ Objet Personne ‚îÇ\r‚îÇ Nom: \"Martin\" ‚îÇ ‚Üê‚îÄ‚îÄ p1 pointe ici\r‚îÇ Prenom: \"Luc\" ‚îÇ ‚Üê‚îÄ‚îÄ p2 pointe ici aussi\r‚îÇ Age: 35 ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò 3. Les Attributs (Champs) 3.1 D√©finition Les attributs (ou champs ou fields) sont des variables d√©clar√©es directement dans une classe. Ils repr√©sentent l‚Äô√©tat ou les donn√©es de l‚Äôobjet.\n3.2 D√©claration des Attributs public class CompteBancaire { // ========================================== // ATTRIBUTS PRIV√âS (convention : pr√©fixe _) // ========================================== private string _numeroCompte; private string _titulaire; private decimal _solde; private DateTime _dateOuverture; private bool _estActif; // ========================================== // ATTRIBUTS PUBLICS (√† √©viter g√©n√©ralement) // ========================================== public int nombreTransactions; // Moins s√©curis√© } 3.3 Pourquoi des Attributs Priv√©s ? ‚ùå Probl√®me avec des attributs publics :\npublic class CompteBancaire { public decimal solde; // PUBLIC = DANGER ! } // Dans le code utilisateur CompteBancaire compte = new CompteBancaire(); compte.solde = -5000; // ‚ùå On peut mettre n'importe quoi ! compte.solde = 999999999; // ‚ùå Aucune validation ! ‚úÖ Solution avec des attributs priv√©s :\npublic class CompteBancaire { private decimal _solde; // PRIV√â = PROT√âG√â public void Deposer(decimal montant) { if (montant \u003e 0) // ‚úÖ Validation { _solde += montant; } } } 3.4 Initialisation des Attributs public class Voiture { // Initialisation lors de la d√©claration private string _marque = \"Inconnue\"; private int _annee = 2020; private double _kilometrage = 0.0; private bool _estDemarree = false; // Sans initialisation (valeurs par d√©faut) private int _nombrePortes; // 0 par d√©faut private string _couleur; // null par d√©faut } Valeurs par d√©faut en C# :\nint, double, float : 0 bool : false string, objets : null DateTime : 01/01/0001 00:00:00 4. Les Propri√©t√©s (Properties) 4.1 Qu‚Äôest-ce qu‚Äôune Propri√©t√© ? Une propri√©t√© est un membre de classe qui fournit un m√©canisme flexible pour lire et √©crire les valeurs des attributs priv√©s. C‚Äôest l‚Äôinterface publique pour acc√©der aux donn√©es priv√©es.\nAnalogie :\nL‚Äôattribut priv√© = Le coffre-fort üîí La propri√©t√© = La porte avec code d‚Äôacc√®s üö™ Le getter = Ouvrir pour voir le contenu üëÄ Le setter = Ouvrir pour modifier le contenu ‚úçÔ∏è 4.2 Syntaxe Compl√®te d‚Äôune Propri√©t√© public class Personne { // ========================================== // ATTRIBUT PRIV√â // ========================================== private int _age; // ========================================== // PROPRI√âT√â AVEC GET ET SET COMPLETS // ========================================== public int Age { // GETTER - Lit la valeur get { Console.WriteLine(\"Lecture de l'√¢ge\"); return _age; } // SETTER - Modifie la valeur set { Console.WriteLine($\"Modification de l'√¢ge: {value}\"); // VALIDATION avant d'assigner if (value \u003e= 0 \u0026\u0026 value \u003c= 150) { _age = value; } else { Console.WriteLine(\"√Çge invalide!\"); } } } } // Utilisation Personne p = new Personne(); p.Age = 25; // Appelle le SETTER avec value = 25 int monAge = p.Age; // Appelle le GETTER 4.3 Types de Propri√©t√©s A) Propri√©t√© Lecture/√âcriture (Get/Set) public class Produit { private string _nom; public string Nom { get { return _nom; } set { _nom = value; } } } B) Propri√©t√© en Lecture Seule (Get seulement) public class Personne { private DateTime _dateNaissance; // On peut LIRE mais pas MODIFIER de l'ext√©rieur public DateTime DateNaissance { get { return _dateNaissance; } // Pas de SET = lecture seule } public Personne(DateTime dateNaissance) { _dateNaissance = dateNaissance; // D√©fini dans le constructeur } } // Utilisation Personne p = new Personne(new DateTime(1990, 5, 15)); Console.WriteLine(p.DateNaissance); // ‚úÖ OK - Lecture // p.DateNaissance = DateTime.Now; // ‚ùå ERREUR - Pas de setter! C) Propri√©t√© en √âcriture Seule (Set seulement) - RARE public class CompteSecurise { private string _motDePasse; // On peut √âCRIRE mais pas LIRE (pour la s√©curit√©) public string MotDePasse { set { _motDePasse = HashPassword(value); } // Pas de GET pour des raisons de s√©curit√© } private string HashPassword(string password) { // Logique de hachage return password; // Simplifi√© } } D) Propri√©t√© Auto-Impl√©ment√©e (Raccourci) public class Livre { // ========================================== // PROPRI√âT√â AUTO-IMPL√âMENT√âE // Le compilateur cr√©e automatiquement un attribut priv√© cach√© // ========================================== public string Titre { get; set; } public string Auteur { get; set; } public int NombrePages { get; set; } // √âquivalent √† : // private string _titre; // public string Titre { get { return _titre; } set { _titre = value; } } } // Utilisation Livre livre = new Livre(); livre.Titre = \"Le Petit Prince\"; livre.Auteur = \"Antoine de Saint-Exup√©ry\"; livre.NombrePages = 96; E) Propri√©t√© avec Logique M√©tier public class Rectangle { private double _longueur; private double _largeur; public double Longueur { get { return _longueur; } set { if (value \u003e 0) _longueur = value; else throw new ArgumentException(\"La longueur doit √™tre positive\"); } } public double Largeur { get { return _largeur; } set { if (value \u003e 0) _largeur = value; else throw new ArgumentException(\"La largeur doit √™tre positive\"); } } // ========================================== // PROPRI√âT√â CALCUL√âE (pas d'attribut associ√©) // ========================================== public double Aire { get { return _longueur * _largeur; } // Pas de SET - calcul√©e √† chaque fois } public double Perimetre { get { return 2 * (_longueur + _largeur); } } } // Utilisation Rectangle rect = new Rectangle(); rect.Longueur = 5; rect.Largeur = 3; Console.WriteLine($\"Aire: {rect.Aire}\"); // 15 Console.WriteLine($\"P√©rim√®tre: {rect.Perimetre}\"); // 16 F) Propri√©t√© avec Accessibilit√© Diff√©rente public class CompteBancaire { private decimal _solde; // ========================================== // GET public, SET priv√© // Tout le monde peut LIRE, seule la classe peut MODIFIER // ========================================== public decimal Solde { get { return _solde; } private set { _solde = value; } // SET PRIV√â } // M√©thodes publiques pour modifier le solde de mani√®re contr√¥l√©e public void Deposer(decimal montant) { if (montant \u003e 0) Solde += montant; // Utilise le setter priv√© } public bool Retirer(decimal montant) { if (montant \u003e 0 \u0026\u0026 montant \u003c= Solde) { Solde -= montant; // Utilise le setter priv√© return true; } return false; } } // Utilisation CompteBancaire compte = new CompteBancaire(); Console.WriteLine(compte.Solde); // ‚úÖ OK - Lecture publique // compte.Solde = 1000; // ‚ùå ERREUR - Set est priv√© compte.Deposer(1000); // ‚úÖ OK - M√©thode publique 4.4 Le Mot-Cl√© value Dans un setter, le mot-cl√© value repr√©sente la valeur qu‚Äôon essaie d‚Äôassigner.\npublic class Exemple { private int _nombre; public int Nombre { get { return _nombre; } set { // 'value' contient la valeur assign√©e Console.WriteLine($\"Valeur re√ßue: {value}\"); _nombre = value; } } } // Utilisation Exemple ex = new Exemple(); ex.Nombre = 42; // 'value' vaut 42 dans le setter 4.5 Propri√©t√©s: Quand Utiliser Quoi ? Situation Type de Propri√©t√© Donn√©es simples sans validation Auto-impl√©ment√©e { get; set; } Donn√©es n√©cessitant validation Propri√©t√© compl√®te avec logique Donn√©es calcul√©es Get seulement (calcul√©e) Donn√©es d√©finies √† la cr√©ation Get seulement + constructeur Donn√©es sensibles Get public, Set priv√© Mot de passe Set seulement (√©criture seule) 5. L‚ÄôEncapsulation 5.1 D√©finition Approfondie L‚Äôencapsulation est le principe qui consiste √† :\nRegrouper les donn√©es (attributs) et les comportements (m√©thodes) dans une classe Cacher les d√©tails d‚Äôimpl√©mentation internes Contr√¥ler l‚Äôacc√®s aux donn√©es via une interface publique M√©taphore de la voiture :\nVous n‚Äôavez pas besoin de comprendre comment fonctionne le moteur (d√©tails cach√©s) Vous utilisez le volant, les p√©dales, le levier de vitesse (interface publique) Le moteur est prot√©g√© sous le capot (encapsulation) 5.2 Modificateurs d‚ÄôAcc√®s Les modificateurs d‚Äôacc√®s contr√¥lent QUI peut acc√©der √† quoi.\nTableau Complet des Modificateurs Modificateur Acc√®s Usage Typique private Classe uniquement Attributs, m√©thodes internes protected Classe + classes d√©riv√©es M√©thodes partag√©es avec enfants internal M√™me assembly (projet) Classes utilitaires internes protected internal Assembly OU d√©riv√©es Cas sp√©cifiques public Partout Interface publique, API Exemples D√©taill√©s public class Voiture { // ========================================== // PRIVATE - Accessible UNIQUEMENT dans cette classe // ========================================== private string _numeroSerie; // Donn√©e sensible private int _temperatureMoteur; // D√©tail interne private void DemarrerMoteur() // M√©thode interne { Console.WriteLine(\"Moteur d√©marr√©\"); } // ========================================== // PROTECTED - Accessible dans cette classe ET ses d√©riv√©es // ========================================== protected double _consommationBase; // Les classes enfants peuvent y acc√©der protected void CalculerConsommation() // M√©thode pour les d√©riv√©es { Console.WriteLine(\"Calcul de la consommation\"); } // ========================================== // PUBLIC - Accessible PARTOUT // ========================================== public string Marque { get; set; } // Propri√©t√© publique public string Modele { get; set; } public void Demarrer() // M√©thode publique (interface) { DemarrerMoteur(); // Appelle la m√©thode priv√©e Console.WriteLine(\"Voiture d√©marr√©e\"); } public void Accelerer(int vitesse) { // Interface publique qui utilise des d√©tails priv√©s _temperatureMoteur += 10; Console.WriteLine($\"Acc√©l√©ration √† {vitesse} km/h\"); } } // Classe d√©riv√©e public class VoitureElectrique : Voiture { public void ChargerBatterie() { // ‚úÖ OK - Acc√®s √† protected _consommationBase = 0.15; CalculerConsommation(); // ‚ùå ERREUR - Pas d'acc√®s √† private // _numeroSerie = \"123\"; // ERREUR DE COMPILATION // DemarrerMoteur(); // ERREUR DE COMPILATION // ‚úÖ OK - Acc√®s √† public Marque = \"Tesla\"; Demarrer(); } } // Utilisation externe class Program { static void Main() { Voiture maVoiture = new Voiture(); // ‚úÖ OK - Acc√®s aux membres publics maVoiture.Marque = \"Toyota\"; maVoiture.Demarrer(); maVoiture.Accelerer(50); // ‚ùå ERREUR - Pas d'acc√®s aux membres priv√©s // maVoiture._numeroSerie = \"ABC123\"; // ERREUR // maVoiture.DemarrerMoteur(); // ERREUR // ‚ùå ERREUR - Pas d'acc√®s aux membres protected // maVoiture._consommationBase = 0.10; // ERREUR // maVoiture.CalculerConsommation(); // ERREUR } } 5.3 Exemple Complet : Compte Bancaire Bien Encapsul√© public class CompteBancaire { // ========================================== // ATTRIBUTS PRIV√âS - √âtat interne prot√©g√© // ========================================== private string _numeroCompte; private string _titulaire; private decimal _solde; private List\u003cstring\u003e _historiqueTransactions; private DateTime _dateOuverture; private const decimal FRAIS_RETRAIT = 1.50m; // Constante priv√©e // ========================================== // PROPRI√âT√âS PUBLIQUES - Interface contr√¥l√©e // ========================================== // Lecture seule de l'ext√©rieur public string NumeroCompte { get { return _numeroCompte; } private set { _numeroCompte = value; } } public string Titulaire { get { return _titulaire; } set { if (!string.IsNullOrWhiteSpace(value)) _titulaire = value; } } // Lecture seule - impossible de modifier directement public decimal Solde { get { return _solde; } private set { _solde = value; } } public DateTime DateOuverture { get { return _dateOuverture; } } // ========================================== // CONSTRUCTEUR // ========================================== public CompteBancaire(string titulaire, string numeroCompte) { _titulaire = titulaire; _numeroCompte = numeroCompte; _solde = 0; _dateOuverture = DateTime.Now; _historiqueTransactions = new List\u003cstring\u003e(); AjouterTransaction(\"Ouverture du compte\"); } // ========================================== // M√âTHODES PUBLIQUES - Actions autoris√©es // ========================================== public bool Deposer(decimal montant) { if (montant \u003c= 0) { Console.WriteLine(\"Le montant doit √™tre positif\"); return false; } _solde += montant; AjouterTransaction($\"D√©p√¥t de {montant:C}\"); Console.WriteLine($\"D√©p√¥t r√©ussi. Nouveau solde: {_solde:C}\"); return true; } public bool Retirer(decimal montant) { if (montant \u003c= 0) { Console.WriteLine(\"Le montant doit √™tre positif\"); return false; } decimal montantTotal = montant + FRAIS_RETRAIT; if (montantTotal \u003e _solde) { Console.WriteLine(\"Solde insuffisant\"); return false; } _solde -= montantTotal; AjouterTransaction($\"Retrait de {montant:C} (frais: {FRAIS_RETRAIT:C})\"); Console.WriteLine($\"Retrait r√©ussi. Nouveau solde: {_solde:C}\"); return true; } public void AfficherHistorique() { Console.WriteLine($\"\\n=== Historique du compte {_numeroCompte} ===\"); foreach (string transaction in _historiqueTransactions) { Console.WriteLine(transaction); } } // ========================================== // M√âTHODES PRIV√âES - D√©tails d'impl√©mentation // ========================================== private void AjouterTransaction(string description) { string transaction = $\"{DateTime.Now:dd/MM/yyyy HH:mm:ss} - {description}\"; _historiqueTransactions.Add(transaction); } private bool VerifierFrauude() { // Logique complexe de v√©rification return true; } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { CompteBancaire compte = new CompteBancaire(\"Jean Dupont\", \"12345\"); // ‚úÖ Interface publique propre et s√©curis√©e compte.Deposer(1000); compte.Retirer(50); compte.AfficherHistorique(); // ‚úÖ Lecture s√©curis√©e Console.WriteLine($\"Solde actuel: {compte.Solde:C}\"); // ‚ùå Impossible de tricher! // compte.Solde = 9999999; // ERREUR - Setter priv√© // compte._solde += 1000; // ERREUR - Attribut priv√© } } 5.4 Avantages de l‚ÄôEncapsulation S√©curit√© : Protection des donn√©es contre les modifications non autoris√©es Validation : Contr√¥le des valeurs assign√©es Flexibilit√© : Modification de l‚Äôimpl√©mentation interne sans casser le code externe Maintenance : Code plus facile √† comprendre et modifier D√©bogage : Points de contr√¥le clairs pour tracer les probl√®mes 6. Les M√©thodes 6.1 D√©finition Les m√©thodes sont des fonctions d√©finies √† l‚Äôint√©rieur d‚Äôune classe. Elles repr√©sentent les comportements ou actions que les objets peuvent effectuer.\n6.2 Syntaxe Compl√®te [modificateur d'acc√®s] [modificateurs] [type de retour] NomMethode([param√®tres]) { // Corps de la m√©thode return valeur; // Si type de retour n'est pas void } 6.3 Types de M√©thodes A) M√©thode Sans Retour (void) public class Robot { public void Avancer() { Console.WriteLine(\"Le robot avance\"); // Pas de return - void signifie \"ne retourne rien\" } public void Saluer(string nom) { Console.WriteLine($\"Bonjour {nom}!\"); } } B) M√©thode Avec Retour public class Calculatrice { public int Additionner(int a, int b) { int resultat = a + b; return resultat; // DOIT retourner un int } public double CalculerMoyenne(double[] nombres) { double somme = 0; foreach (double nombre in nombres) { somme += nombre; } return somme / nombres.Length; } public bool EstPair(int nombre) { return nombre % 2 == 0; // Retourne true ou false } } C) M√©thode Avec Param√®tres public class GestionnaireEmail { // Param√®tres obligatoires public void EnvoyerEmail(string destinataire, string sujet, string message) { Console.WriteLine($\"√Ä: {destinataire}\"); Console.WriteLine($\"Sujet: {sujet}\"); Console.WriteLine($\"Message: {message}\"); } // Param√®tres avec valeurs par d√©faut public void EnvoyerNotification(string message, string niveau = \"INFO\") { Console.WriteLine($\"[{niveau}] {message}\"); } } // Utilisation GestionnaireEmail gestionnaire = new GestionnaireEmail(); gestionnaire.EnvoyerEmail(\"jean@example.com\", \"Bienvenue\", \"Bonjour!\"); gestionnaire.EnvoyerNotification(\"Syst√®me d√©marr√©\"); // Utilise niveau par d√©faut gestionnaire.EnvoyerNotification(\"Erreur d√©tect√©e\", \"ERREUR\"); // Sp√©cifie le niveau D) Surcharge de M√©thodes (Overloading) Plusieurs m√©thodes avec le m√™me nom mais des param√®tres diff√©rents.\npublic class Calculatrice { // M√™me nom, param√®tres diff√©rents public int Additionner(int a, int b) { return a + b; } public int Additionner(int a, int b, int c) { return a + b + c; } public double Additionner(double a, double b) { return a + b; } public int Additionner(params int[] nombres) // Nombre variable de param√®tres { int somme = 0; foreach (int nombre in nombres) { somme += nombre; } return somme; } } // Utilisation Calculatrice calc = new Calculatrice(); calc.Additionner(5, 3); // Appelle la version √† 2 int calc.Additionner(5, 3, 2); // Appelle la version √† 3 int calc.Additionner(5.5, 3.2); // Appelle la version √† 2 double calc.Additionner(1, 2, 3, 4, 5, 6); // Appelle la version avec params 6.4 Le Mot-Cl√© this this fait r√©f√©rence √† l‚Äôinstance actuelle de la classe.\npublic class Personne { private string nom; private int age; public Personne(string nom, int age) { // 'this.nom' = attribut de la classe // 'nom' = param√®tre du constructeur this.nom = nom; // Distingue l'attribut du param√®tre this.age = age; } public void Comparer(Personne autre) { if (this.age \u003e autre.age) { Console.WriteLine($\"{this.nom} est plus √¢g√© que {autre.nom}\"); } } public Personne ObtenirR√©f√©rence() { return this; // Retourne l'objet lui-m√™me } } 6.5 M√©thodes d‚ÄôInstance vs M√©thodes Statiques public class Utilitaires { // Attribut d'instance private int compteur = 0; // ========================================== // M√âTHODE D'INSTANCE - N√©cessite un objet // ========================================== public void Incrementer() { compteur++; // Acc√®de √† l'attribut d'instance Console.WriteLine($\"Compteur: {compteur}\"); } // ========================================== // M√âTHODE STATIQUE - Pas besoin d'objet // ========================================== public static int Additionner(int a, int b) { // Ne peut PAS acc√©der aux membres d'instance // compteur++; // ‚ùå ERREUR! return a + b; } public static double CalculerAire(double rayon) { return Math.PI * rayon * rayon; } } // Utilisation // M√©thode d'instance Utilitaires util = new Utilitaires(); util.Incrementer(); // Besoin d'un objet // M√©thode statique int somme = Utilitaires.Additionner(5, 3); // Pas besoin d'objet double aire = Utilitaires.CalculerAire(5); 7. Les Constructeurs 7.1 D√©finition Approfondie Un constructeur est une m√©thode sp√©ciale qui est automatiquement appel√©e lors de la cr√©ation d‚Äôun objet. Son r√¥le principal est d‚Äôinitialiser l‚Äôobjet dans un √©tat valide.\nCaract√©ristiques d‚Äôun constructeur :\nM√™me nom que la classe Pas de type de retour (m√™me pas void) Peut avoir des param√®tres Peut √™tre surcharg√© (plusieurs constructeurs diff√©rents) Appel√© automatiquement avec new M√©taphore : Le constructeur est comme le mode d‚Äôemploi d‚Äôassemblage d‚Äôun meuble IKEA. Il d√©finit comment cr√©er et pr√©parer l‚Äôobjet pour qu‚Äôil soit utilisable.\n7.2 Constructeur Par D√©faut public class Voiture { public string Marque; public string Modele; public int Annee; // ========================================== // CONSTRUCTEUR PAR D√âFAUT (sans param√®tres) // ========================================== public Voiture() { Console.WriteLine(\"Construction d'une voiture...\"); Marque = \"Inconnue\"; Modele = \"Standard\"; Annee = 2020; } } // Utilisation Voiture v = new Voiture(); // Appelle le constructeur par d√©faut Console.WriteLine($\"{v.Marque} {v.Modele}\"); // Inconnue Standard Important : Si vous ne d√©finissez AUCUN constructeur, C# cr√©e automatiquement un constructeur par d√©faut vide. Mais si vous d√©finissez au moins un constructeur, le constructeur par d√©faut automatique dispara√Æt.\npublic class Exemple1 { // Pas de constructeur d√©fini // C# cr√©e automatiquement : public Exemple1() { } } public class Exemple2 { public Exemple2(int valeur) { } // Le constructeur par d√©faut automatique N'EXISTE PLUS } // Utilisation Exemple1 e1 = new Exemple1(); // ‚úÖ OK Exemple2 e2 = new Exemple2(); // ‚ùå ERREUR - Pas de constructeur sans param√®tre Exemple2 e3 = new Exemple2(5); // ‚úÖ OK 7.3 Constructeur Avec Param√®tres public class Personne { public string Nom { get; set; } public string Prenom { get; set; } public int Age { get; set; } // ========================================== // CONSTRUCTEUR AVEC PARAM√àTRES // ========================================== public Personne(string nom, string prenom, int age) { Console.WriteLine(\"Cr√©ation d'une personne...\"); // Validation avant assignation if (string.IsNullOrWhiteSpace(nom)) throw new ArgumentException(\"Le nom ne peut pas √™tre vide\"); if (age \u003c 0 || age \u003e 150) throw new ArgumentException(\"√Çge invalide\"); Nom = nom; Prenom = prenom; Age = age; } } // Utilisation Personne p1 = new Personne(\"Tremblay\", \"Marie\", 25); // Personne p2 = new Personne(\"\", \"Jean\", 30); // ‚ùå Exception lev√©e 7.4 Surcharge de Constructeurs Une classe peut avoir plusieurs constructeurs avec diff√©rents param√®tres.\npublic class Livre { public string Titre { get; set; } public string Auteur { get; set; } public int Annee { get; set; } public int Pages { get; set; } // ========================================== // CONSTRUCTEUR 1 : Sans param√®tres // ========================================== public Livre() { Titre = \"Sans titre\"; Auteur = \"Anonyme\"; Annee = DateTime.Now.Year; Pages = 0; Console.WriteLine(\"Livre cr√©√© avec valeurs par d√©faut\"); } // ========================================== // CONSTRUCTEUR 2 : Titre seulement // ========================================== public Livre(string titre) { Titre = titre; Auteur = \"Anonyme\"; Annee = DateTime.Now.Year; Pages = 0; Console.WriteLine($\"Livre '{titre}' cr√©√©\"); } // ========================================== // CONSTRUCTEUR 3 : Titre et Auteur // ========================================== public Livre(string titre, string auteur) { Titre = titre; Auteur = auteur; Annee = DateTime.Now.Year; Pages = 0; Console.WriteLine($\"Livre '{titre}' de {auteur} cr√©√©\"); } // ========================================== // CONSTRUCTEUR 4 : Tous les param√®tres // ========================================== public Livre(string titre, string auteur, int annee, int pages) { Titre = titre; Auteur = auteur; Annee = annee; Pages = pages; Console.WriteLine($\"Livre complet cr√©√©\"); } } // Utilisation - Le compilateur choisit le bon constructeur Livre l1 = new Livre(); // Constructeur 1 Livre l2 = new Livre(\"1984\"); // Constructeur 2 Livre l3 = new Livre(\"Le Petit Prince\", \"Saint-Exup√©ry\"); // Constructeur 3 Livre l4 = new Livre(\"Dune\", \"Frank Herbert\", 1965, 412); // Constructeur 4 7.5 Cha√Ænage de Constructeurs avec this Pour √©viter la duplication de code, un constructeur peut appeler un autre constructeur de la m√™me classe avec : this().\npublic class Rectangle { public double Longueur { get; set; } public double Largeur { get; set; } public string Couleur { get; set; } // ========================================== // CONSTRUCTEUR PRINCIPAL (le plus complet) // ========================================== public Rectangle(double longueur, double largeur, string couleur) { Console.WriteLine(\"Constructeur principal appel√©\"); Longueur = longueur; Largeur = largeur; Couleur = couleur; } // ========================================== // CONSTRUCTEUR qui appelle le principal // ========================================== public Rectangle(double longueur, double largeur) : this(longueur, largeur, \"Blanc\") // Appelle le constructeur principal { Console.WriteLine(\"Constructeur sans couleur\"); // Pas besoin de r√©p√©ter l'assignation de longueur et largeur } // ========================================== // CONSTRUCTEUR pour un carr√© // ========================================== public Rectangle(double cote) : this(cote, cote, \"Blanc\") // Appelle le constructeur principal { Console.WriteLine(\"Constructeur pour carr√©\"); } // ========================================== // CONSTRUCTEUR par d√©faut // ========================================== public Rectangle() : this(1, 1, \"Blanc\") // Appelle le constructeur principal { Console.WriteLine(\"Constructeur par d√©faut\"); } } // Utilisation Rectangle r1 = new Rectangle(5, 3, \"Rouge\"); // Affiche: \"Constructeur principal appel√©\" Rectangle r2 = new Rectangle(5, 3); // Affiche: \"Constructeur principal appel√©\" // \"Constructeur sans couleur\" Rectangle r3 = new Rectangle(4); // Affiche: \"Constructeur principal appel√©\" // \"Constructeur pour carr√©\" Ordre d‚Äôex√©cution :\nLe constructeur appel√© avec : this() s‚Äôex√©cute en PREMIER Puis le constructeur actuel s‚Äôex√©cute 7.6 Constructeurs Priv√©s Un constructeur peut √™tre priv√© pour contr√¥ler la cr√©ation d‚Äôinstances.\n// ========================================== // PATTERN SINGLETON - Une seule instance possible // ========================================== public class Configuration { private static Configuration _instance = null; public string CheminFichier { get; set; } public string Langue { get; set; } // ========================================== // CONSTRUCTEUR PRIV√â - Impossible de faire 'new Configuration()' // ========================================== private Configuration() { CheminFichier = \"config.json\"; Langue = \"fr\"; Console.WriteLine(\"Configuration cr√©√©e\"); } // ========================================== // M√âTHODE PUBLIQUE pour obtenir l'instance unique // ========================================== public static Configuration ObtenirInstance() { if (_instance == null) { _instance = new Configuration(); } return _instance; } } // Utilisation // Configuration c1 = new Configuration(); // ‚ùå ERREUR - Constructeur priv√© Configuration c1 = Configuration.ObtenirInstance(); // ‚úÖ OK Configuration c2 = Configuration.ObtenirInstance(); // Retourne la m√™me instance Console.WriteLine(c1 == c2); // True - M√™me objet 7.7 Initialisation d‚ÄôObjets En plus des constructeurs, C# offre des syntaxes modernes pour initialiser les objets.\npublic class Produit { public string Nom { get; set; } public decimal Prix { get; set; } public string Categorie { get; set; } public Produit() { } public Produit(string nom, decimal prix) { Nom = nom; Prix = prix; } } // ========================================== // SYNTAXE 1 : Constructeur traditionnel // ========================================== Produit p1 = new Produit(\"Laptop\", 999.99m); p1.Categorie = \"√âlectronique\"; // ========================================== // SYNTAXE 2 : Initialiseur d'objet (Object Initializer) // ========================================== Produit p2 = new Produit { Nom = \"Souris\", Prix = 29.99m, Categorie = \"Accessoires\" }; // ========================================== // SYNTAXE 3 : Combinaison constructeur + initialiseur // ========================================== Produit p3 = new Produit(\"Clavier\", 79.99m) { Categorie = \"Accessoires\" // Ajoute la cat√©gorie apr√®s la construction }; // ========================================== // SYNTAXE 4 : C# 9+ (sans r√©p√©ter le type) // ========================================== Produit p4 = new(\"√âcran\", 299.99m) { Categorie = \"P√©riph√©riques\" }; 7.8 Exemple Complet : Classe CompteBancaire public class CompteBancaire { // ========================================== // ATTRIBUTS PRIV√âS // ========================================== private string _numeroCompte; private string _titulaire; private decimal _solde; private DateTime _dateOuverture; private static int _compteurComptes = 0; // Pour g√©n√©rer des num√©ros uniques // ========================================== // PROPRI√âT√âS // ========================================== public string NumeroCompte { get { return _numeroCompte; } } public string Titulaire { get { return _titulaire; } } public decimal Solde { get { return _solde; } } public DateTime DateOuverture { get { return _dateOuverture; } } // ========================================== // CONSTRUCTEUR 1 : Complet // ========================================== public CompteBancaire(string titulaire, decimal soldeInitial, string numeroCompte) { if (string.IsNullOrWhiteSpace(titulaire)) throw new ArgumentException(\"Le titulaire ne peut pas √™tre vide\"); if (soldeInitial \u003c 0) throw new ArgumentException(\"Le solde initial ne peut pas √™tre n√©gatif\"); _titulaire = titulaire; _solde = soldeInitial; _numeroCompte = numeroCompte; _dateOuverture = DateTime.Now; _compteurComptes++; Console.WriteLine($\"Compte {_numeroCompte} cr√©√© pour {_titulaire}\"); } // ========================================== // CONSTRUCTEUR 2 : G√©n√®re automatiquement le num√©ro // ========================================== public CompteBancaire(string titulaire, decimal soldeInitial) : this(titulaire, soldeInitial, GenererNumeroCompte()) { Console.WriteLine(\"Num√©ro de compte g√©n√©r√© automatiquement\"); } // ========================================== // CONSTRUCTEUR 3 : Solde initial de 0$ // ========================================== public CompteBancaire(string titulaire) : this(titulaire, 0) { Console.WriteLine(\"Compte cr√©√© avec solde initial de 0$\"); } // ========================================== // M√âTHODE PRIV√âE pour g√©n√©rer un num√©ro // ========================================== private static string GenererNumeroCompte() { return $\"CA{DateTime.Now.Year}{_compteurComptes + 1:D6}\"; } // ========================================== // M√âTHODES // ========================================== public void Deposer(decimal montant) { if (montant \u003e 0) { _solde += montant; Console.WriteLine($\"D√©p√¥t de {montant:C}. Nouveau solde: {_solde:C}\"); } } public void AfficherInfos() { Console.WriteLine($\"\\n=== Compte {_numeroCompte} ===\"); Console.WriteLine($\"Titulaire: {_titulaire}\"); Console.WriteLine($\"Solde: {_solde:C}\"); Console.WriteLine($\"Date d'ouverture: {_dateOuverture:d}\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // 3 fa√ßons de cr√©er un compte CompteBancaire c1 = new CompteBancaire(\"Marie Tremblay\", 1000, \"CA2024001\"); CompteBancaire c2 = new CompteBancaire(\"Jean Gagnon\", 500); CompteBancaire c3 = new CompteBancaire(\"Sophie Roy\"); c1.AfficherInfos(); c2.AfficherInfos(); c3.AfficherInfos(); c3.Deposer(250); c3.AfficherInfos(); } } 8. L‚ÄôH√©ritage 8.1 Concept Fondamental L‚Äôh√©ritage est un m√©canisme qui permet √† une classe (appel√©e classe d√©riv√©e, classe enfant ou sous-classe) d‚Äôh√©riter des membres (attributs et m√©thodes) d‚Äôune autre classe (appel√©e classe de base, classe parent ou super-classe).\nM√©taphore biologique :\nVous h√©ritez des caract√©ristiques de vos parents (couleur des yeux, groupe sanguin) Mais vous avez aussi vos propres caract√©ristiques uniques C‚Äôest la m√™me chose en programmation Pourquoi l‚Äôh√©ritage ?\nR√©utilisation du code : Ne pas r√©√©crire ce qui existe d√©j√† Organisation hi√©rarchique : Mod√©liser des relations ‚Äúest un‚Äù Extensibilit√© : Ajouter des fonctionnalit√©s sans modifier l‚Äôexistant Polymorphisme : Traiter diff√©rents objets de mani√®re uniforme 8.2 Syntaxe de l‚ÄôH√©ritage // Syntaxe : class ClasseDerivee : ClasseDeBase public class Animal { // Classe de base } public class Chien : Animal { // Chien h√©rite de Animal } 8.3 Exemple D√©taill√© : Hi√©rarchie de V√©hicules // ========================================== // CLASSE DE BASE (PARENT) // ========================================== public class Vehicule { // ========================================== // MEMBRES PROT√âG√âS - Accessibles aux d√©riv√©es // ========================================== protected string _marque; protected string _modele; protected int _annee; protected double _kilometrage; // ========================================== // PROPRI√âT√âS PUBLIQUES // ========================================== public string Marque { get { return _marque; } set { _marque = value; } } public string Modele { get { return _modele; } set { _modele = value; } } public int Annee { get; set; } public double Kilometrage { get { return _kilometrage; } protected set // Set prot√©g√© { if (value \u003e= _kilometrage) // Ne peut qu'augmenter _kilometrage = value; } } // ========================================== // CONSTRUCTEUR // ========================================== public Vehicule(string marque, string modele, int annee) { Console.WriteLine(\"Constructeur de Vehicule appel√©\"); _marque = marque; _modele = modele; _annee = annee; _kilometrage = 0; } // ========================================== // M√âTHODES // ========================================== public void Demarrer() { Console.WriteLine($\"Le v√©hicule {_marque} {_modele} d√©marre.\"); } public void Rouler(double km) { _kilometrage += km; Console.WriteLine($\"Parcouru {km} km. Total: {_kilometrage} km\"); } public void AfficherInfos() { Console.WriteLine($\"\\n=== {_marque} {_modele} ===\"); Console.WriteLine($\"Ann√©e: {_annee}\"); Console.WriteLine($\"Kilom√©trage: {_kilometrage} km\"); } } // ========================================== // CLASSE D√âRIV√âE 1 (ENFANT) // ========================================== public class Voiture : Vehicule // H√©rite de Vehicule { // ========================================== // MEMBRES SP√âCIFIQUES √† Voiture // ========================================== private int _nombrePortes; private string _typeCar burant; public int NombrePortes { get { return _nombrePortes; } set { _nombrePortes = value; } } // ========================================== // CONSTRUCTEUR - Doit appeler le constructeur du parent // ========================================== public Voiture(string marque, string modele, int annee, int portes, string carburant) : base(marque, modele, annee) // Appelle le constructeur de Vehicule { Console.WriteLine(\"Constructeur de Voiture appel√©\"); _nombrePortes = portes; _typeCarburant = carburant; } // ========================================== // NOUVELLE M√âTHODE sp√©cifique √† Voiture // ========================================== public void OuvrirCoffre() { Console.WriteLine(\"Coffre ouvert\"); } // ========================================== // ACC√àS AUX MEMBRES H√âRIT√âS // ========================================== public void AfficherToutesInfos() { // Peut acc√©der aux membres protected et public du parent AfficherInfos(); // M√©thode h√©rit√©e Console.WriteLine($\"Nombre de portes: {_nombrePortes}\"); Console.WriteLine($\"Carburant: {_typeCarburant}\"); // Peut acc√©der aux attributs protected Console.WriteLine($\"Marque (attribut protected): {_marque}\"); } } // ========================================== // CLASSE D√âRIV√âE 2 // ========================================== public class Moto : Vehicule { private bool _aCompartiment; public bool ACompartiment { get; set; } public Moto(string marque, string modele, int annee, bool compartiment) : base(marque, modele, annee) { Console.WriteLine(\"Constructeur de Moto appel√©\"); _aCompartiment = compartiment; } public void FaireWheeling() { Console.WriteLine($\"La moto {Marque} fait un wheeling!\"); } } // ========================================== // CLASSE D√âRIV√âE 3 // ========================================== public class Camion : Vehicule { private double _capaciteCharge; // En tonnes public double CapaciteCharge { get; set; } public Camion(string marque, string modele, int annee, double capacite) : base(marque, modele, annee) { _capaciteCharge = capacite; } public void Charger(double poids) { if (poids \u003c= _capaciteCharge) Console.WriteLine($\"Chargement de {poids} tonnes\"); else Console.WriteLine($\"D√©passement de capacit√©!\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // Cr√©ation d'objets d√©riv√©s Voiture voiture = new Voiture(\"Toyota\", \"Camry\", 2023, 4, \"Essence\"); Moto moto = new Moto(\"Harley-Davidson\", \"Street 750\", 2022, true); Camion camion = new Camion(\"Volvo\", \"FH16\", 2021, 20); // ========================================== // La voiture h√©rite de TOUT ce que Vehicule poss√®de // ========================================== voiture.Demarrer(); // ‚úÖ M√©thode h√©rit√©e voiture.Rouler(150); // ‚úÖ M√©thode h√©rit√©e voiture.AfficherInfos(); // ‚úÖ M√©thode h√©rit√©e voiture.OuvrirCoffre(); // ‚úÖ M√©thode sp√©cifique √† Voiture // ========================================== // M√™me chose pour la moto // ========================================== moto.Demarrer(); // ‚úÖ M√©thode h√©rit√©e moto.FaireWheeling(); // ‚úÖ M√©thode sp√©cifique √† Moto // ========================================== // Et le camion // ========================================== camion.Demarrer(); // ‚úÖ M√©thode h√©rit√©e camion.Charger(15); // ‚úÖ M√©thode sp√©cifique √† Camion } } Affichage :\nConstructeur de Vehicule appel√©\rConstructeur de Voiture appel√©\rConstructeur de Vehicule appel√©\rConstructeur de Moto appel√©\rConstructeur de Vehicule appel√©\rLe v√©hicule Toyota Camry d√©marre.\rParcouru 150 km. Total: 150 km\r=== Toyota Camry ===\rAnn√©e: 2023\rKilom√©trage: 150 km\rCoffre ouvert\r... 8.4 Le Mot-Cl√© base Le mot-cl√© base permet d‚Äôacc√©der aux membres de la classe parent.\npublic class Animal { protected string _nom; protected int _age; public Animal(string nom, int age) { _nom = nom; _age = age; Console.WriteLine($\"Animal {nom} cr√©√©\"); } public void Manger() { Console.WriteLine($\"{_nom} mange.\"); } public virtual void Dormir() { Console.WriteLine($\"{_nom} dort paisiblement.\"); } } public class Chien : Animal { private string _race; // ========================================== // UTILISATION 1 de 'base' : Appeler le constructeur parent // ========================================== public Chien(string nom, int age, string race) : base(nom, age) // Appelle Animal(nom, age) { _race = race; Console.WriteLine($\"Chien de race {race} cr√©√©\"); } // ========================================== // UTILISATION 2 de 'base' : Appeler une m√©thode du parent // ========================================== public override void Dormir() { Console.WriteLine($\"{_nom} le chien cherche un endroit confortable\"); base.Dormir(); // Appelle la m√©thode Dormir() de Animal Console.WriteLine(\"...et ronfle un peu\"); } public void AfficherTout() { // ========================================== // UTILISATION 3 de 'base' : Acc√©der √† un membre parent // ========================================== Console.WriteLine($\"Nom: {_nom}\"); // Attribut h√©rit√© Console.WriteLine($\"√Çge: {_age}\"); // Attribut h√©rit√© Console.WriteLine($\"Race: {_race}\"); // Attribut propre base.Manger(); // Appelle explicitement la m√©thode du parent } } // Utilisation Chien chien = new Chien(\"Rex\", 5, \"Labrador\"); chien.Dormir(); Affichage :\nAnimal Rex cr√©√©\rChien de race Labrador cr√©√©\rRex le chien cherche un endroit confortable\rRex dort paisiblement.\r...et ronfle un peu 8.5 Hi√©rarchie Multi-Niveaux L‚Äôh√©ritage peut avoir plusieurs niveaux.\n// ========================================== // NIVEAU 1 : Classe de base // ========================================== public class EtreVivant { public bool EstVivant { get; set; } = true; public void Respirer() { Console.WriteLine(\"Respire...\"); } } // ========================================== // NIVEAU 2 : D√©rive de EtreVivant // ========================================== public class Animal : EtreVivant { public void SeDeplacer() { Console.WriteLine(\"Se d√©place\"); } } // ========================================== // NIVEAU 3 : D√©rive de Animal // ========================================== public class Mammifere : Animal { public void Allaiter() { Console.WriteLine(\"Allaite ses petits\"); } } // ========================================== // NIVEAU 4 : D√©rive de Mammifere // ========================================== public class Chien : Mammifere { public void Aboyer() { Console.WriteLine(\"Wouf wouf!\"); } } // Utilisation Chien chien = new Chien(); // Le chien h√©rite de TOUS ses anc√™tres chien.Respirer(); // ‚úÖ De EtreVivant (arri√®re-arri√®re-grand-parent) chien.SeDeplacer(); // ‚úÖ De Animal (arri√®re-grand-parent) chien.Allaiter(); // ‚úÖ De Mammifere (grand-parent) chien.Aboyer(); // ‚úÖ De Chien (lui-m√™me) Hi√©rarchie :\nEtreVivant\r‚Üì h√©rite\rAnimal\r‚Üì h√©rite\rMammifere\r‚Üì h√©rite\rChien 8.6 Relations ‚ÄúEst-Un‚Äù (Is-A) L‚Äôh√©ritage mod√©lise une relation ‚Äúest un‚Äù.\npublic class Vehicule { } public class Voiture : Vehicule { } // Une Voiture \"est un\" Vehicule ‚úÖ // Un Vehicule \"est une\" Voiture ‚ùå (faux) Voiture v = new Voiture(); // v est une Voiture ‚úÖ // v est aussi un Vehicule ‚úÖ (par h√©ritage) Test mental : Si vous pouvez dire ‚ÄúX est un Y‚Äù, alors X peut h√©riter de Y.\nUn chien est un animal ‚úÖ Une voiture est un v√©hicule ‚úÖ Un √©tudiant est une personne ‚úÖ Une maison est un b√¢timent ‚úÖ Contre-exemples (mauvais h√©ritage) :\nUne maison est un toit ‚ùå (une maison a un toit ‚Üí composition, pas h√©ritage) Un √©tudiant est un cours ‚ùå Une voiture est un moteur ‚ùå (une voiture a un moteur) 8.7 Restrictions de l‚ÄôH√©ritage en C# Important : En C#, une classe ne peut h√©riter que d‚ÄôUNE SEULE classe (pas d‚Äôh√©ritage multiple de classes).\npublic class A { } public class B { } // ‚ùå ERREUR - Pas d'h√©ritage multiple en C# public class C : A, B { } // ‚úÖ OK - H√©ritage simple public class C : A { } Cependant : Une classe peut impl√©menter plusieurs interfaces (voir section sur les interfaces).\n9. Le Polymorphisme 9.1 D√©finition Approfondie Le polymorphisme (du grec ‚Äúpoly‚Äù = plusieurs, ‚Äúmorphe‚Äù = forme) est la capacit√© pour des objets de types diff√©rents de r√©pondre √† la m√™me interface ou au m√™me appel de m√©thode, mais avec des comportements diff√©rents.\nAnalogie du monde r√©el : Imaginez un bouton ‚ÄúD√©marrer‚Äù :\nSur une voiture : D√©marre le moteur Sur un ordinateur : Lance le syst√®me d‚Äôexploitation Sur une cafeti√®re : Commence √† infuser le caf√© M√™me action (‚ÄúD√©marrer‚Äù), comportements diff√©rents Pourquoi le polymorphisme ?\nFlexibilit√© : √âcrire du code qui fonctionne avec diff√©rents types Extensibilit√© : Ajouter de nouveaux types sans modifier le code existant Abstraction : Manipuler des objets sans conna√Ætre leur type exact Code r√©utilisable : Une m√™me fonction pour plusieurs types 9.2 Types de Polymorphisme Il existe deux types principaux :\nPolymorphisme de compilation (surcharge de m√©thodes) Polymorphisme d‚Äôex√©cution (red√©finition de m√©thodes) La Programmation Orient√©e Objet (POO) est un paradigme de programmation bas√© sur le concept d‚Äôobjets qui contiennent des donn√©es (attributs) et du code (m√©thodes).\nLes 4 piliers de la POO : Encapsulation : Regrouper les donn√©es et m√©thodes, cacher les d√©tails internes H√©ritage : Cr√©er de nouvelles classes √† partir de classes existantes Polymorphisme : Utiliser une interface commune pour des types diff√©rents Abstraction : Simplifier la complexit√© en cachant les d√©tails d‚Äôimpl√©mentation 2. Les Classes et les Objets Qu‚Äôest-ce qu‚Äôune classe ? Une classe est un mod√®le ou un plan qui d√©finit la structure et le comportement d‚Äôobjets.\nQu‚Äôest-ce qu‚Äôun objet ? Un objet est une instance d‚Äôune classe, c‚Äôest une entit√© concr√®te cr√©√©e √† partir du mod√®le.\nSyntaxe de base // D√©finition d'une classe public class Personne { // Attributs (champs) public string Nom; public string Prenom; public int Age; // M√©thode public void SePresenter() { Console.WriteLine($\"Bonjour, je m'appelle {Prenom} {Nom} et j'ai {Age} ans.\"); } } // Utilisation class Program { static void Main() { // Cr√©ation d'un objet (instance) Personne personne1 = new Personne(); personne1.Nom = \"Tremblay\"; personne1.Prenom = \"Marie\"; personne1.Age = 25; personne1.SePresenter(); // Affiche: Bonjour, je m'appelle Marie Tremblay et j'ai 25 ans. } } 3. L‚ÄôEncapsulation L‚Äôencapsulation consiste √† prot√©ger les donn√©es d‚Äôune classe et √† contr√¥ler l‚Äôacc√®s via des propri√©t√©s.\nModificateurs d‚Äôacc√®s Modificateur Description public Accessible partout private Accessible uniquement dans la classe protected Accessible dans la classe et ses d√©riv√©es internal Accessible dans le m√™me assembly protected internal Combinaison de protected et internal Propri√©t√©s (Properties) public class Compte { // Champs priv√©s private string _numeroCompte; private decimal _solde; // Propri√©t√© avec get et set public string NumeroCompte { get { return _numeroCompte; } set { _numeroCompte = value; } } // Propri√©t√© avec logique de validation public decimal Solde { get { return _solde; } private set // set priv√© : lecture publique, √©criture priv√©e { if (value \u003e= 0) _solde = value; } } // Propri√©t√© auto-impl√©ment√©e (C# 3.0+) public string Titulaire { get; set; } // Propri√©t√© en lecture seule (C# 6.0+) public DateTime DateCreation { get; } = DateTime.Now; public void Deposer(decimal montant) { if (montant \u003e 0) Solde += montant; } public bool Retirer(decimal montant) { if (montant \u003e 0 \u0026\u0026 montant \u003c= Solde) { Solde -= montant; return true; } return false; } } 4. Les Constructeurs Un constructeur est une m√©thode sp√©ciale appel√©e lors de la cr√©ation d‚Äôun objet.\nTypes de constructeurs public class Voiture { public string Marque { get; set; } public string Modele { get; set; } public int Annee { get; set; } // Constructeur par d√©faut (sans param√®tres) public Voiture() { Marque = \"Inconnue\"; Modele = \"Inconnu\"; Annee = 2020; } // Constructeur avec param√®tres public Voiture(string marque, string modele) { Marque = marque; Modele = modele; Annee = DateTime.Now.Year; } // Constructeur complet public Voiture(string marque, string modele, int annee) { Marque = marque; Modele = modele; Annee = annee; } // Cha√Ænage de constructeurs avec 'this' public Voiture(string marque) : this(marque, \"Standard\", DateTime.Now.Year) { } } // Utilisation var voiture1 = new Voiture(); var voiture2 = new Voiture(\"Toyota\", \"Camry\"); var voiture3 = new Voiture(\"Honda\", \"Civic\", 2023); var voiture4 = new Voiture(\"Ford\"); 5. L‚ÄôH√©ritage L‚Äôh√©ritage permet √† une classe (classe d√©riv√©e) d‚Äôh√©riter des membres d‚Äôune autre classe (classe de base).\nSyntaxe de base // Classe de base (parent) public class Animal { public string Nom { get; set; } public int Age { get; set; } public virtual void Manger() { Console.WriteLine($\"{Nom} est en train de manger.\"); } public virtual void Dormir() { Console.WriteLine($\"{Nom} dort.\"); } } // Classe d√©riv√©e (enfant) public class Chien : Animal { public string Race { get; set; } // Nouvelle m√©thode sp√©cifique au chien public void Aboyer() { Console.WriteLine($\"{Nom} aboie: Wouf wouf!\"); } // Red√©finition (override) d'une m√©thode public override void Manger() { Console.WriteLine($\"{Nom} le chien mange des croquettes.\"); } } // Autre classe d√©riv√©e public class Chat : Animal { public bool EstDomestique { get; set; } public void Miauler() { Console.WriteLine($\"{Nom} miaule: Miaou!\"); } public override void Manger() { Console.WriteLine($\"{Nom} le chat mange du poisson.\"); } } // Utilisation var chien = new Chien { Nom = \"Rex\", Age = 5, Race = \"Labrador\" }; chien.Manger(); // Affiche: Rex le chien mange des croquettes. chien.Aboyer(); // Affiche: Rex aboie: Wouf wouf! chien.Dormir(); // Affiche: Rex dort. Le mot-cl√© base public class Employe { public string Nom { get; set; } public decimal SalaireBase { get; set; } public Employe(string nom, decimal salaire) { Nom = nom; SalaireBase = salaire; } public virtual decimal CalculerSalaire() { return SalaireBase; } } public class Manager : Employe { public decimal Prime { get; set; } // Appel du constructeur de base avec 'base' public Manager(string nom, decimal salaire, decimal prime) : base(nom, salaire) { Prime = prime; } // Utilisation de la m√©thode de base avec 'base' public override decimal CalculerSalaire() { return base.CalculerSalaire() + Prime; } } Modificateur sealed Le mot-cl√© sealed emp√™che l‚Äôh√©ritage d‚Äôune classe ou la red√©finition d‚Äôune m√©thode.\n// Classe scell√©e - ne peut pas √™tre h√©rit√©e public sealed class ClasseFinale { public void Methode() { } } // ERREUR: Impossible d'h√©riter d'une classe sealed // public class Derivee : ClasseFinale { } public class ClasseAvecMethodeScelle : Animal { // M√©thode scell√©e - ne peut plus √™tre red√©finie dans les classes d√©riv√©es public sealed override void Manger() { Console.WriteLine(\"Impl√©mentation finale\"); } } 6. Le Polymorphisme Le polymorphisme permet √† des objets de diff√©rentes classes d‚Äô√™tre trait√©s de mani√®re uniforme via une interface commune.\nPolymorphisme par h√©ritage public class Forme { public virtual double CalculerAire() { return 0; } public virtual void Dessiner() { Console.WriteLine(\"Dessiner une forme g√©n√©rique\"); } } public class Cercle : Forme { public double Rayon { get; set; } public Cercle(double rayon) { Rayon = rayon; } public override double CalculerAire() { return Math.PI * Rayon * Rayon; } public override void Dessiner() { Console.WriteLine($\"Dessiner un cercle de rayon {Rayon}\"); } } public class Rectangle : Forme { public double Longueur { get; set; } public double Largeur { get; set; } public Rectangle(double longueur, double largeur) { Longueur = longueur; Largeur = largeur; } public override double CalculerAire() { return Longueur * Largeur; } public override void Dessiner() { Console.WriteLine($\"Dessiner un rectangle {Longueur}x{Largeur}\"); } } // Utilisation du polymorphisme class Program { static void Main() { // Tableau polymorphe Forme[] formes = new Forme[] { new Cercle(5), new Rectangle(4, 6), new Cercle(3) }; // M√™me code, comportements diff√©rents foreach (Forme forme in formes) { forme.Dessiner(); Console.WriteLine($\"Aire: {forme.CalculerAire():F2}\"); Console.WriteLine(); } } } Mots-cl√©s virtual, override, new public class ClasseBase { public virtual void MethodeVirtuelle() { Console.WriteLine(\"M√©thode virtuelle de base\"); } public void MethodeNormale() { Console.WriteLine(\"M√©thode normale de base\"); } } public class ClasseDerivee : ClasseBase { // Override: red√©finition polymorphique public override void MethodeVirtuelle() { Console.WriteLine(\"M√©thode red√©finie\"); } // New: masquage (non polymorphique) public new void MethodeNormale() { Console.WriteLine(\"M√©thode masqu√©e\"); } } // Test ClasseBase obj1 = new ClasseDerivee(); obj1.MethodeVirtuelle(); // Affiche: M√©thode red√©finie (polymorphisme) obj1.MethodeNormale(); // Affiche: M√©thode normale de base (pas de polymorphisme) ClasseDerivee obj2 = new ClasseDerivee(); obj2.MethodeVirtuelle(); // Affiche: M√©thode red√©finie obj2.MethodeNormale(); // Affiche: M√©thode masqu√©e 7. Les Classes Abstraites Une classe abstraite est une classe incompl√®te qui ne peut pas √™tre instanci√©e directement. Elle sert de mod√®le pour d‚Äôautres classes.\nCaract√©ristiques D√©clar√©e avec le mot-cl√© abstract Peut contenir des m√©thodes abstraites (sans impl√©mentation) et concr√®tes (avec impl√©mentation) Ne peut pas √™tre instanci√©e Les classes d√©riv√©es doivent impl√©menter toutes les m√©thodes abstraites // Classe abstraite public abstract class Vehicule { public string Marque { get; set; } public string Modele { get; set; } // Constructeur (oui, les classes abstraites peuvent avoir des constructeurs) public Vehicule(string marque, string modele) { Marque = marque; Modele = modele; } // M√©thode abstraite (sans impl√©mentation) public abstract void Demarrer(); // M√©thode abstraite public abstract double CalculerConsommation(double distance); // M√©thode concr√®te (avec impl√©mentation) public void AfficherInfo() { Console.WriteLine($\"V√©hicule: {Marque} {Modele}\"); } // M√©thode virtuelle (peut √™tre red√©finie) public virtual void Klaxonner() { Console.WriteLine(\"Beep beep!\"); } } // Classe d√©riv√©e - doit impl√©menter toutes les m√©thodes abstraites public class Voiture : Vehicule { public int NombrePortes { get; set; } public Voiture(string marque, string modele, int portes) : base(marque, modele) { NombrePortes = portes; } // Impl√©mentation obligatoire public override void Demarrer() { Console.WriteLine($\"La voiture {Marque} {Modele} d√©marre avec la cl√©.\"); } // Impl√©mentation obligatoire public override double CalculerConsommation(double distance) { return distance * 0.07; // 7L/100km } } public class Moto : Vehicule { public bool ASidecar { get; set; } public Moto(string marque, string modele) : base(marque, modele) { } public override void Demarrer() { Console.WriteLine($\"La moto {Marque} {Modele} d√©marre avec le kick.\"); } public override double CalculerConsommation(double distance) { return distance * 0.04; // 4L/100km } public override void Klaxonner() { Console.WriteLine(\"Beep beep! (son de moto)\"); } } // Utilisation // var v = new Vehicule(\"Test\", \"Test\"); // ERREUR: impossible d'instancier une classe abstraite var voiture = new Voiture(\"Toyota\", \"Corolla\", 4); voiture.AfficherInfo(); voiture.Demarrer(); Console.WriteLine($\"Consommation sur 100km: {voiture.CalculerConsommation(100)}L\"); var moto = new Moto(\"Harley\", \"Davidson\"); moto.Demarrer(); Exemple avanc√© : Syst√®me de paiement public abstract class MoyenPaiement { public string Titulaire { get; set; } public DateTime DateTransaction { get; protected set; } public abstract bool Payer(decimal montant); public abstract bool Verifier(); public virtual void AfficherRecu(decimal montant) { Console.WriteLine($\"Re√ßu - {Titulaire}\"); Console.WriteLine($\"Montant: {montant:C}\"); Console.WriteLine($\"Date: {DateTransaction}\"); } } public class CarteCredit : MoyenPaiement { public string Numero { get; set; } public DateTime DateExpiration { get; set; } public decimal LimiteCredit { get; set; } private decimal _soldeUtilise; public override bool Verifier() { return DateExpiration \u003e DateTime.Now; } public override bool Payer(decimal montant) { if (!Verifier()) { Console.WriteLine(\"Carte expir√©e\"); return false; } if (_soldeUtilise + montant \u003e LimiteCredit) { Console.WriteLine(\"Limite de cr√©dit d√©pass√©e\"); return false; } _soldeUtilise += montant; DateTransaction = DateTime.Now; Console.WriteLine($\"Paiement de {montant:C} effectu√© par carte de cr√©dit\"); return true; } } public class Paypal : MoyenPaiement { public string Email { get; set; } public decimal Solde { get; private set; } public void Recharger(decimal montant) { Solde += montant; } public override bool Verifier() { return !string.IsNullOrEmpty(Email) \u0026\u0026 Email.Contains(\"@\"); } public override bool Payer(decimal montant) { if (!Verifier()) { Console.WriteLine(\"Email invalide\"); return false; } if (Solde \u003c montant) { Console.WriteLine(\"Solde insuffisant\"); return false; } Solde -= montant; DateTransaction = DateTime.Now; Console.WriteLine($\"Paiement de {montant:C} effectu√© via PayPal\"); return true; } } 8. Les Interfaces Une interface d√©finit un contrat que les classes doivent respecter. Elle ne contient que des signatures de m√©thodes, propri√©t√©s, √©v√©nements ou indexeurs (pas d‚Äôimpl√©mentation).\nCaract√©ristiques D√©clar√©e avec le mot-cl√© interface Tous les membres sont publics par d√©faut Une classe peut impl√©menter plusieurs interfaces (contrairement √† l‚Äôh√©ritage) Pas de champs, pas de constructeurs Convention de nommage : pr√©fixe I (ex: IComparable) // D√©finition d'interfaces public interface IVolant { void Voler(); double AltitudeMax { get; } } public interface INageant { void Nager(); double ProfondeurMax { get; } } public interface IMarchant { void Marcher(); } // Classe impl√©mentant une interface public class Oiseau : IVolant, IMarchant { public string Nom { get; set; } // Impl√©mentation de IVolant public double AltitudeMax { get; set; } = 1000; public void Voler() { Console.WriteLine($\"{Nom} vole dans le ciel.\"); } // Impl√©mentation de IMarchant public void Marcher() { Console.WriteLine($\"{Nom} marche sur le sol.\"); } } public class Canard : IVolant, INageant, IMarchant { public string Nom { get; set; } public double AltitudeMax { get; set; } = 500; public double ProfondeurMax { get; set; } = 10; public void Voler() { Console.WriteLine($\"{Nom} le canard vole.\"); } public void Nager() { Console.WriteLine($\"{Nom} le canard nage.\"); } public void Marcher() { Console.WriteLine($\"{Nom} le canard marche.\"); } } public class Poisson : INageant { public string Nom { get; set; } public double ProfondeurMax { get; set; } = 100; public void Nager() { Console.WriteLine($\"{Nom} le poisson nage sous l'eau.\"); } } // Utilisation polymorphe des interfaces class Program { static void FaireVoler(IVolant volant) { volant.Voler(); Console.WriteLine($\"Altitude maximale: {volant.AltitudeMax}m\"); } static void FaireNager(INageant nageant) { nageant.Nager(); Console.WriteLine($\"Profondeur maximale: {nageant.ProfondeurMax}m\"); } static void Main() { var oiseau = new Oiseau { Nom = \"Aigle\" }; var canard = new Canard { Nom = \"Donald\" }; var poisson = new Poisson { Nom = \"Nemo\" }; FaireVoler(oiseau); FaireVoler(canard); FaireNager(canard); FaireNager(poisson); // Collection polymorphe List\u003cINageant\u003e animauxAquatiques = new List\u003cINageant\u003e { canard, poisson }; foreach (var animal in animauxAquatiques) { animal.Nager(); } } } Interfaces vs Classes Abstraites Aspect Interface Classe Abstraite H√©ritage multiple ‚úÖ Oui (une classe peut impl√©menter plusieurs interfaces) ‚ùå Non (une classe ne peut h√©riter que d‚Äôune seule classe) Impl√©mentation ‚ùå Aucune (sauf depuis C# 8.0 avec impl√©mentation par d√©faut) ‚úÖ Peut contenir des m√©thodes impl√©ment√©es Champs ‚ùå Non ‚úÖ Oui Constructeurs ‚ùå Non ‚úÖ Oui Modificateurs d‚Äôacc√®s Tous publics Peut varier Utilisation D√©finir un contrat/comportement D√©finir une base commune avec du code partag√© Exemple pratique : Syst√®me de notification public interface INotifiable { void EnvoyerNotification(string message); bool EstActif { get; set; } } public interface IConfigurable { void Configurer(Dictionary\u003cstring, string\u003e parametres); Dictionary\u003cstring, string\u003e ObtenirConfiguration(); } public class NotificationEmail : INotifiable, IConfigurable { public bool EstActif { get; set; } = true; public string AdresseEmail { get; set; } public string ServeurSMTP { get; set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"üìß Email envoy√© √† {AdresseEmail}: {message}\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"email\")) AdresseEmail = parametres[\"email\"]; if (parametres.ContainsKey(\"smtp\")) ServeurSMTP = parametres[\"smtp\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"email\", AdresseEmail }, { \"smtp\", ServeurSMTP } }; } } public class NotificationSMS : INotifiable, IConfigurable { public bool EstActif { get; set; } = true; public string NumeroTelephone { get; set; } public string FournisseurSMS { get; set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"üì± SMS envoy√© au {NumeroTelephone}: {message}\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"telephone\")) NumeroTelephone = parametres[\"telephone\"]; if (parametres.ContainsKey(\"fournisseur\")) FournisseurSMS = parametres[\"fournisseur\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"telephone\", NumeroTelephone }, { \"fournisseur\", FournisseurSMS } }; } } public class GestionnaireNotifications { private List\u003cINotifiable\u003e _canaux = new List\u003cINotifiable\u003e(); public void AjouterCanal(INotifiable canal) { _canaux.Add(canal); } public void EnvoyerATous(string message) { foreach (var canal in _canaux) { canal.EnvoyerNotification(message); } } } Impl√©mentation explicite d‚Äôinterface Utilis√©e pour √©viter les conflits de noms entre plusieurs interfaces.\npublic interface IAnimal { void Manger(); } public interface IRobot { void Manger(); // M√™me nom de m√©thode } public class CyberChien : IAnimal, IRobot { // Impl√©mentation explicite de IAnimal.Manger void IAnimal.Manger() { Console.WriteLine(\"Le cyber-chien mange de la vraie nourriture\"); } // Impl√©mentation explicite de IRobot.Manger void IRobot.Manger() { Console.WriteLine(\"Le cyber-chien recharge ses batteries\"); } // M√©thode publique normale public void SeReposer() { Console.WriteLine(\"Le cyber-chien se met en veille\"); } } // Utilisation var cyberChien = new CyberChien(); // cyberChien.Manger(); // ERREUR: ambigu√Øt√© IAnimal animal = cyberChien; animal.Manger(); // Appelle IAnimal.Manger IRobot robot = cyberChien; robot.Manger(); // Appelle IRobot.Manger cyberChien.SeReposer(); // OK 9. Concepts Avanc√©s 9.1 Membres statiques Les membres statiques appartiennent √† la classe plut√¥t qu‚Äô√† une instance.\npublic class Compteur { // Champ statique (partag√© par toutes les instances) private static int _nombreInstances = 0; // Propri√©t√© statique public static int NombreInstances { get { return _nombreInstances; } } // Champ d'instance public int Id { get; private set; } // Constructeur public Compteur() { _nombreInstances++; Id = _nombreInstances; } // M√©thode statique public static void Reinitialiser() { _nombreInstances = 0; } // M√©thode d'instance public void AfficherInfo() { Console.WriteLine($\"Instance #{Id} - Total: {NombreInstances}\"); } } // Constructeur statique (appel√© une seule fois avant la premi√®re utilisation) public class Configuration { public static string CheminFichier { get; private set; } static Configuration() { Console.WriteLine(\"Initialisation de la configuration...\"); CheminFichier = \"config.json\"; } } // Utilisation var c1 = new Compteur(); // NombreInstances = 1 var c2 = new Compteur(); // NombreInstances = 2 var c3 = new Compteur(); // NombreInstances = 3 Console.WriteLine(Compteur.NombreInstances); // 3 c2.AfficherInfo(); // Instance #2 - Total: 3 9.2 Classes statiques Une classe statique ne peut contenir que des membres statiques et ne peut pas √™tre instanci√©e.\npublic static class Utilitaires { public static double CalculerMoyenne(params double[] nombres) { if (nombres.Length == 0) return 0; return nombres.Average(); } public static string FormaterMonnaie(decimal montant) { return $\"{montant:C}\"; } public static T Max\u003cT\u003e(T a, T b) where T : IComparable\u003cT\u003e { return a.CompareTo(b) \u003e 0 ? a : b; } } // Utilisation double moyenne = Utilitaires.CalculerMoyenne(10, 20, 30, 40); string prix = Utilitaires.FormaterMonnaie(99.99m); int maximum = Utilitaires.Max(5, 10); 9.3 Classes partielles (Partial Classes) Permettent de diviser la d√©finition d‚Äôune classe en plusieurs fichiers.\n// Fichier: Personne.cs public partial class Personne { public string Nom { get; set; } public string Prenom { get; set; } partial void OnNomChanged(); } // Fichier: Personne.Methodes.cs public partial class Personne { public void SePresenter() { Console.WriteLine($\"Je suis {Prenom} {Nom}\"); } partial void OnNomChanged() { Console.WriteLine(\"Le nom a √©t√© modifi√©\"); } } 9.4 D√©l√©gu√©s et √âv√©nements (aper√ßu) // D√©l√©gu√© (type pointeur de fonction) public delegate void NotificationHandler(string message); public class Compte { // √âv√©nement public event NotificationHandler SoldeModifie; private decimal _solde; public decimal Solde { get { return _solde; } set { _solde = value; // D√©clencher l'√©v√©nement SoldeModifie?.Invoke($\"Nouveau solde: {_solde:C}\"); } } } // Utilisation var compte = new Compte(); compte.SoldeModifie += (msg) =\u003e Console.WriteLine($\"Notification: {msg}\"); compte.Solde = 100; // D√©clenche l'√©v√©nement 9.5 G√©n√©riques (Generics) // Classe g√©n√©rique public class Boite\u003cT\u003e { private T _contenu; public void Ranger(T item) { _contenu = item; } public T Recuperer() { return _contenu; } } // Utilisation var boiteEntiers = new Boite\u003cint\u003e(); boiteEntiers.Ranger(42); int nombre = boiteEntiers.Recuperer(); var boiteTexte = new Boite\u003cstring\u003e(); boiteTexte.Ranger(\"Bonjour\"); string texte = boiteTexte.Recuperer(); // Classe g√©n√©rique avec contraintes public class Repository\u003cT\u003e where T : class, new() { private List\u003cT\u003e _items = new List\u003cT\u003e(); public void Ajouter(T item) { _items.Add(item); } public T Creer() { return new T(); // Possible gr√¢ce √† la contrainte 'new()' } } 9.6 Extension Methods // Classe statique pour les m√©thodes d'extension public static class StringExtensions { // M√©thode d'extension (noter le 'this' devant le premier param√®tre) public static bool EstEmail(this string texte) { return texte.Contains(\"@\") \u0026\u0026 texte.Contains(\".\"); } public static string Inverser(this string texte) { char[] chars = texte.ToCharArray(); Array.Reverse(chars); return new string(chars); } public static int CompterMots(this string texte) { return texte.Split(new[] { ' ', '\\t', '\\n' }, StringSplitOptions.RemoveEmptyEntries).Length; } } // Utilisation string email = \"test@example.com\"; bool valide = email.EstEmail(); // true string mot = \"Bonjour\"; string inverse = mot.Inverser(); // \"ruojnoB\" string phrase = \"Ceci est une phrase\"; int mots = phrase.CompterMots(); // 4 9.7 Records (C# 9.0+) Les records sont des types de r√©f√©rence immuables optimis√©s pour stocker des donn√©es.\n// Record simple public record Personne(string Nom, string Prenom, int Age); // Utilisation var p1 = new Personne(\"Tremblay\", \"Marie\", 25); var p2 = new Personne(\"Tremblay\", \"Marie\", 25); Console.WriteLine(p1 == p2); // true (√©galit√© par valeur) // Expression 'with' pour cr√©er une copie modifi√©e var p3 = p1 with { Age = 26 }; // Record avec propri√©t√©s additionnelles public record Employe(string Nom, string Prenom, decimal Salaire) { public string Departement { get; init; } = \"Non assign√©\"; public decimal CalculerSalaireAnnuel() =\u003e Salaire * 12; } R√©sum√© des concepts cl√©s Quand utiliser quoi ? Concept Utilisation Classe normale Objets avec √©tat et comportement Classe abstraite Base commune avec impl√©mentation partielle Interface Contrat sans impl√©mentation, h√©ritage multiple Classe statique M√©thodes utilitaires sans √©tat Record Donn√©es immuables Sealed class Emp√™cher l‚Äôh√©ritage Partial class Diviser une classe en plusieurs fichiers Modificateurs d‚Äôacc√®s (du plus au moins restrictif) private - Classe uniquement protected - Classe et d√©riv√©es internal - Assembly actuel protected internal - Assembly ou d√©riv√©es public - Partout Principes SOLID Single Responsibility: Une classe = une responsabilit√© Open/Closed: Ouvert √† l‚Äôextension, ferm√© √† la modification Liskov Substitution: Les sous-classes doivent pouvoir remplacer leurs classes de base Interface Segregation: Interfaces petites et sp√©cifiques Dependency Inversion: D√©pendre des abstractions, pas des impl√©mentations concr√®tes Exercices pratiques Exercice 1 : Cr√©er une hi√©rarchie de comptes bancaires Cr√©ez une classe de base CompteBancaire et des classes d√©riv√©es CompteEpargne et CompteCourant avec des comportements diff√©rents.\nExercice 2 : Syst√®me de formes g√©om√©triques Cr√©ez une classe abstraite Forme avec des m√©thodes pour calculer l‚Äôaire et le p√©rim√®tre. Impl√©mentez des classes concr√®tes comme Cercle, Carre, Triangle.\nExercice 3 : Gestion d‚Äôune biblioth√®que Utilisez des interfaces IEmpruntable, IReservable pour cr√©er un syst√®me de gestion de livres, DVD, magazines.\nExercice 4 : Simulateur de zoo Cr√©ez une hi√©rarchie d‚Äôanimaux avec des interfaces pour diff√©rents comportements (voler, nager, grimper).",
    "description": "Table des mati√®res Introduction √† la POO Les Classes et les Objets Les Attributs (Champs) Les Propri√©t√©s (Properties) L‚ÄôEncapsulation Les M√©thodes Les Constructeurs L‚ÄôH√©ritage Le Polymorphisme 1. Introduction √† la POO 1.1 Qu‚Äôest-ce que la Programmation Orient√©e Objet ? La Programmation Orient√©e Objet (POO) est un paradigme de programmation qui organise le code autour du concept d‚Äôobjets plut√¥t que de fonctions et de logique. Un objet combine des donn√©es (ce qu‚Äôil poss√®de) et des comportements (ce qu‚Äôil peut faire).",
    "tags": [],
    "title": "Programmation orient√©e objet - partie 1",
    "uri": "/420-413/poo/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Table des mati√®res Le mot-cl√© Virtual Le mot-cl√© Abstract Le mot-cl√© Sealed Les Classes Abstraites Les Interfaces Membres Statiques Cours POO C# - Partie 2 : Concepts Avanc√©s 10. Le mot-cl√© Virtual 10.1 D√©finition Le mot-cl√© virtual permet de d√©clarer une m√©thode qui peut √™tre red√©finie (override) dans les classes d√©riv√©es. C‚Äôest la base du polymorphisme d‚Äôex√©cution en C#.\nConcepts cl√©s :\nUne m√©thode virtual a une impl√©mentation dans la classe de base Les classes d√©riv√©es peuvent (mais ne sont pas oblig√©es) la red√©finir Si elles ne la red√©finissent pas, elles utilisent l‚Äôimpl√©mentation de base Analogie : C‚Äôest comme une recette de base que vous pouvez personnaliser. La recette originale existe et fonctionne, mais vous pouvez l‚Äôadapter √† votre go√ªt.\n10.2 Syntaxe et Utilisation // ========================================== // CLASSE DE BASE avec m√©thode virtual // ========================================== public class Animal { protected string _nom; public Animal(string nom) { _nom = nom; } // ========================================== // M√âTHODE VIRTUAL - Peut √™tre red√©finie // ========================================== public virtual void EmettreS on() { Console.WriteLine($\"{_nom} √©met un son g√©n√©rique.\"); } // ========================================== // M√âTHODE NORMALE (non-virtual) - Ne peut PAS √™tre red√©finie polymorphiquement // ========================================== public void Dormir() { Console.WriteLine($\"{_nom} dort.\"); } } // ========================================== // CLASSE D√âRIV√âE - Red√©finit la m√©thode virtual // ========================================== public class Chien : Animal { public Chien(string nom) : base(nom) { } // ========================================== // OVERRIDE - Red√©finition de la m√©thode virtual // ========================================== public override void EmettreSound() { Console.WriteLine($\"{_nom} aboie: Wouf wouf!\"); } } public class Chat : Animal { public Chat(string nom) : base(nom) { } public override void EmettreSound() { Console.WriteLine($\"{_nom} miaule: Miaou!\"); } } public class Vache : Animal { public Vache(string nom) : base(nom) { } public override void EmettreSound() { Console.WriteLine($\"{_nom} meugle: Meuh!\"); } } // ========================================== // D√âMONSTRATION DU POLYMORPHISME // ========================================== class Program { static void Main() { // Cr√©ation d'objets de types diff√©rents Animal animal1 = new Chien(\"Rex\"); Animal animal2 = new Chat(\"F√©lix\"); Animal animal3 = new Vache(\"Marguerite\"); Animal animal4 = new Animal(\"Cr√©ature\"); // ========================================== // POLYMORPHISME EN ACTION // M√™me appel de m√©thode, comportements diff√©rents // ========================================== animal1.EmettreSound(); // Rex aboie: Wouf wouf! animal2.EmettreSound(); // F√©lix miaule: Miaou! animal3.EmettreSound(); // Marguerite meugle: Meuh! animal4.EmettreSound(); // Cr√©ature √©met un son g√©n√©rique. // ========================================== // UTILISATION PRATIQUE : Tableau polymorphe // ========================================== Animal[] animaux = new Animal[] { new Chien(\"Max\"), new Chat(\"Minou\"), new Vache(\"Bella\"), new Chien(\"Rocky\") }; Console.WriteLine(\"\\n=== Concert animalier ===\"); foreach (Animal animal in animaux) { animal.EmettreSound(); // Appelle la bonne version automatiquement } } } Affichage :\nRex aboie: Wouf wouf!\rF√©lix miaule: Miaou!\rMarguerite meugle: Meuh!\rCr√©ature √©met un son g√©n√©rique.\r=== Concert animalier ===\rMax aboie: Wouf wouf!\rMinou miaule: Miaou!\rBella meugle: Meuh!\rRocky aboie: Wouf wouf! 10.3 Exemple Complet : Syst√®me de Calcul de Salaire public class Employe { public string Nom { get; set; } public decimal SalaireBase { get; set; } public Employe(string nom, decimal salaireBase) { Nom = nom; SalaireBase = salaireBase; } // ========================================== // M√âTHODE VIRTUAL - Calcul de base // ========================================== public virtual decimal CalculerSalaire() { Console.WriteLine($\"[Employe] Calcul standard pour {Nom}\"); return SalaireBase; } public virtual void AfficherDetails() { Console.WriteLine($\"\\n=== {Nom} ===\"); Console.WriteLine($\"Type: Employ√©\"); Console.WriteLine($\"Salaire de base: {SalaireBase:C}\"); Console.WriteLine($\"Salaire total: {CalculerSalaire():C}\"); } } public class Manager : Employe { public decimal Prime { get; set; } public Manager(string nom, decimal salaireBase, decimal prime) : base(nom, salaireBase) { Prime = prime; } // ========================================== // OVERRIDE - Red√©finition pour Manager // ========================================== public override decimal CalculerSalaire() { Console.WriteLine($\"[Manager] Calcul avec prime pour {Nom}\"); return SalaireBase + Prime; } public override void AfficherDetails() { base.AfficherDetails(); // Appelle la version de base Console.WriteLine($\"Prime: {Prime:C}\"); } } public class Vendeur : Employe { public decimal CommissionPourcentage { get; set; } public decimal VentesTotales { get; set; } public Vendeur(string nom, decimal salaireBase, decimal commission) : base(nom, salaireBase) { CommissionPourcentage = commission; } public override decimal CalculerSalaire() { Console.WriteLine($\"[Vendeur] Calcul avec commission pour {Nom}\"); decimal commission = VentesTotales * (CommissionPourcentage / 100); return SalaireBase + commission; } public override void AfficherDetails() { base.AfficherDetails(); Console.WriteLine($\"Commission: {CommissionPourcentage}%\"); Console.WriteLine($\"Ventes: {VentesTotales:C}\"); } } public class Stagiaire : Employe { public int HeuresTravaillees { get; set; } public decimal TauxHoraire { get; set; } public Stagiaire(string nom, decimal tauxHoraire) : base(nom, 0) // Pas de salaire de base { TauxHoraire = tauxHoraire; } public override decimal CalculerSalaire() { Console.WriteLine($\"[Stagiaire] Calcul horaire pour {Nom}\"); return HeuresTravaillees * TauxHoraire; } public override void AfficherDetails() { Console.WriteLine($\"\\n=== {Nom} ===\"); Console.WriteLine($\"Type: Stagiaire\"); Console.WriteLine($\"Taux horaire: {TauxHoraire:C}\"); Console.WriteLine($\"Heures travaill√©es: {HeuresTravaillees}h\"); Console.WriteLine($\"Salaire total: {CalculerSalaire():C}\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // ========================================== // Cr√©ation d'employ√©s de diff√©rents types // ========================================== Employe e1 = new Employe(\"Alice\", 3000); Manager m1 = new Manager(\"Bob\", 4000, 1000); Vendeur v1 = new Vendeur(\"Charlie\", 2500, 5) { VentesTotales = 50000 }; Stagiaire s1 = new Stagiaire(\"David\", 15) { HeuresTravaillees = 120 }; // ========================================== // POLYMORPHISME : Liste h√©t√©rog√®ne // ========================================== List\u003cEmploye\u003e employes = new List\u003cEmploye\u003e { e1, m1, v1, s1 }; Console.WriteLine(\"=== CALCUL DES SALAIRES ===\\n\"); decimal masseSalariale = 0; foreach (Employe employe in employes) { // Appelle la bonne version de CalculerSalaire() // automatiquement selon le type r√©el decimal salaire = employe.CalculerSalaire(); masseSalariale += salaire; employe.AfficherDetails(); } Console.WriteLine($\"\\n=== TOTAL ===\"); Console.WriteLine($\"Masse salariale totale: {masseSalariale:C}\"); } } 10.4 R√®gles Importantes de virtual et override public class ClasseBase { // ‚úÖ M√©thode virtual - Peut √™tre red√©finie public virtual void Methode1() { } // ‚úÖ M√©thode normale - Ne peut pas √™tre red√©finie polymorphiquement public void Methode2() { } // ‚úÖ Propri√©t√© virtual public virtual string Propriete { get; set; } } public class ClasseDerivee : ClasseBase { // ‚úÖ OK - Override d'une m√©thode virtual public override void Methode1() { } // ‚ùå ERREUR - Ne peut pas override une m√©thode non-virtual // public override void Methode2() { } // ‚úÖ OK - Override d'une propri√©t√© virtual public override string Propriete { get; set; } // ‚ö†Ô∏è ATTENTION - Masquage avec 'new' (pas polymorphique) public new void Methode2() { // Ceci n'est PAS du polymorphisme // C'est du \"masquage\" (hiding) } } Diff√©rence entre override et new :\npublic class Base { public virtual void Afficher() { Console.WriteLine(\"Base.Afficher()\"); } } public class Derivee1 : Base { public override void Afficher() // OVERRIDE { Console.WriteLine(\"Derivee1.Afficher()\"); } } public class Derivee2 : Base { public new void Afficher() // NEW (masquage) { Console.WriteLine(\"Derivee2.Afficher()\"); } } // Test Base b1 = new Derivee1(); b1.Afficher(); // \"Derivee1.Afficher()\" - POLYMORPHISME ‚úÖ Base b2 = new Derivee2(); b2.Afficher(); // \"Base.Afficher()\" - PAS de polymorphisme ‚ö†Ô∏è Derivee2 d2 = new Derivee2(); d2.Afficher(); // \"Derivee2.Afficher()\" - Appelle la version masqu√©e 11. Le mot-cl√© Abstract 11.1 D√©finition Le mot-cl√© abstract permet de d√©clarer :\nDes classes abstraites : Classes incompl√®tes qui ne peuvent pas √™tre instanci√©es Des m√©thodes abstraites : M√©thodes sans impl√©mentation qui DOIVENT √™tre red√©finies dans les classes d√©riv√©es Diff√©rence avec virtual :\nvirtual : M√©thode avec impl√©mentation, red√©finition optionnelle abstract : M√©thode sans impl√©mentation, red√©finition obligatoire Analogie :\nUne classe abstraite est comme un plan architectural incomplet Elle d√©finit la structure mais certaines parties doivent √™tre compl√©t√©es Vous ne pouvez pas habiter dans un plan, vous devez construire la maison compl√®te 11.2 M√©thodes Abstraites public abstract class Forme { protected string _nom; protected string _couleur; public Forme(string nom, string couleur) { _nom = nom; _couleur = couleur; } // ========================================== // M√âTHODE ABSTRAITE - Pas d'impl√©mentation // DOIT √™tre red√©finie dans les classes d√©riv√©es // ========================================== public abstract double CalculerAire(); public abstract double CalculerPerimetre(); // ========================================== // M√âTHODE CONCR√àTE - A une impl√©mentation // ========================================== public void AfficherInfos() { Console.WriteLine($\"\\n{_nom} ({_couleur})\"); Console.WriteLine($\"Aire: {CalculerAire():F2}\"); Console.WriteLine($\"P√©rim√®tre: {CalculerPerimetre():F2}\"); } } // ========================================== // CLASSE D√âRIV√âE - DOIT impl√©menter les m√©thodes abstraites // ========================================== public class Cercle : Forme { private double _rayon; public Cercle(double rayon, string couleur) : base(\"Cercle\", couleur) { _rayon = rayon; } // ========================================== // IMPL√âMENTATION OBLIGATOIRE // ========================================== public override double CalculerAire() { return Math.PI * _rayon * _rayon; } public override double CalculerPerimetre() { return 2 * Math.PI * _rayon; } } public class Rectangle : Forme { private double _longueur; private double _largeur; public Rectangle(double longueur, double largeur, string couleur) : base(\"Rectangle\", couleur) { _longueur = longueur; _largeur = largeur; } public override double CalculerAire() { return _longueur * _largeur; } public override double CalculerPerimetre() { return 2 * (_longueur + _largeur); } } // ========================================== // SI on oublie d'impl√©menter une m√©thode abstraite ‚Üí ERREUR // ========================================== /* public class Triangle : Forme // ‚ùå ERREUR DE COMPILATION { // Erreur: Triangle ne red√©finit pas les m√©thodes abstraites } */ // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // ‚ùå ERREUR - Impossible d'instancier une classe abstraite // Forme f = new Forme(\"Test\", \"Rouge\"); // ‚úÖ OK - Instanciation des classes concr√®tes Forme cercle = new Cercle(5, \"Rouge\"); Forme rectangle = new Rectangle(4, 6, \"Bleu\"); // Polymorphisme cercle.AfficherInfos(); rectangle.AfficherInfos(); // Liste polymorphe List\u003cForme\u003e formes = new List\u003cForme\u003e { new Cercle(3, \"Vert\"), new Rectangle(5, 2, \"Jaune\"), new Cercle(7, \"Orange\") }; double aireTotal e = 0; foreach (Forme forme in formes) { aireTotal += forme.CalculerAire(); } Console.WriteLine($\"\\nAire totale: {aireTotal:F2}\"); } } 11.3 Propri√©t√©s Abstraites Les propri√©t√©s peuvent aussi √™tre abstraites.\npublic abstract class Vehicule { // ========================================== // PROPRI√âT√â ABSTRAITE // ========================================== public abstract int NombreRoues { get; } public abstract string TypeCarburant { get; set; } public void AfficherInfos() { Console.WriteLine($\"V√©hicule √† {NombreRoues} roues\"); Console.WriteLine($\"Carburant: {TypeCarburant}\"); } } public class Voiture : Vehicule { public override int NombreRoues { get { return 4; } } private string _typeCarburant; public override string TypeCarburant { get { return _typeCarburant; } set { _typeCarburant = value; } } public Voiture() { _typeCarburant = \"Essence\"; } } public class Moto : Vehicule { public override int NombreRoues { get { return 2; } } public override string TypeCarburant { get; set; } = \"Essence\"; } 11.4 Combinaison de Virtual et Abstract Une classe abstraite peut contenir un m√©lange de m√©thodes abstraites, virtuelles et concr√®tes.\npublic abstract class Animal { protected string _nom; public Animal(string nom) { _nom = nom; } // ========================================== // M√âTHODE ABSTRAITE - Impl√©mentation obligatoire // ========================================== public abstract void EmettreSound(); // ========================================== // M√âTHODE VIRTUELLE - Red√©finition optionnelle // ========================================== public virtual void Manger() { Console.WriteLine($\"{_nom} mange.\"); } // ========================================== // M√âTHODE CONCR√àTE - Impl√©mentation finale // ========================================== public void Dormir() { Console.WriteLine($\"{_nom} dort.\"); } } public class Chien : Animal { public Chien(string nom) : base(nom) { } // OBLIGATOIRE - M√©thode abstraite public override void EmettreSound() { Console.WriteLine($\"{_nom} aboie!\"); } // OPTIONNEL - M√©thode virtuelle public override void Manger() { Console.WriteLine($\"{_nom} d√©vore ses croquettes!\"); } // Dormir() est h√©rit√© tel quel } 12. Le mot-cl√© Sealed 12.1 D√©finition Le mot-cl√© sealed emp√™che l‚Äôh√©ritage ou la red√©finition :\nClasse sealed : Aucune classe ne peut en h√©riter M√©thode sealed : Aucune classe d√©riv√©e ne peut la red√©finir Pourquoi utiliser sealed ?\nS√©curit√© : Emp√™cher les modifications non d√©sir√©es Performance : Optimisations possibles par le compilateur Design : Indiquer qu‚Äôune classe est ‚Äúcompl√®te‚Äù et finale Analogie : C‚Äôest comme sceller un document avec de la cire. Une fois scell√©, il ne peut plus √™tre modifi√©.\n12.2 Classe Sealed // ========================================== // CLASSE SEALED - Ne peut pas √™tre h√©rit√©e // ========================================== public sealed class MathUtils { public static double CalculerMoyenne(params double[] nombres) { return nombres.Average(); } public static int Max(int a, int b) { return a \u003e b ? a : b; } } // ‚ùå ERREUR DE COMPILATION - Impossible d'h√©riter d'une classe sealed /* public class MesUtils : MathUtils { // Erreur: cannot derive from sealed type 'MathUtils' } */ Exemples de classes sealed dans .NET :\nString : sealed (impossible d‚Äôh√©riter de string) Int32, Double, etc. : sealed DateTime : sealed // ‚ùå Impossible // public class MaChaine : String { } // ‚úÖ Utilisation normale string texte = \"Bonjour\"; 12.3 M√©thode Sealed Une m√©thode sealed emp√™che sa red√©finition dans les classes d√©riv√©es ult√©rieures.\nImportant : Une m√©thode ne peut √™tre sealed que si elle override d√©j√† une m√©thode.\npublic class Animal { public virtual void EmettreSound() { Console.WriteLine(\"Son animal\"); } } public class Mammifere : Animal { // ========================================== // OVERRIDE + SEALED // Cette version est finale, ne peut plus √™tre red√©finie // ========================================== public sealed override void EmettreSound() { Console.WriteLine(\"Son de mammif√®re\"); } } public class Chien : Mammifere { // ‚ùå ERREUR - Ne peut pas override une m√©thode sealed /* public override void EmettreSound() { Console.WriteLine(\"Wouf!\"); } */ // ‚úÖ OK - M√©thode diff√©rente (pas un override) public void Aboyer() { Console.WriteLine(\"Wouf!\"); } } 12.4 Cas d‚ÄôUsage de Sealed Exemple 1 : Classe Utilitaire Compl√®te // Classe utilitaire qui ne devrait jamais √™tre modifi√©e public sealed class ConfigurationManager { private static ConfigurationManager _instance; private Dictionary\u003cstring, string\u003e _settings; private ConfigurationManager() { _settings = new Dictionary\u003cstring, string\u003e(); ChargerConfiguration(); } public static ConfigurationManager Instance { get { if (_instance == null) _instance = new ConfigurationManager(); return _instance; } } private void ChargerConfiguration() { // Chargement de la configuration } public string ObtenirValeur(string cle) { return _settings.ContainsKey(cle) ? _settings[cle] : null; } } // Impossible d'h√©riter pour modifier le comportement Exemple 2 : M√©thode Sealed pour la S√©curit√© public class SystemeS√©curit√© { public virtual bool VerifierAcces(string utilisateur) { Console.WriteLine(\"V√©rification de base\"); return true; } } public class SystemeAvance : SystemeS√©curit√© { // Version finale de la v√©rification - ne doit plus √™tre modifi√©e public sealed override bool VerifierAcces(string utilisateur) { Console.WriteLine(\"V√©rification avanc√©e (FINALE)\"); // Logique critique de s√©curit√© bool accesBase = base.VerifierAcces(utilisateur); bool verification2FA = Verifier2FA(utilisateur); bool verificationBiometrique = VerifierBiometrie(utilisateur); return accesBase \u0026\u0026 verification2FA \u0026\u0026 verificationBiometrique; } private bool Verifier2FA(string utilisateur) { return true; } private bool VerifierBiometrie(string utilisateur) { return true; } } // Aucune classe d√©riv√©e ne peut affaiblir la s√©curit√© public class SystemeTresAvance : SystemeAvance { // ‚ùå Ne peut pas override VerifierAcces // La s√©curit√© est garantie } 13. Les Classes Abstraites 13.1 D√©finition Compl√®te Une classe abstraite est une classe d√©clar√©e avec le mot-cl√© abstract qui :\nNe peut pas √™tre instanci√©e directement Peut contenir des m√©thodes abstraites (sans impl√©mentation) ET des m√©thodes concr√®tes (avec impl√©mentation) Peut avoir des constructeurs (appel√©s par les classes d√©riv√©es) Peut avoir des attributs, propri√©t√©s, etc. Sert de mod√®le ou de base pour d‚Äôautres classes Quand utiliser une classe abstraite ?\nQuand vous voulez d√©finir un comportement commun pour un groupe de classes Quand certaines m√©thodes doivent √™tre impl√©ment√©es diff√©remment par chaque classe d√©riv√©e Quand vous voulez partager du code entre classes similaires Quand la classe repr√©sente un concept abstrait qui ne devrait pas exister seul 13.2 Anatomie Compl√®te d‚Äôune Classe Abstraite public abstract class Vehicule { // ========================================== // 1. ATTRIBUTS (comme une classe normale) // ========================================== protected string _marque; protected string _modele; private int _annee; protected double _kilometrage; // ========================================== // 2. PROPRI√âT√âS // ========================================== public string Marque { get { return _marque; } } public string Modele { get { return _modele; } } public int Annee { get { return _annee; } } public double Kilometrage { get { return _kilometrage; } } // ========================================== // 3. CONSTRUCTEUR (Oui, les classes abstraites peuvent en avoir!) // ========================================== protected Vehicule(string marque, string modele, int annee) { _marque = marque; _modele = modele; _annee = annee; _kilometrage = 0; Console.WriteLine($\"Constructeur de Vehicule appel√© pour {marque} {modele}\"); } // ========================================== // 4. M√âTHODES ABSTRAITES - Impl√©mentation obligatoire // ========================================== public abstract void Demarrer(); public abstract double CalculerConsommation(double distance); public abstract string ObtenirTypeCarburant(); // ========================================== // 5. M√âTHODES VIRTUELLES - Red√©finition optionnelle // ========================================== public virtual void Accelerer(int vitesse) { Console.WriteLine($\"Le v√©hicule acc√©l√®re √† {vitesse} km/h\"); } public virtual void Klaxonner() { Console.WriteLine(\"Beep beep!\"); } // ========================================== // 6. M√âTHODES CONCR√àTES - H√©rit√©es telles quelles // ========================================== public void Rouler(double distance) { _kilometrage += distance; double consommation = CalculerConsommation(distance); // Appelle la m√©thode abstraite Console.WriteLine($\"Parcouru {distance} km. Consommation: {consommation:F2}L\"); Console.WriteLine($\"Kilom√©trage total: {_kilometrage} km\"); } public void AfficherInfos() { Console.WriteLine($\"\\n=== {_marque} {_modele} ({_annee}) ===\"); Console.WriteLine($\"Type de carburant: {ObtenirTypeCarburant()}\"); Console.WriteLine($\"Kilom√©trage: {_kilometrage} km\"); } // ========================================== // 7. PROPRI√âT√âS ABSTRAITES // ========================================== public abstract int NombreRoues { get; } } 13.3 Impl√©mentation de la Classe Abstraite // ========================================== // CLASSE CONCR√àTE 1 : Voiture // ========================================== public class Voiture : Vehicule { private string _typeCarburant; private double _consommationAu100; private int _nombrePortes; public Voiture(string marque, string modele, int annee, int portes, string carburant, double consommation) : base(marque, modele, annee) // Appelle le constructeur abstrait { _nombrePortes = portes; _typeCarburant = carburant; _consommationAu100 = consommation; } // Impl√©mentation obligatoire des m√©thodes abstraites public override void Demarrer() { Console.WriteLine($\"La voiture {_marque} {_modele} d√©marre avec la cl√©.\"); } public override double CalculerConsommation(double distance) { return (distance / 100) * _consommationAu100; } public override string ObtenirTypeCarburant() { return _typeCarburant; } // Impl√©mentation de la propri√©t√© abstraite public override int NombreRoues { get { return 4; } } // Red√©finition optionnelle d'une m√©thode virtuelle public override void Klaxonner() { Console.WriteLine(\"La voiture klaxonne: BEEP BEEP!\"); } // Nouvelle m√©thode sp√©cifique public void OuvrirCoffre() { Console.WriteLine(\"Coffre ouvert\"); } } // ========================================== // CLASSE CONCR√àTE 2 : Moto // ========================================== public class Moto : Vehicule { private bool _aSidecar; private double _consommationAu100; public Moto(string marque, string modele, int annee, bool sidecar, double consommation) : base(marque, modele, annee) { _aSidecar = sidecar; _consommationAu100 = consommation; } public override void Demarrer() { Console.WriteLine($\"La moto {_marque} {_modele} d√©marre avec le bouton start.\"); } public override double CalculerConsommation(double distance) { double consommation = (distance / 100) * _consommationAu100; if (_aSidecar) consommation *= 1.2; // 20% de plus avec sidecar return consommation; } public override string ObtenirTypeCarburant() { return \"Essence\"; } public override int NombreRoues { get { return _aSidecar ? 3 : 2; } } // Utilise la m√©thode virtuelle h√©rit√©e (pas de red√©finition) // Donc Klaxonner() sera \"Beep beep!\" de la classe de base } // ========================================== // CLASSE CONCR√àTE 3 : Camion // ========================================== public class Camion : Vehicule { private double _capaciteChargeTonnes; private double _consommationAu100; private double _chargeActuelle; public Camion(string marque, string modele, int annee, double capacite, double consommation) : base(marque, modele, annee) { _capaciteChargeTonnes = capacite; _consommationAu100 = consommation; _chargeActuelle = 0; } public override void Demarrer() { Console.WriteLine($\"Le camion {_marque} {_modele} d√©marre avec un vrombissement.\"); } public override double CalculerConsommation(double distance) { double baseConsommation = (distance / 100) * _consommationAu100; // Consommation augmente avec la charge double facteurCharge = 1 + (_chargeActuelle / _capaciteChargeTonnes) * 0.5; return baseConsommation * facteurCharge; } public override string ObtenirTypeCarburant() { return \"Diesel\"; } public override int NombreRoues { get { return 18; } } public void Charger(double poids) { if (_chargeActuelle + poids \u003c= _capaciteChargeTonnes) { _chargeActuelle += poids; Console.WriteLine($\"Chargement de {poids}t. Charge totale: {_chargeActuelle}t\"); } else { Console.WriteLine($\"Impossible! Capacit√© d√©pass√©e.\"); } } } 13.4 Utilisation Polymorphe class Program { static void Main() { // ‚ùå IMPOSSIBLE - Classe abstraite // Vehicule v = new Vehicule(\"Test\", \"Test\", 2020); // ‚úÖ OK - Classes concr√®tes Vehicule voiture = new Voiture(\"Toyota\", \"Camry\", 2023, 4, \"Essence\", 7.5); Vehicule moto = new Moto(\"Harley\", \"Davidson\", 2022, false, 4.5); Vehicule camion = new Camion(\"Volvo\", \"FH16\", 2021, 25, 30); // ========================================== // POLYMORPHISME EN ACTION // ========================================== List\u003cVehicule\u003e parc = new List\u003cVehicule\u003e { voiture, moto, camion }; Console.WriteLine(\"=== D√âMARRAGE DE TOUS LES V√âHICULES ===\\n\"); foreach (Vehicule vehicule in parc) { vehicule.Demarrer(); // Appelle la bonne version } Console.WriteLine(\"\\n=== TRAJET DE 100 KM ===\\n\"); foreach (Vehicule vehicule in parc) { vehicule.Rouler(100); vehicule.AfficherInfos(); } // ========================================== // UTILISATION SP√âCIFIQUE // ========================================== if (camion is Camion c) { c.Charger(10); c.Rouler(50); // Consommation affect√©e par la charge } } } 13.5 Exemple Complet : Syst√®me de Paiement // ========================================== // CLASSE ABSTRAITE : Moyen de Paiement // ========================================== public abstract class MoyenPaiement { protected string _titulaire; protected DateTime _dateTransaction; public string Titulaire { get { return _titulaire; } } public DateTime DateTransaction { get { return _dateTransaction; } } protected MoyenPaiement(string titulaire) { _titulaire = titulaire; } // M√©thodes abstraites public abstract bool Payer(decimal montant); public abstract bool Verifier(); public abstract string ObtenirType(); // M√©thode virtuelle public virtual void AfficherRecu(decimal montant) { Console.WriteLine($\"\\n====== RE√áU DE PAIEMENT ======\"); Console.WriteLine($\"Titulaire: {_titulaire}\"); Console.WriteLine($\"Type: {ObtenirType()}\"); Console.WriteLine($\"Montant: {montant:C}\"); Console.WriteLine($\"Date: {_dateTransaction:F}\"); Console.WriteLine($\"==============================\\n\"); } // M√©thode concr√®te protected void EnregistrerTransaction() { _dateTransaction = DateTime.Now; Console.WriteLine($\"[LOG] Transaction enregistr√©e pour {_titulaire}\"); } } // Classes concr√®tes... // (voir continuation dans le message suivant) public class CarteCredit : MoyenPaiement { private string _numero; private DateTime _dateExpiration; private decimal _limiteCredit; private decimal _soldeUtilise; public CarteCredit(string titulaire, string numero, DateTime expiration, decimal limite) : base(titulaire) { _numero = numero; _dateExpiration = expiration; _limiteCredit = limite; _soldeUtilise = 0; } public override bool Verifier() { if (_dateExpiration \u003c DateTime.Now) { Console.WriteLine(\"‚ùå Carte expir√©e\"); return false; } return true; } public override bool Payer(decimal montant) { if (!Verifier()) return false; if (_soldeUtilise + montant \u003e _limiteCredit) { Console.WriteLine($\"‚ùå Limite de cr√©dit d√©pass√©e ({_limiteCredit:C})\"); return false; } _soldeUtilise += montant; EnregistrerTransaction(); Console.WriteLine($\"‚úÖ Paiement de {montant:C} effectu√© par carte de cr√©dit\"); Console.WriteLine($\" Solde disponible: {_limiteCredit - _soldeUtilise:C}\"); return true; } public override string ObtenirType() { return \"Carte de Cr√©dit\"; } } public class CompteBancaire : MoyenPaiement { private string _numeroCompte; private decimal _solde; public CompteBancaire(string titulaire, string numero, decimal soldeInitial) : base(titulaire) { _numeroCompte = numero; _solde = soldeInitial; } public override bool Verifier() { return true; // Toujours valide } public override bool Payer(decimal montant) { if (_solde \u003c montant) { Console.WriteLine($\"‚ùå Solde insuffisant (Disponible: {_solde:C})\"); return false; } _solde -= montant; EnregistrerTransaction(); Console.WriteLine($\"‚úÖ Paiement de {montant:C} effectu√© par compte bancaire\"); Console.WriteLine($\" Nouveau solde: {_solde:C}\"); return true; } public override string ObtenirType() { return \"Compte Bancaire\"; } } // Utilisation List\u003cMoyenPaiement\u003e moyensPaiement = new List\u003cMoyenPaiement\u003e { new CarteCredit(\"Alice Martin\", \"1234-5678-9012-3456\", DateTime.Now.AddYears(2), 5000), new CompteBancaire(\"Bob Gagnon\", \"CA123456\", 2000) }; foreach (var moyen in moyensPaiement) { if (moyen.Payer(150)) { moyen.AfficherRecu(150); } } 14. Les Interfaces 14.1 D√©finition Approfondie Une interface est un contrat qui d√©finit un ensemble de membres (m√©thodes, propri√©t√©s, √©v√©nements) que les classes doivent impl√©menter, sans fournir d‚Äôimpl√©mentation.\nDiff√©rences cl√©s : Interface vs Classe Abstraite\nAspect Interface Classe Abstraite Impl√©mentation Aucune (contrat pur) Peut contenir du code H√©ritage multiple ‚úÖ Oui ‚ùå Non Constructeurs ‚ùå Non ‚úÖ Oui Champs ‚ùå Non ‚úÖ Oui Modificateurs d‚Äôacc√®s Tous public Vari√©s (private, protected, etc.) But D√©finir un comportement Partager du code commun Quand utiliser une interface ?\nD√©finir un comportement commun √† des classes sans relation hi√©rarchique Permettre l‚Äôh√©ritage multiple de comportements Cr√©er des contrats que diff√©rentes classes doivent respecter Favoriser le couplage faible dans votre architecture Analogie : Une interface est comme un certificat de comp√©tence :\nUn pilote peut avoir : certificat voiture, certificat moto, certificat avion Chaque certificat garantit certaines comp√©tences Diff√©rentes personnes peuvent avoir diff√©rentes combinaisons de certificats 14.2 D√©claration d‚Äôune Interface // ========================================== // CONVENTION : Pr√©fixe 'I' pour les interfaces // ========================================== public interface IVolant { // ========================================== // M√âTHODES (pas d'impl√©mentation) // ========================================== void Voler(); void Atterrir(); // ========================================== // PROPRI√âT√âS (seulement les signatures) // ========================================== double AltitudeMaximale { get; } double Vitesse { get; set; } // ========================================== // TOUS les membres sont PUBLIC par d√©faut // Pas besoin de sp√©cifier 'public' // ========================================== } public interface INageant { void Nager(); void Plonger(double profondeur); double ProfondeurMaximale { get; } } public interface IMarchant { void Marcher(); void Courir(); int VitesseMarche { get; } } 14.3 Impl√©mentation d‚ÄôInterfaces // ========================================== // Une classe peut impl√©menter PLUSIEURS interfaces // ========================================== public class Canard : IVolant, INageant, IMarchant { private double _altitudeActuelle; private double _profondeurActuelle; // ========================================== // Impl√©mentation de IVolant // ========================================== public double AltitudeMaximale { get { return 1000; } } public double Vitesse { get; set; } public void Voler() { _altitudeActuelle = 100; Console.WriteLine($\"Le canard vole √† {_altitudeActuelle}m\"); } public void Atterrir() { _altitudeActuelle = 0; Console.WriteLine(\"Le canard atterrit\"); } // ========================================== // Impl√©mentation de INageant // ========================================== public double ProfondeurMaximale { get { return 5; } } public void Nager() { Console.WriteLine(\"Le canard nage √† la surface\"); } public void Plonger(double profondeur) { if (profondeur \u003c= ProfondeurMaximale) { _profondeurActuelle = profondeur; Console.WriteLine($\"Le canard plonge √† {profondeur}m\"); } else { Console.WriteLine(\"Trop profond!\"); } } // ========================================== // Impl√©mentation de IMarchant // ========================================== public int VitesseMarche { get { return 5; } } public void Marcher() { Console.WriteLine(\"Le canard se dandine\"); } public void Courir() { Console.WriteLine(\"Le canard court maladroitement\"); } } // ========================================== // Autre classe avec un sous-ensemble d'interfaces // ========================================== public class Avion : IVolant { public double AltitudeMaximale { get { return 12000; } } public double Vitesse { get; set; } public void Voler() { Console.WriteLine($\"L'avion vole √† {Vitesse} km/h\"); } public void Atterrir() { Console.WriteLine(\"L'avion atterrit sur la piste\"); } } public class Poisson : INageant { public double ProfondeurMaximale { get { return 500; } } public void Nager() { Console.WriteLine(\"Le poisson nage gracieusement\"); } public void Plonger(double profondeur) { Console.WriteLine($\"Le poisson plonge √† {profondeur}m\"); } } 14.4 Polymorphisme avec Interfaces class Program { static void Main() { // ========================================== // Collections polymorphes bas√©es sur les interfaces // ========================================== // Tous les √™tres volants List\u003cIVolant\u003e volants = new List\u003cIVolant\u003e { new Canard(), new Avion { Vitesse = 800 }, new Canard() }; Console.WriteLine(\"=== D√âCOLLAGE ===\"); foreach (IVolant volant in volants) { volant.Voler(); // Polymorphisme! } // Tous les √™tres nageants List\u003cINageant\u003e nageants = new List\u003cINageant\u003e { new Canard(), new Poisson() }; Console.WriteLine(\"\\n=== PLONG√âE ===\"); foreach (INageant nageant in nageants) { nageant.Nager(); nageant.Plonger(3); } // ========================================== // Le canard peut √™tre utilis√© comme 3 types diff√©rents // ========================================== Canard donald = new Canard(); IVolant v = donald; // R√©f√©rence comme IVolant INageant n = donald; // R√©f√©rence comme INageant IMarchant m = donald; // R√©f√©rence comme IMarchant v.Voler(); n.Nager(); m.Marcher(); } } 14.5 V√©rification de Type avec Interfaces public void TraiterAnimal(object animal) { // ========================================== // Test avec 'is' // ========================================== if (animal is IVolant) { Console.WriteLine(\"Cet animal peut voler!\"); } if (animal is INageant) { Console.WriteLine(\"Cet animal peut nager!\"); } // ========================================== // Cast avec 'as' // ========================================== IVolant volant = animal as IVolant; if (volant != null) { volant.Voler(); } // ========================================== // Pattern matching (C# 7+) // ========================================== if (animal is IVolant v) { Console.WriteLine($\"Altitude max: {v.AltitudeMaximale}m\"); v.Voler(); } } 14.6 Impl√©mentation Explicite d‚ÄôInterface Utilis√©e pour r√©soudre les conflits quand deux interfaces ont des membres avec le m√™me nom.\npublic interface IAnimal { void Manger(); string Nom { get; } } public interface IRobot { void Manger(); // M√™me nom! string Nom { get; } } public class CyberChien : IAnimal, IRobot { private string _nom; public CyberChien(string nom) { _nom = nom; } // ========================================== // IMPL√âMENTATION EXPLICITE pour IAnimal // ========================================== void IAnimal.Manger() { Console.WriteLine($\"{_nom} mange de la nourriture organique\"); } string IAnimal.Nom { get { return $\"{_nom} (animal)\"; } } // ========================================== // IMPL√âMENTATION EXPLICITE pour IRobot // ========================================== void IRobot.Manger() { Console.WriteLine($\"{_nom} recharge ses batteries\"); } string IRobot.Nom { get { return $\"{_nom} (robot)\"; } } // ========================================== // M√©thode publique normale // ========================================== public void SeReposer() { Console.WriteLine($\"{_nom} se met en veille\"); } } // Utilisation CyberChien cyber = new CyberChien(\"RoboDog\"); // ‚ùå ERREUR - Ambigu√Øt√© // cyber.Manger(); // ‚úÖ OK - Cast explicite IAnimal animal = cyber; animal.Manger(); // Nourriture organique Console.WriteLine(animal.Nom); IRobot robot = cyber; robot.Manger(); // Recharge batteries Console.WriteLine(robot.Nom); cyber.SeReposer(); // ‚úÖ OK - M√©thode publique 14.7 Exemple Complet : Syst√®me de Notifications // ========================================== // INTERFACES // ========================================== public interface INotifiable { void EnvoyerNotification(string message); bool EstActif { get; set; } } public interface IConfigurable { void Configurer(Dictionary\u003cstring, string\u003e parametres); Dictionary\u003cstring, string\u003e ObtenirConfiguration(); } public interface IPrioritaire { int Priorite { get; set; } } // ========================================== // CLASSES D'IMPL√âMENTATION // ========================================== public class NotificationEmail : INotifiable, IConfigurable { public bool EstActif { get; set; } = true; public string AdresseEmail { get; private set; } public string ServeurSMTP { get; private set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"üìß [EMAIL] √Ä: {AdresseEmail}\"); Console.WriteLine($\" Message: {message}\"); Console.WriteLine($\" Via: {ServeurSMTP}\\n\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"email\")) AdresseEmail = parametres[\"email\"]; if (parametres.ContainsKey(\"smtp\")) ServeurSMTP = parametres[\"smtp\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"email\", AdresseEmail }, { \"smtp\", ServeurSMTP } }; } } public class NotificationSMS : INotifiable, IConfigurable, IPrioritaire { public bool EstActif { get; set; } = true; public int Priorite { get; set; } = 1; public string NumeroTelephone { get; private set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"üì± [SMS] Au: {NumeroTelephone}\"); Console.WriteLine($\" Message: {message}\"); Console.WriteLine($\" Priorit√©: {Priorite}\\n\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"telephone\")) NumeroTelephone = parametres[\"telephone\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"telephone\", NumeroTelephone } }; } } public class NotificationPush : INotifiable, IPrioritaire { public bool EstActif { get; set; } = true; public int Priorite { get; set; } = 2; public string DeviceId { get; set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"üîî [PUSH] Device: {DeviceId}\"); Console.WriteLine($\" Message: {message}\"); Console.WriteLine($\" Priorit√©: {Priorite}\\n\"); } } } // ========================================== // GESTIONNAIRE // ========================================== public class GestionnaireNotifications { private List\u003cINotifiable\u003e _canaux = new List\u003cINotifiable\u003e(); public void AjouterCanal(INotifiable canal) { _canaux.Add(canal); Console.WriteLine($\"‚úÖ Canal ajout√©: {canal.GetType().Name}\"); } public void EnvoyerATous(string message) { Console.WriteLine($\"\\n{'='.ToString().PadLeft(50, '=')}\"); Console.WriteLine($\"ENVOI √Ä TOUS LES CANAUX\"); Console.WriteLine($\"{'='.ToString().PadLeft(50, '=')}\\n\"); foreach (INotifiable canal in _canaux) { canal.EnvoyerNotification(message); } } public void EnvoyerParPriorite(string message, int prioriteMin) { Console.WriteLine($\"\\n{'='.ToString().PadLeft(50, '=')}\"); Console.WriteLine($\"ENVOI PRIORITAIRE (\u003e= {prioriteMin})\"); Console.WriteLine($\"{'='.ToString().PadLeft(50, '=')}\\n\"); foreach (INotifiable canal in _canaux) { // V√©rifie si le canal supporte IPrioritaire if (canal is IPrioritaire prioritaire) { if (prioritaire.Priorite \u003e= prioriteMin) { canal.EnvoyerNotification(message); } } } } public void ConfigurerCanaux() { foreach (INotifiable canal in _canaux) { if (canal is IConfigurable configurable) { Console.WriteLine($\"\\nConfiguration de {canal.GetType().Name}:\"); var config = configurable.ObtenirConfiguration(); foreach (var param in config) { Console.WriteLine($\" {param.Key}: {param.Value}\"); } } } } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { GestionnaireNotifications gestionnaire = new GestionnaireNotifications(); // Cr√©ation et configuration des canaux var email = new NotificationEmail(); email.Configurer(new Dictionary\u003cstring, string\u003e { { \"email\", \"user@example.com\" }, { \"smtp\", \"smtp.example.com\" } }); var sms = new NotificationSMS { Priorite = 3 }; sms.Configurer(new Dictionary\u003cstring, string\u003e { { \"telephone\", \"+1-514-555-0123\" } }); var push = new NotificationPush { DeviceId = \"ABC123\", Priorite = 2 }; // Ajout des canaux gestionnaire.AjouterCanal(email); gestionnaire.AjouterCanal(sms); gestionnaire.AjouterCanal(push); // Envoi de notifications gestionnaire.EnvoyerATous(\"Bienvenue dans le syst√®me!\"); gestionnaire.EnvoyerParPriorite(\"ALERTE: Activit√© suspecte d√©tect√©e!\", 2); // Affichage de la configuration gestionnaire.ConfigurerCanaux(); } } 14.8 Interfaces vs Classes Abstraites : Quand Utiliser Quoi ? Utilisez une INTERFACE quand :\nVous d√©finissez un comportement que des classes sans relation peuvent partager Vous voulez permettre l‚Äôh√©ritage multiple de comportements Vous cr√©ez un plugin system ou une architecture d√©coupl√©e Les impl√©mentations seront tr√®s diff√©rentes Exemples d‚Äôinterfaces : IComparable, IDisposable, IEnumerable\nUtilisez une CLASSE ABSTRAITE quand :\nVous voulez partager du code entre classes li√©es Vous avez une hi√©rarchie ‚Äúest-un‚Äù claire Vous voulez fournir une impl√©mentation par d√©faut Les classes d√©riv√©es ont beaucoup en commun Exemples : Stream, DbConnection, Control (UI)\nExemple combin√© :\n// Interface pour le comportement public interface IPayable { bool EffectuerPaiement(decimal montant); } // Classe abstraite pour le code commun public abstract class MoyenPaiement : IPayable { protected string _titulaire; protected MoyenPaiement(string titulaire) { _titulaire = titulaire; } // Impl√©mentation commune public void AfficherTitulaire() { Console.WriteLine($\"Titulaire: {_titulaire}\"); } // Impl√©mentation de l'interface (peut √™tre virtual ou abstract) public abstract bool EffectuerPaiement(decimal montant); } public class CarteCredit : MoyenPaiement { public CarteCredit(string titulaire) : base(titulaire) { } public override bool EffectuerPaiement(decimal montant) { Console.WriteLine($\"Paiement de {montant:C} par carte\"); return true; } } 15. Membres Statiques 15.1 D√©finition Les membres statiques (attributs, m√©thodes, propri√©t√©s) appartiennent √† la classe elle-m√™me plut√¥t qu‚Äôaux instances individuelles de la classe.\nAnalogie :\nMembres d‚Äôinstance = Caract√©ristiques personnelles (votre √¢ge, votre nom) Membres statiques = Caract√©ristiques partag√©es (le nombre total d‚Äô√™tres humains sur Terre) Caract√©ristiques :\nUn seul exemplaire existe pour toute la classe Partag√© entre toutes les instances Accessible via le nom de la classe (pas via une instance) Existe m√™me sans aucune instance cr√©√©e 15.2 Attributs Statiques public class Compteur { // ========================================== // ATTRIBUT STATIQUE - Partag√© par toutes les instances // ========================================== private static int _nombreInstances = 0; // ========================================== // ATTRIBUT D'INSTANCE - Unique pour chaque objet // ========================================== private int _id; public int Id { get { return _id; } } // ========================================== // PROPRI√âT√â STATIQUE // ========================================== public static int NombreInstances { get { return _nombreInstances; } } // ========================================== // CONSTRUCTEUR // ========================================== public Compteur() { _nombreInstances++; // Modifie la variable STATIQUE _id = _nombreInstances; // Assigne un ID unique bas√© sur le compteur Console.WriteLine($\"Instance #{_id} cr√©√©e. Total: {_nombreInstances}\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { Console.WriteLine($\"Instances au d√©part: {Compteur.NombreInstances}\"); // 0 Compteur c1 = new Compteur(); // Instance #1 cr√©√©e. Total: 1 Compteur c2 = new Compteur(); // Instance #2 cr√©√©e. Total: 2 Compteur c3 = new Compteur(); // Instance #3 cr√©√©e. Total: 3 Console.WriteLine($\"\\nTotal d'instances: {Compteur.NombreInstances}\"); // 3 Console.WriteLine($\"ID de c1: {c1.Id}\"); // 1 Console.WriteLine($\"ID de c2: {c2.Id}\"); // 2 Console.WriteLine($\"ID de c3: {c3.Id}\"); // 3 // ========================================== // Le compteur est PARTAG√â // ========================================== Compteur c4 = new Compteur(); // Instance #4 cr√©√©e. Total: 4 Console.WriteLine($\"\\nTotal apr√®s c4: {Compteur.NombreInstances}\"); // 4 } } 15.3 M√©thodes Statiques public class CalculatriceMath { // ========================================== // M√âTHODES STATIQUES - Pas besoin d'instance // ========================================== public static double CalculerAireRectangle(double longueur, double largeur) { return longueur * largeur; } public static double CalculerAireCercle(double rayon) { return Math.PI * rayon * rayon; } public static int CalculerFactorielle(int n) { if (n \u003c= 1) return 1; return n * CalculerFactorielle(n - 1); } public static bool EstPremier(int nombre) { if (nombre \u003c 2) return false; for (int i = 2; i \u003c= Math.Sqrt(nombre); i++) { if (nombre % i == 0) return false; } return true; } } // Utilisation - SANS cr√©er d'objet double aire = CalculatriceMath.CalculerAireRectangle(5, 3); // 15 double cercle = CalculatriceMath.CalculerAireCercle(4); // ~50.27 int fact = CalculatriceMath.CalculerFactorielle(5); // 120 bool premier = CalculatriceMath.EstPremier(17); // true 15.4 Classes Statiques Une classe enti√®rement statique ne peut contenir que des membres statiques et ne peut pas √™tre instanci√©e.\n// ========================================== // CLASSE STATIQUE - Ne peut pas √™tre instanci√©e // ========================================== public static class Convertisseur { // Toutes les m√©thodes doivent √™tre statiques public static double CelsiusVersFahrenheit(double celsius) { return (celsius * 9 / 5) + 32; } public static double FahrenheitVersCelsius(double fahrenheit) { return (fahrenheit - 32) * 5 / 9; } public static double KilometresVersMiles(double km) { return km * 0.621371; } public static double MilesVersKilometres(double miles) { return miles / 0.621371; } } // Utilisation double fahrenheit = Convertisseur.CelsiusVersFahrenheit(25); // 77 double miles = Convertisseur.KilometresVersMiles(100); // 62.14 // ‚ùå ERREUR - Impossible d'instancier // Convertisseur conv = new Convertisseur(); Exemples de classes statiques dans .NET :\nConsole Math File Directory Environment 15.5 Constructeur Statique Un constructeur statique est ex√©cut√© une seule fois, avant la premi√®re utilisation de la classe.\npublic class Configuration { public static string CheminFichier { get; private set; } public static DateTime DateInitialisation { get; private set; } public static Dictionary\u003cstring, string\u003e Parametres { get; private set; } // ========================================== // CONSTRUCTEUR STATIQUE // Appel√© automatiquement avant la premi√®re utilisation // ========================================== static Configuration() { Console.WriteLine(\"Initialisation de la configuration...\"); CheminFichier = \"config.json\"; DateInitialisation = DateTime.Now; Parametres = new Dictionary\u003cstring, string\u003e { { \"version\", \"1.0\" }, { \"langue\", \"fr\" } }; Console.WriteLine($\"Configuration initialis√©e √† {DateInitialisation}\"); } public static void AfficherConfiguration() { Console.WriteLine($\"\\nConfiguration:\"); Console.WriteLine($\" Fichier: {CheminFichier}\"); Console.WriteLine($\" Initialis√©e: {DateInitialisation}\"); foreach (var param in Parametres) { Console.WriteLine($\" {param.Key}: {param.Value}\"); } } } // Utilisation class Program { static void Main() { Console.WriteLine(\"D√©but du programme\\n\"); // Le constructeur statique est appel√© ici (premi√®re utilisation) Configuration.AfficherConfiguration(); // Deuxi√®me utilisation - constructeur statique PAS rappel√© Configuration.AfficherConfiguration(); } } Affichage :\nD√©but du programme\rInitialisation de la configuration...\rConfiguration initialis√©e √† 01/02/2026 10:30:00\rConfiguration:\rFichier: config.json\rInitialis√©e: 01/02/2026 10:30:00\rversion: 1.0\rlangue: fr\rConfiguration:\rFichier: config.json\rInitialis√©e: 01/02/2026 10:30:00\rversion: 1.0\rlangue: fr 15.6 Exemple Complet : Gestionnaire de Base de Donn√©es public class GestionnaireDB { // ========================================== // MEMBRES STATIQUES - Partag√©s // ========================================== private static string _chaine Connexion; private static int _nombreConnexionsActives = 0; private static int _nombreConnexionsTotales = 0; public static int NombreConnexionsActives { get { return _nombreConnexionsActives; } } public static int NombreConnexionsTotales { get { return _nombreConnexionsTotales; } } // ========================================== // MEMBRES D'INSTANCE - Uniques √† chaque connexion // ========================================== private int _id; private bool _estConnecte; private DateTime _dateConnexion; public int Id { get { return _id; } } public bool EstConnecte { get { return _estConnecte; } } // ========================================== // CONSTRUCTEUR STATIQUE // ========================================== static GestionnaireDB() { Console.WriteLine(\"[STATIC] Initialisation du gestionnaire DB\"); _chaineConnexion = \"Server=localhost;Database=test;\"; } // ========================================== // CONSTRUCTEUR D'INSTANCE // ========================================== public GestionnaireDB() { _nombreConnexionsTotales++; _id = _nombreConnexionsTotales; Console.WriteLine($\"[INSTANCE #{_id}] Cr√©√©e\"); } // ========================================== // M√âTHODE D'INSTANCE // ========================================== public void Connecter() { if (!_estConnecte) { _estConnecte = true; _dateConnexion = DateTime.Now; _nombreConnexionsActives++; Console.WriteLine($\"[INSTANCE #{_id}] Connect√©e. Actives: {_nombreConnexionsActives}\"); } } public void Deconnecter() { if (_estConnecte) { _estConnecte = false; _nombreConnexionsActives--; Console.WriteLine($\"[INSTANCE #{_id}] D√©connect√©e. Actives: {_nombreConnexionsActives}\"); } } // ========================================== // M√âTHODE STATIQUE // ========================================== public static void AfficherStatistiques() { Console.WriteLine($\"\\n=== STATISTIQUES DB ===\"); Console.WriteLine($\"Cha√Æne de connexion: {_chaineConnexion}\"); Console.WriteLine($\"Connexions actives: {_nombreConnexionsActives}\"); Console.WriteLine($\"Total cr√©√©es: {_nombreConnexionsTotales}\"); Console.WriteLine($\"=======================\\n\"); } } // Utilisation class Program { static void Main() { GestionnaireDB.AfficherStatistiques(); // D√©clenche le constructeur statique GestionnaireDB db1 = new GestionnaireDB(); GestionnaireDB db2 = new GestionnaireDB(); GestionnaireDB db3 = new GestionnaireDB(); db1.Connecter(); db2.Connecter(); db3.Connecter(); GestionnaireDB.AfficherStatistiques(); db1.Deconnecter(); db2.Deconnecter(); GestionnaireDB.AfficherStatistiques(); } } 15.7 R√®gles Importantes public class Exemple { private static int _compteurStatique = 0; private int _compteurInstance = 0; // ========================================== // M√âTHODE STATIQUE // ========================================== public static void MethodeStatique() { // ‚úÖ OK - Acc√®s √† membre statique _compteurStatique++; // ‚ùå ERREUR - Pas d'acc√®s aux membres d'instance // _compteurInstance++; // ERREUR! // this._compteurInstance++; // ERREUR! // ‚úÖ OK - Appel d'autre m√©thode statique AutreMethodeStatique(); // ‚ùå ERREUR - Pas d'appel de m√©thode d'instance // MethodeInstance(); // ERREUR! } // ========================================== // M√âTHODE D'INSTANCE // ========================================== public void MethodeInstance() { // ‚úÖ OK - Acc√®s aux membres d'instance _compteurInstance++; // ‚úÖ OK - Acc√®s aux membres statiques aussi _compteurStatique++; // ‚úÖ OK - Appel de m√©thodes statiques MethodeStatique(); AutreMethodeStatique(); } private static void AutreMethodeStatique() { } } R√©sum√© Final Tableau R√©capitulatif des Concepts Concept D√©finition Exemple d‚ÄôUsage virtual M√©thode avec impl√©mentation, red√©finition optionnelle Comportement par d√©faut modifiable abstract M√©thode sans impl√©mentation, red√©finition obligatoire Forcer les d√©riv√©es √† impl√©menter sealed Emp√™che l‚Äôh√©ritage ou la red√©finition Classe/m√©thode finale override Red√©finit une m√©thode virtual ou abstract Polymorphisme new Masque un membre de la classe de base √âviter, pr√©f√©rer override base Acc√®de aux membres de la classe parent Appeler la version parente this R√©f√©rence √† l‚Äôinstance actuelle Distinguer attributs/param√®tres static Membre appartenant √† la classe Utilitaires, compteurs partag√©s interface Contrat sans impl√©mentation D√©finir comportements multiples abstract class Classe incompl√®te avec code partag√© Base commune avec impl√©mentation Hi√©rarchie Compl√®te d‚ÄôExemple // Interface public interface IVolant { void Voler(); } // Classe abstraite public abstract class Animal { protected string _nom; public Animal(string nom) { _nom = nom; } // M√©thode abstraite public abstract void EmettreSound(); // M√©thode virtuelle public virtual void Dormir() { Console.WriteLine($\"{_nom} dort\"); } // M√©thode concr√®te public void Respirer() { Console.WriteLine($\"{_nom} respire\"); } } // Classe concr√®te public class Oiseau : Animal, IVolant { public Oiseau(string nom) : base(nom) { } // Impl√©mentation obligatoire (abstract) public override void EmettreSound() { Console.WriteLine($\"{_nom} chante\"); } // Red√©finition optionnelle (virtual) public override void Dormir() { Console.WriteLine($\"{_nom} dort dans un nid\"); } // Impl√©mentation d'interface public void Voler() { Console.WriteLine($\"{_nom} vole\"); } } // Classe sealed public sealed class Pingouin : Oiseau { public Pingouin(string nom) : base(nom) { } // Sealed override public sealed override void Dormir() { Console.WriteLine($\"{_nom} dort en groupe\"); } // Les pingouins ne volent pas, mais impl√©mentent quand m√™me IVolant public new void Voler() { Console.WriteLine($\"{_nom} ne peut pas voler!\"); } } // ‚ùå Impossible d'h√©riter de Pingouin (sealed) // public class SuperPingouin : Pingouin { }",
    "description": "Table des mati√®res Le mot-cl√© Virtual Le mot-cl√© Abstract Le mot-cl√© Sealed Les Classes Abstraites Les Interfaces Membres Statiques Cours POO C# - Partie 2 : Concepts Avanc√©s 10. Le mot-cl√© Virtual 10.1 D√©finition Le mot-cl√© virtual permet de d√©clarer une m√©thode qui peut √™tre red√©finie (override) dans les classes d√©riv√©es. C‚Äôest la base du polymorphisme d‚Äôex√©cution en C#.",
    "tags": [],
    "title": "Programmation orient√©e objet - partie 2",
    "uri": "/420-413/poo_2/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Mini-Projets : Programmation Orient√©e Objet en C# Progression recommand√©e Niveau Projets D√©butant Projet 8 (Formes), Projet 5 (T√¢ches) Interm√©diaire Projet 1 (Banque), Projet 2 (Biblioth√®que), Projet 6 (Zoo) Avanc√© Projet 3 (RPG), Projet 4 (Restaurant), Projet 7 (H√¥tel) Table des mati√®res Projet 1 : Syst√®me de Gestion Bancaire Projet 2 : Gestion d‚Äôune Biblioth√®que Projet 3 : Jeu de Combat RPG Projet 4 : Syst√®me de Commandes Restaurant Projet 5 : Gestionnaire de T√¢ches Projet 6 : Simulateur de Zoo Projet 7 : Syst√®me de R√©servation H√¥tel Projet 8 : Calculatrice de Formes G√©om√©triques Projet 1 : Syst√®me de Gestion Bancaire üìã Objectif Cr√©er un syst√®me de gestion de comptes bancaires avec diff√©rents types de comptes et op√©rations.\nüéØ Concepts utilis√©s H√©ritage Encapsulation Polymorphisme Classes abstraites üìù Sp√©cifications Cr√©er :\nUne classe abstraite CompteBancaire avec :\nPropri√©t√©s : NumeroCompte, Titulaire, Solde, DateOuverture M√©thodes abstraites : CalculerInterets() M√©thodes concr√®tes : Deposer(), Retirer(), AfficherReleve() Classe CompteEpargne h√©ritant de CompteBancaire :\nPropri√©t√© : TauxInteret (ex: 2.5%) Minimum de retrait : 10$ Impl√©mente CalculerInterets() Classe CompteCourant h√©ritant de CompteBancaire :\nPropri√©t√© : DecouvertAutorise (ex: -500$) Frais mensuels : 5$ Peut retirer jusqu‚Äô√† atteindre le d√©couvert Classe CompteJeune h√©ritant de CompteEpargne :\nPour les moins de 18 ans Bonus annuel de 50$ si solde \u003e 500$ Limite de retrait : 200$ par transaction üí° Code de d√©marrage using System; using System.Collections.Generic; namespace GestionBancaire { // Classe abstraite de base public abstract class CompteBancaire { // TODO: Ajouter les propri√©t√©s // TODO: Ajouter le constructeur public virtual bool Deposer(decimal montant) { // TODO: Impl√©menter return false; } public abstract bool Retirer(decimal montant); public abstract decimal CalculerInterets(); public virtual void AfficherReleve() { // TODO: Impl√©menter } } // TODO: Cr√©er la classe CompteEpargne // TODO: Cr√©er la classe CompteCourant // TODO: Cr√©er la classe CompteJeune // Classe de gestion public class Banque { private List\u003cCompteBancaire\u003e _comptes = new List\u003cCompteBancaire\u003e(); public void AjouterCompte(CompteBancaire compte) { // TODO: Impl√©menter } public void AppliquerInt√©rets() { // TODO: Parcourir tous les comptes et appliquer les int√©r√™ts } public void AfficherTousLesComptes() { // TODO: Impl√©menter } } class Program { static void Main(string[] args) { // TODO: Cr√©er des comptes et tester Console.WriteLine(\"=== Syst√®me Bancaire ===\"); // Cr√©er une banque Banque banque = new Banque(); // Cr√©er diff√©rents types de comptes // ... // Effectuer des op√©rations // ... // Appliquer les int√©r√™ts // ... // Afficher tous les comptes // ... } } } ‚úÖ Crit√®res de r√©ussite Impossible de retirer plus que le solde (sauf compte courant avec d√©couvert) Les int√©r√™ts sont correctement calcul√©s Le polymorphisme fonctionne (m√™me m√©thode, comportements diff√©rents) Les encapsulations prot√®gent les donn√©es sensibles Projet 2 : Gestion d‚Äôune Biblioth√®que üìã Objectif Cr√©er un syst√®me de gestion de biblioth√®que avec emprunts et r√©servations.\nüéØ Concepts utilis√©s Interfaces H√©ritage Collections √ânum√©rations üìù Sp√©cifications Cr√©er :\nInterface IEmpruntable :\nM√©thodes : Emprunter(string emprunteur), Retourner() Propri√©t√© : EstDisponible Interface IReservable :\nM√©thodes : Reserver(string utilisateur), AnnulerReservation() Classe abstraite Document :\nPropri√©t√©s : Titre, Auteur, AnneePublication, Cote M√©thode abstraite : AfficherDetails() Classe Livre h√©ritant de Document et impl√©mentant IEmpruntable, IReservable :\nPropri√©t√©s suppl√©mentaires : ISBN, NombrePages, Genre Dur√©e d‚Äôemprunt : 21 jours Classe DVD h√©ritant de Document et impl√©mentant IEmpruntable :\nPropri√©t√©s suppl√©mentaires : Duree (en minutes), Genre Dur√©e d‚Äôemprunt : 7 jours Classe Magazine h√©ritant de Document et impl√©mentant IEmpruntable :\nPropri√©t√©s suppl√©mentaires : NumeroEdition, Mois Dur√©e d‚Äôemprunt : 14 jours Ne peut pas √™tre r√©serv√© √ânum√©ration GenreLivre : Fiction, NonFiction, ScienceFiction, Romance, Thriller, etc.\nClasse Bibliotheque :\nCollection de documents M√©thodes : AjouterDocument(), RechercherParTitre(), RechercherParAuteur(), ListerDocumentsDisponibles() üí° Code de d√©marrage using System; using System.Collections.Generic; using System.Linq; namespace GestionBibliotheque { public interface IEmpruntable { // TODO: D√©finir l'interface } public interface IReservable { // TODO: D√©finir l'interface } public enum GenreLivre { Fiction, NonFiction, ScienceFiction, Romance, Thriller, Biographie, Histoire } public abstract class Document { // TODO: Propri√©t√©s communes public abstract void AfficherDetails(); } public class Livre : Document, IEmpruntable, IReservable { // TODO: Impl√©menter } public class DVD : Document, IEmpruntable { // TODO: Impl√©menter } public class Magazine : Document, IEmpruntable { // TODO: Impl√©menter } public class Bibliotheque { private List\u003cDocument\u003e _documents = new List\u003cDocument\u003e(); public void AjouterDocument(Document document) { // TODO: Impl√©menter } public List\u003cDocument\u003e RechercherParTitre(string titre) { // TODO: Impl√©menter return null; } public void ListerDocumentsDisponibles() { // TODO: Impl√©menter } public void ListerEmprunts() { // TODO: Afficher tous les documents emprunt√©s } } class Program { static void Main(string[] args) { Bibliotheque biblio = new Bibliotheque(); // TODO: Ajouter des documents // TODO: Tester les emprunts // TODO: Tester les r√©servations // TODO: Tester les recherches } } } ‚úÖ Crit√®res de r√©ussite Impossible d‚Äôemprunter un document d√©j√† emprunt√© Les r√©servations fonctionnent uniquement pour les livres La recherche fonctionne correctement L‚Äôaffichage des d√©tails est polymorphe Projet 3 : Jeu de Combat RPG üìã Objectif Cr√©er un mini-jeu de combat avec diff√©rentes classes de personnages.\nüéØ Concepts utilis√©s H√©ritage Polymorphisme Classes abstraites Interfaces üìù Sp√©cifications Cr√©er :\nClasse abstraite Personnage :\nPropri√©t√©s : Nom, PointsDeVie, PointsDeVieMax, Force, Defense, Niveau M√©thode abstraite : AttaqueSpeciale() M√©thodes concr√®tes : Attaquer(Personnage cible), RecevoirDegats(int degats), EstVivant(), Guerir(int points) Classe Guerrier h√©ritant de Personnage :\nComp√©tence : Coup Puissant (2x la force, mais perd 10 PV) Bonus : +5 d√©fense Classe Mage h√©ritant de Personnage :\nPropri√©t√© suppl√©mentaire : Mana Comp√©tence : Boule de Feu (3x la force, co√ªte 30 mana) Peut se r√©g√©n√©rer (r√©cup√®re 20 mana par tour) Classe Archer h√©ritant de Personnage :\nPropri√©t√© suppl√©mentaire : Precision (%) Comp√©tence : Tir Critique (chance de critique bas√©e sur pr√©cision) Attaque √† distance (peut √©viter les contre-attaques) Classe Paladin h√©ritant de Personnage :\nPeut se soigner (50% de la force en soins) Comp√©tence : Bouclier Sacr√© (augmente d√©fense de 50% pour 3 tours) Bonus : R√©g√©n√©ration passive (5 PV par tour) Interface IInventaire :\nM√©thodes : AjouterObjet(), UtiliserObjet(), AfficherInventaire() Classe Objet :\nTypes : Potion (restore PV), PotionMana, ElixirForce (augmente force temporairement) üí° Code de d√©marrage using System; using System.Collections.Generic; namespace JeuCombatRPG { public abstract class Personnage { public string Nom { get; set; } public int PointsDeVie { get; protected set; } public int PointsDeVieMax { get; protected set; } public int Force { get; protected set; } public int Defense { get; protected set; } public int Niveau { get; protected set; } protected Personnage(string nom, int pv, int force, int defense) { // TODO: Initialiser } public virtual int Attaquer(Personnage cible) { // TODO: Calculer les d√©g√¢ts (Force - Defense de la cible) // Minimum 1 d√©g√¢t return 0; } public void RecevoirDegats(int degats) { // TODO: R√©duire les PV } public abstract void AttaqueSpeciale(Personnage cible); public bool EstVivant() { return PointsDeVie \u003e 0; } public void AfficherStats() { // TODO: Afficher nom, PV, Force, D√©fense } } public class Guerrier : Personnage { public Guerrier(string nom) : base(nom, 150, 25, 15) { } public override void AttaqueSpeciale(Personnage cible) { // TODO: Coup Puissant } } // TODO: Cr√©er les autres classes (Mage, Archer, Paladin) public class Combat { public void Duel(Personnage p1, Personnage p2) { Console.WriteLine($\"=== COMBAT: {p1.Nom} VS {p2.Nom} ===\\n\"); int tour = 1; while (p1.EstVivant() \u0026\u0026 p2.EstVivant()) { Console.WriteLine($\"--- Tour {tour} ---\"); // TODO: p1 attaque p2 if (!p2.EstVivant()) { Console.WriteLine($\"\\nüèÜ {p1.Nom} remporte le combat!\"); break; } // TODO: p2 attaque p1 if (!p1.EstVivant()) { Console.WriteLine($\"\\nüèÜ {p2.Nom} remporte le combat!\"); break; } tour++; Console.WriteLine(); } } } class Program { static void Main(string[] args) { // TODO: Cr√©er des personnages // TODO: Lancer des combats // TODO: Tester les attaques sp√©ciales } } } ‚úÖ Crit√®res de r√©ussite Chaque classe a une attaque sp√©ciale unique Le syst√®me de combat est √©quilibr√© Les statistiques sont correctement affich√©es Le polymorphisme permet des combats entre diff√©rents types üéÆ Extensions possibles Ajouter un syst√®me d‚Äôexp√©rience et de mont√©e de niveau Impl√©menter un inventaire d‚Äôobjets Cr√©er un mode tournoi avec plusieurs combattants Ajouter des effets de statut (poison, paralysie, etc.) Projet 4 : Syst√®me de Commandes Restaurant üìã Objectif Cr√©er un syst√®me de gestion de commandes pour un restaurant.\nüéØ Concepts utilis√©s H√©ritage Interfaces Collections √ânum√©rations üìù Sp√©cifications Cr√©er :\n√ânum√©ration CategoriePlat : Entree, PlatPrincipal, Dessert, Boisson\nClasse abstraite Article :\nPropri√©t√©s : Nom, Prix, Description, Categorie M√©thode abstraite : CalculerPrix() (pour g√©rer les options/suppl√©ments) Classe Plat h√©ritant de Article :\nPropri√©t√©s : Ingredients (liste), TempsPreparation, EstVegetarien Peut avoir des suppl√©ments (fromage +2$, bacon +3$) Classe Boisson h√©ritant de Article :\nPropri√©t√©s : Taille (Petit, Moyen, Grand), EstGazeuse Prix varie selon la taille Interface IPersonnalisable :\nM√©thodes : AjouterOption(string option, decimal prix), RetirerIngredient(string ingredient) Classe Menu :\nContient une entr√©e, un plat principal, un dessert et une boisson Prix r√©duit de 15% par rapport aux articles s√©par√©s Classe Commande :\nPropri√©t√©s : NumeroCommande, Client, Articles, DateHeure, Statut M√©thodes : AjouterArticle(), RetirerArticle(), CalculerTotal(), CalculerTaxes(), AfficherFacture() √ânum√©ration StatutCommande : EnAttente, EnPreparation, Prete, Livree, Annulee\nüí° Code de d√©marrage using System; using System.Collections.Generic; using System.Linq; namespace SystemeRestaurant { public enum CategoriePlat { Entree, PlatPrincipal, Dessert, Boisson } public enum StatutCommande { EnAttente, EnPreparation, Prete, Livree, Annulee } public enum TailleBoisson { Petit, Moyen, Grand } public interface IPersonnalisable { void AjouterOption(string option, decimal prix); void RetirerIngredient(string ingredient); } public abstract class Article { public string Nom { get; set; } public decimal PrixBase { get; set; } public string Description { get; set; } public CategoriePlat Categorie { get; set; } public abstract decimal CalculerPrix(); public virtual void AfficherDetails() { Console.WriteLine($\"{Nom} - {PrixBase:C}\"); Console.WriteLine($\" {Description}\"); } } public class Plat : Article, IPersonnalisable { public List\u003cstring\u003e Ingredients { get; set; } public int TempsPreparation { get; set; } // en minutes public bool EstVegetarien { get; set; } private Dictionary\u003cstring, decimal\u003e _options = new Dictionary\u003cstring, decimal\u003e(); public Plat() { Ingredients = new List\u003cstring\u003e(); } public void AjouterOption(string option, decimal prix) { // TODO: Impl√©menter } public void RetirerIngredient(string ingredient) { // TODO: Impl√©menter } public override decimal CalculerPrix() { // TODO: Prix de base + options return 0; } public override void AfficherDetails() { base.AfficherDetails(); Console.WriteLine($\" Temps de pr√©paration: {TempsPreparation} min\"); Console.WriteLine($\" V√©g√©tarien: {(EstVegetarien ? \"Oui\" : \"Non\")}\"); Console.WriteLine($\" Ingr√©dients: {string.Join(\", \", Ingredients)}\"); } } public class Boisson : Article { public TailleBoisson Taille { get; set; } public bool EstGazeuse { get; set; } public override decimal CalculerPrix() { // TODO: Ajuster le prix selon la taille // Petit: 100%, Moyen: 130%, Grand: 160% return 0; } } public class Menu { public Plat Entree { get; set; } public Plat PlatPrincipal { get; set; } public Article Dessert { get; set; } public Boisson Boisson { get; set; } public decimal CalculerPrix() { // TODO: Calculer avec r√©duction de 15% return 0; } public void AfficherMenu() { // TODO: Afficher tous les √©l√©ments du menu } } public class Commande { private static int _compteurCommandes = 0; public int NumeroCommande { get; private set; } public string Client { get; set; } public List\u003cArticle\u003e Articles { get; private set; } public DateTime DateHeure { get; private set; } public StatutCommande Statut { get; set; } public Commande(string client) { NumeroCommande = ++_compteurCommandes; Client = client; Articles = new List\u003cArticle\u003e(); DateHeure = DateTime.Now; Statut = StatutCommande.EnAttente; } public void AjouterArticle(Article article) { // TODO: Impl√©menter } public decimal CalculerSousTotal() { // TODO: Sommer tous les articles return 0; } public decimal CalculerTaxes() { // TODO: Calculer TPS (5%) + TVQ (9.975%) return 0; } public decimal CalculerTotal() { return CalculerSousTotal() + CalculerTaxes(); } public void AfficherFacture() { // TODO: Afficher facture d√©taill√©e } } public class Restaurant { public string Nom { get; set; } private List\u003cArticle\u003e _carte = new List\u003cArticle\u003e(); private List\u003cCommande\u003e _commandes = new List\u003cCommande\u003e(); public void AjouterAuMenu(Article article) { _carte.Add(article); } public void AfficherCarte() { // TODO: Afficher par cat√©gorie } public Commande CreerCommande(string client) { var commande = new Commande(client); _commandes.Add(commande); return commande; } public void AfficherCommandesEnCours() { // TODO: Afficher commandes non termin√©es } } class Program { static void Main(string[] args) { Restaurant resto = new Restaurant { Nom = \"Chez Claude\" }; // TODO: Cr√©er des plats et les ajouter au menu // TODO: Cr√©er une commande // TODO: Personnaliser des plats // TODO: Afficher la facture Console.WriteLine(\"\\n=== BIENVENUE CHEZ CLAUDE ===\\n\"); // Exemple de cr√©ation de plats var poutine = new Plat { Nom = \"Poutine Classique\", PrixBase = 12.99m, Description = \"Frites, sauce brune et fromage en grains\", Categorie = CategoriePlat.PlatPrincipal, Ingredients = new List\u003cstring\u003e { \"Frites\", \"Sauce brune\", \"Fromage en grains\" }, TempsPreparation = 15, EstVegetarien = true }; // ... cr√©er d'autres plats } } } ‚úÖ Crit√®res de r√©ussite Les prix sont calcul√©s correctement avec les options Les taxes sont appliqu√©es correctement La facture s‚Äôaffiche proprement Les menus offrent une r√©duction Projet 5 : Gestionnaire de T√¢ches üìã Objectif Cr√©er une application de gestion de t√¢ches avec diff√©rents types de t√¢ches et priorit√©s.\nüéØ Concepts utilis√©s H√©ritage Interfaces D√©l√©gu√©s et √©v√©nements Propri√©t√©s üìù Sp√©cifications Cr√©er :\n√ânum√©ration Priorite : Basse, Normale, Haute, Critique\n√ânum√©ration StatutTache : AFaire, EnCours, Terminee, Annulee\nInterface INotifiable :\n√âv√©nement : TacheModifiee M√©thode : NotifierChangement() Classe abstraite Tache :\nPropri√©t√©s : Id, Titre, Description, DateCreation, DateEcheance, Priorite, Statut M√©thodes abstraites : Executer(), EstEnRetard() Classe TacheSimple h√©ritant de Tache\nClasse TacheRecurrente h√©ritant de Tache :\nPropri√©t√© : Frequence (Quotidien, Hebdomadaire, Mensuel) M√©thode : CreerProchaineTache() Classe TacheAvecSousTaches h√©ritant de Tache :\nListe de sous-t√¢ches Calcul de progression (%) Classe ProjetTaches :\nCollection de t√¢ches M√©thodes : AjouterTache(), SupprimerTache(), ObtenirTachesParPriorite(), ObtenirTachesEnRetard() üí° Code de d√©marrage using System; using System.Collections.Generic; using System.Linq; namespace GestionnaireTaches { public enum Priorite { Basse, Normale, Haute, Critique } public enum StatutTache { AFaire, EnCours, Terminee, Annulee } public enum FrequenceRecurrence { Quotidien, Hebdomadaire, Mensuel } public interface INotifiable { event EventHandler\u003cstring\u003e TacheModifiee; void NotifierChangement(string message); } public abstract class Tache : INotifiable { private static int _compteur = 0; public int Id { get; private set; } public string Titre { get; set; } public string Description { get; set; } public DateTime DateCreation { get; private set; } public DateTime? DateEcheance { get; set; } public Priorite Priorite { get; set; } public StatutTache Statut { get; set; } public event EventHandler\u003cstring\u003e TacheModifiee; protected Tache(string titre) { Id = ++_compteur; Titre = titre; DateCreation = DateTime.Now; Statut = StatutTache.AFaire; Priorite = Priorite.Normale; } public abstract void Executer(); public virtual bool EstEnRetard() { // TODO: V√©rifier si la date d'√©ch√©ance est d√©pass√©e return false; } public void NotifierChangement(string message) { TacheModifiee?.Invoke(this, message); } public virtual void AfficherDetails() { // TODO: Afficher toutes les infos } } public class TacheSimple : Tache { public TacheSimple(string titre) : base(titre) { } public override void Executer() { // TODO: Marquer comme termin√©e } } public class TacheRecurrente : Tache { public FrequenceRecurrence Frequence { get; set; } public TacheRecurrente(string titre, FrequenceRecurrence frequence) : base(titre) { Frequence = frequence; } public override void Executer() { // TODO: Marquer comme termin√©e et cr√©er la prochaine occurrence } public TacheRecurrente CreerProchaineTache() { // TODO: Cr√©er une nouvelle t√¢che avec date d'√©ch√©ance ajust√©e return null; } } public class TacheAvecSousTaches : Tache { public List\u003cTache\u003e SousTaches { get; private set; } public TacheAvecSousTaches(string titre) : base(titre) { SousTaches = new List\u003cTache\u003e(); } public void AjouterSousTache(Tache tache) { // TODO: Impl√©menter } public double CalculerProgression() { // TODO: Calculer % de sous-t√¢ches termin√©es return 0; } public override void Executer() { // TODO: Marquer toutes les sous-t√¢ches comme termin√©es } public override void AfficherDetails() { base.AfficherDetails(); Console.WriteLine($\"Progression: {CalculerProgression():P0}\"); Console.WriteLine(\"Sous-t√¢ches:\"); // TODO: Afficher les sous-t√¢ches } } public class ProjetTaches { public string Nom { get; set; } private List\u003cTache\u003e _taches = new List\u003cTache\u003e(); public ProjetTaches(string nom) { Nom = nom; } public void AjouterTache(Tache tache) { _taches.Add(tache); tache.TacheModifiee += OnTacheModifiee; } private void OnTacheModifiee(object sender, string message) { Console.WriteLine($\"[NOTIFICATION] {message}\"); } public List\u003cTache\u003e ObtenirTachesParPriorite(Priorite priorite) { // TODO: Filtrer par priorit√© return null; } public List\u003cTache\u003e ObtenirTachesEnRetard() { // TODO: Retourner les t√¢ches en retard return null; } public void AfficherResume() { // TODO: Afficher statistiques (nombre total, termin√©es, en retard, etc.) } public void AfficherTachesParStatut() { // TODO: Grouper et afficher par statut } } class Program { static void Main(string[] args) { ProjetTaches projet = new ProjetTaches(\"D√©veloppement Application\"); // TODO: Cr√©er diff√©rents types de t√¢ches // TODO: Afficher les t√¢ches // TODO: Marquer des t√¢ches comme termin√©es // TODO: Afficher les statistiques } } } ‚úÖ Crit√®res de r√©ussite Les √©v√©nements notifient correctement les changements Les t√¢ches r√©currentes cr√©ent de nouvelles instances La progression des t√¢ches avec sous-t√¢ches est correcte Les filtres fonctionnent correctement Projet 6 : Simulateur de Zoo üìã Objectif Cr√©er un simulateur de zoo avec diff√©rents types d‚Äôanimaux et comportements.\nüéØ Concepts utilis√©s H√©ritage multiple (interfaces) Polymorphisme Classes abstraites Collections üìù Sp√©cifications Cr√©er :\nInterfaces de comportements :\nIVolant : Voler(), AltitudeMaximale INageant : Nager(), ProfondeurMaximale IGrimpant : Grimper(), Agilite ICarnivore : Chasser(Animal proie) IHerbivore : Brouter() Classe abstraite Animal :\nPropri√©t√©s : Nom, Espece, Age, Poids, Sante, Faim M√©thodes : Manger(), Dormir(), SeReproduire(), AfficherInfos() Classes d‚Äôanimaux impl√©mentant les bonnes interfaces :\nLion : ICarnivore Aigle : IVolant, ICarnivore Dauphin : INageant, ICarnivore Singe : IGrimpant, IHerbivore Elephant : IHerbivore Pingouin : INageant (ne vole pas!) Canard : IVolant, INageant Classe Enclos :\nType (Terrestre, Aquatique, Aerien, Mixte) Capacite maximale Liste d‚Äôanimaux M√©thode : AjouterAnimal(), RetirerAnimal(), NourririAnimaux() Classe Zoo :\nNom du zoo Collection d‚Äôenclos M√©thodes : AjouterEnclos(), FaireVisiter(), RapportJournalier(), NourrirTousLesAnimaux() üí° Code de d√©marrage using System; using System.Collections.Generic; using System.Linq; namespace SimulateurZoo { public interface IVolant { void Voler(); double AltitudeMaximale { get; } } public interface INageant { void Nager(); double ProfondeurMaximale { get; } } public interface IGrimpant { void Grimper(); int Agilite { get; } // Sur 10 } public interface ICarnivore { void Chasser(Animal proie); string RegimeAlimentaire { get; } } public interface IHerbivore { void Brouter(); string VegetationPreferee { get; } } public enum TypeEnclos { Terrestre, Aquatique, Aerien, Mixte } public abstract class Animal { public string Nom { get; set; } public string Espece { get; protected set; } public int Age { get; set; } public double Poids { get; set; } public int Sante { get; protected set; } // 0-100 public int Faim { get; protected set; } // 0-100 protected Animal(string nom, int age, double poids) { Nom = nom; Age = age; Poids = poids; Sante = 100; Faim = 50; } public virtual void Manger() { Faim = Math.Max(0, Faim - 30); Console.WriteLine($\"{Nom} mange. Faim: {Faim}%\"); } public void Dormir() { Sante = Math.Min(100, Sante + 10); Console.WriteLine($\"{Nom} dort. Sant√©: {Sante}%\"); } public abstract void EmettreSon(); public virtual void AfficherInfos() { Console.WriteLine($\"=== {Nom} ===\"); Console.WriteLine($\"Esp√®ce: {Espece}\"); Console.WriteLine($\"√Çge: {Age} ans\"); Console.WriteLine($\"Poids: {Poids} kg\"); Console.WriteLine($\"Sant√©: {Sante}%\"); Console.WriteLine($\"Faim: {Faim}%\"); } } // TODO: Cr√©er la classe Lion public class Lion : Animal, ICarnivore { public string RegimeAlimentaire { get; } = \"Carnivore strict\"; public Lion(string nom, int age, double poids) : base(nom, age, poids) { Espece = \"Lion\"; } public void Chasser(Animal proie) { // TODO: Impl√©menter } public override void EmettreSon() { Console.WriteLine($\"{Nom} rugit: ROARRR!\"); } } // TODO: Cr√©er les autres classes d'animaux public class Enclos { private static int _compteur = 0; public int Numero { get; private set; } public string Nom { get; set; } public TypeEnclos Type { get; set; } public int CapaciteMax { get; set; } public List\u003cAnimal\u003e Animaux { get; private set; } public Enclos(string nom, TypeEnclos type, int capacite) { Numero = ++_compteur; Nom = nom; Type = type; CapaciteMax = capacite; Animaux = new List\u003cAnimal\u003e(); } public bool AjouterAnimal(Animal animal) { // TODO: V√©rifier capacit√© et compatibilit√© return false; } public void NourrirAnimaux() { // TODO: Nourrir tous les animaux } public void AfficherContenu() { // TODO: Afficher infos de l'enclos } } public class Zoo { public string Nom { get; set; } public string Ville { get; set; } private List\u003cEnclos\u003e _enclos = new List\u003cEnclos\u003e(); public Zoo(string nom, string ville) { Nom = nom; Ville = ville; } public void AjouterEnclos(Enclos enclos) { _enclos.Add(enclos); } public void NourrirTousLesAnimaux() { // TODO: Parcourir tous les enclos } public void FaireVisiter() { // TODO: Afficher tous les enclos } public void RapportJournalier() { // TODO: Statistiques (nombre animaux, par type, sant√© moyenne, etc.) } public List\u003cAnimal\u003e RechercherAnimauxParCapacite(Type interfaceType) { // TODO: Trouver tous les animaux qui impl√©mentent une interface donn√©e // Ex: tous les IVolant return null; } } class Program { static void Main(string[] args) { Zoo zoo = new Zoo(\"Zoo de Montr√©al\", \"Montr√©al\"); // TODO: Cr√©er des enclos // TODO: Cr√©er des animaux // TODO: Placer les animaux dans les enclos // TODO: Faire une visite // TODO: Nourrir les animaux // TODO: G√©n√©rer un rapport } } } ‚úÖ Crit√®res de r√©ussite Les animaux ont les bonnes capacit√©s (nager, voler, etc.) Les enclos acceptent seulement les animaux compatibles Le polymorphisme fonctionne pour les comportements Les statistiques sont correctes Projet 7 : Syst√®me de R√©servation H√¥tel üìã Objectif Cr√©er un syst√®me de r√©servation pour un h√¥tel avec diff√©rents types de chambres.\nüéØ Concepts utilis√©s H√©ritage Interfaces Propri√©t√©s calcul√©es √ânum√©rations üìù Sp√©cifications Cr√©er :\n√ânum√©rations :\nTypeChambre : Simple, Double, Suite, Penthouse StatutReservation : Confirmee, EnAttente, Annulee, Terminee Interface IAnnulable :\nM√©thode : Annuler(), ObtenirFraisAnnulation() Classe abstraite Chambre :\nPropri√©t√©s : Numero, Type, PrixParNuit, NombrePersonnesMax, Superficie, EstDisponible M√©thode abstraite : CalculerPrix(int nuits) Classes de chambres :\nChambreSimple : 1 personne, prix de base ChambreDouble : 2 personnes, prix + 30% Suite : 4 personnes, prix + 80%, inclut petit-d√©jeuner Penthouse : 6 personnes, prix + 150%, tous services inclus Classe Service :\nTypes : PetitDejeuner, Spa, Parking, RoomService Prix par service Classe Reservation impl√©mentant IAnnulable :\nPropri√©t√©s : NumeroReservation, Client, Chambre, DateArrivee, DateDepart, Services, Statut M√©thodes : AjouterService(), CalculerCoutTotal(), CalculerDuree() Classe Hotel :\nGestion des chambres et r√©servations M√©thodes : RechercherChambresDisponibles(), CreerReservation(), AfficherOccupation() üí° Code de d√©marrage using System; using System.Collections.Generic; using System.Linq; namespace SystemeHotel { public enum TypeChambre { Simple, Double, Suite, Penthouse } public enum StatutReservation { Confirmee, EnAttente, Annulee, Terminee } public enum TypeService { PetitDejeuner, Spa, Parking, RoomService, Wifi } public interface IAnnulable { bool Annuler(); decimal ObtenirFraisAnnulation(); } public abstract class Chambre { public int Numero { get; set; } public TypeChambre Type { get; protected set; } public decimal PrixParNuit { get; set; } public int NombrePersonnesMax { get; protected set; } public double Superficie { get; set; } public bool EstDisponible { get; set; } public List\u003cstring\u003e Equipements { get; protected set; } protected Chambre(int numero, decimal prixParNuit) { Numero = numero; PrixParNuit = prixParNuit; EstDisponible = true; Equipements = new List\u003cstring\u003e(); } public abstract decimal CalculerPrix(int nuits); public virtual void AfficherDetails() { Console.WriteLine($\"Chambre #{Numero} - {Type}\"); Console.WriteLine($\"Prix par nuit: {PrixParNuit:C}\"); Console.WriteLine($\"Capacit√©: {NombrePersonnesMax} personne(s)\"); Console.WriteLine($\"Superficie: {Superficie}m¬≤\"); Console.WriteLine($\"Disponible: {(EstDisponible ? \"Oui\" : \"Non\")}\"); } } // TODO: Cr√©er ChambreSimple // TODO: Cr√©er ChambreDouble // TODO: Cr√©er Suite // TODO: Cr√©er Penthouse public class Service { public TypeService Type { get; set; } public string Description { get; set; } public decimal Prix { get; set; } public Service(TypeService type, string description, decimal prix) { Type = type; Description = description; Prix = prix; } } public class Reservation : IAnnulable { private static int _compteur = 0; public int NumeroReservation { get; private set; } public string NomClient { get; set; } public string EmailClient { get; set; } public Chambre Chambre { get; set; } public DateTime DateArrivee { get; set; } public DateTime DateDepart { get; set; } public List\u003cService\u003e Services { get; private set; } public StatutReservation Statut { get; set; } public DateTime DateReservation { get; private set; } public Reservation(string nomClient, string email, Chambre chambre, DateTime arrivee, DateTime depart) { NumeroReservation = ++_compteur; NomClient = nomClient; EmailClient = email; Chambre = chambre; DateArrivee = arrivee; DateDepart = depart; Services = new List\u003cService\u003e(); Statut = StatutReservation.Confirmee; DateReservation = DateTime.Now; } public int CalculerDuree() { // TODO: Calculer nombre de nuits return 0; } public void AjouterService(Service service) { // TODO: Impl√©menter } public decimal CalculerCoutTotal() { // TODO: Chambre + services return 0; } public bool Annuler() { // TODO: V√©rifier si annulation possible et appliquer frais return false; } public decimal ObtenirFraisAnnulation() { // TODO: Calculer frais selon date d'annulation // Moins de 48h avant: 100% // Moins d'une semaine: 50% // Plus d'une semaine: 25% return 0; } public void AfficherDetails() { // TODO: Afficher tous les d√©tails } } public class Hotel { public string Nom { get; set; } public string Adresse { get; set; } private List\u003cChambre\u003e _chambres = new List\u003cChambre\u003e(); private List\u003cReservation\u003e _reservations = new List\u003cReservation\u003e(); public Hotel(string nom, string adresse) { Nom = nom; Adresse = adresse; } public void AjouterChambre(Chambre chambre) { _chambres.Add(chambre); } public List\u003cChambre\u003e RechercherChambresDisponibles(DateTime arrivee, DateTime depart) { // TODO: Filtrer les chambres disponibles pour ces dates return null; } public List\u003cChambre\u003e RechercherParType(TypeChambre type) { // TODO: Filtrer par type return null; } public Reservation CreerReservation(string client, string email, int numeroChambre, DateTime arrivee, DateTime depart) { // TODO: Cr√©er et ajouter la r√©servation return null; } public void AfficherOccupation() { // TODO: Statistiques d'occupation } public decimal CalculerRevenuTotal() { // TODO: Sommer toutes les r√©servations confirm√©es return 0; } } class Program { static void Main(string[] args) { Hotel hotel = new Hotel(\"Grand H√¥tel\", \"123 Rue Principale, Montr√©al\"); // TODO: Ajouter des chambres // TODO: Cr√©er des r√©servations // TODO: Ajouter des services // TODO: Afficher l'occupation // TODO: Tester les annulations } } } ‚úÖ Crit√®res de r√©ussite Les prix varient selon le type de chambre et les services Les frais d‚Äôannulation sont calcul√©s correctement Impossible de r√©server une chambre d√©j√† r√©serv√©e Les statistiques sont exactes Projet 8 : Calculatrice de Formes G√©om√©triques üìã Objectif Cr√©er un syst√®me pour calculer l‚Äôaire, le p√©rim√®tre et d‚Äôautres propri√©t√©s de formes g√©om√©triques.\nüéØ Concepts utilis√©s Classes abstraites Polymorphisme M√©thodes virtuelles Interfaces üìù Sp√©cifications Cr√©er :\nInterface IDessinable :\nM√©thode : Dessiner() Classe abstraite Forme :\nPropri√©t√©s : Nom, Couleur M√©thodes abstraites : CalculerAire(), CalculerPerimetre() M√©thode virtuelle : AfficherInfos() Classes de formes 2D :\nCercle : rayon Rectangle : longueur, largeur Carre : c√¥t√© Triangle : base, hauteur Polygone : nombre de c√¥t√©s, longueur des c√¥t√©s Classe abstraite Forme3D h√©ritant de Forme :\nM√©thode abstraite suppl√©mentaire : CalculerVolume() Classes de formes 3D :\nSphere : rayon Cube : c√¥t√© Cylindre : rayon, hauteur Cone : rayon base, hauteur Classe Calculateur :\nM√©thodes statiques pour comparer des formes, trier par aire, etc. üí° Code de d√©marrage using System; using System.Collections.Generic; using System.Linq; namespace CalculatriceFormes { public interface IDessinable { void Dessiner(); } public abstract class Forme { public string Nom { get; set; } public string Couleur { get; set; } public abstract double CalculerAire(); public abstract double CalculerPerimetre(); public virtual void AfficherInfos() { Console.WriteLine($\"=== {Nom} ===\"); Console.WriteLine($\"Couleur: {Couleur}\"); Console.WriteLine($\"Aire: {CalculerAire():F2}\"); Console.WriteLine($\"P√©rim√®tre: {CalculerPerimetre():F2}\"); } } public class Cercle : Forme, IDessinable { public double Rayon { get; set; } public Cercle(double rayon, string couleur = \"Noir\") { Rayon = rayon; Couleur = couleur; Nom = \"Cercle\"; } public override double CalculerAire() { // TODO: œÄ √ó r¬≤ return 0; } public override double CalculerPerimetre() { // TODO: 2 √ó œÄ √ó r return 0; } public void Dessiner() { Console.WriteLine($\"Dessin d'un cercle de rayon {Rayon} en {Couleur}\"); Console.WriteLine(\" *** \"); Console.WriteLine(\" * * \"); Console.WriteLine(\" * * \"); Console.WriteLine(\" * * \"); Console.WriteLine(\" *** \"); } } // TODO: Cr√©er Rectangle // TODO: Cr√©er Carre // TODO: Cr√©er Triangle public abstract class Forme3D : Forme { public abstract double CalculerVolume(); public override void AfficherInfos() { base.AfficherInfos(); Console.WriteLine($\"Volume: {CalculerVolume():F2}\"); } } // TODO: Cr√©er Sphere // TODO: Cr√©er Cube // TODO: Cr√©er Cylindre public static class Calculateur { public static Forme TrouverPlusGrandeAire(List\u003cForme\u003e formes) { // TODO: Retourner la forme avec la plus grande aire return null; } public static double CalculerAireTotale(List\u003cForme\u003e formes) { // TODO: Sommer toutes les aires return 0; } public static List\u003cForme\u003e TrierParAire(List\u003cForme\u003e formes) { // TODO: Trier par aire croissante return null; } public static void ComparerFormes(Forme f1, Forme f2) { // TODO: Comparer aires et p√©rim√®tres } } class Program { static void Main(string[] args) { List\u003cForme\u003e formes = new List\u003cForme\u003e(); // TODO: Cr√©er diff√©rentes formes // TODO: Afficher les infos // TODO: Utiliser le calculateur // TODO: Dessiner les formes qui sont IDessinable } } } Conseils pour r√©ussir les projets üéØ M√©thodologie Lire attentivement les sp√©cifications Planifier la structure avant de coder Tester fr√©quemment chaque nouvelle fonctionnalit√© Refactoriser le code pour am√©liorer la qualit√© Documenter avec des commentaires clairs üîç Points de contr√¥le Pour chaque projet, v√©rifiez :\n‚úÖ Respect de l‚Äôencapsulation (propri√©t√©s priv√©es/publiques appropri√©es) ‚úÖ Utilisation correcte de l‚Äôh√©ritage ‚úÖ Polymorphisme fonctionnel ‚úÖ Interfaces bien impl√©ment√©es ‚úÖ Gestion des cas d‚Äôerreur ‚úÖ Code lisible et bien organis√©",
    "description": "Mini-Projets : Programmation Orient√©e Objet en C# Progression recommand√©e Niveau Projets D√©butant Projet 8 (Formes), Projet 5 (T√¢ches) Interm√©diaire Projet 1 (Banque), Projet 2 (Biblioth√®que), Projet 6 (Zoo) Avanc√© Projet 3 (RPG), Projet 4 (Restaurant), Projet 7 (H√¥tel) Table des mati√®res Projet 1 : Syst√®me de Gestion Bancaire Projet 2 : Gestion d‚Äôune Biblioth√®que Projet 3 : Jeu de Combat RPG Projet 4 : Syst√®me de Commandes Restaurant Projet 5 : Gestionnaire de T√¢ches Projet 6 : Simulateur de Zoo Projet 7 : Syst√®me de R√©servation H√¥tel Projet 8 : Calculatrice de Formes G√©om√©triques Projet 1 : Syst√®me de Gestion Bancaire üìã Objectif Cr√©er un syst√®me de gestion de comptes bancaires avec diff√©rents types de comptes et op√©rations.",
    "tags": [],
    "title": "Exercices - POO",
    "uri": "/420-413/poo_exos/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Table des mati√®res Introduction √† Agile Qu‚Äôest-ce que Scrum ? Les R√¥les Scrum Les Artefacts Scrum Les C√©r√©monies Scrum Epics, Stories et Sprints Exercice Pratique pour √âtudiants Introduction √† Agile Qu‚Äôest-ce que l‚ÄôAgile ? Agile est un ensemble de valeurs et de principes qui servent de philosophie de travail pour le d√©veloppement de produits et de projets. La m√©thodologie Agile a r√©volutionn√© la fa√ßon dont le travail est effectu√©, non seulement dans le d√©veloppement logiciel, mais aussi dans d‚Äôautres domaines.\nLes principes fondamentaux d‚ÄôAgile L‚Äôapproche Agile met l‚Äôaccent sur :\nLes personnes d‚Äôabord : Mettre les utilisateurs finaux au centre de la conversation La flexibilit√© : Capacit√© √† r√©pondre au changement rapidement La livraison continue : Fournir de la valeur r√©guli√®rement plut√¥t qu‚Äôen une seule fois La collaboration : Travail d‚Äô√©quipe transparent et communication ouverte L‚Äôam√©lioration continue : R√©flexion constante pour optimiser les processus Les 4 C de Scrum Les principes directeurs qui guident les √©quipes Scrum :\nCommunication : Dialogue transparent et ouvert Collaboration : Soutien mutuel et travail d‚Äô√©quipe Commitment (Engagement) : D√©vouement aux objectifs Continuous Improvement (Am√©lioration continue) : R√©flexion r√©guli√®re pour am√©liorer les processus Qu‚Äôest-ce que Scrum ? Scrum est l‚Äôun des frameworks agiles les plus populaires. Il aide les √©quipes √† organiser et √† g√©rer leur travail √† travers des valeurs, des principes et des pratiques structur√©es.\nLa r√®gle 3:5:3 de Scrum Scrum est structur√© autour de :\n3 r√¥les : Product Owner, Scrum Master, √âquipe de d√©veloppement 5 √©v√©nements : Sprint, Planification de sprint, Daily Scrum, Revue de sprint, R√©trospective 3 artefacts : Product Backlog, Sprint Backlog, Incr√©ment Caract√©ristiques cl√©s de Scrum Sprints : Cycles de travail fixes (g√©n√©ralement 1 √† 4 semaines) √âquipes auto-organis√©es : Les √©quipes d√©cident comment accomplir leur travail Transparence : Visibilit√© sur le travail en cours et les obstacles Inspection et adaptation : √âvaluation r√©guli√®re et ajustement des processus Les R√¥les Scrum 1. Product Owner (Propri√©taire du produit) Responsabilit√©s principales :\nGestion du Product Backlog : Maintenir et prioriser la liste de toutes les fonctionnalit√©s et exigences Vision du produit : D√©finir la direction et les objectifs du produit Repr√©sentant du client : Comprendre et communiquer les besoins des utilisateurs Priorisation : D√©cider quelles fonctionnalit√©s apportent le plus de valeur Gestion des versions : Planifier les releases (bien que le sprint ne soit pas un cycle de release) Clarification des exigences : R√©pondre aux questions de l‚Äô√©quipe sur le backlog Profil : Le Product Owner se concentre sur la strat√©gie et les besoins m√©tier. Il n‚Äôest pas un chef de projet traditionnel, mais plut√¥t un facilitateur entre les parties prenantes et l‚Äô√©quipe de d√©veloppement.\n2. Scrum Master Responsabilit√©s principales :\nFacilitation des c√©r√©monies : S‚Äôassurer que les r√©unions sont productives et limit√©es dans le temps Suppression des obstacles : √âliminer les blocages qui emp√™chent l‚Äô√©quipe d‚Äôavancer Coaching : Former l‚Äô√©quipe aux principes Agile et Scrum Protection de l‚Äô√©quipe : Prot√©ger l‚Äô√©quipe des distractions externes Promotion de l‚Äôam√©lioration continue : Encourager la r√©flexion et l‚Äôoptimisation Facilitation de la collaboration : Favoriser la communication entre tous les membres Comp√©tences essentielles :\nLeadership serviteur (servant leadership) Empathie et intelligence √©motionnelle Comp√©tences en facilitation de r√©unions Adaptabilit√© Communication efficace Connaissances techniques (optionnel mais utile) √Ä noter : Le Scrum Master n‚Äôest pas un gestionnaire traditionnel. Son r√¥le est d‚Äôhabiliter l‚Äô√©quipe √† s‚Äôauto-organiser et √† r√©ussir. Les Scrum Masters ne sont pas remplac√©s par l‚ÄôIA car leur travail n√©cessite jugement humain, empathie et adaptabilit√©.\n3. L‚Äô√âquipe de D√©veloppement (Development Team) Caract√©ristiques :\nTaille optimale : 5 √† 11 membres (id√©alement 7) Cross-fonctionnelle : Poss√®de toutes les comp√©tences n√©cessaires pour livrer l‚Äôincr√©ment Auto-organis√©e : D√©cide comment accomplir le travail Responsabilit√© collective : Tous sont responsables de la livraison Composition : Contrairement √† ce que le nom sugg√®re, l‚Äô√©quipe de d√©veloppement n‚Äôinclut pas seulement des programmeurs. Elle peut comprendre :\nD√©veloppeurs Designers R√©dacteurs Testeurs Analystes Tout autre r√¥le n√©cessaire pour livrer le produit Leadership distribu√© : Il n‚Äôy a pas de leader traditionnel dans une √©quipe Scrum. Le leadership est distribu√© : le Scrum Master dirige le processus, le Product Owner dirige la vision produit, et l‚Äô√©quipe de d√©veloppement est collectivement responsable de la livraison.\nLes Artefacts Scrum Les artefacts Scrum repr√©sentent le travail ou la valeur et sont con√ßus pour maximiser la transparence.\n1. Product Backlog (Backlog produit) D√©finition : Liste ordonn√©e et √©volutive de tout ce qui pourrait √™tre n√©cessaire dans le produit. C‚Äôest la source unique de v√©rit√© pour les exigences.\nCaract√©ristiques :\nVivant et dynamique : Constamment mis √† jour en fonction des retours et des apprentissages Prioris√© : Les √©l√©ments sont class√©s par valeur m√©tier et urgence D√©taill√© au sommet : Les √©l√©ments en haut sont plus d√©taill√©s que ceux en bas Propri√©t√© : G√©r√© par le Product Owner (bien que d‚Äôautres puissent y contribuer) Contenu typique :\nUser Stories Bugs Am√©liorations techniques Recherches n√©cessaires 2. Sprint Backlog D√©finition : Ensemble des √©l√©ments du Product Backlog s√©lectionn√©s pour le sprint, plus un plan pour livrer l‚Äôincr√©ment et atteindre l‚Äôobjectif du sprint.\nCaract√©ristiques :\nEngagement de l‚Äô√©quipe : L‚Äô√©quipe s‚Äôengage √† livrer ces √©l√©ments durant le sprint Flexible pendant le sprint : Peut √™tre ajust√© si n√©cessaire, en accord avec l‚Äô√©quipe Visible et transparent : G√©n√©ralement affich√© sur un tableau Scrum (physique ou num√©rique) √âtats typiques :\n√Ä faire (To Do) En cours (In Progress) Termin√© (Done) 3. Incr√©ment D√©finition : La somme de tous les √©l√©ments du Product Backlog compl√©t√©s durant un sprint et tous les sprints pr√©c√©dents. C‚Äôest le produit potentiellement livrable.\nCrit√®res :\nD√©finition de ‚ÄúDone‚Äù : Doit respecter la d√©finition d‚Äôach√®vement de l‚Äô√©quipe Utilisable : Doit √™tre dans un √©tat utilisable, m√™me si le Product Owner d√©cide de ne pas le livrer Cumulatif : Chaque incr√©ment s‚Äôajoute aux pr√©c√©dents Les C√©r√©monies Scrum Les c√©r√©monies (ou √©v√©nements) Scrum cr√©ent une r√©gularit√© et aident les √©quipes √† maintenir une communication transparente. Elles sont time-boxed (limit√©es dans le temps) et ont des objectifs sp√©cifiques.\n1. Sprint Planning (Planification de Sprint) Objectif : D√©finir ce qui peut √™tre livr√© dans le sprint et comment ce travail sera accompli.\nDur√©e : Maximum 8 heures pour un sprint d‚Äôun mois (proportionnel pour des sprints plus courts, ex : 4 heures pour 2 semaines)\nParticipants :\nProduct Owner (pr√©sente le Product Backlog) Scrum Master (facilite) √âquipe de d√©veloppement compl√®te Structure typique :\nPartie 1 - Quoi ? (1√®re moiti√©)\nLe Product Owner pr√©sente les √©l√©ments prioritaires du Product Backlog L‚Äô√©quipe pose des questions pour clarifier les exigences L‚Äô√©quipe s√©lectionne les √©l√©ments qu‚Äôelle pense pouvoir compl√©ter D√©finition de l‚Äôobjectif du sprint (Sprint Goal) Partie 2 - Comment ? (2√®me moiti√©)\nL‚Äô√©quipe d√©compose les √©l√©ments s√©lectionn√©s en t√¢ches Estimation de l‚Äôeffort (story points, heures, etc.) Identification des d√©pendances et des risques Cr√©ation du Sprint Backlog R√©sultat :\nSprint Backlog complet Objectif du sprint clair Engagement de l‚Äô√©quipe 2. Daily Scrum (M√™l√©e quotidienne / Standup) Objectif : Synchroniser les activit√©s et cr√©er un plan pour les prochaines 24 heures. Identifier rapidement les obstacles.\nDur√©e : Maximum 15 minutes (d‚Äôo√π l‚Äôappellation ‚Äústandup‚Äù - debout pour garder la r√©union courte)\nFr√©quence : Chaque jour √† la m√™me heure, au m√™me endroit\nParticipants :\n√âquipe de d√©veloppement (obligatoire) Scrum Master (facilite si n√©cessaire) Product Owner (optionnel, en observateur) Format classique - Les 3 questions : Chaque membre de l‚Äô√©quipe r√©pond √† :\nQu‚Äôai-je accompli hier qui a aid√© l‚Äô√©quipe √† atteindre l‚Äôobjectif du sprint ? Que vais-je faire aujourd‚Äôhui pour aider l‚Äô√©quipe √† atteindre l‚Äôobjectif du sprint ? Y a-t-il des obstacles qui m‚Äôemp√™chent ou qui emp√™chent l‚Äô√©quipe d‚Äôatteindre l‚Äôobjectif ? Bonnes pratiques :\nRester debout pour maintenir l‚Äô√©nergie et la bri√®vet√© Se concentrer sur les progr√®s, pas sur un rapport de statut d√©taill√© Ton l√©ger et amusant, mais informatif Responsabilit√© implicite devant les pairs Les discussions d√©taill√©es se font apr√®s le standup Ne pas r√©server de salle de conf√©rence - le faire pr√®s du tableau Scrum √Ä √©viter :\nTransformer le standup en r√©union d‚Äôune heure Rapports d√©taill√©s au Scrum Master ou Product Owner R√©solution de probl√®mes complexes (reporter apr√®s) 3. Sprint Review (Revue de Sprint) Objectif : Inspecter l‚Äôincr√©ment et adapter le Product Backlog si n√©cessaire. Obtenir des retours des parties prenantes.\nDur√©e : Maximum 4 heures pour un sprint d‚Äôun mois (proportionnel pour sprints plus courts)\nParticipants :\n√âquipe Scrum compl√®te Parties prenantes Clients (si possible) Management Structure typique :\nIntroduction (Product Owner)\nRappel de l‚Äôobjectif du sprint √âl√©ments compl√©t√©s vs planifi√©s D√©monstration (√âquipe de d√©veloppement)\nPr√©sentation de l‚Äôincr√©ment fonctionnel Fonctionnalit√©s en action, pas de slides PowerPoint Les parties prenantes testent et manipulent le produit Discussion (Tous)\nRetours et questions Ce qui fonctionne bien Suggestions d‚Äôam√©liorations Discussion sur le march√© ou l‚Äôutilisation potentielle Mise √† jour du Product Backlog (Product Owner)\nAjustement des priorit√©s bas√© sur les retours Nouvelles id√©es de fonctionnalit√©s R√©vision de la timeline si n√©cessaire R√©sultat :\nProduct Backlog r√©vis√© Compr√©hension partag√©e de ce qui a √©t√© accompli Retours pr√©cieux pour orienter le prochain sprint Philosophie : La revue n‚Äôest PAS une porte de validation (gate). C‚Äôest une opportunit√© d‚Äôinspection et d‚Äôadaptation collaborative. Id√©alement, les √©quipes livrent fr√©quemment tout au long du sprint, permettant √† la revue de porter sur l‚Äôusage r√©el par les clients.\n4. Sprint Retrospective (R√©trospective) Objectif : R√©fl√©chir sur le sprint √©coul√© et identifier des am√©liorations concr√®tes pour le prochain sprint. C‚Äôest le c≈ìur de l‚Äôam√©lioration continue.\nDur√©e : Maximum 3 heures pour un sprint d‚Äôun mois (1,5 heure pour 2 semaines)\nTiming : Apr√®s la Sprint Review, avant la prochaine Sprint Planning\nParticipants :\n√âquipe de d√©veloppement Scrum Master (facilite) Product Owner (optionnel mais recommand√©) Structure typique :\nPr√©parer le terrain (5-10 minutes)\nCr√©er un environnement s√ªr et ouvert Rappeler la prime directive : ‚ÄúNous croyons que tous ont fait de leur mieux‚Äù Collecter des donn√©es (20-30 minutes)\nCe qui a bien fonctionn√© Ce qui n‚Äôa pas fonctionn√© Puzzles ou questions G√©n√©rer des insights (20-30 minutes)\nIdentifier les patterns Analyser les causes profondes Discussions en groupe D√©cider quoi faire (15-20 minutes)\nS√©lectionner 1-3 actions d‚Äôam√©lioration D√©finir des actions concr√®tes et mesurables Assigner des responsables Cl√¥ture (5-10 minutes)\nR√©sumer les d√©cisions Appr√©ciation de l‚Äô√©quipe Techniques populaires :\nStart, Stop, Continue : Quoi commencer √† faire, arr√™ter de faire, continuer de faire Glad, Sad, Mad : Ce qui nous rend heureux, triste ou en col√®re 4Ls : Liked, Learned, Lacked, Longed for Sailboat : Vents favorables (ce qui nous aide), ancres (ce qui nous freine) Bonnes pratiques :\nCe n‚Äôest PAS seulement un moment pour se plaindre Focus sur les solutions, pas seulement les probl√®mes M√™me si tout va bien, continuer les r√©trospectives Varier les formats pour maintenir l‚Äôengagement Suivre les actions d√©cid√©es lors de la prochaine r√©tro R√©sultat :\n1-3 am√©liorations concr√®tes identifi√©es Plan d‚Äôaction pour le prochain sprint Engagement de l‚Äô√©quipe envers l‚Äôam√©lioration Citation cl√© : ‚ÄúL‚Äôam√©lioration continue est ce qui soutient et stimule le d√©veloppement au sein d‚Äôune √©quipe agile, et les r√©trospectives en sont un √©l√©ment cl√©.‚Äù\n5. Product Backlog Refinement (Affinement du Backlog) Note : Bien que non officielle dans le Scrum Guide original, cette c√©r√©monie est largement adopt√©e.\nObjectif : Ajouter des d√©tails, des estimations et de l‚Äôordre aux √©l√©ments du Product Backlog pour pr√©parer les futurs sprints.\nDur√©e : G√©n√©ralement 1-2 heures par semaine (environ 10% de la capacit√© du sprint)\nParticipants :\nProduct Owner (dirige) √âquipe de d√©veloppement Scrum Master (facilite si n√©cessaire) Activit√©s :\nClarification : Discuter des user stories √† venir D√©composition : Diviser les grandes stories en plus petites Estimation : Estimer l‚Äôeffort n√©cessaire (story points) Crit√®res d‚Äôacceptation : D√©finir la ‚ÄúDefinition of Done‚Äù pour chaque story Priorisation : R√©organiser selon la valeur m√©tier R√©sultat : Un backlog ‚Äúpr√™t‚Äù (ready) avec des √©l√©ments clairs et estim√©s pour la prochaine planification de sprint.\nEpics, Stories et Sprints User Stories (Histoires Utilisateur) D√©finition : Une user story est une description concise d‚Äôune fonctionnalit√© du point de vue de l‚Äôutilisateur final. Elle utilise un langage non technique pour fournir du contexte √† l‚Äô√©quipe.\nFormat standard :\nEn tant que [persona/r√¥le],\rJe veux [objectif/d√©sir],\rAfin de [b√©n√©fice/valeur]. Exemple :\nEn tant que client r√©gulier,\rJe veux sauvegarder des articles dans une liste de souhaits,\rAfin de pouvoir les acheter plus tard. Composantes d‚Äôune bonne user story - INVEST :\nInd√©pendante : Peut √™tre d√©velopp√©e sans d√©pendre d‚Äôautres stories N√©gociable : Les d√©tails peuvent √™tre discut√©s et ajust√©s Valoris√©e : Apporte de la valeur claire √† l‚Äôutilisateur Estimable : L‚Äô√©quipe peut estimer l‚Äôeffort n√©cessaire Small (Petite) : Peut √™tre compl√©t√©e en un sprint Testable : Des crit√®res d‚Äôacceptation clairs existent Crit√®res d‚Äôacceptation : Conditions sp√©cifiques qui doivent √™tre remplies pour que la story soit consid√©r√©e comme ‚ÄúDone‚Äù. Exemple :\nUser Story : Connexion utilisateur\rCrit√®res d'acceptation :\r- L'utilisateur peut entrer son email et mot de passe\r- Un message d'erreur s'affiche si les identifiants sont incorrects\r- L'utilisateur est redirig√© vers le tableau de bord apr√®s connexion r√©ussie\r- Un lien \"Mot de passe oubli√©\" est visible\r- La session reste active pendant 24 heures Taille : Une story doit pouvoir √™tre compl√©t√©e dans un sprint. Si une story prend des semaines ou des mois, elle devrait √™tre d√©compos√©e ou consid√©r√©e comme un epic.\nQuand utiliser les stories :\nD√©veloppement de nouvelles fonctionnalit√©s Am√©lioration d‚Äôexp√©rience utilisateur Corrections de bugs (format adapt√©) Travail qui peut √™tre compl√©t√© en une ou deux semaines Epics D√©finition : Un epic est un grand corps de travail qui peut √™tre d√©compos√© en plusieurs user stories plus petites. Les epics repr√©sentent souvent une fonctionnalit√© majeure ou un objectif important.\nCaract√©ristiques :\nLarge port√©e : Trop grand pour √™tre compl√©t√© en un seul sprint D√©composable : Se divise en plusieurs stories √âvolutif : Les stories associ√©es peuvent √™tre ajout√©es ou retir√©es selon les retours Multi-sprints : G√©n√©ralement livr√© sur plusieurs sprints Flexible : La port√©e s‚Äôadapte selon les retours clients et le rythme de l‚Äô√©quipe Exemple d‚Äôepic et ses stories :\nEPIC : Syst√®me d'authentification utilisateur\rStories :\r‚îú‚îÄ Story 1 : Impl√©menter la fonctionnalit√© de connexion\r‚îú‚îÄ Story 2 : Cr√©er la fonctionnalit√© de r√©initialisation de mot de passe\r‚îú‚îÄ Story 3 : Ajouter l'authentification √† deux facteurs\r‚îú‚îÄ Story 4 : D√©velopper la d√©connexion automatique apr√®s inactivit√©\r‚îî‚îÄ Story 5 : Cr√©er la gestion de sessions utilisateur Quand cr√©er un epic :\nVous avez un grand volume de travail qui n√©cessite plusieurs sprints Vous remarquez un pattern parmi plusieurs user stories Vous voulez regrouper des stories li√©es sous une m√™me initiative Techniques pour d√©composer un epic en stories :\nPar r√¥le utilisateur : Cr√©er une story pour chaque persona\n‚ÄúConnexion rapide pour nouveaux visiteurs‚Äù ‚ÄúConnexion rapide pour clients r√©guliers‚Äù Par √©tapes du processus : Une story par √©tape\n‚ÄúSaisie des identifiants‚Äù ‚ÄúValidation des identifiants‚Äù ‚ÄúCr√©ation de session‚Äù Par CRUD (Create, Read, Update, Delete) :\n‚ÄúCr√©er un compte utilisateur‚Äù ‚ÄúAfficher le profil utilisateur‚Äù ‚ÄúModifier les informations du profil‚Äù ‚ÄúSupprimer un compte‚Äù Par plateforme :\n‚ÄúConnexion sur mobile‚Äù ‚ÄúConnexion sur web‚Äù ‚ÄúConnexion sur tablette‚Äù Par crit√®res de temps :\nStories qui peuvent √™tre compl√©t√©es en un sprint ou moins Estimation des epics : Les epics sont g√©n√©ralement estim√©s avec des tailles T-shirt (XS, S, M, L, XL) ou en nombre de sprints n√©cessaires, plut√¥t qu‚Äôen story points pr√©cis.\nSprints D√©finition : Un sprint est une p√©riode time-boxed (dur√©e fixe) pendant laquelle une √©quipe Scrum travaille pour compl√©ter une quantit√© d√©finie de travail. C‚Äôest le c≈ìur de Scrum.\nCaract√©ristiques :\nDur√©e fixe : G√©n√©ralement 1, 2 ou 4 semaines (2 semaines est le plus courant) Objectif clair : Chaque sprint a un Sprint Goal sp√©cifique Cadence r√©guli√®re : L‚Äô√©quipe op√®re perp√©tuellement sur cette cadence Livrable : Produit un incr√©ment potentiellement livrable Anatomie d‚Äôun sprint :\nSprint de 2 semaines (exemple)\rJour 1 :\r‚îî‚îÄ Sprint Planning (4h)\rJours 2-10 :\r‚îú‚îÄ Daily Scrum (15 min/jour)\r‚îî‚îÄ Travail de d√©veloppement\rJour 10 :\r‚îú‚îÄ Sprint Review (2h)\r‚îî‚îÄ Sprint Retrospective (1.5h)\rJour 11 :\r‚îî‚îÄ D√©but du prochain sprint Pourquoi des sprints fixes ?\nPr√©visibilit√© : Aide √† pr√©voir la v√©locit√© future Rythme : Cr√©e un battement r√©gulier pour l‚Äô√©quipe Focus : Limite le travail en cours Livraison r√©guli√®re : Valeur livr√©e fr√©quemment Feedback rapide : Retours r√©guliers des parties prenantes Sprint Goal (Objectif du Sprint) : Une d√©claration courte d√©crivant ce que le sprint vise √† accomplir. Il fournit une orientation et permet une certaine flexibilit√© dans l‚Äôimpl√©mentation.\nExemple de Sprint Goals :\n‚ÄúPermettre aux utilisateurs de cr√©er et g√©rer leur profil‚Äù ‚ÄúAm√©liorer la performance de chargement des pages de 50%‚Äù ‚ÄúImpl√©menter le syst√®me de paiement de base‚Äù V√©locit√© (Velocity) : Mesure de la quantit√© de travail qu‚Äôune √©quipe peut accomplir durant un sprint, g√©n√©ralement exprim√©e en story points.\nCalcul√©e en additionnant les points de toutes les stories compl√©t√©es Utilis√©e pour pr√©voir combien de travail peut √™tre fait dans les futurs sprints Devient plus pr√©cise au fil du temps Que se passe-t-il si le travail n‚Äôest pas termin√© ?\n√Ä la fin du sprint, vous avez plusieurs options :\nRetourner au backlog : L‚Äôhistoire retourne dans le Product Backlog D√©placer au prochain sprint : Si presque termin√©e et toujours prioritaire Cr√©er un nouveau sprint : Jira peut cr√©er automatiquement Important : Tous les sous-t√¢ches doivent √™tre compl√©t√©es pour fermer un sprint.\nInitiatives D√©finition : Une initiative est une collection d‚Äôepics qui travaillent ensemble vers un objectif strat√©gique commun, souvent √† l‚Äô√©chelle de l‚Äôentreprise.\nHi√©rarchie compl√®te :\nINITIATIVE (1 an)\r‚îÇ\r‚îú‚îÄ EPIC 1 (1-3 mois)\r‚îÇ ‚îú‚îÄ Story 1.1 (1 sprint)\r‚îÇ ‚îú‚îÄ Story 1.2 (1 sprint)\r‚îÇ ‚îî‚îÄ Story 1.3 (1 sprint)\r‚îÇ\r‚îú‚îÄ EPIC 2 (1-3 mois)\r‚îÇ ‚îú‚îÄ Story 2.1 (1 sprint)\r‚îÇ ‚îî‚îÄ Story 2.2 (1 sprint)\r‚îÇ\r‚îî‚îÄ EPIC 3 (1-3 mois)\r‚îú‚îÄ Story 3.1 (1 sprint)\r‚îú‚îÄ Story 3.2 (1 sprint)\r‚îî‚îÄ Story 3.3 (1 sprint) Exemple concret - Entreprise de fus√©es spatiales :\nINITIATIVE : R√©duire le co√ªt par lancement de 5% cette ann√©e\r‚îú‚îÄ EPIC 1 : Optimiser la consommation de carburant\r‚îÇ ‚îú‚îÄ Story : Analyser les donn√©es de consommation des 10 derniers lancements\r‚îÇ ‚îú‚îÄ Story : D√©velopper un algorithme d'optimisation de trajectoire\r‚îÇ ‚îî‚îÄ Story : Tester le nouvel algorithme en simulation\r‚îÇ\r‚îú‚îÄ EPIC 2 : Automatiser les v√©rifications pr√©-lancement\r‚îÇ ‚îú‚îÄ Story : Cr√©er un syst√®me de diagnostic automatique\r‚îÇ ‚îú‚îÄ Story : Impl√©menter des capteurs IoT suppl√©mentaires\r‚îÇ ‚îî‚îÄ Story : D√©velopper le tableau de bord de monitoring\r‚îÇ\r‚îî‚îÄ EPIC 3 : Am√©liorer la r√©utilisabilit√© des composants\r‚îú‚îÄ Story : Concevoir un syst√®me de r√©cup√©ration am√©lior√©\r‚îú‚îÄ Story : D√©velopper les tests de r√©sistance des mat√©riaux\r‚îî‚îÄ Story : Cr√©er le processus de reconditionnement Timeframes typiques :\nStory : 1-2 semaines (1 sprint) Epic : 1-3 mois (plusieurs sprints) Initiative : 6-12 mois (plusieurs quarters) Relation entre Backlog, Stories, Epics et Sprints Product Backlog : Contient toutes les stories et epics prioris√©s\nSprint Backlog : Contient les stories s√©lectionn√©es pour le sprint actuel\nFlux de travail typique :\nLe Product Owner ajoute un epic au Product Backlog L‚Äôepic est d√©compos√© en stories pendant le Backlog Refinement Les stories sont estim√©es et prioris√©es Pendant Sprint Planning, les stories en haut du backlog sont s√©lectionn√©es pour le sprint Ces stories deviennent le Sprint Backlog L‚Äô√©quipe compl√®te les stories durant le sprint Les stories compl√©t√©es contribuent √† l‚Äôavancement de l‚Äôepic Le processus se r√©p√®te jusqu‚Äô√† ce que l‚Äôepic soit compl√©t√© Exercice Pratique pour √âtudiants üéØ Exercice : ‚ÄúLe Festival √âtudiant‚Äù Contexte Votre classe est responsable de l‚Äôorganisation d‚Äôun festival √©tudiant qui aura lieu dans 6 semaines (3 sprints de 2 semaines). Le festival comprendra de la musique, de la nourriture, des activit√©s et des comp√©titions.\nObjectif P√©dagogique Cet exercice permet aux √©tudiants de :\nPratiquer tous les r√¥les Scrum Vivre toutes les c√©r√©monies Cr√©er et g√©rer des epics, stories et sprints Exp√©rimenter la collaboration agile Comprendre l‚Äôimportance de l‚Äôadaptation üìã Phase 1 : Mise en Place (30 minutes) √âtape 1 : Formation des √©quipes (10 min) Formez des √©quipes de 5-7 √©tudiants Chaque √©quipe repr√©sente une ‚Äú√©quipe Scrum‚Äù √âtape 2 : Attribution des r√¥les (10 min) Chaque √©quipe assigne les r√¥les (rotation √† chaque sprint) :\n1 Product Owner : Repr√©sente les √©tudiants qui participeront au festival 1 Scrum Master : Facilite les c√©r√©monies et supprime les obstacles 3-5 D√©veloppeurs : √âquipe qui ex√©cute le travail √âtape 3 : Cr√©ation de la vision (10 min) Le Product Owner de chaque √©quipe d√©finit :\nLa vision du festival Les contraintes (budget fictif, espace, r√®glements) Les attentes des ‚Äúutilisateurs‚Äù (√©tudiants participants) üìù Phase 2 : Cr√©ation du Product Backlog (45 minutes) √âtape 1 : Identifier les Epics (15 min) L‚Äô√©quipe identifie les grands domaines du festival. Exemples d‚Äôepics :\nEPIC 1 : Programmation musicale\rEPIC 2 : Stands de nourriture et boissons\rEPIC 3 : Activit√©s et animations\rEPIC 4 : Marketing et communication\rEPIC 5 : Logistique et infrastructure\rEPIC 6 : Gestion budg√©taire √âtape 2 : D√©composer en User Stories (25 min) Pour chaque epic, cr√©ez des user stories au format : ‚ÄúEn tant que [persona], je veux [objectif], afin de [b√©n√©fice]‚Äù\nExemples de stories pour EPIC 1 (Programmation musicale) :\nStory 1.1 : En tant que participant, je veux voir la liste des groupes qui se produiront, afin de d√©cider si je veux assister au festival.\rStory 1.2 : En tant que participant, je veux conna√Ætre l'horaire des performances, afin de planifier ma journ√©e.\rStory 1.3 : En tant qu'organisateur, je veux cr√©er une sc√®ne avec syst√®me audio, afin que les groupes puissent performer.\rStory 1.4 : En tant que participant malentendant, je veux avoir acc√®s √† une interpr√©tation en langue des signes, afin de profiter des spectacles. Exemples pour EPIC 4 (Marketing et communication) :\nStory 4.1 : En tant qu'√©tudiant potentiel, je veux voir des affiches dans l'√©cole, afin d'√™tre inform√© du festival.\rStory 4.2 : En tant qu'√©tudiant, je veux pouvoir acheter des billets en ligne, afin d'√©viter les files d'attente.\rStory 4.3 : En tant qu'organisateur, je veux cr√©er une page Instagram pour l'√©v√©nement, afin de g√©n√©rer de l'engouement. √âtape 3 : Ajouter les crit√®res d‚Äôacceptation (15 min) Pour chaque story, d√©finissez 2-3 crit√®res d‚Äôacceptation.\nExemple pour Story 1.1 :\nCrit√®res d'acceptation :\r‚úì Une liste de minimum 3 groupes est confirm√©e\r‚úì Une courte bio de chaque groupe est disponible\r‚úì Des liens vers la musique de chaque groupe sont fournis\r‚úì Les genres musicaux sont clairement indiqu√©s √âtape 4 : Estimation (10 min) Utilisez la technique du Planning Poker :\nCartes avec valeurs : 1, 2, 3, 5, 8, 13, 20 Chaque membre estime silencieusement R√©v√®le simultan√©ment Discussion sur les √©carts Consensus Note : Pour l‚Äôexercice, 1 point = 1 heure de travail fictif\nüöÄ Phase 3 : Sprint 1 (1 semaine simul√©e = 1 heure de classe) Sprint Planning - Partie 1 : Quoi ? (15 min) Le Product Owner pr√©sente les stories prioritaires (5 min)\nLit chaque story Explique la valeur R√©pond aux questions D√©finir le Sprint Goal (5 min) Exemple : ‚ÄúCr√©er l‚Äôinfrastructure de base et la strat√©gie marketing initiale‚Äù\nS√©lectionner les stories (5 min)\nL‚Äô√©quipe choisit les stories qu‚Äôelle peut compl√©ter Bas√© sur la v√©locit√© estim√©e (pour Sprint 1, estimez conservativement) Exemple : Si l‚Äô√©quipe pense pouvoir faire 15 points, s√©lectionner des stories totalisant 12-15 points Sprint Planning - Partie 2 : Comment ? (10 min) D√©composer en t√¢ches Pour chaque story s√©lectionn√©e, cr√©er des t√¢ches concr√®tes.\nExemple pour Story 1.1 (Liste des groupes) :\nT√¢ches :\r‚ñ° Contacter 5 groupes potentiels\r‚ñ° N√©gocier les cachetsfictifs\r‚ñ° Obtenir les confirmations √©crites\r‚ñ° R√©diger les biographies\r‚ñ° Collecter les liens musicaux\r‚ñ° Cr√©er la page web de pr√©sentation Attribution initiale (optionnel)\nLes d√©veloppeurs peuvent s‚Äôassigner des t√¢ches Ou d√©cider de s‚Äôorganiser jour par jour Daily Scrum (Simulation - 3 fois pendant le sprint - 5 min chaque) Simulation 1 - D√©but du sprint : Chaque d√©veloppeur r√©pond :\nQu‚Äôai-je choisi de faire aujourd‚Äôhui ? Comment vais-je contribuer au Sprint Goal ? Y a-t-il des obstacles anticip√©s ? Simulation 2 - Milieu du sprint :\nQu‚Äôai-je accompli depuis hier ? Que vais-je faire aujourd‚Äôhui ? Y a-t-il des obstacles ? Exemple de d√©roulement :\nMarie : \"Hier j'ai contact√© 5 groupes. Aujourd'hui je vais n√©gocier avec les 2 qui ont r√©pondu positivement. Aucun obstacle.\"\rJean : \"Hier j'ai commenc√© la page web de pr√©sentation. Aujourd'hui je vais finir le design et int√©grer les infos. J'ai besoin des biographies de Marie pour avancer.\"\rSophie : \"Hier j'ai cr√©√© la page Instagram et post√© 2 visuels. Aujourd'hui je vais cr√©er les affiches √† imprimer. Pas d'obstacle.\" Simulation 3 - Fin du sprint :\nQu‚Äôai-je accompli depuis hier ? Que reste-t-il √† finaliser ? Quelles stories sont ‚ÄúDone‚Äù ? R√¥le du Scrum Master pendant les Standups :\nS‚Äôassurer que c‚Äôest rapide (15 min max) Noter les obstacles mentionn√©s Faciliter les conversations bloqu√©es Reporter les discussions d√©taill√©es apr√®s le standup Travail du Sprint (Simulation - 15 min) Les √©quipes ‚Äútravaillent‚Äù sur leurs t√¢ches. Pour l‚Äôexercice :\nCr√©er des maquettes rapides (dessins, documents) Lister les √©tapes qu‚Äôils feraient r√©ellement D√©placer les stories sur le tableau Scrum (√Ä faire ‚Üí En cours ‚Üí Done) Simuler des obstacles (ex : ‚ÄúLe budget pour un groupe est insuffisant‚Äù) Tableau Scrum √† utiliser :\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ TO DO ‚îÇ IN PROGRESS ‚îÇ TESTING ‚îÇ DONE ‚îÇ\r‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r‚îÇ Story 1.1 ‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ Story 4.1 ‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îÇ Story 5.1 ‚îÇ ‚îÇ ‚îÇ ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Sprint Review (10 min) Introduction par le Product Owner (2 min)\nRappel du Sprint Goal Vue d‚Äôensemble de ce qui a √©t√© planifi√© D√©monstration par l‚Äô√©quipe (5 min)\nChaque story ‚ÄúDone‚Äù est d√©montr√©e Montrer les livrables concrets (maquettes, plans, documents) Les ‚Äúparties prenantes‚Äù (autres √©quipes) posent des questions Feedback et mise √† jour du backlog (3 min)\nRecueillir les retours Ajuster les priorit√©s si n√©cessaire Identifier de nouvelles stories √† ajouter Exemple de d√©monstration :\nD√©veloppeur : \"Nous avons compl√©t√© la Story 1.1. Voici la maquette de la page web qui pr√©sente les 3 groupes confirm√©s. Chaque groupe a une bio de 50 mots et 2 liens vers leur musique.\"\rPartie prenante : \"Super ! Est-ce que les horaires de chaque groupe seront sur cette page aussi ?\"\rProduct Owner : \"Bonne question. J'ajoute une story pour √ßa au backlog.\" Sprint Retrospective (10 min) Pr√©parer le terrain (2 min) Le Scrum Master cr√©e un environnement s√ªr et rappelle la prime directive.\nFormat Start-Stop-Continue (6 min)\nL‚Äô√©quipe identifie :\nSTART (Commencer √† faire) :\nQuelles nouvelles pratiques adopter ? Exemple : ‚ÄúCommencer √† pr√©parer les questions avant le standup‚Äù STOP (Arr√™ter de faire) :\nQuoi cesser car inefficace ? Exemple : ‚ÄúArr√™ter de v√©rifier nos t√©l√©phones pendant les r√©unions‚Äù CONTINUE (Continuer √† faire) :\nCe qui fonctionne bien et doit continuer Exemple : ‚ÄúContinuer √† se r√©partir les t√¢ches √©quitablement‚Äù S√©lectionner 2 actions concr√®tes (2 min)\nVoter sur les am√©liorations prioritaires D√©finir comment les impl√©menter au prochain sprint Assigner un responsable pour chaque action Exemple de r√©trospective :\nSTART :\r- Faire un backlog refinement mid-sprint pour clarifier les stories √† venir\r- Utiliser un timer pour les standups\rSTOP :\r- Attendre la derni√®re minute pour demander de l'aide\r- Avoir des r√©unions en retard\rCONTINUE :\r- C√©l√©brer les petites victoires\r- Partager les connaissances entre membres\rActions choisies pour Sprint 2 :\r1. Jean sera responsable du timer pendant les standups ‚úì\r2. Marie organisera un refinement √† mi-sprint ‚úì üîÑ Phase 4 : Sprints 2 et 3 (m√™me structure) Sprint 2 et 3 suivent la m√™me structure :\nSprint Planning Daily Scrums (3 simulations) Travail du sprint Sprint Review Sprint Retrospective Particularit√©s √† introduire :\nSprint 2 - Changements et adaptation :\nLe professeur introduit un ‚Äúchangement de priorit√©‚Äù (simulation r√©aliste) Exemple : ‚ÄúUn groupe annule, il faut trouver un rempla√ßant rapidement‚Äù L‚Äô√©quipe doit adapter son Sprint Backlog Discussion : Comment g√©rer le changement en Scrum ? Sprint 3 - Finalisation et livraison :\nFocus sur la compl√©tion de l‚Äôincr√©ment final Pr√©paration d‚Äôune d√©mo compl√®te du festival planifi√© R√©trospective globale sur les 3 sprints üìä Phase 5 : Pr√©sentation Finale et D√©briefing (45 minutes) Pr√©sentations des √©quipes (25 min - 5 min par √©quipe) Chaque √©quipe pr√©sente :\nLeur festival final (2 min)\nQu‚Äôest-ce qui a √©t√© livr√© ? Quels epics sont compl√©t√©s ? M√©triques Scrum (1 min)\nV√©locit√© par sprint Graphique burndown Nombre de stories compl√©t√©es Apprentissages cl√©s (2 min)\nQu‚Äôont-ils appris sur Scrum ? Quels d√©fis ont-ils rencontr√©s ? Discussion de classe (20 min) Questions √† discuter :\nSur les r√¥les :\nQuel r√¥le avez-vous trouv√© le plus difficile ? Pourquoi ? Comment le Product Owner a-t-il g√©r√© les priorit√©s conflictuelles ? Comment le Scrum Master a-t-il supprim√© les obstacles ? Sur les c√©r√©monies :\nQuelle c√©r√©monie a √©t√© la plus utile ? Avez-vous trouv√© certaines r√©unions trop longues ou inutiles ? Comment les Daily Scrums ont-ils am√©lior√© la communication ? Sur les artefacts :\nComment le Product Backlog a-t-il √©volu√© ? Avez-vous bien estim√© votre v√©locit√© ? Qu‚Äôavez-vous appris sur la d√©composition des epics ? Sur l‚Äôagilit√© :\nComment avez-vous r√©agi aux changements ? Qu‚Äôest-ce qui a facilit√© ou emp√™ch√© l‚Äôadaptation ? En quoi Scrum est-il diff√©rent d‚Äôune gestion de projet traditionnelle ? Applications r√©elles :\nComment pourriez-vous utiliser Scrum dans d‚Äôautres contextes ? Quelles limitations de Scrum avez-vous observ√©es ? Dans quels types de projets Scrum serait-il inadapt√© ? üìù Livrables de l‚Äôexercice Chaque √©quipe doit produire :\nProduct Backlog complet (Excel ou Jira)\nTous les epics Toutes les stories avec crit√®res d‚Äôacceptation Estimations Sprint Backlogs (3)\nStories s√©lectionn√©es pour chaque sprint T√¢ches d√©taill√©es Attribution Graphiques de suivi\nBurndown chart pour chaque sprint V√©locit√© par sprint Graphique d‚Äôavancement des epics Notes de r√©trospectives (3)\nCe qui a bien fonctionn√© Ce qui n‚Äôa pas fonctionn√© Actions d‚Äôam√©lioration identifi√©es Pr√©sentation finale\nPlan du festival D√©mos visuelles (affiches, site web mockup, etc.) R√©trospective globale Conclusion Scrum et Agile ne sont pas juste des processus, ce sont des mentalit√©s. Le succ√®s de Scrum repose sur :\nLa transparence : Visibilit√© sur le travail et les obstacles L‚Äôinspection : √âvaluation r√©guli√®re des progr√®s et du processus L‚Äôadaptation : Ajustement continu bas√© sur l‚Äôapprentissage La collaboration : Travail d‚Äô√©quipe et communication ouverte La livraison de valeur : Focus constant sur ce qui compte pour l‚Äôutilisateur Les c√©r√©monies Scrum ne sont pas des r√©unions bureaucratiques - elles sont des opportunit√©s d‚Äôinspection et d‚Äôadaptation qui permettent aux √©quipes de livrer mieux et plus rapidement.\nEn pratiquant Scrum √† travers cet exercice, vous d√©veloppez non seulement des comp√©tences en gestion de projet, mais aussi en communication, collaboration, et r√©solution de probl√®mes - des comp√©tences essentielles dans tous les domaines professionnels.\nRessources compl√©mentaires Documentation officielle :\nScrum Guide : https://scrumguides.org/ Documentation Atlassian : https://www.atlassian.com/agile/scrum Outils populaires :\nJira : Pour la gestion de projets Scrum Trello : Alternative plus simple Miro/Mural : Pour les r√©trospectives et brainstorming Confluence : Pour la documentation d‚Äô√©quipe Lectures recommand√©es :\n‚ÄúScrum: The Art of Doing Twice the Work in Half the Time‚Äù - Jeff Sutherland ‚ÄúUser Stories Applied‚Äù - Mike Cohn ‚ÄúThe Phoenix Project‚Äù - Gene Kim (DevOps et Agile) Certifications :\nCertified ScrumMaster (CSM) Professional Scrum Master (PSM) SAFe Agilist (pour l‚ÄôAgile √† l‚Äô√©chelle) Document cr√©√© sur la base des meilleures pratiques Scrum et Agile d‚ÄôAtlassian Version : 2.0 | F√©vrier 2026",
    "description": "Table des mati√®res Introduction √† Agile Qu‚Äôest-ce que Scrum ? Les R√¥les Scrum Les Artefacts Scrum Les C√©r√©monies Scrum Epics, Stories et Sprints Exercice Pratique pour √âtudiants Introduction √† Agile Qu‚Äôest-ce que l‚ÄôAgile ? Agile est un ensemble de valeurs et de principes qui servent de philosophie de travail pour le d√©veloppement de produits et de projets. La m√©thodologie Agile a r√©volutionn√© la fa√ßon dont le travail est effectu√©, non seulement dans le d√©veloppement logiciel, mais aussi dans d‚Äôautres domaines.",
    "tags": [],
    "title": "Agile - Scrum",
    "uri": "/420-413/agile-_scrum/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "üìò LINQ en C# Language Integrated Query üìã Table des mati√®res Introduction √† LINQ Pourquoi utiliser LINQ ? Les Bases de LINQ Les Deux Syntaxes LINQ Op√©rations de Filtrage Op√©rations de Projection Op√©rations de Tri Op√©rations d‚ÄôAgr√©gation Op√©rations de Regroupement Op√©rations de Jointure Op√©rations d‚ÄôEnsemble Op√©rations de Quantification Op√©rations de Partition LINQ avec Objets Complexes Cas Pratiques R√©els Bonnes Pratiques et Pi√®ges 1. Introduction √† LINQ 1.1 Qu‚Äôest-ce que LINQ ? LINQ (Language Integrated Query) est une fonctionnalit√© de C# qui permet d‚Äôinterroger des collections de donn√©es directement dans le code, avec une syntaxe √©l√©gante et lisible.\nAnalogie : Imaginez que vous avez une biblioth√®que remplie de livres. Plut√¥t que de parcourir manuellement chaque √©tag√®re pour trouver ‚Äútous les romans de science-fiction publi√©s apr√®s 2020‚Äù, LINQ vous permet de poser cette question directement et d‚Äôobtenir la r√©ponse instantan√©ment.\n1.2 Les sources de donn√©es LINQ LINQ peut interroger diff√©rents types de donn√©es :\n// LINQ to Objects - Collections en m√©moire List\u003cint\u003e nombres = new List\u003cint\u003e { 1, 2, 3, 4, 5 }; var pairs = from n in nombres where n % 2 == 0 select n; // LINQ to XML - Documents XML XDocument doc = XDocument.Load(\"data.xml\"); var elements = from e in doc.Descendants(\"item\") select e; // LINQ to SQL / Entity Framework - Bases de donn√©es var clients = from c in dbContext.Clients where c.Ville == \"Montr√©al\" select c; Dans ce cours, nous nous concentrerons sur LINQ to Objects (collections en m√©moire).\n1.3 Mise en contexte : Probl√®me sans LINQ // ========================================== // SC√âNARIO : Trouver tous les √©tudiants avec une moyenne \u003e= 75 // ========================================== public class Etudiant { public string Nom { get; set; } public int Age { get; set; } public double Moyenne { get; set; } public string Programme { get; set; } } // Donn√©es List\u003cEtudiant\u003e etudiants = new List\u003cEtudiant\u003e { new Etudiant { Nom = \"Alice\", Age = 20, Moyenne = 85.5, Programme = \"Informatique\" }, new Etudiant { Nom = \"Bob\", Age = 22, Moyenne = 72.0, Programme = \"G√©nie\" }, new Etudiant { Nom = \"Charlie\", Age = 21, Moyenne = 90.0, Programme = \"Informatique\" }, new Etudiant { Nom = \"Diana\", Age = 19, Moyenne = 68.5, Programme = \"Math\" }, new Etudiant { Nom = \"Eve\", Age = 23, Moyenne = 78.0, Programme = \"Informatique\" } }; // ========================================== // SANS LINQ - Approche traditionnelle (boucles) // ========================================== List\u003cEtudiant\u003e etudiantsAvecBonneMoyenne = new List\u003cEtudiant\u003e(); foreach (var etudiant in etudiants) { if (etudiant.Moyenne \u003e= 75) { etudiantsAvecBonneMoyenne.Add(etudiant); } } Console.WriteLine(\"√âtudiants avec moyenne \u003e= 75:\"); foreach (var etudiant in etudiantsAvecBonneMoyenne) { Console.WriteLine($\"{etudiant.Nom}: {etudiant.Moyenne}\"); } // Affiche: // Alice: 85.5 // Charlie: 90 // Eve: 78 Probl√®mes avec cette approche :\nCode verbeux (beaucoup de lignes pour une t√¢che simple) Lisibilit√© r√©duite Variables temporaires n√©cessaires Difficile √† combiner plusieurs op√©rations 2. Pourquoi utiliser LINQ ? 2.1 Avantages de LINQ // ========================================== // AVEC LINQ - √âl√©gant et concis // ========================================== var etudiantsAvecBonneMoyenne = etudiants.Where(e =\u003e e.Moyenne \u003e= 75); foreach (var etudiant in etudiantsAvecBonneMoyenne) { Console.WriteLine($\"{etudiant.Nom}: {etudiant.Moyenne}\"); } // M√™me r√©sultat, mais en UNE SEULE LIGNE ! üéØ Avantages :\nConcision : Moins de code pour le m√™me r√©sultat Lisibilit√© : Le code se lit comme une phrase en anglais Composabilit√© : Facile d‚Äôencha√Æner plusieurs op√©rations Type-safe : Erreurs d√©tect√©es √† la compilation IntelliSense : Auto-compl√©tion dans Visual Studio R√©utilisabilit√© : Requ√™tes r√©utilisables 2.2 Comparaison avant/apr√®s LINQ // ========================================== // SC√âNARIO : Trouver les noms des √©tudiants en informatique, // tri√©s par moyenne d√©croissante, avec moyenne \u003e= 80 // ========================================== // SANS LINQ - 15+ lignes List\u003cEtudiant\u003e etudiantsInfo = new List\u003cEtudiant\u003e(); foreach (var e in etudiants) { if (e.Programme == \"Informatique\" \u0026\u0026 e.Moyenne \u003e= 80) { etudiantsInfo.Add(e); } } // Tri manuel etudiantsInfo.Sort((a, b) =\u003e b.Moyenne.CompareTo(a.Moyenne)); List\u003cstring\u003e noms = new List\u003cstring\u003e(); foreach (var e in etudiantsInfo) { noms.Add(e.Nom); } // AVEC LINQ - 3 lignes (ou m√™me 1 ligne!) var nomsInfo = etudiants .Where(e =\u003e e.Programme == \"Informatique\" \u0026\u0026 e.Moyenne \u003e= 80) .OrderByDescending(e =\u003e e.Moyenne) .Select(e =\u003e e.Nom); // Affichage foreach (var nom in nomsInfo) { Console.WriteLine(nom); } // Affiche: // Charlie // Alice 3. Les bases de LINQ 3.1 Importer le namespace using System.Linq; // ‚ö†Ô∏è OBLIGATOIRE pour utiliser LINQ using System.Collections.Generic; 3.2 Les collections et IEnumerable LINQ fonctionne avec tout ce qui impl√©mente IEnumerable\u003cT\u003e :\n// Listes List\u003cint\u003e nombres = new List\u003cint\u003e { 1, 2, 3, 4, 5 }; // Tableaux int[] tableauNombres = { 1, 2, 3, 4, 5 }; // Dictionnaires Dictionary\u003cstring, int\u003e ages = new Dictionary\u003cstring, int\u003e { { \"Alice\", 25 }, { \"Bob\", 30 } }; // Tous peuvent √™tre interrog√©s avec LINQ ! var resultats1 = nombres.Where(n =\u003e n \u003e 3); var resultats2 = tableauNombres.Where(n =\u003e n \u003e 3); var resultats3 = ages.Where(kvp =\u003e kvp.Value \u003e 25); 3.3 L‚Äôex√©cution diff√©r√©e (deferred execution) Concept important : LINQ utilise l‚Äôex√©cution diff√©r√©e - la requ√™te n‚Äôest ex√©cut√©e que lorsqu‚Äôon √©num√®re les r√©sultats.\nList\u003cint\u003e nombres = new List\u003cint\u003e { 1, 2, 3, 4, 5 }; // ‚ö†Ô∏è La requ√™te est D√âFINIE mais PAS EX√âCUT√âE var nombresPairs = nombres.Where(n =\u003e n % 2 == 0); Console.WriteLine(\"Requ√™te d√©finie\"); // Ajout d'un nouvel √©l√©ment APR√àS la d√©finition de la requ√™te nombres.Add(6); // ‚úÖ La requ√™te est EX√âCUT√âE maintenant (lors du foreach) foreach (var n in nombresPairs) { Console.WriteLine(n); // Affiche: 2, 4, 6 (6 est inclus!) } Forcer l‚Äôex√©cution imm√©diate :\n// Ex√©cution diff√©r√©e (par d√©faut) var requete = nombres.Where(n =\u003e n % 2 == 0); // IEnumerable\u003cint\u003e // Ex√©cution imm√©diate avec ToList() var liste = nombres.Where(n =\u003e n % 2 == 0).ToList(); // List\u003cint\u003e // Ex√©cution imm√©diate avec ToArray() var tableau = nombres.Where(n =\u003e n % 2 == 0).ToArray(); // int[] // Ex√©cution imm√©diate avec Count() int compte = nombres.Where(n =\u003e n % 2 == 0).Count(); // int 4. Les deux syntaxes LINQ LINQ offre deux syntaxes pour √©crire les requ√™tes :\n4.1 Syntaxe de m√©thode (method syntax) Utilise des m√©thodes d‚Äôextension avec des expressions lambda.\nvar resultat = etudiants .Where(e =\u003e e.Moyenne \u003e= 75) .OrderBy(e =\u003e e.Nom) .Select(e =\u003e e.Nom); Avantages :\nPlus concise Plus flexible (acc√®s √† toutes les m√©thodes LINQ) Pr√©f√©r√©e par la plupart des d√©veloppeurs Recommand√©e pour ce cours 4.2 Syntaxe de requ√™te (query syntax) Ressemble au SQL, utilise des mots-cl√©s comme from, where, select.\nvar resultat = from e in etudiants where e.Moyenne \u003e= 75 orderby e.Nom select e.Nom; Avantages :\nFamili√®re pour ceux qui connaissent SQL Parfois plus lisible pour des requ√™tes complexes 4.3 Comparaison des deux syntaxes // ========================================== // SC√âNARIO : √âtudiants en informatique avec moyenne \u003e= 80 // ========================================== // SYNTAXE DE M√âTHODE (recommand√©e) var resultat1 = etudiants .Where(e =\u003e e.Programme == \"Informatique\") .Where(e =\u003e e.Moyenne \u003e= 80) .Select(e =\u003e e.Nom); // SYNTAXE DE REQU√äTE var resultat2 = from e in etudiants where e.Programme == \"Informatique\" where e.Moyenne \u003e= 80 select e.Nom; // Les DEUX produisent le m√™me r√©sultat ! üí° Dans ce cours, nous utiliserons principalement la syntaxe de m√©thode car elle est :\nPlus courante dans l‚Äôindustrie Plus flexible Mieux support√©e par IntelliSense 5. Op√©rations de filtrage 5.1 Where - Filtrer selon une condition Where() retourne tous les √©l√©ments qui satisfont une condition.\n// ========================================== // MISE EN CONTEXTE : Gestion d'un magasin // ========================================== public class Produit { public int Id { get; set; } public string Nom { get; set; } public decimal Prix { get; set; } public string Categorie { get; set; } public int Stock { get; set; } public bool EstEnPromotion { get; set; } } List\u003cProduit\u003e produits = new List\u003cProduit\u003e { new Produit { Id = 1, Nom = \"Laptop\", Prix = 1200, Categorie = \"√âlectronique\", Stock = 5, EstEnPromotion = true }, new Produit { Id = 2, Nom = \"Souris\", Prix = 25, Categorie = \"√âlectronique\", Stock = 50, EstEnPromotion = false }, new Produit { Id = 3, Nom = \"Clavier\", Prix = 80, Categorie = \"√âlectronique\", Stock = 30, EstEnPromotion = true }, new Produit { Id = 4, Nom = \"Chaise\", Prix = 150, Categorie = \"Mobilier\", Stock = 10, EstEnPromotion = false }, new Produit { Id = 5, Nom = \"Bureau\", Prix = 400, Categorie = \"Mobilier\", Stock = 3, EstEnPromotion = true }, new Produit { Id = 6, Nom = \"Lampe\", Prix = 45, Categorie = \"Mobilier\", Stock = 20, EstEnPromotion = false } }; // ========================================== // EXEMPLE 1 : Produits en promotion // ========================================== var produitsEnPromotion = produits.Where(p =\u003e p.EstEnPromotion); Console.WriteLine(\"Produits en promotion:\"); foreach (var p in produitsEnPromotion) { Console.WriteLine($\"- {p.Nom} ({p.Prix:C})\"); } // Affiche: // - Laptop (1 200,00 $) // - Clavier (80,00 $) // - Bureau (400,00 $) // ========================================== // EXEMPLE 2 : Produits chers (\u003e 100$) // ========================================== var produitsChe rs = produits.Where(p =\u003e p.Prix \u003e 100); // ========================================== // EXEMPLE 3 : √âlectronique PAS en promotion // ========================================== var electroniqueNormale = produits.Where(p =\u003e p.Categorie == \"√âlectronique\" \u0026\u0026 !p.EstEnPromotion ); // ========================================== // EXEMPLE 4 : Stock faible (\u003c 10 unit√©s) // ========================================== var stockFaible = produits.Where(p =\u003e p.Stock \u003c 10); Console.WriteLine(\"\\n‚ö†Ô∏è ALERTE Stock faible:\"); foreach (var p in stockFaible) { Console.WriteLine($\"- {p.Nom}: seulement {p.Stock} unit√©s\"); } // Affiche: // - Laptop: seulement 5 unit√©s // - Bureau: seulement 3 unit√©s // ========================================== // EXEMPLE 5 : Conditions multiples // ========================================== var produitsSpeciaux = produits.Where(p =\u003e p.Prix \u003e= 50 \u0026\u0026 p.Prix \u003c= 200 \u0026\u0026 p.Stock \u003e 5 \u0026\u0026 p.Categorie == \"√âlectronique\" ); üí° Astuce : Vous pouvez cha√Æner plusieurs Where() :\n// Ces deux requ√™tes sont √©quivalentes: // Version 1 : Une seule condition complexe var resultat1 = produits.Where(p =\u003e p.Prix \u003e 50 \u0026\u0026 p.Stock \u003e 10); // Version 2 : Deux Where() s√©par√©s, mais moins efficace que la premi√®re version var resultat2 = produits .Where(p =\u003e p.Prix \u003e 50) .Where(p =\u003e p.Stock \u003e 10); 5.2 OfType - Filtrer par type Utile quand vous avez une collection d‚Äôobjets de types diff√©rents.\n// ========================================== // MISE EN CONTEXTE : Gestion de formes g√©om√©triques // ========================================== public abstract class Forme { public string Couleur { get; set; } } public class Cercle : Forme { public double Rayon { get; set; } } public class Rectangle : Forme { public double Longueur { get; set; } public double Largeur { get; set; } } public class Triangle : Forme { public double Base { get; set; } public double Hauteur { get; set; } } // Collection mixte List\u003cForme\u003e formes = new List\u003cForme\u003e { new Cercle { Couleur = \"Rouge\", Rayon = 5 }, new Rectangle { Couleur = \"Bleu\", Longueur = 10, Largeur = 5 }, new Cercle { Couleur = \"Vert\", Rayon = 3 }, new Triangle { Couleur = \"Jaune\", Base = 4, Hauteur = 6 }, new Rectangle { Couleur = \"Orange\", Longueur = 8, Largeur = 4 } }; // ========================================== // Obtenir seulement les cercles // ========================================== var cercles = formes.OfType\u003cCercle\u003e(); Console.WriteLine(\"Cercles:\"); foreach (var c in cercles) { Console.WriteLine($\"- Cercle {c.Couleur}, rayon = {c.Rayon}\"); } // Affiche: // - Cercle Rouge, rayon = 5 // - Cercle Vert, rayon = 3 // ========================================== // Obtenir seulement les rectangles // ========================================== var rectangles = formes.OfType\u003cRectangle\u003e(); // ========================================== // Calcul d'aire pour tous les cercles // ========================================== var airesDesCercles = formes .OfType\u003cCercle\u003e() .Select(c =\u003e Math.PI * c.Rayon * c.Rayon); 6. Op√©rations de projection La projection transforme les √©l√©ments d‚Äôune collection en un autre format.\n6.1 Select - Transformer chaque √©l√©ment // ========================================== // MISE EN CONTEXTE : Syst√®me de gestion d'employ√©s // ========================================== public class Employe { public int Id { get; set; } public string Prenom { get; set; } public string Nom { get; set; } public string Departement { get; set; } public decimal Salaire { get; set; } public DateTime DateEmbauche { get; set; } } List\u003cEmploye\u003e employes = new List\u003cEmploye\u003e { new Employe { Id = 1, Prenom = \"Alice\", Nom = \"Tremblay\", Departement = \"IT\", Salaire = 75000, DateEmbauche = new DateTime(2020, 5, 15) }, new Employe { Id = 2, Prenom = \"Bob\", Nom = \"Gagnon\", Departement = \"RH\", Salaire = 65000, DateEmbauche = new DateTime(2019, 3, 10) }, new Employe { Id = 3, Prenom = \"Charlie\", Nom = \"Roy\", Departement = \"IT\", Salaire = 85000, DateEmbauche = new DateTime(2018, 1, 20) }, new Employe { Id = 4, Prenom = \"Diana\", Nom = \"Martin\", Departement = \"Ventes\", Salaire = 70000, DateEmbauche = new DateTime(2021, 7, 5) } }; // ========================================== // EXEMPLE 1 : Extraire seulement les noms complets // ========================================== var nomsComplets = employes.Select(e =\u003e $\"{e.Prenom} {e.Nom}\"); Console.WriteLine(\"Liste des employ√©s:\"); foreach (var nom in nomsComplets) { Console.WriteLine($\"- {nom}\"); } // Affiche: // - Alice Tremblay // - Bob Gagnon // - Charlie Roy // - Diana Martin // ========================================== // EXEMPLE 2 : Extraire seulement les salaires // ========================================== var salaires = employes.Select(e =\u003e e.Salaire); // ========================================== // EXEMPLE 3 : Augmenter tous les salaires de 10% // ========================================== var salairesAugmentes = employes.Select(e =\u003e e.Salaire * 1.10m); Console.WriteLine(\"\\nSalaires apr√®s augmentation de 10%:\"); foreach (var salaire in salairesAugmentes) { Console.WriteLine($\"{salaire:C}\"); } // ========================================== // EXEMPLE 4 : Projection vers un type anonyme // ========================================== var resumeEmployes = employes.Select(e =\u003e new { NomComplet = $\"{e.Prenom} {e.Nom}\", Dept = e.Departement, SalaireAnnuel = e.Salaire, SalaireMensuel = e.Salaire / 12, Anciennete = DateTime.Now.Year - e.DateEmbauche.Year }); Console.WriteLine(\"\\nR√©sum√© des employ√©s:\"); foreach (var e in resumeEmployes) { Console.WriteLine($\"{e.NomComplet} ({e.Dept}) - {e.SalaireAnnuel:C}/an - {e.Anciennete} ans d'anciennet√©\"); } // ========================================== // EXEMPLE 5 : Projection vers une nouvelle classe // ========================================== public class EmployeDTO // DTO = Data Transfer Object { public string NomComplet { get; set; } public string Departement { get; set; } public string InformationSalaire { get; set; } } var employesDTO = employes.Select(e =\u003e new EmployeDTO { NomComplet = $\"{e.Prenom} {e.Nom}\", Departement = e.Departement, InformationSalaire = $\"{e.Salaire:C} par ann√©e\" }); 6.2 SelectMany - Aplatir des collections imbriqu√©es Utilis√© pour ‚Äúaplatir‚Äù des collections de collections en une seule collection.\n// ========================================== // MISE EN CONTEXTE : Universit√© avec √©tudiants et cours // ========================================== public class Cours { public string Code { get; set; } public string Nom { get; set; } public int Credits { get; set; } } public class EtudiantAvecCours { public string Nom { get; set; } public List\u003cCours\u003e CoursInscrits { get; set; } } List\u003cEtudiantAvecCours\u003e etudiants = new List\u003cEtudiantAvecCours\u003e { new EtudiantAvecCours { Nom = \"Alice\", CoursInscrits = new List\u003cCours\u003e { new Cours { Code = \"INF101\", Nom = \"Programmation I\", Credits = 3 }, new Cours { Code = \"MAT201\", Nom = \"Calcul I\", Credits = 4 } } }, new EtudiantAvecCours { Nom = \"Bob\", CoursInscrits = new List\u003cCours\u003e { new Cours { Code = \"INF101\", Nom = \"Programmation I\", Credits = 3 }, new Cours { Code = \"INF202\", Nom = \"Structures de donn√©es\", Credits = 3 } } }, new EtudiantAvecCours { Nom = \"Charlie\", CoursInscrits = new List\u003cCours\u003e { new Cours { Code = \"MAT201\", Nom = \"Calcul I\", Credits = 4 }, new Cours { Code = \"PHY101\", Nom = \"Physique I\", Credits = 4 } } } }; // ========================================== // PROBL√àME : Obtenir TOUS les cours (de tous les √©tudiants) // ========================================== // ‚ùå MAUVAISE approche avec Select (ne fonctionne pas comme voulu) var tentative = etudiants.Select(e =\u003e e.CoursInscrits); // Retourne : IEnumerable\u003cList\u003cCours\u003e\u003e - Une liste de listes ! // ‚úÖ BONNE approche avec SelectMany var tousLesCours = etudiants.SelectMany(e =\u003e e.CoursInscrits); // Retourne : IEnumerable\u003cCours\u003e - Une liste plate ! Console.WriteLine(\"Tous les cours (avec doublons):\"); foreach (var cours in tousLesCours) { Console.WriteLine($\"- {cours.Code}: {cours.Nom}\"); } // Affiche: // - INF101: Programmation I // - MAT201: Calcul I // - INF101: Programmation I (doublon) // - INF202: Structures de donn√©es // - MAT201: Calcul I (doublon) // - PHY101: Physique I // ========================================== // Obtenir les cours uniques // ========================================== var coursUniques = etudiants .SelectMany(e =\u003e e.CoursInscrits) .Distinct() // √âlimine les doublons .Select(c =\u003e c.Code); Console.WriteLine(\"\\nCours uniques:\"); foreach (var code in coursUniques) { Console.WriteLine($\"- {code}\"); } // ========================================== // Compter le nombre total de cr√©dits de tous les √©tudiants // ========================================== int totalCredits = etudiants .SelectMany(e =\u003e e.CoursInscrits) .Sum(c =\u003e c.Credits); Console.WriteLine($\"\\nTotal de cr√©dits inscrits: {totalCredits}\"); Visualisation Select vs SelectMany :\nDonn√©es:\r√âtudiant 1 ‚Üí [Cours A, Cours B]\r√âtudiant 2 ‚Üí [Cours C, Cours D]\r√âtudiant 3 ‚Üí [Cours E]\rSelect() :\r[[Cours A, Cours B], [Cours C, Cours D], [Cours E]]\r‚Üë Liste de listes\rSelectMany() :\r[Cours A, Cours B, Cours C, Cours D, Cours E]\r‚Üë Liste plate 7. Op√©rations de tri 7.1 OrderBy et OrderByDescending // ========================================== // MISE EN CONTEXTE : Classement d'athl√®tes // ========================================== public class Athlete { public string Nom { get; set; } public string Pays { get; set; } public int Age { get; set; } public double TempsCourse { get; set; } // En secondes public int MedaillesOr { get; set; } } List\u003cAthlete\u003e athletes = new List\u003cAthlete\u003e { new Athlete { Nom = \"Usain Bolt\", Pays = \"Jama√Øque\", Age = 36, TempsCourse = 9.58, MedaillesOr = 8 }, new Athlete { Nom = \"Carl Lewis\", Pays = \"USA\", Age = 61, TempsCourse = 9.86, MedaillesOr = 9 }, new Athlete { Nom = \"Andre De Grasse\", Pays = \"Canada\", Age = 28, TempsCourse = 9.89, MedaillesOr = 1 }, new Athlete { Nom = \"Yohan Blake\", Pays = \"Jama√Øque\", Age = 33, TempsCourse = 9.69, MedaillesOr = 1 }, new Athlete { Nom = \"Justin Gatlin\", Pays = \"USA\", Age = 41, TempsCourse = 9.74, MedaillesOr = 1 } }; // ========================================== // EXEMPLE 1 : Trier par temps (du plus rapide au plus lent) // ========================================== var classementParTemps = athletes.OrderBy(a =\u003e a.TempsCourse); Console.WriteLine(\"Classement par temps de course:\"); int position = 1; foreach (var athlete in classementParTemps) { Console.WriteLine($\"{position}. {athlete.Nom} - {athlete.TempsCourse}s\"); position++; } // Affiche: // 1. Usain Bolt - 9.58s // 2. Yohan Blake - 9.69s // 3. Justin Gatlin - 9.74s // 4. Carl Lewis - 9.86s // 5. Andre De Grasse - 9.89s // ========================================== // EXEMPLE 2 : Trier par m√©dailles (du plus au moins) // ========================================== var classementParMedailles = athletes.OrderByDescending(a =\u003e a.MedaillesOr); Console.WriteLine(\"\\nClassement par m√©dailles d'or:\"); foreach (var athlete in classementParMedailles) { Console.WriteLine($\"{athlete.Nom}: {athlete.MedaillesOr} m√©daille(s)\"); } // ========================================== // EXEMPLE 3 : Trier par nom (ordre alphab√©tique) // ========================================== var classementAlphabetique = athletes.OrderBy(a =\u003e a.Nom); // ========================================== // EXEMPLE 4 : Trier par √¢ge (du plus jeune au plus vieux) // ========================================== var classementParAge = athletes.OrderBy(a =\u003e a.Age); 7.2 ThenBy et ThenByDescending - Tris secondaires Utilis√©s pour trier selon plusieurs crit√®res.\n// ========================================== // EXEMPLE : Trier par pays, puis par temps // ========================================== var classementPaysEtTemps = athletes .OrderBy(a =\u003e a.Pays) // D'abord par pays .ThenBy(a =\u003e a.TempsCourse); // Ensuite par temps Console.WriteLine(\"Classement par pays puis temps:\"); foreach (var athlete in classementPaysEtTemps) { Console.WriteLine($\"{athlete.Pays} - {athlete.Nom} ({athlete.TempsCourse}s)\"); } // Affiche: // Canada - Andre De Grasse (9.89s) // Jama√Øque - Usain Bolt (9.58s) // Jama√Øque - Yohan Blake (9.69s) // USA - Justin Gatlin (9.74s) // USA - Carl Lewis (9.86s) // ========================================== // EXEMPLE : Trier par m√©dailles (desc), puis par temps (asc) // ========================================== var classementComplet = athletes .OrderByDescending(a =\u003e a.MedaillesOr) // Plus de m√©dailles en premier .ThenBy(a =\u003e a.TempsCourse); // Si √©galit√©, plus rapide en premier Console.WriteLine(\"\\nClassement final:\"); foreach (var athlete in classementComplet) { Console.WriteLine($\"{athlete.Nom}: {athlete.MedaillesOr} m√©daille(s), {athlete.TempsCourse}s\"); } 7.3 Reverse - Inverser l‚Äôordre // Liste de nombres List\u003cint\u003e nombres = new List\u003cint\u003e { 1, 2, 3, 4, 5 }; // Inverser l'ordre var nombresInverses = nombres.AsEnumerable().Reverse(); foreach (var n in nombresInverses) { Console.Write($\"{n} \"); // Affiche: 5 4 3 2 1 } 8. Op√©rations d‚ÄôAgr√©gation Les op√©rations d‚Äôagr√©gation calculent une valeur unique √† partir d‚Äôune collection.\n8.1 Count - Compter les √©l√©ments // ========================================== // MISE EN CONTEXTE : Syst√®me de gestion de biblioth√®que // ========================================== public class Livre { public string Titre { get; set; } public string Auteur { get; set; } public int AnneePublication { get; set; } public string Genre { get; set; } public int NombrePages { get; set; } public bool EstDisponible { get; set; } public double Note { get; set; } // Sur 5 } List\u003cLivre\u003e bibliotheque = new List\u003cLivre\u003e { new Livre { Titre = \"1984\", Auteur = \"George Orwell\", AnneePublication = 1949, Genre = \"Science-Fiction\", NombrePages = 328, EstDisponible = true, Note = 4.7 }, new Livre { Titre = \"Le Petit Prince\", Auteur = \"Antoine de Saint-Exup√©ry\", AnneePublication = 1943, Genre = \"Fiction\", NombrePages = 96, EstDisponible = false, Note = 4.8 }, new Livre { Titre = \"Harry Potter √† l'√©cole des sorciers\", Auteur = \"J.K. Rowling\", AnneePublication = 1997, Genre = \"Fantasy\", NombrePages = 309, EstDisponible = true, Note = 4.9 }, new Livre { Titre = \"Le Seigneur des Anneaux\", Auteur = \"J.R.R. Tolkien\", AnneePublication = 1954, Genre = \"Fantasy\", NombrePages = 1178, EstDisponible = true, Note = 4.9 }, new Livre { Titre = \"Dune\", Auteur = \"Frank Herbert\", AnneePublication = 1965, Genre = \"Science-Fiction\", NombrePages = 688, EstDisponible = false, Note = 4.6 }, new Livre { Titre = \"Les Mis√©rables\", Auteur = \"Victor Hugo\", AnneePublication = 1862, Genre = \"Classique\", NombrePages = 1463, EstDisponible = true, Note = 4.5 } }; // ========================================== // EXEMPLE 1 : Compter tous les livres // ========================================== int totalLivres = bibliotheque.Count(); Console.WriteLine($\"Total de livres: {totalLivres}\"); // 6 // ========================================== // EXEMPLE 2 : Compter les livres disponibles // ========================================== int livresDisponibles = bibliotheque.Count(l =\u003e l.EstDisponible); Console.WriteLine($\"Livres disponibles: {livresDisponibles}\"); // 4 // ========================================== // EXEMPLE 3 : Compter par genre // ========================================== int livresSciFi = bibliotheque.Count(l =\u003e l.Genre == \"Science-Fiction\"); int livresFantasy = bibliotheque.Count(l =\u003e l.Genre == \"Fantasy\"); Console.WriteLine($\"Science-Fiction: {livresSciFi}\"); // 2 Console.WriteLine($\"Fantasy: {livresFantasy}\"); // 2 // ========================================== // EXEMPLE 4 : Compter les livres r√©cents (apr√®s 1990) // ========================================== int livresRecents = bibliotheque.Count(l =\u003e l.AnneePublication \u003e= 1990); Console.WriteLine($\"Livres publi√©s apr√®s 1990: {livresRecents}\"); // 1 8.2 Sum - Calculer la somme // ========================================== // EXEMPLE 1 : Nombre total de pages dans la biblioth√®que // ========================================== int totalPages = bibliotheque.Sum(l =\u003e l.NombrePages); Console.WriteLine($\"Total de pages: {totalPages:N0}\"); // 4 062 // ========================================== // EXEMPLE 2 : Pages des livres disponibles // ========================================== int pagesDisponibles = bibliotheque .Where(l =\u003e l.EstDisponible) .Sum(l =\u003e l.NombrePages); Console.WriteLine($\"Pages disponibles: {pagesDisponibles:N0}\"); // 3 178 // ========================================== // EXEMPLE 3 : Somme simple (liste de nombres) // ========================================== List\u003cint\u003e ventes = new List\u003cint\u003e { 100, 250, 175, 320, 95 }; int totalVentes = ventes.Sum(); Console.WriteLine($\"Total des ventes: {totalVentes}\"); // 940 8.3 Average - Calculer la moyenne // ========================================== // EXEMPLE 1 : Note moyenne de tous les livres // ========================================== double noteMoyenne = bibliotheque.Average(l =\u003e l.Note); Console.WriteLine($\"Note moyenne: {noteMoyenne:F2}/5\"); // 4.73/5 // ========================================== // EXEMPLE 2 : Nombre moyen de pages // ========================================== double moyennePages = bibliotheque.Average(l =\u003e l.NombrePages); Console.WriteLine($\"Moyenne de pages: {moyennePages:F0}\"); // 677 // ========================================== // EXEMPLE 3 : Note moyenne des livres Fantasy // ========================================== double noteMoyenneFantasy = bibliotheque .Where(l =\u003e l.Genre == \"Fantasy\") .Average(l =\u003e l.Note); Console.WriteLine($\"Note moyenne Fantasy: {noteMoyenneFantasy:F2}/5\"); // 4.90/5 8.4 Min et Max - Trouver minimum et maximum // ========================================== // EXEMPLE 1 : Plus vieux et plus r√©cent livre // ========================================== int anneeMin = bibliotheque.Min(l =\u003e l.AnneePublication); int anneeMax = bibliotheque.Max(l =\u003e l.AnneePublication); Console.WriteLine($\"Plus vieux livre: {anneeMin}\"); // 1862 Console.WriteLine($\"Plus r√©cent livre: {anneeMax}\"); // 1997 // ========================================== // EXEMPLE 2 : Livre le plus court et le plus long // ========================================== int pagesMin = bibliotheque.Min(l =\u003e l.NombrePages); int pagesMax = bibliotheque.Max(l =\u003e l.NombrePages); Console.WriteLine($\"Livre le plus court: {pagesMin} pages\"); // 96 Console.WriteLine($\"Livre le plus long: {pagesMax} pages\"); // 1463 // ========================================== // EXEMPLE 3 : Meilleure et pire note // ========================================== double meilleureNote = bibliotheque.Max(l =\u003e l.Note); double pireNote = bibliotheque.Min(l =\u003e l.Note); Console.WriteLine($\"Meilleure note: {meilleureNote}/5\"); // 4.9/5 Console.WriteLine($\"Pire note: {pireNote}/5\"); // 4.5/5 // ========================================== // EXEMPLE 4 : Obtenir LE livre avec la meilleure note (pas juste la note) // ========================================== var meilleurLivre = bibliotheque.OrderByDescending(l =\u003e l.Note).First(); Console.WriteLine($\"Meilleur livre: {meilleurLivre.Titre} ({meilleurLivre.Note}/5)\"); // Harry Potter √† l'√©cole des sorciers (4.9/5) 8.5 Aggregate - Agr√©gation personnalis√©e Pour des calculs plus complexes.\n// ========================================== // EXEMPLE 1 : Concat√©ner tous les titres // ========================================== string tousTitres = bibliotheque .Select(l =\u003e l.Titre) .Aggregate((titre1, titre2) =\u003e titre1 + \", \" + titre2); Console.WriteLine($\"Tous les titres: {tousTitres}\"); // ========================================== // EXEMPLE 2 : Calculer un produit (multiplication) // ========================================== List\u003cint\u003e nombres = new List\u003cint\u003e { 2, 3, 4, 5 }; int produit = nombres.Aggregate((a, b) =\u003e a * b); Console.WriteLine($\"Produit: {produit}\"); // 2 √ó 3 √ó 4 √ó 5 = 120 // ========================================== // EXEMPLE 3 : Calculer un total avec valeur initiale // ========================================== int sommeAvecInitial = nombres.Aggregate(100, (total, nombre) =\u003e total + nombre); Console.WriteLine($\"Somme avec initial: {sommeAvecInitial}\"); // 100 + 2 + 3 + 4 + 5 = 114 9. Op√©rations de Regroupement 9.1 GroupBy - Regrouper par cl√© // ========================================== // MISE EN CONTEXTE : Analyse des ventes d'un magasin // ========================================== public class Vente { public int Id { get; set; } public string Produit { get; set; } public string Categorie { get; set; } public decimal Montant { get; set; } public DateTime Date { get; set; } public string Vendeur { get; set; } } List\u003cVente\u003e ventes = new List\u003cVente\u003e { new Vente { Id = 1, Produit = \"Laptop\", Categorie = \"√âlectronique\", Montant = 1200, Date = new DateTime(2024, 1, 15), Vendeur = \"Alice\" }, new Vente { Id = 2, Produit = \"Souris\", Categorie = \"√âlectronique\", Montant = 25, Date = new DateTime(2024, 1, 16), Vendeur = \"Bob\" }, new Vente { Id = 3, Produit = \"Bureau\", Categorie = \"Mobilier\", Montant = 400, Date = new DateTime(2024, 1, 17), Vendeur = \"Alice\" }, new Vente { Id = 4, Produit = \"Chaise\", Categorie = \"Mobilier\", Montant = 150, Date = new DateTime(2024, 1, 18), Vendeur = \"Charlie\" }, new Vente { Id = 5, Produit = \"Clavier\", Categorie = \"√âlectronique\", Montant = 80, Date = new DateTime(2024, 1, 19), Vendeur = \"Bob\" }, new Vente { Id = 6, Produit = \"Lampe\", Categorie = \"Mobilier\", Montant = 45, Date = new DateTime(2024, 1, 20), Vendeur = \"Alice\" }, new Vente { Id = 7, Produit = \"√âcran\", Categorie = \"√âlectronique\", Montant = 350, Date = new DateTime(2024, 1, 21), Vendeur = \"Charlie\" } }; // ========================================== // EXEMPLE 1 : Regrouper par cat√©gorie // ========================================== var ventesParCategorie = ventes.GroupBy(v =\u003e v.Categorie); Console.WriteLine(\"Ventes par cat√©gorie:\"); foreach (var groupe in ventesParCategorie) { Console.WriteLine($\"\\n{groupe.Key}:\"); // Key = la cat√©gorie foreach (var vente in groupe) { Console.WriteLine($\" - {vente.Produit}: {vente.Montant:C}\"); } } // Affiche: // √âlectronique: // - Laptop: 1 200,00 $ // - Souris: 25,00 $ // - Clavier: 80,00 $ // - √âcran: 350,00 $ // Mobilier: // - Bureau: 400,00 $ // - Chaise: 150,00 $ // - Lampe: 45,00 $ // ========================================== // EXEMPLE 2 : Calculer le total par cat√©gorie // ========================================== var totauxParCategorie = ventes .GroupBy(v =\u003e v.Categorie) .Select(groupe =\u003e new { Categorie = groupe.Key, NombreVentes = groupe.Count(), MontantTotal = groupe.Sum(v =\u003e v.Montant), MontantMoyen = groupe.Average(v =\u003e v.Montant) }); Console.WriteLine(\"\\nüìä Statistiques par cat√©gorie:\"); foreach (var stat in totauxParCategorie) { Console.WriteLine($\"{stat.Categorie}:\"); Console.WriteLine($\" Nombre de ventes: {stat.NombreVentes}\"); Console.WriteLine($\" Total: {stat.MontantTotal:C}\"); Console.WriteLine($\" Moyenne: {stat.MontantMoyen:C}\"); } // Affiche: // √âlectronique: // Nombre de ventes: 4 // Total: 1 655,00 $ // Moyenne: 413,75 $ // Mobilier: // Nombre de ventes: 3 // Total: 595,00 $ // Moyenne: 198,33 $ // ========================================== // EXEMPLE 3 : Regrouper par vendeur // ========================================== var ventesParVendeur = ventes .GroupBy(v =\u003e v.Vendeur) .Select(groupe =\u003e new { Vendeur = groupe.Key, NombreVentes = groupe.Count(), TotalVentes = groupe.Sum(v =\u003e v.Montant), MeilleureVente = groupe.Max(v =\u003e v.Montant) }) .OrderByDescending(x =\u003e x.TotalVentes); Console.WriteLine(\"\\nüèÜ Performance des vendeurs:\"); foreach (var vendeur in ventesParVendeur) { Console.WriteLine($\"{vendeur.Vendeur}:\"); Console.WriteLine($\" {vendeur.NombreVentes} vente(s)\"); Console.WriteLine($\" Total: {vendeur.TotalVentes:C}\"); Console.WriteLine($\" Meilleure vente: {vendeur.MeilleureVente:C}\"); } // ========================================== // EXEMPLE 4 : Regrouper par mois // ========================================== var ventesParMois = ventes .GroupBy(v =\u003e v.Date.Month) .Select(groupe =\u003e new { Mois = groupe.Key, Total = groupe.Sum(v =\u003e v.Montant) }); 10. Op√©rations de Jointure Les jointures combinent des donn√©es de deux collections bas√©es sur une cl√© commune.\n10.1 Join - Jointure interne // ========================================== // MISE EN CONTEXTE : Syst√®me de commandes en ligne // ========================================== public class Client { public int Id { get; set; } public string Nom { get; set; } public string Email { get; set; } public string Ville { get; set; } } public class Commande { public int Id { get; set; } public int ClientId { get; set; } public DateTime DateCommande { get; set; } public decimal Montant { get; set; } public string Statut { get; set; } } List\u003cClient\u003e clients = new List\u003cClient\u003e { new Client { Id = 1, Nom = \"Alice Tremblay\", Email = \"alice@email.com\", Ville = \"Montr√©al\" }, new Client { Id = 2, Nom = \"Bob Gagnon\", Email = \"bob@email.com\", Ville = \"Qu√©bec\" }, new Client { Id = 3, Nom = \"Charlie Roy\", Email = \"charlie@email.com\", Ville = \"Montr√©al\" }, new Client { Id = 4, Nom = \"Diana Martin\", Email = \"diana@email.com\", Ville = \"Laval\" } }; List\u003cCommande\u003e commandes = new List\u003cCommande\u003e { new Commande { Id = 101, ClientId = 1, DateCommande = new DateTime(2024, 1, 15), Montant = 150.00m, Statut = \"Livr√©e\" }, new Commande { Id = 102, ClientId = 1, DateCommande = new DateTime(2024, 1, 20), Montant = 75.50m, Statut = \"En cours\" }, new Commande { Id = 103, ClientId = 2, DateCommande = new DateTime(2024, 1, 18), Montant = 200.00m, Statut = \"Livr√©e\" }, new Commande { Id = 104, ClientId = 3, DateCommande = new DateTime(2024, 1, 22), Montant = 95.00m, Statut = \"Livr√©e\" }, new Commande { Id = 105, ClientId = 1, DateCommande = new DateTime(2024, 1, 25), Montant = 120.00m, Statut = \"En cours\" } // Note: Aucune commande pour Diana (Id = 4) }; // ========================================== // EXEMPLE 1 : Joindre clients et commandes // ========================================== var commandesAvecClient = commandes.Join( clients, // Collection √† joindre commande =\u003e commande.ClientId, // Cl√© de la premi√®re collection client =\u003e client.Id, // Cl√© de la deuxi√®me collection (commande, client) =\u003e new // R√©sultat de la jointure { NumeroCommande = commande.Id, NomClient = client.Nom, VilleClient = client.Ville, Montant = commande.Montant, Date = commande.DateCommande, Statut = commande.Statut } ); Console.WriteLine(\"üì¶ Commandes avec informations clients:\"); foreach (var cmd in commandesAvecClient) { Console.WriteLine($\"Commande #{cmd.NumeroCommande} - {cmd.NomClient} ({cmd.VilleClient}) - {cmd.Montant:C} - {cmd.Statut}\"); } // Affiche: // Commande #101 - Alice Tremblay (Montr√©al) - 150,00 $ - Livr√©e // Commande #102 - Alice Tremblay (Montr√©al) - 75,50 $ - En cours // Commande #103 - Bob Gagnon (Qu√©bec) - 200,00 $ - Livr√©e // Commande #104 - Charlie Roy (Montr√©al) - 95,00 $ - Livr√©e // Commande #105 - Alice Tremblay (Montr√©al) - 120,00 $ - En cours // ‚ö†Ô∏è Note: Diana n'appara√Æt pas (elle n'a aucune commande) // ========================================== // EXEMPLE 2 : Total des commandes par client // ========================================== var totauxParClient = commandes .Join(clients, cmd =\u003e cmd.ClientId, cli =\u003e cli.Id, (cmd, cli) =\u003e new { Client = cli.Nom, Montant = cmd.Montant }) .GroupBy(x =\u003e x.Client) .Select(groupe =\u003e new { Client = groupe.Key, NombreCommandes = groupe.Count(), TotalAchats = groupe.Sum(x =\u003e x.Montant) }) .OrderByDescending(x =\u003e x.TotalAchats); Console.WriteLine(\"\\nüí∞ Total des achats par client:\"); foreach (var total in totauxParClient) { Console.WriteLine($\"{total.Client}: {total.NombreCommandes} commande(s) - Total: {total.TotalAchats:C}\"); } // Affiche: // Alice Tremblay: 3 commande(s) - Total: 345,50 $ // Bob Gagnon: 1 commande(s) - Total: 200,00 $ // Charlie Roy: 1 commande(s) - Total: 95,00 $ 10.2 GroupJoin - Jointure de groupe Similaire √† un LEFT JOIN en SQL - inclut tous les √©l√©ments de la premi√®re collection m√™me s‚Äôils n‚Äôont pas de correspondance.\n// ========================================== // EXEMPLE : Tous les clients avec leurs commandes (m√™me ceux sans commande) // ========================================== var clientsAvecCommandes = clients.GroupJoin( commandes, client =\u003e client.Id, commande =\u003e commande.ClientId, (client, commandesClient) =\u003e new { NomClient = client.Nom, Ville = client.Ville, NombreCommandes = commandesClient.Count(), TotalAchats = commandesClient.Sum(c =\u003e (decimal?)c.Montant) ?? 0, Commandes = commandesClient.ToList() } ); Console.WriteLine(\"\\nüë• Tous les clients:\"); foreach (var client in clientsAvecCommandes) { Console.WriteLine($\"\\n{client.NomClient} ({client.Ville}):\"); Console.WriteLine($\" Nombre de commandes: {client.NombreCommandes}\"); Console.WriteLine($\" Total des achats: {client.TotalAchats:C}\"); if (client.Commandes.Any()) { Console.WriteLine(\" Commandes:\"); foreach (var cmd in client.Commandes) { Console.WriteLine($\" - #{cmd.Id}: {cmd.Montant:C} ({cmd.Statut})\"); } } else { Console.WriteLine(\" ‚ö†Ô∏è Aucune commande\"); } } // Affiche maintenant TOUS les clients, y compris Diana qui n'a aucune commande! 11. Op√©rations d‚ÄôEnsemble 11.1 Distinct - √âliminer les doublons // ========================================== // MISE EN CONTEXTE : Tags d'articles de blog // ========================================== List\u003cstring\u003e tagsArticle1 = new List\u003cstring\u003e { \"C#\", \"LINQ\", \"Programming\", \"Tutorial\" }; List\u003cstring\u003e tagsArticle2 = new List\u003cstring\u003e { \"C#\", \"ASP.NET\", \"Web\", \"Programming\" }; List\u003cstring\u003e tagsArticle3 = new List\u003cstring\u003e { \"Python\", \"Programming\", \"Data Science\" }; // Combiner tous les tags List\u003cstring\u003e tousTags = new List\u003cstring\u003e(); tousTags.AddRange(tagsArticle1); tousTags.AddRange(tagsArticle2); tousTags.AddRange(tagsArticle3); Console.WriteLine(\"Tous les tags (avec doublons):\"); Console.WriteLine(string.Join(\", \", tousTags)); // C#, LINQ, Programming, Tutorial, C#, ASP.NET, Web, Programming, Python, Programming, Data Science // Obtenir les tags uniques var tagsUniques = tousTags.Distinct(); Console.WriteLine(\"\\nTags uniques:\"); Console.WriteLine(string.Join(\", \", tagsUniques)); // C#, LINQ, Programming, Tutorial, ASP.NET, Web, Python, Data Science // ========================================== // Distinct avec objets personnalis√©s // ========================================== public class Ville { public string Nom { get; set; } public string Province { get; set; } } List\u003cVille\u003e villes = new List\u003cVille\u003e { new Ville { Nom = \"Montr√©al\", Province = \"Qu√©bec\" }, new Ville { Nom = \"Qu√©bec\", Province = \"Qu√©bec\" }, new Ville { Nom = \"Montr√©al\", Province = \"Qu√©bec\" }, // Doublon! new Ville { Nom = \"Toronto\", Province = \"Ontario\" } }; // Pour Distinct sur objets, il faut impl√©menter IEquatable ou utiliser DistinctBy var villesUniques = villes.DistinctBy(v =\u003e v.Nom); Console.WriteLine(\"\\nVilles uniques:\"); foreach (var ville in villesUniques) { Console.WriteLine($\"{ville.Nom}, {ville.Province}\"); } 11.2 Union - Union de deux collections Combine deux collections et √©limine les doublons.\nList\u003cint\u003e liste1 = new List\u003cint\u003e { 1, 2, 3, 4, 5 }; List\u003cint\u003e liste2 = new List\u003cint\u003e { 4, 5, 6, 7, 8 }; var union = liste1.Union(liste2); Console.WriteLine(\"Union:\"); Console.WriteLine(string.Join(\", \", union)); // 1, 2, 3, 4, 5, 6, 7, 8 11.3 Intersect - Intersection Retourne uniquement les √©l√©ments pr√©sents dans LES DEUX collections.\nvar intersection = liste1.Intersect(liste2); Console.WriteLine(\"Intersection:\"); Console.WriteLine(string.Join(\", \", intersection)); // 4, 5 11.4 Except - Diff√©rence Retourne les √©l√©ments de la premi√®re collection qui ne sont PAS dans la deuxi√®me.\nvar difference = liste1.Except(liste2); Console.WriteLine(\"Diff√©rence (liste1 - liste2):\"); Console.WriteLine(string.Join(\", \", difference)); // 1, 2, 3 11.5 Exemple Pratique : Gestion d‚Äôabonnements // ========================================== // MISE EN CONTEXTE : Abonn√©s √† des newsletters // ========================================== List\u003cstring\u003e abonnesNewsletter = new List\u003cstring\u003e { \"alice@email.com\", \"bob@email.com\", \"charlie@email.com\", \"diana@email.com\" }; List\u003cstring\u003e abonnesBlog = new List\u003cstring\u003e { \"bob@email.com\", \"charlie@email.com\", \"eve@email.com\", \"frank@email.com\" }; // Qui est abonn√© aux DEUX? var abonnesDeuxServices = abonnesNewsletter.Intersect(abonnesBlog); Console.WriteLine(\"üìß Abonn√©s aux deux services:\"); foreach (var email in abonnesDeuxServices) { Console.WriteLine($\" - {email}\"); } // bob@email.com // charlie@email.com // Qui est abonn√© √† la newsletter mais PAS au blog? var uniquementNewsletter = abonnesNewsletter.Except(abonnesBlog); Console.WriteLine(\"\\nüì∞ Uniquement √† la newsletter:\"); foreach (var email in uniquementNewsletter) { Console.WriteLine($\" - {email}\"); } // alice@email.com // diana@email.com // Tous les abonn√©s (peu importe le service) var tousLesAbonnes = abonnesNewsletter.Union(abonnesBlog); Console.WriteLine($\"\\nüë• Total d'abonn√©s uniques: {tousLesAbonnes.Count()}\"); // 6 12. Op√©rations de Quantification Ces op√©rations retournent un bool√©en (true/false).\n12.1 Any - Au moins un √©l√©ment satisfait la condition // ========================================== // MISE EN CONTEXTE : Validation de stock // ========================================== List\u003cProduit\u003e produits = new List\u003cProduit\u003e { new Produit { Nom = \"Laptop\", Stock = 5 }, new Produit { Nom = \"Souris\", Stock = 50 }, new Produit { Nom = \"Clavier\", Stock = 0 }, // Rupture de stock! new Produit { Nom = \"√âcran\", Stock = 10 } }; // Y a-t-il au moins un produit en rupture de stock? bool ruptureStock = produits.Any(p =\u003e p.Stock == 0); Console.WriteLine($\"Rupture de stock: {ruptureStock}\"); // True // Y a-t-il au moins un produit avec beaucoup de stock? bool stockAbondant = produits.Any(p =\u003e p.Stock \u003e 30); Console.WriteLine($\"Stock abondant: {stockAbondant}\"); // True // Y a-t-il des produits? bool existeProduits = produits.Any(); Console.WriteLine($\"Existe des produits: {existeProduits}\"); // True // ========================================== // EXEMPLE PRATIQUE : Validation de formulaire // ========================================== public class Formulaire { public string Nom { get; set; } public string Email { get; set; } public string Telephone { get; set; } } bool FormulaireEstValide(Formulaire form) { // Au moins un champ doit √™tre vide pour que le formulaire soit invalide bool champVide = new[] { form.Nom, form.Email, form.Telephone } .Any(champ =\u003e string.IsNullOrWhiteSpace(champ)); return !champVide; } 12.2 All - Tous les √©l√©ments satisfont la condition // Tous les produits ont-ils un stock positif? bool tousEnStock = produits.All(p =\u003e p.Stock \u003e 0); Console.WriteLine($\"Tous en stock: {tousEnStock}\"); // False (√† cause du Clavier) // Tous les produits ont-ils un stock \u003e= 0? bool stockValide = produits.All(p =\u003e p.Stock \u003e= 0); Console.WriteLine($\"Stock valide: {stockValide}\"); // True // ========================================== // EXEMPLE : Validation d'√¢ge pour un groupe // ========================================== List\u003cEtudiant\u003e groupe = new List\u003cEtudiant\u003e { new Etudiant { Nom = \"Alice\", Age = 20 }, new Etudiant { Nom = \"Bob\", Age = 22 }, new Etudiant { Nom = \"Charlie\", Age = 21 } }; // Tous les √©tudiants sont-ils majeurs? bool tousMajeurs = groupe.All(e =\u003e e.Age \u003e= 18); Console.WriteLine($\"Tous majeurs: {tousMajeurs}\"); // True // Tous les √©tudiants ont-ils plus de 21 ans? bool tousPlus21 = groupe.All(e =\u003e e.Age \u003e 21); Console.WriteLine($\"Tous plus de 21 ans: {tousPlus21}\"); // False 12.3 Contains - V√©rifie si un √©l√©ment existe List\u003cstring\u003e fruits = new List\u003cstring\u003e { \"Pomme\", \"Banane\", \"Orange\", \"Kiwi\" }; bool aPomme = fruits.Contains(\"Pomme\"); Console.WriteLine($\"Contient Pomme: {aPomme}\"); // True bool aRaisin = fruits.Contains(\"Raisin\"); Console.WriteLine($\"Contient Raisin: {aRaisin}\"); // False // ========================================== // EXEMPLE : V√©rifier si un utilisateur existe // ========================================== List\u003cstring\u003e utilisateursAutorises = new List\u003cstring\u003e { \"admin@site.com\", \"moderateur@site.com\", \"editeur@site.com\" }; string emailUtilisateur = \"admin@site.com\"; bool estAutorise = utilisateursAutorises.Contains(emailUtilisateur); if (estAutorise) { Console.WriteLine(\"‚úÖ Acc√®s autoris√©\"); } else { Console.WriteLine(\"‚ùå Acc√®s refus√©\"); } 13. Op√©rations de Partition 13.1 Take - Prendre les N premiers √©l√©ments // ========================================== // MISE EN CONTEXTE : Affichage de r√©sultats pagin√©s // ========================================== List\u003cstring\u003e resultatsRecherche = new List\u003cstring\u003e { \"R√©sultat 1\", \"R√©sultat 2\", \"R√©sultat 3\", \"R√©sultat 4\", \"R√©sultat 5\", \"R√©sultat 6\", \"R√©sultat 7\", \"R√©sultat 8\", \"R√©sultat 9\", \"R√©sultat 10\" }; // Afficher les 3 premiers r√©sultats var top3 = resultatsRecherche.Take(3); Console.WriteLine(\"Top 3 r√©sultats:\"); foreach (var resultat in top3) { Console.WriteLine($\" - {resultat}\"); } // R√©sultat 1 // R√©sultat 2 // R√©sultat 3 // ========================================== // EXEMPLE : Top 5 des meilleurs √©tudiants // ========================================== var top5Etudiants = etudiants .OrderByDescending(e =\u003e e.Moyenne) .Take(5) .Select(e =\u003e new { e.Nom, e.Moyenne }); Console.WriteLine(\"\\nüèÜ Top 5 des √©tudiants:\"); int rang = 1; foreach (var etudiant in top5Etudiants) { Console.WriteLine($\"{rang}. {etudiant.Nom}: {etudiant.Moyenne}\"); rang++; } 13.2 Skip - Ignorer les N premiers √©l√©ments // Ignorer les 3 premiers r√©sultats var apres3 = resultatsRecherche.Skip(3); Console.WriteLine(\"Apr√®s les 3 premiers:\"); foreach (var resultat in apres3) { Console.WriteLine($\" - {resultat}\"); } // R√©sultat 4 // R√©sultat 5 // ... // R√©sultat 10 13.3 Pagination avec Take et Skip // ========================================== // EXEMPLE PRATIQUE : Pagination // ========================================== int pageSize = 3; // 3 r√©sultats par page int pageNumber = 2; // Page 2 var resultatsPagines = resultatsRecherche .Skip((pageNumber - 1) * pageSize) // Ignorer les pages pr√©c√©dentes .Take(pageSize); // Prendre uniquement cette page Console.WriteLine($\"Page {pageNumber}:\"); foreach (var resultat in resultatsPagines) { Console.WriteLine($\" - {resultat}\"); } // Page 2: // - R√©sultat 4 // - R√©sultat 5 // - R√©sultat 6 // ========================================== // Fonction de pagination r√©utilisable // ========================================== public static IEnumerable\u003cT\u003e ObtenirPage\u003cT\u003e(IEnumerable\u003cT\u003e source, int numeroPage, int taillePage) { return source .Skip((numeroPage - 1) * taillePage) .Take(taillePage); } // Utilisation var page1 = ObtenirPage(resultatsRecherche, 1, 3); var page2 = ObtenirPage(resultatsRecherche, 2, 3); var page3 = ObtenirPage(resultatsRecherche, 3, 3); 13.4 TakeWhile et SkipWhile - Selon une condition List\u003cint\u003e nombres = new List\u003cint\u003e { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // Prendre tant que la condition est vraie var inferieursA6 = nombres.TakeWhile(n =\u003e n \u003c 6); Console.WriteLine(\"TakeWhile (\u003c 6):\"); Console.WriteLine(string.Join(\", \", inferieursA6)); // 1, 2, 3, 4, 5 // Ignorer tant que la condition est vraie var depuis6 = nombres.SkipWhile(n =\u003e n \u003c 6); Console.WriteLine(\"SkipWhile (\u003c 6):\"); Console.WriteLine(string.Join(\", \", depuis6)); // 6, 7, 8, 9, 10 14. LINQ avec Objets Complexes 14.1 Exemple Complet : Syst√®me Universitaire public class Universite { public string Nom { get; set; } public List\u003cDepartement\u003e Departements { get; set; } } public class Departement { public string Nom { get; set; } public List\u003cProfesseur\u003e Professeurs { get; set; } public List\u003cCours\u003e Cours { get; set; } } public class Professeur { public string Nom { get; set; } public string Specialite { get; set; } public int AnneesExperience { get; set; } } public class Cours { public string Code { get; set; } public string Titre { get; set; } public int Credits { get; set; } public string ProfesseurNom { get; set; } public List\u003cEtudiant\u003e EtudiantsInscrits { get; set; } } // Donn√©es var universite = new Universite { Nom = \"Universit√© du Qu√©bec\", Departements = new List\u003cDepartement\u003e { new Departement { Nom = \"Informatique\", Professeurs = new List\u003cProfesseur\u003e { new Professeur { Nom = \"Dr. Smith\", Specialite = \"Intelligence Artificielle\", AnneesExperience = 15 }, new Professeur { Nom = \"Dr. Johnson\", Specialite = \"Bases de donn√©es\", AnneesExperience = 10 } }, Cours = new List\u003cCours\u003e { new Cours { Code = \"INF101\", Titre = \"Programmation I\", Credits = 3, ProfesseurNom = \"Dr. Smith\", EtudiantsInscrits = new List\u003cEtudiant\u003e { new Etudiant { Nom = \"Alice\", Moyenne = 85 }, new Etudiant { Nom = \"Bob\", Moyenne = 78 } } }, new Cours { Code = \"INF202\", Titre = \"Structures de donn√©es\", Credits = 4, ProfesseurNom = \"Dr. Johnson\", EtudiantsInscrits = new List\u003cEtudiant\u003e { new Etudiant { Nom = \"Charlie\", Moyenne = 90 }, new Etudiant { Nom = \"Diana\", Moyenne = 82 } } } } }, new Departement { Nom = \"Math√©matiques\", Professeurs = new List\u003cProfesseur\u003e { new Professeur { Nom = \"Dr. Williams\", Specialite = \"Alg√®bre\", AnneesExperience = 20 } }, Cours = new List\u003cCours\u003e { new Cours { Code = \"MAT101\", Titre = \"Calcul I\", Credits = 4, ProfesseurNom = \"Dr. Williams\", EtudiantsInscrits = new List\u003cEtudiant\u003e { new Etudiant { Nom = \"Eve\", Moyenne = 88 } } } } } } }; // ========================================== // REQU√äTE 1 : Tous les professeurs de l'universit√© // ========================================== var tousProfesseurs = universite.Departements .SelectMany(d =\u003e d.Professeurs) .Select(p =\u003e new { p.Nom, p.Specialite, p.AnneesExperience }); Console.WriteLine(\"üë®‚Äçüè´ Tous les professeurs:\"); foreach (var prof in tousProfesseurs) { Console.WriteLine($\" - {prof.Nom} ({prof.Specialite}) - {prof.AnneesExperience} ans\"); } // ========================================== // REQU√äTE 2 : Tous les cours avec plus de 3 cr√©dits // ========================================== var coursAvances = universite.Departements .SelectMany(d =\u003e d.Cours) .Where(c =\u003e c.Credits \u003e 3) .Select(c =\u003e new { c.Code, c.Titre, c.Credits }); Console.WriteLine(\"\\nüìö Cours avanc√©s (\u003e3 cr√©dits):\"); foreach (var cours in coursAvances) { Console.WriteLine($\" - {cours.Code}: {cours.Titre} ({cours.Credits} cr√©dits)\"); } // ========================================== // REQU√äTE 3 : Nombre total d'√©tudiants dans l'universit√© // ========================================== int totalEtudiants = universite.Departements .SelectMany(d =\u003e d.Cours) .SelectMany(c =\u003e c.EtudiantsInscrits) .Distinct() // Au cas o√π un √©tudiant est dans plusieurs cours .Count(); Console.WriteLine($\"\\nüë• Total d'√©tudiants: {totalEtudiants}\"); // ========================================== // REQU√äTE 4 : Moyenne g√©n√©rale de l'universit√© // ========================================== double moyenneGenerale = universite.Departements .SelectMany(d =\u003e d.Cours) .SelectMany(c =\u003e c.EtudiantsInscrits) .Average(e =\u003e e.Moyenne); Console.WriteLine($\"üìä Moyenne g√©n√©rale: {moyenneGenerale:F2}\"); // ========================================== // REQU√äTE 5 : Statistiques par d√©partement // ========================================== var statsParDepartement = universite.Departements .Select(d =\u003e new { Departement = d.Nom, NombreProfesseurs = d.Professeurs.Count, NombreCours = d.Cours.Count, TotalEtudiants = d.Cours.SelectMany(c =\u003e c.EtudiantsInscrits).Count(), MoyenneDepartement = d.Cours.SelectMany(c =\u003e c.EtudiantsInscrits).Average(e =\u003e e.Moyenne) }); Console.WriteLine(\"\\nüìà Statistiques par d√©partement:\"); foreach (var stat in statsParDepartement) { Console.WriteLine($\"{stat.Departement}:\"); Console.WriteLine($\" Professeurs: {stat.NombreProfesseurs}\"); Console.WriteLine($\" Cours: {stat.NombreCours}\"); Console.WriteLine($\" √âtudiants: {stat.TotalEtudiants}\"); Console.WriteLine($\" Moyenne: {stat.MoyenneDepartement:F2}\"); } // ========================================== // REQU√äTE 6 : Cours les plus populaires // ========================================== var coursPopulaires = universite.Departements .SelectMany(d =\u003e d.Cours) .OrderByDescending(c =\u003e c.EtudiantsInscrits.Count) .Take(3) .Select(c =\u003e new { c.Code, c.Titre, NombreEtudiants = c.EtudiantsInscrits.Count }); Console.WriteLine(\"\\nüî• Cours les plus populaires:\"); foreach (var cours in coursPopulaires) { Console.WriteLine($\" - {cours.Code}: {cours.Titre} ({cours.NombreEtudiants} √©tudiants)\"); } 15. Cas Pratiques R√©els 15.1 Analyse de Logs d‚ÄôApplication public class LogEntry { public DateTime Timestamp { get; set; } public string Level { get; set; } // INFO, WARNING, ERROR public string Message { get; set; } public string Module { get; set; } } List\u003cLogEntry\u003e logs = new List\u003cLogEntry\u003e { new LogEntry { Timestamp = DateTime.Now.AddHours(-5), Level = \"INFO\", Message = \"Application started\", Module = \"Startup\" }, new LogEntry { Timestamp = DateTime.Now.AddHours(-4), Level = \"ERROR\", Message = \"Database connection failed\", Module = \"Database\" }, new LogEntry { Timestamp = DateTime.Now.AddHours(-3), Level = \"WARNING\", Message = \"High memory usage\", Module = \"Performance\" }, new LogEntry { Timestamp = DateTime.Now.AddHours(-2), Level = \"ERROR\", Message = \"Null reference exception\", Module = \"UserService\" }, new LogEntry { Timestamp = DateTime.Now.AddHours(-1), Level = \"INFO\", Message = \"User logged in\", Module = \"Auth\" }, new LogEntry { Timestamp = DateTime.Now, Level = \"ERROR\", Message = \"Payment processing failed\", Module = \"Payment\" } }; // ========================================== // Rapport d'erreurs // ========================================== var erreurs = logs .Where(log =\u003e log.Level == \"ERROR\") .OrderByDescending(log =\u003e log.Timestamp) .Select(log =\u003e new { Heure = log.Timestamp.ToString(\"HH:mm\"), log.Module, log.Message }); Console.WriteLine(\"üî¥ Erreurs r√©centes:\"); foreach (var erreur in erreurs) { Console.WriteLine($\"[{erreur.Heure}] {erreur.Module}: {erreur.Message}\"); } // ========================================== // Statistiques par module // ========================================== var statsParModule = logs .GroupBy(log =\u003e log.Module) .Select(groupe =\u003e new { Module = groupe.Key, Total = groupe.Count(), Erreurs = groupe.Count(log =\u003e log.Level == \"ERROR\"), Warnings = groupe.Count(log =\u003e log.Level == \"WARNING\") }) .OrderByDescending(stat =\u003e stat.Erreurs); Console.WriteLine(\"\\nüìä Statistiques par module:\"); foreach (var stat in statsParModule) { Console.WriteLine($\"{stat.Module}: {stat.Total} logs (dont {stat.Erreurs} erreurs)\"); } // ========================================== // Alertes critiques (plusieurs erreurs dans un module) // ========================================== var modulesCritiques = logs .Where(log =\u003e log.Level == \"ERROR\") .GroupBy(log =\u003e log.Module) .Where(groupe =\u003e groupe.Count() \u003e= 2) .Select(groupe =\u003e groupe.Key); if (modulesCritiques.Any()) { Console.WriteLine(\"\\n‚ö†Ô∏è ALERTE: Modules avec erreurs multiples:\"); foreach (var module in modulesCritiques) { Console.WriteLine($\" - {module}\"); } } 15.2 Analyse de Donn√©es de Ventes public class Transaction { public int Id { get; set; } public DateTime Date { get; set; } public string Produit { get; set; } public decimal Prix { get; set; } public int Quantite { get; set; } public string Categorie { get; set; } public string Region { get; set; } } List\u003cTransaction\u003e transactions = new List\u003cTransaction\u003e { new Transaction { Id = 1, Date = new DateTime(2024, 1, 15), Produit = \"Laptop\", Prix = 1200, Quantite = 2, Categorie = \"√âlectronique\", Region = \"Qu√©bec\" }, new Transaction { Id = 2, Date = new DateTime(2024, 1, 16), Produit = \"Souris\", Prix = 25, Quantite = 10, Categorie = \"√âlectronique\", Region = \"Montr√©al\" }, new Transaction { Id = 3, Date = new DateTime(2024, 1, 17), Produit = \"Bureau\", Prix = 400, Quantite = 1, Categorie = \"Mobilier\", Region = \"Qu√©bec\" }, new Transaction { Id = 4, Date = new DateTime(2024, 1, 18), Produit = \"Chaise\", Prix = 150, Quantite = 4, Categorie = \"Mobilier\", Region = \"Laval\" }, new Transaction { Id = 5, Date = new DateTime(2024, 1, 19), Produit = \"Clavier\", Prix = 80, Quantite = 5, Categorie = \"√âlectronique\", Region = \"Montr√©al\" } }; // ========================================== // Chiffre d'affaires total // ========================================== decimal chiffreAffaires = transactions.Sum(t =\u003e t.Prix * t.Quantite); Console.WriteLine($\"üí∞ Chiffre d'affaires total: {chiffreAffaires:C}\"); // ========================================== // Top 3 des produits les plus vendus // ========================================== var top3Produits = transactions .GroupBy(t =\u003e t.Produit) .Select(groupe =\u003e new { Produit = groupe.Key, QuantiteTotale = groupe.Sum(t =\u003e t.Quantite), Revenu = groupe.Sum(t =\u003e t.Prix * t.Quantite) }) .OrderByDescending(x =\u003e x.Revenu) .Take(3); Console.WriteLine(\"\\nüèÜ Top 3 produits par revenu:\"); foreach (var produit in top3Produits) { Console.WriteLine($\" {produit.Produit}: {produit.QuantiteTotale} unit√©s - {produit.Revenu:C}\"); } // ========================================== // Performance par r√©gion // ========================================== var performanceRegions = transactions .GroupBy(t =\u003e t.Region) .Select(groupe =\u003e new { Region = groupe.Key, NombreTransactions = groupe.Count(), RevenuTotal = groupe.Sum(t =\u003e t.Prix * t.Quantite), PanierMoyen = groupe.Average(t =\u003e t.Prix * t.Quantite) }) .OrderByDescending(x =\u003e x.RevenuTotal); Console.WriteLine(\"\\nüìç Performance par r√©gion:\"); foreach (var region in performanceRegions) { Console.WriteLine($\"{region.Region}:\"); Console.WriteLine($\" Transactions: {region.NombreTransactions}\"); Console.WriteLine($\" Revenu: {region.RevenuTotal:C}\"); Console.WriteLine($\" Panier moyen: {region.PanierMoyen:C}\"); } // ========================================== // Tendance quotidienne // ========================================== var ventesParJour = transactions .GroupBy(t =\u003e t.Date.Date) .Select(groupe =\u003e new { Date = groupe.Key.ToString(\"dd/MM/yyyy\"), Revenu = groupe.Sum(t =\u003e t.Prix * t.Quantite) }) .OrderBy(x =\u003e x.Date); Console.WriteLine(\"\\nüìà Ventes quotidiennes:\"); foreach (var jour in ventesParJour) { Console.WriteLine($\" {jour.Date}: {jour.Revenu:C}\"); } 16. Bonnes Pratiques et Pi√®ges 16.1 √âviter l‚ÄôEx√©cution Multiple // ‚ùå MAUVAIS - La requ√™te est ex√©cut√©e 3 fois! var requete = produits.Where(p =\u003e p.Prix \u003e 100); int count = requete.Count(); // Ex√©cution 1 decimal total = requete.Sum(p =\u003e p.Prix); // Ex√©cution 2 var liste = requete.ToList(); // Ex√©cution 3 // ‚úÖ BON - Ex√©cuter une seule fois avec ToList() var resultats = produits.Where(p =\u003e p.Prix \u003e 100).ToList(); int count = resultats.Count; // Pas d'ex√©cution (d√©j√† en m√©moire) decimal total = resultats.Sum(p =\u003e p.Prix); // Pas d'ex√©cution 16.2 Attention aux Null References // ‚ùå RISQUE - NullReferenceException si un produit est null var produitsChers = produits.Where(p =\u003e p.Prix \u003e 100); // ‚úÖ MIEUX - Filtrer les nulls d'abord var produitsChers = produits .Where(p =\u003e p != null) .Where(p =\u003e p.Prix \u003e 100); // ‚úÖ OU utiliser l'op√©rateur ?. var prixMax = produits .Where(p =\u003e p != null) .Max(p =\u003e p.Prix); 16.3 Performance : Where avant Select // ‚ùå MOINS EFFICACE - Transforme tout puis filtre var resultats = produits .Select(p =\u003e new { p.Nom, p.Prix }) .Where(x =\u003e x.Prix \u003e 100); // ‚úÖ PLUS EFFICACE - Filtre d'abord, puis transforme var resultats = produits .Where(p =\u003e p.Prix \u003e 100) .Select(p =\u003e new { p.Nom, p.Prix }); 16.4 Utiliser Any() plut√¥t que Count() // ‚ùå MOINS EFFICACE - Compte tous les √©l√©ments if (produits.Count() \u003e 0) { // ... } // ‚úÖ PLUS EFFICACE - S'arr√™te d√®s qu'un √©l√©ment est trouv√© if (produits.Any()) { // ... } // ‚ùå MOINS EFFICACE if (produits.Where(p =\u003e p.Prix \u003e 1000).Count() \u003e 0) { // ... } // ‚úÖ PLUS EFFICACE if (produits.Any(p =\u003e p.Prix \u003e 1000)) { // ... } 16.5 √âviter les Requ√™tes Complexes dans les Boucles // ‚ùå TR√àS MAUVAIS - Requ√™te LINQ dans une boucle! foreach (var categorie in categories) { var count = produits.Count(p =\u003e p.Categorie == categorie); Console.WriteLine($\"{categorie}: {count}\"); } // ‚úÖ BON - Une seule requ√™te avec GroupBy var comptesParCategorie = produits .GroupBy(p =\u003e p.Categorie) .Select(g =\u003e new { Categorie = g.Key, Count = g.Count() }); foreach (var groupe in comptesParCategorie) { Console.WriteLine($\"{groupe.Categorie}: {groupe.Count}\"); } 16.6 Pr√©f√©rer FirstOrDefault() √† First() // ‚ùå RISQUE - L√®ve une exception si aucun √©l√©ment trouv√© var produit = produits.First(p =\u003e p.Id == 999); // ‚úÖ S√âCURITAIRE - Retourne null si aucun √©l√©ment trouv√© var produit = produits.FirstOrDefault(p =\u003e p.Id == 999); if (produit != null) { Console.WriteLine(produit.Nom); } else { Console.WriteLine(\"Produit introuvable\"); } 16.7 Ordre des Op√©rations // L'ordre compte pour la performance! // ‚úÖ BON - Filtre puis trie (trie moins d'√©l√©ments) var resultats = produits .Where(p =\u003e p.Prix \u003e 100) // R√©duit la collection .OrderBy(p =\u003e p.Nom); // Trie une petite collection // ‚ùå MOINS BON - Trie puis filtre (trie inutilement tout) var resultats = produits .OrderBy(p =\u003e p.Nom) // Trie TOUT .Where(p =\u003e p.Prix \u003e 100); // Puis filtre üìö R√©sum√© des Op√©rations LINQ Cat√©gorie Op√©rations Description Filtrage Where, OfType S√©lectionner des √©l√©ments selon une condition Projection Select, SelectMany Transformer les √©l√©ments Tri OrderBy, OrderByDescending, ThenBy, Reverse Trier les √©l√©ments Agr√©gation Count, Sum, Average, Min, Max, Aggregate Calculer des valeurs Regroupement GroupBy Regrouper par cl√© Jointure Join, GroupJoin Combiner deux collections Ensemble Distinct, Union, Intersect, Except Op√©rations d‚Äôensemble Quantification Any, All, Contains Tests bool√©ens Partition Take, Skip, TakeWhile, SkipWhile Pagination et d√©coupage √âl√©ment First, FirstOrDefault, Last, Single Obtenir un √©l√©ment Conversion ToList, ToArray, ToDictionary Convertir en collection üéØ Checklist de Ma√Ætrise LINQ Je comprends la diff√©rence entre ex√©cution diff√©r√©e et imm√©diate Je sais utiliser Where() pour filtrer Je sais utiliser Select() pour projeter/transformer Je ma√Ætrise OrderBy() et ThenBy() pour trier Je sais utiliser GroupBy() pour regrouper Je comprends la diff√©rence entre First() et FirstOrDefault() Je sais utiliser Any() et All() pour tester Je ma√Ætrise Sum(), Average(), Min(), Max() Je sais utiliser Take() et Skip() pour paginer Je comprends Join() et GroupJoin() Je sais √©viter les pi√®ges de performance Je peux √©crire des requ√™tes LINQ complexes üîó Ressources Suppl√©mentaires Documentation Microsoft LINQ : https://docs.microsoft.com/fr-fr/dotnet/csharp/linq/ LINQ samples : https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b",
    "description": "üìò LINQ en C# Language Integrated Query üìã Table des mati√®res Introduction √† LINQ Pourquoi utiliser LINQ ? Les Bases de LINQ Les Deux Syntaxes LINQ Op√©rations de Filtrage Op√©rations de Projection Op√©rations de Tri Op√©rations d‚ÄôAgr√©gation Op√©rations de Regroupement Op√©rations de Jointure Op√©rations d‚ÄôEnsemble Op√©rations de Quantification Op√©rations de Partition LINQ avec Objets Complexes Cas Pratiques R√©els Bonnes Pratiques et Pi√®ges 1. Introduction √† LINQ 1.1 Qu‚Äôest-ce que LINQ ? LINQ (Language Integrated Query) est une fonctionnalit√© de C# qui permet d‚Äôinterroger des collections de donn√©es directement dans le code, avec une syntaxe √©l√©gante et lisible.",
    "tags": [],
    "title": "LINQ",
    "uri": "/420-413/linq/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "üìù EXERCICE DE PR√âPARATION √Ä L‚ÄôEXAMEN Syst√®me de Gestion d‚Äôune Biblioth√®que Municipale POO Avanc√©e + LINQ üéØ CONTEXTE Vous travaillez pour la Ville de Montr√©al et devez cr√©er un syst√®me de gestion pour la biblioth√®que municipale. Le syst√®me doit g√©rer diff√©rents types de documents (livres, magazines, DVD), les membres, les emprunts et g√©n√©rer des statistiques.\nTechnologies: Application Console C# (.NET), POO avanc√©e (h√©ritage, interfaces, polymorphisme), LINQ obligatoire pour toutes les requ√™tes\nüìã PARTIE 1: MOD√àLE DE DONN√âES 1.1 √ânum√©rations √† cr√©er Enum GenreLivre\nRoman ScienceFiction Policier Biographie Histoire Science Jeunesse BD Enum StatutEmprunt\nEnCours Retourne EnRetard Perdu Enum TypeMembre\nRegulier Etudiant Senior 1.2 Interface IEmpruntable Cr√©ez une interface qui d√©finit le comportement des √©l√©ments empruntables.\nInterface IEmpruntable\nM√©thodes:\nbool PeutEtreEmprunte() - Retourne true si l‚Äôitem peut √™tre emprunt√© bool Emprunter() - Tente d‚Äôemprunter, retourne true si succ√®s void Retourner() - Retourne l‚Äôitem int ObtenirDureeEmprunt(TypeMembre typeMembre) - Retourne la dur√©e d‚Äôemprunt selon le type de membre 1.3 Classe abstraite Document Cr√©ez une classe abstraite qui servira de base pour tous les types de documents.\nClasse abstraite Document\nChamp statique:\nprivate static int prochainId = 1 - Compteur pour g√©n√©rer des ID uniques Propri√©t√©s:\nint Id - Identifiant unique auto-g√©n√©r√© string Titre - Titre du document int AnneePublication - Ann√©e de publication bool EstDisponible - Disponibilit√© Propri√©t√©s calcul√©es:\nint Age - Retourne l‚Äô√¢ge du document (ann√©e actuelle - ann√©e publication) bool EstRecent - Retourne true si publi√© dans les 5 derni√®res ann√©es Propri√©t√©s abstraites √† impl√©menter dans les classes d√©riv√©es:\nabstract string TypeDocument - Retourne le type de document (‚ÄúLivre‚Äù, ‚ÄúMagazine‚Äù, ‚ÄúDVD‚Äù) Constructeur:\nprotected Document() { Id = prochainId++; EstDisponible = true; } M√©thodes virtuelles:\nvirtual string ObtenirDescription() - Retourne ‚Äú{Titre} ({AnneePublication})‚Äù virtual void AfficherInfos() - Affiche les informations de base du document M√©thodes abstraites:\nabstract int ObtenirDureeEmpruntDefaut() - Dur√©e d‚Äôemprunt par d√©faut selon le type de document Override obligatoire:\noverride string ToString() - Format: ‚ÄúTypeDocument: Titre‚Äù 1.4 Classe Livre (h√©rite de Document et impl√©mente IEmpruntable) Classe Livre : Document, IEmpruntable\nPropri√©t√©s sp√©cifiques:\nstring Auteur - Nom de l‚Äôauteur string ISBN - Num√©ro ISBN GenreLivre Genre - Genre du livre int NombrePages - Nombre de pages int NombreExemplaires - Nombre total d‚Äôexemplaires int NombreDisponibles - Nombre d‚Äôexemplaires disponibles Impl√©mentation propri√©t√© abstraite:\noverride string TypeDocument - Retourne ‚ÄúLivre‚Äù Override m√©thodes virtuelles:\noverride string ObtenirDescription() - Retourne ‚Äú{Titre} par {Auteur} ({AnneePublication})‚Äù override void AfficherInfos() - Affiche toutes les infos du livre incluant auteur, genre, pages Impl√©mentation m√©thode abstraite:\noverride int ObtenirDureeEmpruntDefaut() - Retourne 14 jours Impl√©mentation interface IEmpruntable:\nbool PeutEtreEmprunte() - Retourne true si NombreDisponibles \u003e 0 bool Emprunter() - Diminue NombreDisponibles si possible, met √† jour EstDisponible void Retourner() - Augmente NombreDisponibles, met √† jour EstDisponible int ObtenirDureeEmprunt(TypeMembre typeMembre) - Retourne dur√©e selon type: Regulier: 14 jours Etudiant: 21 jours Senior: 21 jours Constructeur:\npublic Livre() : base() { NombreExemplaires = 1; NombreDisponibles = 1; } 1.5 Classe Magazine (h√©rite de Document et impl√©mente IEmpruntable) Classe Magazine : Document, IEmpruntable\nPropri√©t√©s sp√©cifiques:\nint NumeroEdition - Num√©ro de l‚Äô√©dition string Editeur - Nom de l‚Äô√©diteur int Periodicite - P√©riodicit√© en jours (7 pour hebdo, 30 pour mensuel) Impl√©mentation propri√©t√© abstraite:\noverride string TypeDocument - Retourne ‚ÄúMagazine‚Äù Override m√©thodes virtuelles:\noverride string ObtenirDescription() - Retourne ‚Äú{Titre} #{NumeroEdition} - {Editeur}‚Äù override void AfficherInfos() - Affiche infos du magazine incluant √©diteur, num√©ro Impl√©mentation m√©thode abstraite:\noverride int ObtenirDureeEmpruntDefaut() - Retourne 7 jours (magazines = emprunts courts) Impl√©mentation interface IEmpruntable:\nbool PeutEtreEmprunte() - Retourne EstDisponible bool Emprunter() - Met EstDisponible √† false void Retourner() - Met EstDisponible √† true int ObtenirDureeEmprunt(TypeMembre typeMembre) - Retourne toujours 7 jours (m√™me dur√©e pour tous) 1.6 Classe Membre Propri√©t√©s:\nint Id - Identifiant unique auto-g√©n√©r√© string Nom - Nom complet string NumeroMembre - Format: MEM-XXXXX string Courriel - Adresse courriel TypeMembre Type - Type de membre DateTime DateInscription - Date d‚Äôinscription List\u003cEmprunt\u003e Emprunts - Liste de tous les emprunts Champ statique:\nprivate static int prochainId = 1; Propri√©t√©s calcul√©es:\nint NombreEmpruntsActuels - Compte les emprunts avec Statut == EnCours int NombreEmpruntsTotal - Total d‚Äôemprunts dans l‚Äôhistorique bool PeutEmprunter - true si NombreEmpruntsActuels \u003c LimiteEmprunts int LimiteEmprunts - Selon le type: Regulier: 5 Etudiant: 10 Senior: 8 int JoursMembre - Jours depuis l‚Äôinscription Constructeur:\npublic Membre() { Id = prochainId++; Emprunts = new List\u003cEmprunt\u003e(); DateInscription = DateTime.Now; } M√©thodes:\nvoid AjouterEmprunt(Emprunt emprunt) - Ajoute un emprunt override string ToString() - Format: ‚ÄúNumeroMembre - Nom (Type)‚Äù 1.7 Classe Emprunt Propri√©t√©s:\nint Id { get; private set; } - ID unique auto-g√©n√©r√© IEmpruntable Document { get; set; } - Le document emprunt√© (interface!) Membre Membre { get; set; } - Le membre qui emprunte DateTime DateEmprunt { get; set; } - Date de l‚Äôemprunt DateTime DateRetourPrevue { get; set; } - Date de retour pr√©vue DateTime? DateRetourReelle { get; set; } - Date de retour effective (nullable) StatutEmprunt Statut { get; set; } - Statut actuel Champ statique:\nprivate static int prochainId = 1; Propri√©t√©s calcul√©es:\nint DureeEmprunt - Obtenue via Document.ObtenirDureeEmprunt(Membre.Type) int JoursEmprunt - Jours depuis DateEmprunt bool EstEnRetard - true si maintenant \u003e DateRetourPrevue ET Statut == EnCours int JoursRetard - Jours de retard (0 si pas en retard) decimal Penalite - JoursRetard √ó 0.50$ Constructeur:\npublic Emprunt(IEmpruntable document, Membre membre) { Id = prochainId++; Document = document; Membre = membre; DateEmprunt = DateTime.Now; int duree = document.ObtenirDureeEmprunt(membre.Type); DateRetourPrevue = DateEmprunt.AddDays(duree); Statut = StatutEmprunt.EnCours; } M√©thodes:\nvoid Retourner() - Met DateRetourReelle, change Statut override string ToString() - Format: ‚ÄúDocument.Titre - Membre.Nom - Statut‚Äù üìã PARTIE 2: CLASSE GESTIONNAIRE AVEC POLYMORPHISME Classe GestionnaireBibliotheque Propri√©t√©s:\nList\u003cDocument\u003e Documents { get; set; } - Tous les documents (polymorphisme!) List\u003cMembre\u003e Membres { get; set; } - Tous les membres List\u003cEmprunt\u003e Emprunts { get; set; } - Tous les emprunts Constructeur:\nInitialise les 3 listes vides M√âTHODES √Ä IMPL√âMENTER AVEC LINQ 2.1 Gestion de base avec polymorphisme void AjouterDocument(Document document)\nAjoute un document (peut √™tre Livre ou Magazine) Valide que l‚ÄôID n‚Äôexiste pas d√©j√† (LINQ) void AjouterMembre(Membre membre)\nAjoute un membre Valide que le courriel n‚Äôexiste pas d√©j√† (LINQ) bool CreerEmprunt(int documentId, int membreId)\nTrouve le document avec LINQ (FirstOrDefault) Cast vers IEmpruntable si le document impl√©mente l‚Äôinterface Trouve le membre avec LINQ V√©rifie PeutEmprunter du membre V√©rifie PeutEtreEmprunte() du document Cr√©e l‚ÄôEmprunt et l‚Äôajoute aux listes Appelle document.Emprunter() Retourne true si succ√®s bool RetournerDocument(int empruntId)\nTrouve l‚Äôemprunt avec LINQ Appelle Emprunt.Retourner() Appelle Document.Retourner() Retourne true si succ√®s 2.2 Recherches LINQ avec polymorphisme List\u003cDocument\u003e ObtenirDocumentsDisponibles()\nRetourne tous les documents disponibles Tri√©s par Titre List\u003cLivre\u003e ObtenirLivresParGenre(GenreLivre genre)\nFiltre les documents qui sont des Livre (utilisez is ou OfType\u003cLivre\u003e()) Filtre par genre Tri√©s par AnneePublication d√©croissant List\u003cMagazine\u003e ObtenirMagazinesRecents()\nFiltre les documents qui sont des Magazine O√π EstRecent == true Tri√©s par NumeroEdition d√©croissant List\u003cDocument\u003e ObtenirDocumentsParAuteur(string auteur)\nFiltre les documents qui sont des Livre Dont l‚Äôauteur contient la cha√Æne (ignore casse) Retourne comme List (polymorphisme!) Tri√©s par Titre List\u003cEmprunt\u003e ObtenirEmpruntsEnRetard()\nTous les emprunts o√π EstEnRetard == true Tri√©s par JoursRetard d√©croissant 2.3 Statistiques LINQ int CompterDocumentsParType(string typeDocument)\nCompte les documents o√π TypeDocument == param√®tre Exemple: CompterDocumentsParType(‚ÄúLivre‚Äù) int CompterLivresParGenre(GenreLivre genre)\nFiltre les Livre du genre donn√© Compte le total decimal CalculerPenalitesTotales()\nSomme toutes les p√©nalit√©s double CalculerMoyenneEmpruntsParMembre()\nMoyenne d‚Äôemprunts par membre Document ObtenirDocumentLePlusEmprunte()\nGroupBy sur Document OrderByDescending par Count Retourne le premier 2.4 Requ√™tes avanc√©es avec polymorphisme Dictionary\u003cstring, int\u003e ObtenirStatistiquesParTypeDocument()\nGroupBy sur TypeDocument Retourne: ‚ÄúLivre‚Äù ‚Üí 25, ‚ÄúMagazine‚Äù ‚Üí 15 Tri√© par nombre d√©croissant var ObtenirStatistiquesCompletes()\nPour chaque type de document, retourne (type anonyme): new { TypeDocument = \"Livre\", Nombre = ..., NombreDisponibles = ..., TauxDisponibilite = ... } List\u003cIEmpruntable\u003e ObtenirDocumentsEmpruntables()\nRetourne tous les documents qui sont IEmpruntable O√π PeutEtreEmprunte() == true Important: retour polymorphe comme IEmpruntable Dictionary\u003cTypeMembre, List\u003cMembre\u003e\u003e GrouperMembresParType()\nGroupBy par type Retourne dictionnaire var ObtenirTop5MembresActifs()\nTop 5 par nombre d‚Äôemprunts totaux Type anonyme avec Nom et NombreEmprunts List\u003cEmprunt\u003e ObtenirHistoriqueMembreParType(int membreId, string typeDocument)\nEmprunts d‚Äôun membre Filtre par TypeDocument du Document Tri√©s par DateEmprunt d√©croissant 2.5 M√©thodes utilisant le polymorphisme (IMPORTANT!) void AfficherTousLesDocuments()\nParcourt la liste Documents Pour chaque document, appelle document.AfficherInfos() (polymorphisme!) La bonne m√©thode est appel√©e selon le type r√©el List\u003cstring\u003e ObtenirDescriptionsTousDocuments()\nSelect sur Documents Appelle document.ObtenirDescription() pour chacun (polymorphisme!) Retourne la liste des descriptions Dictionary\u003cstring, int\u003e CalculerDureeMoyenneParType()\nGroupBy par TypeDocument Pour chaque groupe, calcule la dur√©e moyenne d‚Äôemprunt Retourne: ‚ÄúLivre‚Äù ‚Üí 18, ‚ÄúMagazine‚Äù ‚Üí 7 üìã PARTIE 3: PROGRAMME PRINCIPAL Dans Program.cs:\nCr√©ez un GestionnaireBibliotheque\nAjoutez des donn√©es de test:\nAu moins 8 Livres (diff√©rents genres) Au moins 4 Magazines Au moins 5 Membres (diff√©rents types) Au moins 10 Emprunts (certains en retard, certains de livres, certains de magazines) D√©montrez le polymorphisme:\n// Ajout polymorphe Document doc1 = new Livre { Titre = \"1984\", Auteur = \"Orwell\" }; Document doc2 = new Magazine { Titre = \"Science et Vie\", NumeroEdition = 125 }; gestionnaire.AjouterDocument(doc1); gestionnaire.AjouterDocument(doc2); // Affichage polymorphe gestionnaire.AfficherTousLesDocuments(); Testez et affichez:\nStatistiques par type de document Documents disponibles (livres ET magazines) Emprunts en retard avec p√©nalit√©s Top 5 membres actifs Descriptions de tous les documents (polymorphisme!) Format d‚Äôaffichage sugg√©r√©:\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\rSYST√àME DE GESTION - BIBLIOTH√àQUE\r‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\rüìä STATISTIQUES PAR TYPE:\r‚Ä¢ Livre: 8 documents (5 disponibles) - 62.5%\r‚Ä¢ Magazine: 4 documents (3 disponibles) - 75.0%\rüìö TOUS LES DOCUMENTS DISPONIBLES:\r‚Ä¢ Livre: 1984 par George Orwell (1949)\r‚Ä¢ Magazine: Science et Vie #125 - Editeur XYZ\r‚Ä¢ Livre: Le Petit Prince par Saint-Exup√©ry (1943)\r‚è∞ EMPRUNTS EN RETARD:\r‚Ä¢ 1984 - Alice Tremblay - 5 jours - 2.50$\r‚Ä¢ Science et Vie #120 - Bob Gagnon - 2 jours - 1.00$\rüí∞ P√âNALIT√âS TOTALES: 3.50$\rüèÜ TOP 5 MEMBRES ACTIFS:\r1. Alice Tremblay - 8 emprunts\r2. Bob Gagnon - 6 emprunts\r3. Charlie Roy - 4 emprunts ‚úÖ CRIT√àRES D‚Äô√âVALUATION POO Avanc√©e (40%) Interface IEmpruntable correctement d√©finie et impl√©ment√©e Classe abstraite Document avec propri√©t√©s/m√©thodes abstraites et virtuelles H√©ritage correct: Livre et Magazine h√©ritent de Document Impl√©mentation correcte de l‚Äôinterface dans les deux classes Utilisation de override pour les m√©thodes virtuelles/abstraites Utilisation de base dans les constructeurs Polymorphisme d√©montr√© (Document peut r√©f√©rer Livre ou Magazine) Propri√©t√© prot√©g√©e (protected) utilis√©e correctement LINQ (40%) Utilisation de OfType\u003cT\u003e() ou is pour filtrer par type Toutes les m√©thodes utilisent LINQ (pas de boucles) Where, OrderBy, Select correctement utilis√©s GroupBy, Count, Sum, Average correctement utilis√©s FirstOrDefault avec gestion du null Types anonymes utilis√©s Qualit√© du code (20%) Code compile sans erreurs Noms significatifs Gestion des cas null Polymorphisme bien exploit√© Programme principal d√©montre bien les concepts üéì CONCEPTS POO √Ä MA√éTRISER Classe abstraite vs Interface Classe abstraite (Document):\nPeut avoir des propri√©t√©s concr√®tes ET abstraites Peut avoir des m√©thodes impl√©ment√©es ET abstraites Peut avoir un constructeur H√©ritage simple uniquement (une classe ne peut h√©riter que d‚Äôune classe abstraite) Interface (IEmpruntable):\nD√©finit uniquement un contrat (signatures) Pas d‚Äôimpl√©mentation Pas de constructeur Une classe peut impl√©menter plusieurs interfaces Mots-cl√©s importants abstract - Classe ou membre qui DOIT √™tre impl√©ment√©\npublic abstract string TypeDocument { get; } public abstract int ObtenirDureeEmpruntDefaut(); virtual - Membre qui PEUT √™tre surcharg√©\npublic virtual string ObtenirDescription() { ... } override - Surcharge un membre virtual ou abstract\npublic override string ObtenirDescription() { ... } protected - Accessible dans la classe et les classes d√©riv√©es\nprotected set { ... } base - Appelle le constructeur/m√©thode de la classe parent\npublic Livre() : base() { } Pattern matching avec is et as // V√©rifier le type if (document is Livre livre) { Console.WriteLine(livre.Auteur); } // Cast s√©curitaire IEmpruntable empruntable = document as IEmpruntable; if (empruntable != null) { empruntable.Emprunter(); } // Avec LINQ var livres = Documents.OfType\u003cLivre\u003e(); üìö RAPPELS LINQ SP√âCIFIQUES AU POLYMORPHISME // Filtrer par type avec OfType var livres = Documents.OfType\u003cLivre\u003e(); // Filtrer par type avec Where et is var magazines = Documents.Where(d =\u003e d is Magazine); // Cast apr√®s filtrage var livresSciFi = Documents .OfType\u003cLivre\u003e() .Where(l =\u003e l.Genre == GenreLivre.ScienceFiction); // GroupBy sur propri√©t√© polymorphe var stats = Documents .GroupBy(d =\u003e d.TypeDocument) .Select(g =\u003e new { Type = g.Key, Count = g.Count() }); // Utiliser l'interface var disponibles = Documents .OfType\u003cIEmpruntable\u003e() .Where(e =\u003e e.PeutEtreEmprunte()); Focus: H√©ritage, Interfaces, Polymorphisme et LINQ!",
    "description": "üìù EXERCICE DE PR√âPARATION √Ä L‚ÄôEXAMEN Syst√®me de Gestion d‚Äôune Biblioth√®que Municipale POO Avanc√©e + LINQ üéØ CONTEXTE Vous travaillez pour la Ville de Montr√©al et devez cr√©er un syst√®me de gestion pour la biblioth√®que municipale. Le syst√®me doit g√©rer diff√©rents types de documents (livres, magazines, DVD), les membres, les emprunts et g√©n√©rer des statistiques.",
    "tags": [],
    "title": "Pratique - Exam 1",
    "uri": "/420-413/pratique_exam1/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "D√©veloppement d‚Äôapplications WPF avec C# Partie 1 : Installation de .NET Desktop Development 1.1 Pourquoi Visual Studio 2022 ? Visual Studio 2022 est l‚ÄôIDE (environnement de d√©veloppement int√©gr√©) officiel de Microsoft pour cr√©er des applications .NET.\nAvantages :\nDesigner visuel pour WPF (glisser-d√©poser de contr√¥les) IntelliSense (auto-compl√©tion intelligente) D√©bogueur puissant Gratuit dans la version Community 1.2 √âtapes d‚Äôinstallation √âtape 1 : T√©l√©charger Visual Studio 2022 Allez sur : https://visualstudio.microsoft.com/fr/ T√©l√©chargez Visual Studio 2022 Community (gratuit) Lancez le programme d‚Äôinstallation t√©l√©charg√© √âtape 2 : Installer la charge de travail .NET Desktop Quand le Visual Studio Installer s‚Äôouvre :\nDans l‚Äôonglet ‚ÄúCharges de travail‚Äù, cochez :\n‚úÖ D√©veloppement .NET Desktop (en fran√ßais) ‚úÖ \".NET desktop development\" (en anglais) Cette charge de travail installe automatiquement :\n.NET SDK (kit de d√©veloppement) Windows Forms WPF (Windows Presentation Foundation) Templates de projets pour applications de bureau Cliquez sur ‚ÄúInstaller‚Äù ou ‚ÄúModifier‚Äù (si VS est d√©j√† install√©)\n√âtape 3 : V√©rifier l‚Äôinstallation Une fois l‚Äôinstallation termin√©e :\nLancez Visual Studio 2022 Cliquez sur ‚ÄúCr√©er un projet‚Äù Dans la barre de recherche, tapez ‚ÄúWPF‚Äù Vous devriez voir : ‚ÄúApplication WPF (.NET)‚Äù Si vous voyez ce template, l‚Äôinstallation a r√©ussi ! ‚úÖ\n1.3 Cr√©er votre premier projet WPF Proc√©dure compl√®te :\nFichier ‚Üí Nouveau ‚Üí Projet Recherchez ‚ÄúWPF‚Äù S√©lectionnez ‚ÄúApplication WPF‚Äù (assurez-vous que c‚Äôest bien .NET et pas .NET Framework) Cliquez sur ‚ÄúSuivant‚Äù Donnez un nom au projet : MonPremierWPF Choisissez un emplacement sur votre disque Cliquez sur ‚ÄúSuivant‚Äù S√©lectionnez \".NET 8.0\" ou \".NET 7.0\" (la version la plus r√©cente) Cliquez sur ‚ÄúCr√©er‚Äù Visual Studio va cr√©er :\nUn fichier MainWindow.xaml (l‚Äôinterface) Un fichier MainWindow.xaml.cs (le code C#) Un fichier App.xaml (configuration de l‚Äôapplication) Appuyez sur F5 pour lancer l‚Äôapplication. Une fen√™tre vide s‚Äôouvrira ‚Äî c‚Äôest votre premi√®re app WPF ! üéâ\nPartie 2 : Introduction √† la programmation de bureau 2.1 Qu‚Äôest-ce qu‚Äôune application de bureau ? Jusqu‚Äô√† pr√©sent, vous avez probablement √©crit des applications console (avec Console.WriteLine).\nApplication console :\n\u003e Entrez votre nom: Alice\r\u003e Bonjour Alice! Application de bureau (WPF) :\nFen√™tres avec boutons, champs de texte, images Interface graphique (GUI) Interaction √† la souris Exemple : Microsoft Word, Excel, calculatrice Windows 2.2 Diff√©rence entre Console et WPF Aspect Application Console Application WPF Interface Texte uniquement Graphique (boutons, images, etc.) Interaction Clavier (input/output) Souris + clavier Apparence Noire et blanche Couleurs, polices, animations Complexit√© Simple Plus complexe mais plus puissante Utilisation Scripts, outils admin Logiciels utilisateur final 2.3 Les 3 technologies de bureau en .NET Technologie Ann√©e Utilisation Windows Forms 2002 Ancienne, simple mais limit√©e WPF 2006 Moderne, puissante, flexible WinUI 3 2021 Tr√®s r√©cente, encore en d√©veloppement Dans ce cours, on se concentre sur WPF car c‚Äôest le standard de l‚Äôindustrie.\n2.4 Architecture d‚Äôune application WPF MonProjet/\r‚îú‚îÄ‚îÄ App.xaml ‚Üê Configuration de l'application\r‚îú‚îÄ‚îÄ App.xaml.cs ‚Üê Code-behind de App\r‚îú‚îÄ‚îÄ MainWindow.xaml ‚Üê Interface de la fen√™tre principale\r‚îú‚îÄ‚îÄ MainWindow.xaml.cs ‚Üê Logique de la fen√™tre principale\r‚îî‚îÄ‚îÄ (Autres fen√™tres, classes, ressources...) Principe fondamental : WPF s√©pare l‚Äôinterface (XAML) de la logique (C#).\nPartie 3 : Premiers pas avec WPF 3.1 Structure d‚Äôun projet WPF Quand vous cr√©ez un projet WPF, Visual Studio g√©n√®re automatiquement :\nApp.xaml\n\u003cApplication x:Class=\"MonPremierWPF.App\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" StartupUri=\"MainWindow.xaml\"\u003e \u003cApplication.Resources\u003e \u003c/Application.Resources\u003e \u003c/Application\u003e StartupUri=\"MainWindow.xaml\" ‚Üí Quelle fen√™tre s‚Äôouvre au d√©marrage MainWindow.xaml\n\u003cWindow x:Class=\"MonPremierWPF.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"MainWindow\" Height=\"450\" Width=\"800\"\u003e \u003cGrid\u003e \u003c/Grid\u003e \u003c/Window\u003e Title ‚Üí Titre de la fen√™tre Height et Width ‚Üí Dimensions en pixels \u003cGrid\u003e ‚Üí Conteneur pour placer les contr√¥les MainWindow.xaml.cs\nusing System.Windows; namespace MonPremierWPF { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } } } InitializeComponent() ‚Üí Charge le XAML et construit l‚Äôinterface 3.2 Le Designer visuel Dans Visual Studio, quand vous ouvrez MainWindow.xaml, vous voyez deux panneaux :\nEn haut : Le Designer (aper√ßu visuel) En bas : Le code XAML Vous pouvez :\nGlisser-d√©poser des contr√¥les depuis la Bo√Æte √† outils (View ‚Üí Toolbox) Modifier le XAML directement Les deux sont synchronis√©s ! 3.3 Votre premier bouton Modifiez MainWindow.xaml :\n\u003cWindow x:Class=\"MonPremierWPF.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"Ma premi√®re application\" Height=\"300\" Width=\"400\"\u003e \u003cGrid\u003e \u003cButton Content=\"Cliquez-moi !\" Width=\"150\" Height=\"50\" Click=\"Button_Click\" /\u003e \u003c/Grid\u003e \u003c/Window\u003e Dans MainWindow.xaml.cs, ajoutez la m√©thode :\nusing System.Windows; namespace MonPremierWPF { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } private void Button_Click(object sender, RoutedEventArgs e) { MessageBox.Show(\"Bonjour du monde WPF !\"); } } } Appuyez sur F5 et cliquez sur le bouton. Un message appara√Æt ! üéâ\nExplications :\nClick=\"Button_Click\" dans le XAML cr√©e un lien vers la m√©thode C# Visual Studio peut cr√©er cette m√©thode automatiquement : double-cliquez sur le bouton dans le Designer MessageBox.Show() affiche une bo√Æte de dialogue Partie 4 : XAML ‚Äî Le langage de l‚Äôinterface 4.1 Qu‚Äôest-ce que XAML ? XAML (prononcez ‚Äúzamel‚Äù) = eXtensible Application Markup Language\nC‚Äôest un langage bas√© sur XML pour d√©crire des interfaces graphiques.\nAnalogie :\nXAML est √† WPF ce que HTML est aux sites web C# est √† WPF ce que JavaScript est aux sites web 4.2 Syntaxe de base XAML Les balises (√©l√©ments) \u003cButton /\u003e \u003c!-- Balise auto-fermante --\u003e \u003cButton\u003e \u003c!-- Balise avec contenu --\u003e Texte du bouton \u003c/Button\u003e Les attributs (propri√©t√©s) \u003cButton Content=\"Mon bouton\" Width=\"100\" Height=\"40\" Background=\"Blue\" /\u003e Chaque attribut configure une propri√©t√© de l‚Äôobjet C#.\n√âquivalent en C# pur :\nButton monBouton = new Button(); monBouton.Content = \"Mon bouton\"; monBouton.Width = 100; monBouton.Height = 40; monBouton.Background = Brushes.Blue; 4.3 Les namespaces XML En haut de chaque fichier XAML :\nxmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Premier namespace (par d√©faut) : Contient tous les contr√¥les WPF (Button, TextBox, Grid, etc.) Namespace x: : Contient les √©l√©ments sp√©ciaux XAML (x:Name, x:Class, etc.) 4.4 L‚Äôattribut x:Name Pour acc√©der √† un contr√¥le depuis le code C#, donnez-lui un nom :\n\u003cTextBox x:Name=\"txtNom\" Width=\"200\" Height=\"30\" /\u003e Ensuite, dans le C# :\nprivate void Button_Click(object sender, RoutedEventArgs e) { string nom = txtNom.Text; // Acc√®s direct ! MessageBox.Show($\"Bonjour {nom}\"); } Convention de nommage :\nTextBox ‚Üí txt prefix (ex: txtNom, txtCourriel) Button ‚Üí btn prefix (ex: btnEnvoyer, btnAnnuler) Label ‚Üí lbl prefix ListBox ‚Üí lst prefix 4.5 Propri√©t√©s complexes Certaines propri√©t√©s sont trop complexes pour un simple attribut.\nSyntaxe avec attribut (simple) :\n\u003cButton Background=\"Blue\" /\u003e Syntaxe avec balise (complexe) :\n\u003cButton\u003e \u003cButton.Background\u003e \u003cLinearGradientBrush\u003e \u003cGradientStop Color=\"LightBlue\" Offset=\"0\" /\u003e \u003cGradientStop Color=\"DarkBlue\" Offset=\"1\" /\u003e \u003c/LinearGradientBrush\u003e \u003c/Button.Background\u003e \u003cButton.Content\u003e Mon bouton avec d√©grad√© \u003c/Button.Content\u003e \u003c/Button\u003e 4.6 Les √©v√©nements Les √©v√©nements relient l‚Äôinterface au code C#.\n√âv√©nements courants :\n\u003cButton Click=\"MonBouton_Click\" /\u003e \u003cTextBox TextChanged=\"MonTexte_Changed\" /\u003e \u003cCheckBox Checked=\"MaCase_Checked\" /\u003e \u003cListBox SelectionChanged=\"MaListe_SelectionChanged\" /\u003e Dans le C# :\nprivate void MonBouton_Click(object sender, RoutedEventArgs e) { // Code ex√©cut√© quand on clique } private void MonTexte_Changed(object sender, TextChangedEventArgs e) { // Code ex√©cut√© quand le texte change } Partie 5 : Les Layouts (mise en page) Les Layouts sont des conteneurs qui organisent les contr√¥les √† l‚Äô√©cran.\n5.1 Grid ‚Äî Le layout principal Le Grid divise l‚Äôespace en lignes et colonnes, comme un tableau Excel.\nExemple de base \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"Auto\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003cRowDefinition Height=\"50\" /\u003e \u003c/Grid.RowDefinitions\u003e \u003cGrid.ColumnDefinitions\u003e \u003cColumnDefinition Width=\"200\" /\u003e \u003cColumnDefinition Width=\"*\" /\u003e \u003c/Grid.ColumnDefinitions\u003e \u003c!-- Placer les contr√¥les --\u003e \u003cButton Grid.Row=\"0\" Grid.Column=\"0\" Content=\"Haut gauche\" /\u003e \u003cButton Grid.Row=\"0\" Grid.Column=\"1\" Content=\"Haut droite\" /\u003e \u003cTextBox Grid.Row=\"1\" Grid.Column=\"0\" Grid.ColumnSpan=\"2\" /\u003e \u003c/Grid\u003e Types de dimensions Valeur Signification Exemple 100 Pixels fixes Height=\"100\" Auto S‚Äôadapte au contenu Height=\"Auto\" * Prend l‚Äôespace restant Height=\"*\" 2* Prend 2 fois plus d‚Äôespace Height=\"2*\" Exemple avec proportions :\n\u003cGrid.ColumnDefinitions\u003e \u003cColumnDefinition Width=\"*\" /\u003e \u003c!-- 1/3 de l'espace --\u003e \u003cColumnDefinition Width=\"2*\" /\u003e \u003c!-- 2/3 de l'espace --\u003e \u003c/Grid.ColumnDefinitions\u003e Si la fen√™tre fait 900 pixels de large :\nColonne 0 : 300 pixels Colonne 1 : 600 pixels Fusionner des cellules \u003c!-- Prendre 2 colonnes --\u003e \u003cButton Grid.Row=\"0\" Grid.Column=\"0\" Grid.ColumnSpan=\"2\" Content=\"Large\" /\u003e \u003c!-- Prendre 2 rang√©es --\u003e \u003cButton Grid.Row=\"0\" Grid.Column=\"0\" Grid.RowSpan=\"2\" Content=\"Haut\" /\u003e 5.2 StackPanel ‚Äî Empilement Le StackPanel empile les √©l√©ments verticalement (d√©faut) ou horizontalement.\nVertical (d√©faut) \u003cStackPanel\u003e \u003cButton Content=\"Bouton 1\" Height=\"40\" /\u003e \u003cButton Content=\"Bouton 2\" Height=\"40\" /\u003e \u003cButton Content=\"Bouton 3\" Height=\"40\" /\u003e \u003c/StackPanel\u003e Les boutons sont empil√©s du haut vers le bas.\nHorizontal \u003cStackPanel Orientation=\"Horizontal\"\u003e \u003cButton Content=\"Bouton 1\" Width=\"100\" /\u003e \u003cButton Content=\"Bouton 2\" Width=\"100\" /\u003e \u003cButton Content=\"Bouton 3\" Width=\"100\" /\u003e \u003c/StackPanel\u003e Les boutons sont c√¥te √† c√¥te.\nAvec Margin (espacement) \u003cStackPanel Margin=\"20\"\u003e \u003cTextBlock Text=\"Nom :\" FontWeight=\"Bold\" /\u003e \u003cTextBox Height=\"30\" Margin=\"0,5,0,10\" /\u003e \u003cTextBlock Text=\"Courriel :\" FontWeight=\"Bold\" /\u003e \u003cTextBox Height=\"30\" Margin=\"0,5,0,10\" /\u003e \u003cButton Content=\"Envoyer\" Height=\"40\" /\u003e \u003c/StackPanel\u003e Margin : Left, Top, Right, Bottom\nMargin=\"10\" ‚Üí 10 pixels de tous les c√¥t√©s Margin=\"10,20\" ‚Üí 10 gauche/droite, 20 haut/bas Margin=\"10,20,30,40\" ‚Üí Gauche, Haut, Droite, Bas 5.3 WrapPanel ‚Äî Empilement avec retour automatique Comme StackPanel, mais retourne √† la ligne si pas assez d‚Äôespace.\n\u003cWrapPanel\u003e \u003cButton Content=\"1\" Width=\"100\" Height=\"40\" Margin=\"5\" /\u003e \u003cButton Content=\"2\" Width=\"100\" Height=\"40\" Margin=\"5\" /\u003e \u003cButton Content=\"3\" Width=\"100\" Height=\"40\" Margin=\"5\" /\u003e \u003cButton Content=\"4\" Width=\"100\" Height=\"40\" Margin=\"5\" /\u003e \u003cButton Content=\"5\" Width=\"100\" Height=\"40\" Margin=\"5\" /\u003e \u003c/WrapPanel\u003e Si la fen√™tre est √©troite, les boutons passent √† la ligne suivante.\n5.4 DockPanel ‚Äî Ancrage sur les bords \u003cDockPanel\u003e \u003cMenu DockPanel.Dock=\"Top\" Height=\"30\" Background=\"LightGray\"\u003e \u003cMenuItem Header=\"Fichier\" /\u003e \u003cMenuItem Header=\"Edition\" /\u003e \u003c/Menu\u003e \u003cStatusBar DockPanel.Dock=\"Bottom\" Height=\"25\" Background=\"LightGray\"\u003e \u003cTextBlock Text=\"Pr√™t\" /\u003e \u003c/StatusBar\u003e \u003cTreeView DockPanel.Dock=\"Left\" Width=\"200\" /\u003e \u003cTextBox /\u003e \u003c!-- Remplit le centre --\u003e \u003c/DockPanel\u003e R√©sultat : Interface classique avec menu en haut, barre de statut en bas, arbre √† gauche, et zone centrale.\n5.5 Canvas ‚Äî Positionnement absolu \u003cCanvas\u003e \u003cButton Content=\"Bouton 1\" Canvas.Left=\"50\" Canvas.Top=\"100\" Width=\"100\" Height=\"40\" /\u003e \u003cEllipse Fill=\"Red\" Canvas.Left=\"200\" Canvas.Top=\"150\" Width=\"80\" Height=\"80\" /\u003e \u003c/Canvas\u003e Rarement utilis√© car pas responsive.\n5.6 Exemple : Interface compl√®te Application de calculatrice simple :\nüí° Solution\r```xml\r\u003cGrid Margin=\"10\"\u003e\r\u003cGrid.RowDefinitions\u003e\r\u003cRowDefinition Height=\"80\" /\u003e\r\u003cRowDefinition Height=\"*\" /\u003e\r\u003c/Grid.RowDefinitions\u003e\r\u003c!-- Affichage --\u003e\r\u003cBorder Grid.Row=\"0\" BorderBrush=\"Black\" BorderThickness=\"2\" Background=\"White\"\rPadding=\"10\"\u003e\r\u003cTextBlock x:Name=\"txtAffichage\" Text=\"0\" FontSize=\"36\" HorizontalAlignment=\"Right\"\rVerticalAlignment=\"Center\" /\u003e\r\u003c/Border\u003e\r\u003c!-- Boutons --\u003e\r\u003cGrid Grid.Row=\"1\" Margin=\"0,10,0,0\"\u003e\r\u003cGrid.RowDefinitions\u003e\r\u003cRowDefinition Height=\"*\" /\u003e\r\u003cRowDefinition Height=\"*\" /\u003e\r\u003cRowDefinition Height=\"*\" /\u003e\r\u003cRowDefinition Height=\"*\" /\u003e\r\u003c/Grid.RowDefinitions\u003e\r\u003cGrid.ColumnDefinitions\u003e\r\u003cColumnDefinition Width=\"*\" /\u003e\r\u003cColumnDefinition Width=\"*\" /\u003e\r\u003cColumnDefinition Width=\"*\" /\u003e\r\u003cColumnDefinition Width=\"*\" /\u003e\r\u003c/Grid.ColumnDefinitions\u003e\r\u003c!-- Ligne 0 --\u003e\r\u003cButton Grid.Row=\"0\" Grid.Column=\"0\" Content=\"7\" FontSize=\"24\" Margin=\"2\" /\u003e\r\u003cButton Grid.Row=\"0\" Grid.Column=\"1\" Content=\"8\" FontSize=\"24\" Margin=\"2\" /\u003e\r\u003cButton Grid.Row=\"0\" Grid.Column=\"2\" Content=\"9\" FontSize=\"24\" Margin=\"2\" /\u003e\r\u003cButton Grid.Row=\"0\" Grid.Column=\"3\" Content=\"√∑\" FontSize=\"24\" Margin=\"2\" Background=\"LightBlue\" /\u003e\r\u003c!-- Ligne 1 --\u003e\r\u003cButton Grid.Row=\"1\" Grid.Column=\"0\" Content=\"4\" FontSize=\"24\" Margin=\"2\" /\u003e\r\u003cButton Grid.Row=\"1\" Grid.Column=\"1\" Content=\"5\" FontSize=\"24\" Margin=\"2\" /\u003e\r\u003cButton Grid.Row=\"1\" Grid.Column=\"2\" Content=\"6\" FontSize=\"24\" Margin=\"2\" /\u003e\r\u003cButton Grid.Row=\"1\" Grid.Column=\"3\" Content=\"√ó\" FontSize=\"24\" Margin=\"2\" Background=\"LightBlue\" /\u003e\r\u003c!-- Ligne 2 --\u003e\r\u003cButton Grid.Row=\"2\" Grid.Column=\"0\" Content=\"1\" FontSize=\"24\" Margin=\"2\" /\u003e\r\u003cButton Grid.Row=\"2\" Grid.Column=\"1\" Content=\"2\" FontSize=\"24\" Margin=\"2\" /\u003e\r\u003cButton Grid.Row=\"2\" Grid.Column=\"2\" Content=\"3\" FontSize=\"24\" Margin=\"2\" /\u003e\r\u003cButton Grid.Row=\"2\" Grid.Column=\"3\" Content=\"-\" FontSize=\"24\" Margin=\"2\" Background=\"LightBlue\" /\u003e\r\u003c!-- Ligne 3 --\u003e\r\u003cButton Grid.Row=\"3\" Grid.Column=\"0\" Content=\"0\" FontSize=\"24\" Margin=\"2\" Grid.ColumnSpan=\"2\" /\u003e\r\u003cButton Grid.Row=\"3\" Grid.Column=\"2\" Content=\"=\" FontSize=\"24\" Margin=\"2\" Background=\"Orange\" /\u003e\r\u003cButton Grid.Row=\"3\" Grid.Column=\"3\" Content=\"+\" FontSize=\"24\" Margin=\"2\" Background=\"LightBlue\" /\u003e\r\u003c/Grid\u003e\r\u003c/Grid\u003e\r```\rPartie 6 : Les contr√¥les de base 6.1 TextBox ‚Äî Saisie de texte \u003cTextBox x:Name=\"txtNom\" Width=\"200\" Height=\"30\" Text=\"Valeur par d√©faut\" /\u003e Propri√©t√©s importantes :\nText : Le contenu MaxLength : Limite de caract√®res IsReadOnly : Lecture seule AcceptsReturn : Multi-lignes Acc√®s en C# :\nstring texte = txtNom.Text; txtNom.Text = \"Nouveau texte\"; 6.2 TextBlock ‚Äî Texte non modifiable \u003cTextBlock Text=\"Ceci est un texte\" FontSize=\"16\" FontWeight=\"Bold\" Foreground=\"DarkBlue\" /\u003e Diff√©rence avec TextBox :\nTextBlock : Affichage seulement (comme un label HTML) TextBox : Saisie utilisateur (comme un input HTML) 6.3 Button ‚Äî Bouton \u003cButton Content=\"Cliquer ici\" Width=\"120\" Height=\"40\" Click=\"MonBouton_Click\" /\u003e Propri√©t√©s :\nContent : Texte ou contenu IsEnabled : Actif/d√©sactiv√© Background : Couleur de fond 6.4 CheckBox ‚Äî Case √† cocher \u003cCheckBox Content=\"J'accepte les conditions\" IsChecked=\"True\" Checked=\"Case_Checked\" /\u003e Acc√®s en C# :\nbool estCoche = maCaseACocher.IsChecked == true; 6.5 RadioButton ‚Äî Bouton radio \u003cStackPanel\u003e \u003cRadioButton Content=\"Option 1\" GroupName=\"Options\" IsChecked=\"True\" /\u003e \u003cRadioButton Content=\"Option 2\" GroupName=\"Options\" /\u003e \u003cRadioButton Content=\"Option 3\" GroupName=\"Options\" /\u003e \u003c/StackPanel\u003e GroupName : Regroupe les RadioButtons (un seul s√©lectionnable par groupe)\n6.6 ComboBox ‚Äî Liste d√©roulante \u003cComboBox x:Name=\"cbVilles\" Width=\"200\" Height=\"30\"\u003e \u003cComboBoxItem Content=\"Montr√©al\" /\u003e \u003cComboBoxItem Content=\"Qu√©bec\" /\u003e \u003cComboBoxItem Content=\"Laval\" /\u003e \u003c/ComboBox\u003e Acc√®s en C# :\nComboBoxItem item = (ComboBoxItem)cbVilles.SelectedItem; string ville = item.Content.ToString(); 6.7 ListBox ‚Äî Liste \u003cListBox x:Name=\"lstNoms\" Height=\"200\"\u003e \u003cListBoxItem Content=\"Alice\" /\u003e \u003cListBoxItem Content=\"Bob\" /\u003e \u003cListBoxItem Content=\"Charlie\" /\u003e \u003c/ListBox\u003e Ajouter des √©l√©ments en C# :\nlstNoms.Items.Add(\"David\"); 6.8 Image ‚Äî Afficher une image \u003cImage Source=\"logo.png\" Width=\"100\" Height=\"100\" /\u003e Note : L‚Äôimage doit √™tre dans le dossier du projet et configur√©e en ‚ÄúCopy to Output Directory‚Äù.\n6.9 ProgressBar ‚Äî Barre de progression \u003cProgressBar x:Name=\"barreProgression\" Height=\"20\" Minimum=\"0\" Maximum=\"100\" Value=\"50\" /\u003e 6.10 Slider ‚Äî Curseur \u003cSlider x:Name=\"sliderVolume\" Minimum=\"0\" Maximum=\"100\" Value=\"50\" TickFrequency=\"10\" IsSnapToTickEnabled=\"True\" /\u003e Partie 7 : Data Binding (Liaison de donn√©es) Le Data Binding est la fonctionnalit√© qui rend WPF vraiment puissant. Il synchronise automatiquement l‚Äôinterface avec les donn√©es.\n7.1 Pourquoi le Data Binding ? Sans Data Binding (approche manuelle) :\nprivate string nom = \"Alice\"; private void ChangerNom() { nom = \"Bob\"; txtAffichage.Text = nom; // Mise √† jour manuelle ! } Probl√®me : √Ä chaque changement, il faut manuellement mettre √† jour l‚Äôinterface.\nAvec Data Binding :\n\u003cTextBox Text=\"{Binding Nom}\" /\u003e Maintenant, quand Nom change, le TextBox se met √† jour automatiquement !\n7.2 Le DataContext Le DataContext est l‚Äôobjet source auquel les contr√¥les se lient.\nExemple simple :\nClasse Personne.cs :\npublic class Personne { public string Nom { get; set; } public int Age { get; set; } } MainWindow.xaml :\n\u003cWindow x:Class=\"BindingDemo.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"Data Binding Demo\" Height=\"200\" Width=\"350\"\u003e \u003cStackPanel Margin=\"20\"\u003e \u003cTextBlock Text=\"Nom :\" FontWeight=\"Bold\" /\u003e \u003cTextBox Text=\"{Binding Nom}\" Height=\"30\" Margin=\"0,5,0,10\" /\u003e \u003cTextBlock Text=\"√Çge :\" FontWeight=\"Bold\" /\u003e \u003cTextBox Text=\"{Binding Age}\" Height=\"30\" Margin=\"0,5,0,10\" /\u003e \u003cTextBlock Text=\"{Binding Nom}\" FontSize=\"16\" /\u003e \u003c/StackPanel\u003e \u003c/Window\u003e MainWindow.xaml.cs :\nusing System.Windows; namespace BindingDemo { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); // Cr√©er une personne Personne p = new Personne { Nom = \"Alice\", Age = 25 }; // D√©finir le DataContext this.DataContext = p; } } } R√©sultat : Les TextBox affichent ‚ÄúAlice‚Äù et ‚Äú25‚Äù.\n7.3 Les modes de Binding Mode Direction Usage OneWay Source ‚Üí UI Affichage (lecture seule) TwoWay Source ‚Üî UI √âdition (bidirectionnel) OneTime Source ‚Üí UI (une seule fois) Valeurs constantes OneWayToSource UI ‚Üí Source Rare Exemples :\n\u003c!-- TwoWay : modifications dans les deux sens --\u003e \u003cTextBox Text=\"{Binding Nom, Mode=TwoWay}\" /\u003e \u003c!-- OneWay : lecture seule --\u003e \u003cTextBlock Text=\"{Binding Nom, Mode=OneWay}\" /\u003e Par d√©faut :\nTextBox : TwoWay TextBlock : OneWay",
    "description": "D√©veloppement d‚Äôapplications WPF avec C# Partie 1 : Installation de .NET Desktop Development 1.1 Pourquoi Visual Studio 2022 ? Visual Studio 2022 est l‚ÄôIDE (environnement de d√©veloppement int√©gr√©) officiel de Microsoft pour cr√©er des applications .NET.",
    "tags": [],
    "title": "WPF - intro",
    "uri": "/420-413/wpf/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Partie 1 : Le patron Observateur (Contexte g√©n√©ral) Qu‚Äôest-ce qu‚Äôun patron de conception ? D√©finition simple : Un patron de conception est une solution √©prouv√©e √† un probl√®me r√©current en programmation.\nAnalogie : C‚Äôest comme une recette de cuisine. Si vous voulez faire un g√¢teau, vous n‚Äôinventez pas la m√©thode √† chaque fois ‚Äî vous suivez une recette qui a fait ses preuves.\nLes patrons de conception ne sont pas :\n‚ùå Du code √† copier-coller ‚ùå Une biblioth√®que ou un framework ‚ùå Sp√©cifiques √† un langage Les patrons de conception sont :\n‚úÖ Des principes d‚Äôorganisation du code ‚úÖ Des solutions conceptuelles ‚úÖ Applicables dans n‚Äôimporte quel langage orient√© objet Le patron Observateur ‚Äî Le probl√®me qu‚Äôil r√©sout Mise en situation r√©elle :\nImaginez une station m√©t√©o. Elle mesure :\nLa temp√©rature L‚Äôhumidit√© La pression Plusieurs appareils doivent afficher ces donn√©es :\nUn thermom√®tre digital Une application mobile Un site web Un syst√®me d‚Äôalerte Probl√®me : Comment faire en sorte que tous ces appareils soient notifi√©s automatiquement quand les donn√©es changent ?\n‚ùå Mauvaise solution (couplage fort) :\npublic class StationMeteo { private double temperature; public void SetTemperature(double temp) { temperature = temp; // Mettre √† jour chaque appareil manuellement thermometre.Afficher(temp); appMobile.MettreAJour(temp); siteWeb.Actualiser(temp); systemeAlerte.Verifier(temp); // Probl√®me : Si on ajoute un nouvel appareil, // il faut modifier cette m√©thode ! } } Probl√®mes de cette approche :\nLa station m√©t√©o conna√Æt tous les appareils (couplage fort) Pour ajouter un nouvel appareil, il faut modifier la station Impossible de d√©sactiver un appareil sans modifier le code Code rigide et difficile √† maintenir Le patron Observateur ‚Äî La solution Principe fondamental : Inverser la d√©pendance.\nAu lieu que la station connaisse tous les appareils, les appareils s‚Äôabonnent √† la station.\nAnalogie : C‚Äôest comme une newsletter par email :\nLe site web (sujet) publie du contenu Les lecteurs (observateurs) s‚Äôabonnent Quand un nouvel article sort, tous les abonn√©s re√ßoivent un email Les lecteurs peuvent se d√©sabonner √† tout moment Le site web ne conna√Æt pas les lecteurs individuellement Diagramme conceptuel :\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ SUJET (Observable) ‚îÇ\r‚îÇ - Liste d'observateurs ‚îÇ\r‚îÇ + Attacher(observateur) ‚îÇ\r‚îÇ + D√©tacher(observateur) ‚îÇ\r‚îÇ + Notifier() ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ\r‚îÇ notifie\r‚Üì\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ OBSERVATEUR ‚îÇ\r‚îÇ (Interface) ‚îÇ\r‚îÇ + Actualiser() ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚ñ≥\r‚îÇ impl√©mente\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ ‚îÇ ‚îÇ\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇThermo- ‚îÇ ‚îÇApp ‚îÇ ‚îÇSite ‚îÇ\r‚îÇm√®tre ‚îÇ ‚îÇMobile ‚îÇ ‚îÇWeb ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Impl√©mentation compl√®te √âtape 1 : L‚Äôinterface Observateur\n// Ce que TOUS les observateurs doivent impl√©menter public interface IObservateur { void Actualiser(double temperature, double humidite, double pression); } √âtape 2 : Le Sujet (Observable)\npublic class StationMeteo { // Liste des observateurs abonn√©s private List\u003cIObservateur\u003e observateurs = new List\u003cIObservateur\u003e(); // Donn√©es private double temperature; private double humidite; private double pression; // M√©thodes d'abonnement public void Abonner(IObservateur observateur) { observateurs.Add(observateur); Console.WriteLine($\"{observateur.GetType().Name} s'est abonn√©\"); } public void Desabonner(IObservateur observateur) { observateurs.Remove(observateur); Console.WriteLine($\"{observateur.GetType().Name} s'est d√©sabonn√©\"); } // Notifier tous les observateurs private void Notifier() { Console.WriteLine(\"=== Notification des observateurs ===\"); foreach (var observateur in observateurs) { observateur.Actualiser(temperature, humidite, pression); } } // Quand les donn√©es changent public void SetMesures(double temp, double hum, double press) { Console.WriteLine($\"\\nüì° Nouvelles mesures re√ßues\"); temperature = temp; humidite = hum; pression = press; // Notifier automatiquement Notifier(); } } √âtape 3 : Les observateurs concrets\n// Observateur 1 : Thermom√®tre digital public class ThermometreDigital : IObservateur { public void Actualiser(double temperature, double humidite, double pression) { Console.WriteLine($\"üå°Ô∏è Thermom√®tre : {temperature}¬∞C\"); } } // Observateur 2 : Application mobile public class ApplicationMobile : IObservateur { public void Actualiser(double temperature, double humidite, double pression) { Console.WriteLine($\"üì± App Mobile : Temp={temperature}¬∞C, \" + $\"Humidit√©={humidite}%, Pression={pression}hPa\"); } } // Observateur 3 : Syst√®me d'alerte public class SystemeAlerte : IObservateur { private const double SEUIL_CANICULE = 35; private const double SEUIL_GEL = 0; public void Actualiser(double temperature, double humidite, double pression) { if (temperature \u003e= SEUIL_CANICULE) Console.WriteLine(\"‚ö†Ô∏è ALERTE : Canicule d√©tect√©e !\"); else if (temperature \u003c= SEUIL_GEL) Console.WriteLine(\"‚ö†Ô∏è ALERTE : Risque de gel !\"); else Console.WriteLine(\"‚úÖ Syst√®me d'alerte : Conditions normales\"); } } // Observateur 4 : Site web public class SiteWeb : IObservateur { public void Actualiser(double temperature, double humidite, double pression) { Console.WriteLine($\"üåê Site Web actualis√© : {temperature}¬∞C\"); } } √âtape 4 : Utilisation\nclass Program { static void Main(string[] args) { // Cr√©er la station m√©t√©o StationMeteo station = new StationMeteo(); // Cr√©er les observateurs ThermometreDigital thermo = new ThermometreDigital(); ApplicationMobile appMobile = new ApplicationMobile(); SystemeAlerte alerte = new SystemeAlerte(); SiteWeb siteWeb = new SiteWeb(); // Abonnement Console.WriteLine(\"=== Phase d'abonnement ===\"); station.Abonner(thermo); station.Abonner(appMobile); station.Abonner(alerte); station.Abonner(siteWeb); // Premi√®re mise √† jour station.SetMesures(22.5, 65, 1013); // Deuxi√®me mise √† jour station.SetMesures(38, 45, 1010); // Le site web se d√©sabonne Console.WriteLine(\"\\n=== Site web se d√©sabonne ===\"); station.Desabonner(siteWeb); // Troisi√®me mise √† jour (le site web ne re√ßoit plus de notification) station.SetMesures(-2, 80, 1020); } } Sortie :\n=== Phase d'abonnement ===\rThermometreDigital s'est abonn√©\rApplicationMobile s'est abonn√©\rSystemeAlerte s'est abonn√©\rSiteWeb s'est abonn√©\rüì° Nouvelles mesures re√ßues\r=== Notification des observateurs ===\rüå°Ô∏è Thermom√®tre : 22.5¬∞C\rüì± App Mobile : Temp=22.5¬∞C, Humidit√©=65%, Pression=1013hPa\r‚úÖ Syst√®me d'alerte : Conditions normales\rüåê Site Web actualis√© : 22.5¬∞C\rüì° Nouvelles mesures re√ßues\r=== Notification des observateurs ===\rüå°Ô∏è Thermom√®tre : 38¬∞C\rüì± App Mobile : Temp=38¬∞C, Humidit√©=45%, Pression=1010hPa\r‚ö†Ô∏è ALERTE : Canicule d√©tect√©e !\rüåê Site Web actualis√© : 38¬∞C\r=== Site web se d√©sabonne ===\rSiteWeb s'est d√©sabonn√©\rüì° Nouvelles mesures re√ßues\r=== Notification des observateurs ===\rüå°Ô∏è Thermom√®tre : -2¬∞C\rüì± App Mobile : Temp=-2¬∞C, Humidit√©=80%, Pression=1020hPa\r‚ö†Ô∏è ALERTE : Risque de gel ! Avantages du patron Observateur 1. D√©couplage (Low Coupling)\n// La station ne conna√Æt PAS les observateurs concrets // Elle conna√Æt seulement l'interface IObservateur // On peut ajouter 100 nouveaux observateurs sans modifier la station 2. Ouvert/Ferm√© (Open/Closed Principle)\nOuvert √† l‚Äôextension : On peut ajouter de nouveaux observateurs Ferm√© √† la modification : Pas besoin de modifier le sujet 3. Flexibilit√©\n// Abonnement/d√©sabonnement dynamique √† l'ex√©cution station.Abonner(nouvelObservateur); station.Desabonner(ancienObservateur); 4. Diffusion un-√†-plusieurs\n// Une seule mise √† jour ‚Üí Tous les observateurs notifi√©s station.SetMesures(25, 60, 1015); // Un appel // ‚Üí Notifie automatiquement tous les abonn√©s Quand utiliser le patron Observateur ? ‚úÖ Utilisez-le quand :\nUn changement d‚Äô√©tat dans un objet n√©cessite de mettre √† jour d‚Äôautres objets Vous ne savez pas √† l‚Äôavance combien d‚Äôobjets doivent √™tre notifi√©s Vous voulez d√©coupler le sujet des observateurs Vous voulez permettre l‚Äôajout/suppression d‚Äôobservateurs dynamiquement ‚ùå N‚Äôutilisez pas si :\nIl n‚Äôy a qu‚Äôun seul observateur (pas besoin de ce patron) Les observateurs sont tr√®s peu nombreux et fixes (une simple m√©thode suffit) Performance critique (chaque notification a un co√ªt) Variantes du patron Observateur 1. Push vs Pull\nPush (ce qu‚Äôon a fait) : Le sujet envoie les donn√©es\nvoid Actualiser(double temp, double hum, double press) { // Toutes les donn√©es sont pouss√©es } Pull : L‚Äôobservateur r√©cup√®re ce dont il a besoin\npublic interface IObservateur { void Actualiser(StationMeteo station); } public class ThermometreDigital : IObservateur { public void Actualiser(StationMeteo station) { // Je r√©cup√®re seulement ce qui m'int√©resse double temp = station.GetTemperature(); Console.WriteLine($\"Temp: {temp}¬∞C\"); } } 2. √âv√©nements C# (version .NET du patron)\nC# impl√©mente le patron Observateur avec les √©v√©nements :\npublic class StationMeteo { // D√©finir un √©v√©nement public event EventHandler\u003cMesuresEventArgs\u003e MesuresChangees; private double temperature; public void SetTemperature(double temp) { temperature = temp; // D√©clencher l'√©v√©nement MesuresChangees?.Invoke(this, new MesuresEventArgs { Temperature = temp }); } } // Classe pour passer les donn√©es public class MesuresEventArgs : EventArgs { public double Temperature { get; set; } public double Humidite { get; set; } public double Pression { get; set; } } // Utilisation StationMeteo station = new StationMeteo(); // S'abonner avec += station.MesuresChangees += (sender, e) =\u003e { Console.WriteLine($\"Temp√©rature : {e.Temperature}¬∞C\"); }; // D√©clencher station.SetTemperature(25); Partie 2 : Le patron Observateur (INotifyPropertyChanged) Le probl√®me Avec le code pr√©c√©dent, si on modifie une propri√©t√© en C#, l‚Äôinterface ne se met PAS √† jour :\nPersonne p = new Personne { Nom = \"Alice\" }; this.DataContext = p; // Plus tard... p.Nom = \"Bob\"; // L'interface ne change pas ! ‚ùå Pourquoi ? WPF ne sait pas que Nom a chang√©.\nLa solution : INotifyPropertyChanged Pour que WPF d√©tecte les changements, la classe doit impl√©menter l‚Äôinterface INotifyPropertyChanged.\nClasse Personne am√©lior√©e :\nusing System.ComponentModel; public class Personne : INotifyPropertyChanged { private string nom; private int age; public string Nom { get { return nom; } set { nom = value; OnPropertyChanged(\"Nom\"); // Notifier le changement } } public int Age { get { return age; } set { age = value; OnPropertyChanged(\"Age\"); } } // √âv√©nement requis par l'interface public event PropertyChangedEventHandler PropertyChanged; // M√©thode pour d√©clencher l'√©v√©nement protected void OnPropertyChanged(string propertyName) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } Maintenant, √ßa fonctionne :\nPersonne p = new Personne { Nom = \"Alice\" }; this.DataContext = p; // Plus tard... p.Nom = \"Bob\"; // L'interface se met √† jour automatiquement ! ‚úÖ Explication d√©taill√©e Le patron Observateur (Observer Pattern) :\nUn objet (la source) notifie ses observateurs quand son √©tat change Les observateurs (ici, les contr√¥les WPF) √©coutent ces notifications Quand notifi√©s, ils se mettent √† jour Dans notre exemple :\nSource : La classe Personne Observateurs : Les TextBox et TextBlock Notification : PropertyChanged?.Invoke(...) Le ? (op√©rateur null-conditional) :\nPropertyChanged?.Invoke(...) = Si PropertyChanged n‚Äôest pas null, alors invoke √âvite une exception si personne n‚Äô√©coute Version moderne avec CallerMemberName Pour √©viter d‚Äô√©crire le nom de la propri√©t√© en string, on peut utiliser CallerMemberName :\nusing System.ComponentModel; using System.Runtime.CompilerServices; public class Personne : INotifyPropertyChanged { private string nom; private int age; public string Nom { get { return nom; } set { nom = value; OnPropertyChanged(); // Pas besoin de sp√©cifier \"Nom\" } } public int Age { get { return age; } set { age = value; OnPropertyChanged(); } } public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = \"\") { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } Avantage : Plus s√ªr (pas de risque de typo dans le nom de propri√©t√©).\nClasse de base r√©utilisable Pour √©viter de r√©√©crire le code dans chaque classe, cr√©ez une classe de base :\nBaseViewModel.cs :\nusing System.ComponentModel; using System.Runtime.CompilerServices; public class BaseViewModel : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = \"\") { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } Utilisation :\npublic class Personne : BaseViewModel { private string nom; public string Nom { get { return nom; } set { nom = value; OnPropertyChanged(); } } }",
    "description": "Partie 1 : Le patron Observateur (Contexte g√©n√©ral) Qu‚Äôest-ce qu‚Äôun patron de conception ? D√©finition simple : Un patron de conception est une solution √©prouv√©e √† un probl√®me r√©current en programmation.\nAnalogie : C‚Äôest comme une recette de cuisine. Si vous voulez faire un g√¢teau, vous n‚Äôinventez pas la m√©thode √† chaque fois ‚Äî vous suivez une recette qui a fait ses preuves.",
    "tags": [],
    "title": "Patron observateur",
    "uri": "/420-413/patron_observateur/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Le patron Commande (Contexte g√©n√©ral) Le probl√®me qu‚Äôil r√©sout Mise en situation : Un √©diteur de texte\nVous d√©veloppez un √©diteur de texte (comme Notepad). L‚Äôutilisateur peut :\nCouper du texte Copier du texte Coller du texte Annuler la derni√®re action Refaire une action annul√©e Question : Comment organiser tout √ßa ?\n‚ùå Approche na√Øve (code spaghetti) :\nprivate void btnCouper_Click(object sender, EventArgs e) { // Code pour couper string texteSelectionne = txtEditeur.SelectedText; presse-papiers = texteSelectionne; txtEditeur.SelectedText = \"\"; // Ajouter √† l'historique pour annuler historique.Add(new ActionCouper { Texte = texteSelectionne, Position = ... }); } private void btnCopier_Click(object sender, EventArgs e) { // Code pour copier presse-papiers = txtEditeur.SelectedText; // Ajouter √† l'historique historique.Add(new ActionCopier { Texte = ... }); } private void btnColler_Click(object sender, EventArgs e) { // Code pour coller txtEditeur.SelectedText = presse-papiers; // Ajouter √† l'historique historique.Add(new ActionColler { Texte = presse-papiers, Position = ... }); } private void btnAnnuler_Click(object sender, EventArgs e) { var derniere = historique.Last(); // üò± Comment annuler selon le type d'action ? if (derniere is ActionCouper) { // Code pour d√©faire une coupe } else if (derniere is ActionCopier) { // Code pour d√©faire une copie } else if (derniere is ActionColler) { // Code pour d√©faire un collage } // ... et ainsi de suite pour chaque type d'action ! } Probl√®mes :\nCode dupliqu√© : La logique d‚Äôannulation est √©parpill√©e partout Difficile √† tester : Impossible de tester une action sans l‚Äôinterface Pas r√©utilisable : Si on ajoute un raccourci clavier, il faut dupliquer le code Couplage fort : Les boutons sont directement coupl√©s √† la logique m√©tier Difficile √† √©tendre : Ajouter une nouvelle action n√©cessite de modifier plein d‚Äôendroits Le patron Commande ‚Äî La solution Principe central : Encapsuler une action dans un objet.\nAnalogie : Pensez √† une t√©l√©commande TV :\nChaque bouton est une commande (Volume+, Volume-, Chaine+, etc.) La t√©l√©commande ne sait pas comment augmenter le volume Elle envoie juste la commande ‚ÄúVolume+‚Äù √† la TV La TV ex√©cute la commande On peut enregistrer les commandes (macro) On peut annuler des commandes Diagramme conceptuel :\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ INTERFACE COMMANDE ‚îÇ\r‚îÇ + Executer() ‚îÇ\r‚îÇ + Annuler() ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚ñ≥\r‚îÇ impl√©mente\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ ‚îÇ ‚îÇ\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇCommande ‚îÇ ‚îÇCommande ‚îÇ ‚îÇCommande ‚îÇ\r‚îÇCouper ‚îÇ ‚îÇCopier ‚îÇ ‚îÇColler ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ INVOCATEUR ‚îÇ\r‚îÇ (Bouton, raccourci) ‚îÇ\r‚îÇ - commande: ICommande ‚îÇ\r‚îÇ + AppuiSurBouton() ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ\r‚îÇ utilise\r‚Üì\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ R√âCEPTEUR ‚îÇ\r‚îÇ (EditeurTexte) ‚îÇ\r‚îÇ + Couper() ‚îÇ\r‚îÇ + Copier() ‚îÇ\r‚îÇ + Coller() ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Impl√©mentation compl√®te √âtape 1 : Interface Commande\npublic interface ICommande { void Executer(); void Annuler(); } √âtape 2 : Le R√©cepteur (celui qui fait le vrai travail)\npublic class EditeurTexte { private StringBuilder contenu = new StringBuilder(); private string presse_papiers = \"\"; public string Contenu =\u003e contenu.ToString(); public void Couper(int debut, int longueur) { presse_papiers = contenu.ToString(debut, longueur); contenu.Remove(debut, longueur); Console.WriteLine($\"‚úÇÔ∏è Texte coup√© : '{presse_papiers}'\"); } public void Copier(int debut, int longueur) { presse_papiers = contenu.ToString(debut, longueur); Console.WriteLine($\"üìã Texte copi√© : '{presse_papiers}'\"); } public void Coller(int position) { contenu.Insert(position, presse_papiers); Console.WriteLine($\"üìå Texte coll√© : '{presse_papiers}' √† la position {position}\"); } public void AjouterTexte(string texte) { contenu.Append(texte); } public void Afficher() { Console.WriteLine($\"üìÑ Contenu : '{Contenu}'\"); } } √âtape 3 : Les Commandes concr√®tes\n// Commande Couper public class CommandeCouper : ICommande { private EditeurTexte editeur; private int debut; private int longueur; private string texteCoupe; // Pour pouvoir annuler public CommandeCouper(EditeurTexte editeur, int debut, int longueur) { this.editeur = editeur; this.debut = debut; this.longueur = longueur; } public void Executer() { texteCoupe = editeur.Contenu.Substring(debut, longueur); editeur.Couper(debut, longueur); } public void Annuler() { // Restaurer le texte coup√© editeur.AjouterTexte(texteCoupe); Console.WriteLine($\"‚Ü©Ô∏è Annulation : texte '{texteCoupe}' restaur√©\"); } } // Commande Copier public class CommandeCopier : ICommande { private EditeurTexte editeur; private int debut; private int longueur; public CommandeCopier(EditeurTexte editeur, int debut, int longueur) { this.editeur = editeur; this.debut = debut; this.longueur = longueur; } public void Executer() { editeur.Copier(debut, longueur); } public void Annuler() { // Copier ne modifie pas le texte, donc pas besoin d'annuler Console.WriteLine(\"‚Ü©Ô∏è Copier annul√© (aucun changement au texte)\"); } } // Commande Coller public class CommandeColler : ICommande { private EditeurTexte editeur; private int position; private int longueurCollee; public CommandeColler(EditeurTexte editeur, int position) { this.editeur = editeur; this.position = position; } public void Executer() { // On suppose qu'on conna√Æt la longueur du presse-papiers editeur.Coller(position); } public void Annuler() { // Retirer le texte coll√© Console.WriteLine($\"‚Ü©Ô∏è Annulation du collage\"); } } √âtape 4 : L‚ÄôInvocateur (gestionnaire de commandes)\npublic class GestionnaireCommandes { private Stack\u003cICommande\u003e historique = new Stack\u003cICommande\u003e(); private Stack\u003cICommande\u003e historiqueAnnule = new Stack\u003cICommande\u003e(); public void ExecuterCommande(ICommande commande) { commande.Executer(); historique.Push(commande); // Vider l'historique d'annulation (comme dans Word) historiqueAnnule.Clear(); } public void Annuler() { if (historique.Count == 0) { Console.WriteLine(\"‚ùå Rien √† annuler\"); return; } ICommande commande = historique.Pop(); commande.Annuler(); historiqueAnnule.Push(commande); } public void Refaire() { if (historiqueAnnule.Count == 0) { Console.WriteLine(\"‚ùå Rien √† refaire\"); return; } ICommande commande = historiqueAnnule.Pop(); commande.Executer(); historique.Push(commande); } } √âtape 5 : Utilisation\nclass Program { static void Main(string[] args) { // Cr√©er l'√©diteur et le gestionnaire EditeurTexte editeur = new EditeurTexte(); GestionnaireCommandes gestionnaire = new GestionnaireCommandes(); // Ajouter du texte initial Console.WriteLine(\"=== Initialisation ===\"); editeur.AjouterTexte(\"Bonjour le monde!\"); editeur.Afficher(); // Cr√©er et ex√©cuter des commandes Console.WriteLine(\"\\n=== Copier 'Bonjour' ===\"); ICommande copier = new CommandeCopier(editeur, 0, 7); gestionnaire.ExecuterCommande(copier); Console.WriteLine(\"\\n=== Coller √† la fin ===\"); ICommande coller = new CommandeColler(editeur, editeur.Contenu.Length); gestionnaire.ExecuterCommande(coller); editeur.Afficher(); Console.WriteLine(\"\\n=== Couper ' le monde' ===\"); ICommande couper = new CommandeCouper(editeur, 7, 9); gestionnaire.ExecuterCommande(couper); editeur.Afficher(); Console.WriteLine(\"\\n=== Annuler la derni√®re action ===\"); gestionnaire.Annuler(); editeur.Afficher(); Console.WriteLine(\"\\n=== Refaire ===\"); gestionnaire.Refaire(); editeur.Afficher(); } } Avantages du patron Commande 1. D√©couplage\n// Le bouton ne conna√Æt PAS l'√©diteur // Il conna√Æt seulement l'interface ICommande Button btnCouper = new Button(); btnCouper.Command = new CommandeCouper(editeur, 0, 5); 2. Historique automatique\n// Toutes les commandes sont automatiquement historis√©es // Annuler/Refaire gratuit ! 3. Testabilit√©\n[TestMethod] public void Test_CommandeCouper() { EditeurTexte editeur = new EditeurTexte(); editeur.AjouterTexte(\"Test\"); CommandeCouper cmd = new CommandeCouper(editeur, 0, 2); cmd.Executer(); Assert.AreEqual(\"st\", editeur.Contenu); } 4. R√©utilisabilit√©\n// M√™me commande utilisable de plusieurs fa√ßons ICommande couper = new CommandeCouper(editeur, 0, 5); // Via un bouton button.Command = couper; // Via un raccourci clavier if (e.Key == Key.X \u0026\u0026 e.Control) gestionnaire.ExecuterCommande(couper); // Via un menu menuItem.Command = couper; 5. Macros et scripts\n// On peut cr√©er des s√©quences de commandes List\u003cICommande\u003e macro = new List\u003cICommande\u003e { new CommandeCopier(editeur, 0, 5), new CommandeColler(editeur, 10), new CommandeCouper(editeur, 0, 5) }; // Ex√©cuter la macro foreach (var cmd in macro) gestionnaire.ExecuterCommande(cmd); Variantes du patron Commande 1. Commandes param√©tr√©es\npublic interface ICommande\u003cT\u003e { void Executer(T parametre); void Annuler(); } public class CommandeRechercher : ICommande\u003cstring\u003e { public void Executer(string motCle) { // Rechercher le mot-cl√© } public void Annuler() { // Annuler la recherche } } 2. Commandes asynchrones\npublic interface ICommandeAsync { Task ExecuterAsync(); Task AnnulerAsync(); } public class CommandeSauvegarder : ICommandeAsync { public async Task ExecuterAsync() { await SauvegarderDansFichierAsync(); } public async Task AnnulerAsync() { await RestaurerVersionPrecedenteAsync(); } } Le lien avec WPF ICommand (aper√ßu) WPF utilise le patron Commande !\n// ICommand dans WPF public interface ICommand { bool CanExecute(object parameter); // Peut-on ex√©cuter ? void Execute(object parameter); // Ex√©cuter event EventHandler CanExecuteChanged; // Notifier changement d'√©tat } Diff√©rences avec notre version :\nWPF n‚Äôa pas de m√©thode Annuler() (on peut l‚Äôajouter) WPF a CanExecute() pour activer/d√©sactiver les boutons WPF a un √©v√©nement pour notifier les changements d‚Äô√©tat Utilisation en WPF :\n\u003cButton Content=\"Sauvegarder\" Command=\"{Binding SauvegarderCommand}\" /\u003e Quand le bouton est cliqu√© :\nWPF v√©rifie CanExecute() ‚Üí Active/d√©sactive le bouton WPF appelle Execute() ‚Üí Ex√©cute l‚Äôaction C‚Äôest exactement le patron Commande appliqu√© √† WPF !",
    "description": "Le patron Commande (Contexte g√©n√©ral) Le probl√®me qu‚Äôil r√©sout Mise en situation : Un √©diteur de texte\nVous d√©veloppez un √©diteur de texte (comme Notepad). L‚Äôutilisateur peut :\nCouper du texte Copier du texte Coller du texte Annuler la derni√®re action Refaire une action annul√©e Question : Comment organiser tout √ßa ?",
    "tags": [],
    "title": "Patron commande",
    "uri": "/420-413/patron_commande/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": ": Injection de d√©pendances (Contexte g√©n√©ral) Le probl√®me des d√©pendances Mise en situation : Un syst√®me de notification\nVous d√©veloppez une application qui doit envoyer des notifications :\nPar email Par SMS Par notification push ‚ùå Approche na√Øve (d√©pendances c√¢bl√©es en dur) :\npublic class ServiceUtilisateur { private EmailService emailService; private SMSService smsService; public ServiceUtilisateur() { // Cr√©er les d√©pendances directement emailService = new EmailService(); smsService = new SMSService(); } public void EnregistrerUtilisateur(string nom, string email, string telephone) { // Logique d'enregistrement Console.WriteLine($\"Utilisateur {nom} enregistr√©\"); // Envoyer notifications emailService.Envoyer(email, \"Bienvenue !\"); smsService.Envoyer(telephone, \"Compte cr√©√©\"); } } Probl√®mes de cette approche :\nCouplage fort // ServiceUtilisateur D√âPEND DIRECTEMENT de EmailService et SMSService // Si EmailService change, ServiceUtilisateur doit changer aussi Difficile √† tester // Pour tester ServiceUtilisateur, je DOIS avoir un serveur email fonctionnel // Les emails seront vraiment envoy√©s pendant les tests ! Pas flexible // Et si je veux utiliser un autre service email ? // Je dois modifier ServiceUtilisateur Pas r√©utilisable // ServiceUtilisateur est li√© √† des impl√©mentations sp√©cifiques // Impossible de le r√©utiliser avec d'autres services Le principe d‚Äôinversion de d√©pendance (DIP) Principe fondamental : D√©pendre d‚Äôabstractions, pas de concr√©tions.\nAnalogie : Les prises √©lectriques\nTous vos appareils utilisent une prise standard (abstraction) Vous ne c√¢blez pas directement les appareils √† l‚Äôalimentation √©lectrique Vous pouvez brancher n‚Äôimporte quel appareil (machine √† caf√©, ordinateur, lampe) L‚Äôappareil ne sait pas d‚Äôo√π vient l‚Äô√©lectricit√© (centrale nucl√©aire, solaire, etc.) Diagramme :\n‚ùå AVANT (d√©pendance directe)\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ ServiceUtilisateur‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ\r‚îÇ d√©pend de\r‚Üì\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ EmailService ‚îÇ ‚Üê Classe concr√®te\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚úÖ APR√àS (inversion de d√©pendance)\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ ServiceUtilisateur‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îÇ\r‚îÇ d√©pend de\r‚Üì\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ INotification ‚îÇ ‚Üê Interface (abstraction)\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚ñ≥\r‚îÇ impl√©mente\r‚îå‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇEmail ‚îÇ ‚îÇ ‚îÇSMS ‚îÇ\r‚îÇService ‚îÇ ‚îÇ ‚îÇService ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇPush ‚îÇ\r‚îÇService ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Impl√©mentation compl√®te √âtape 1 : D√©finir l‚Äôabstraction (interface)\npublic interface INotificationService { void Envoyer(string destinataire, string message); } √âtape 2 : Cr√©er les impl√©mentations concr√®tes\n// Service Email public class EmailService : INotificationService { public void Envoyer(string destinataire, string message) { Console.WriteLine($\"üìß Email envoy√© √† {destinataire}: {message}\"); // Code r√©el pour envoyer un email } } // Service SMS public class SMSService : INotificationService { public void Envoyer(string destinataire, string message) { Console.WriteLine($\"üì± SMS envoy√© √† {destinataire}: {message}\"); // Code r√©el pour envoyer un SMS } } // Service Push public class PushNotificationService : INotificationService { public void Envoyer(string destinataire, string message) { Console.WriteLine($\"üîî Notification push √† {destinataire}: {message}\"); // Code r√©el pour envoyer une notification push } } // Faux service pour les tests public class FakeNotificationService : INotificationService { public List\u003cstring\u003e MessagesEnvoyes = new List\u003cstring\u003e(); public void Envoyer(string destinataire, string message) { MessagesEnvoyes.Add($\"{destinataire}: {message}\"); Console.WriteLine($\"üß™ [TEST] Message enregistr√© (non envoy√©)\"); } } √âtape 3 : Injection de d√©pendances\nIl existe 3 types d‚Äôinjection :\nType 1 : Injection par constructeur (recommand√©e)\npublic class ServiceUtilisateur { private readonly INotificationService notificationService; // La d√©pendance est INJECT√âE via le constructeur public ServiceUtilisateur(INotificationService notificationService) { this.notificationService = notificationService; } public void EnregistrerUtilisateur(string nom, string contact) { Console.WriteLine($\"‚úì Utilisateur {nom} enregistr√©\"); notificationService.Envoyer(contact, \"Bienvenue !\"); } } Utilisation :\n// En production : Email INotificationService emailService = new EmailService(); ServiceUtilisateur service = new ServiceUtilisateur(emailService); service.EnregistrerUtilisateur(\"Alice\", \"alice@email.com\"); // En test : Fake INotificationService fakeService = new FakeNotificationService(); ServiceUtilisateur serviceTest = new ServiceUtilisateur(fakeService); serviceTest.EnregistrerUtilisateur(\"Bob\", \"bob@test.com\"); Type 2 : Injection par propri√©t√©\npublic class ServiceUtilisateur { // Propri√©t√© publique public INotificationService NotificationService { get; set; } public void EnregistrerUtilisateur(string nom, string contact) { Console.WriteLine($\"‚úì Utilisateur {nom} enregistr√©\"); NotificationService.Envoyer(contact, \"Bienvenue !\"); } } Utilisation :\nServiceUtilisateur service = new ServiceUtilisateur(); service.NotificationService = new EmailService(); // Injection service.EnregistrerUtilisateur(\"Alice\", \"alice@email.com\"); Type 3 : Injection par m√©thode\npublic class ServiceUtilisateur { public void EnregistrerUtilisateur(string nom, string contact, INotificationService notificationService) { Console.WriteLine($\"‚úì Utilisateur {nom} enregistr√©\"); notificationService.Envoyer(contact, \"Bienvenue !\"); } } Utilisation :\nServiceUtilisateur service = new ServiceUtilisateur(); service.EnregistrerUtilisateur(\"Alice\", \"alice@email.com\", new EmailService()); Comparaison des types d‚Äôinjection Type Avantages Inconv√©nients Quand utiliser Constructeur - D√©pendances obligatoires\n- Immutabilit√© (readonly)\n- D√©pendances claires - Constructeur peut devenir long Par d√©faut (99% des cas) Propri√©t√© - D√©pendances optionnelles\n- Flexible - Risque d‚Äôoubli\n- Mutable D√©pendances optionnelles M√©thode - D√©pendance ponctuelle - R√©p√©titif\n- Pas de contr√¥le D√©pendance change souvent Conteneur d‚Äôinjection de d√©pendances (IoC Container) Probl√®me : Cr√©er toutes les d√©pendances manuellement devient fastidieux.\nSolution : Un conteneur IoC (Inversion of Control) g√®re la cr√©ation des objets.\nExemple avec Microsoft.Extensions.DependencyInjection :\nusing Microsoft.Extensions.DependencyInjection; class Program { static void Main(string[] args) { // 1. Cr√©er le conteneur var services = new ServiceCollection(); // 2. Enregistrer les d√©pendances services.AddTransient\u003cINotificationService, EmailService\u003e(); services.AddTransient\u003cServiceUtilisateur\u003e(); // 3. Construire le provider var serviceProvider = services.BuildServiceProvider(); // 4. R√©soudre automatiquement les d√©pendances var service = serviceProvider.GetService\u003cServiceUtilisateur\u003e(); // ‚Üë Le conteneur cr√©e automatiquement EmailService et l'injecte // 5. Utiliser service.EnregistrerUtilisateur(\"Alice\", \"alice@email.com\"); } } Dur√©es de vie :\n// Transient : Nouvelle instance √† chaque demande services.AddTransient\u003cINotificationService, EmailService\u003e(); // Scoped : Une instance par \"scope\" (requ√™te web par exemple) services.AddScoped\u003cINotificationService, EmailService\u003e(); // Singleton : UNE SEULE instance pour toute l'application services.AddSingleton\u003cINotificationService, EmailService\u003e(); Avantages de l‚Äôinjection de d√©pendances 1. Testabilit√©\n[TestMethod] public void Test_EnregistrerUtilisateur() { // Utiliser un faux service var fakeService = new FakeNotificationService(); var service = new ServiceUtilisateur(fakeService); service.EnregistrerUtilisateur(\"Bob\", \"bob@test.com\"); // V√©rifier qu'un message a √©t√© \"envoy√©\" Assert.AreEqual(1, fakeService.MessagesEnvoyes.Count); Assert.IsTrue(fakeService.MessagesEnvoyes[0].Contains(\"Bienvenue\")); } 2. Flexibilit√©\n// Basculer facilement entre impl√©mentations // En production services.AddTransient\u003cINotificationService, EmailService\u003e(); // En d√©veloppement services.AddTransient\u003cINotificationService, FakeNotificationService\u003e(); // Pas besoin de changer ServiceUtilisateur ! 3. D√©couplage\n// ServiceUtilisateur ne sait PAS quelle impl√©mentation il utilise // Il d√©pend seulement de l'interface INotificationService 4. Maintenabilit√©\n// Ajouter une nouvelle impl√©mentation ne n√©cessite PAS de modifier les classes existantes public class SlackService : INotificationService { ... } // Juste changer l'enregistrement services.AddTransient\u003cINotificationService, SlackService\u003e(); Le lien avec MVVM (aper√ßu) En MVVM, on injecte souvent des services dans les ViewModels :\npublic class ProduitViewModel { private readonly IProduitRepository repository; private readonly INotificationService notificationService; // Injection par constructeur public ProduitViewModel(IProduitRepository repository, INotificationService notificationService) { this.repository = repository; this.notificationService = notificationService; } public void AjouterProduit(Produit produit) { repository.Ajouter(produit); notificationService.Envoyer(\"admin@app.com\", \"Nouveau produit ajout√©\"); } } Avantages en MVVM :\n‚úÖ ViewModel testable sans interface graphique ‚úÖ R√©utilisable avec diff√©rents services ‚úÖ D√©coupl√© de l‚Äôimpl√©mentation des services",
    "description": ": Injection de d√©pendances (Contexte g√©n√©ral) Le probl√®me des d√©pendances Mise en situation : Un syst√®me de notification\nVous d√©veloppez une application qui doit envoyer des notifications :\nPar email Par SMS Par notification push ‚ùå Approche na√Øve (d√©pendances c√¢bl√©es en dur) :",
    "tags": [],
    "title": "Injection de d√©pendance",
    "uri": "/420-413/injection_dependance/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Le patron MVVM (Model-View-ViewModel) Qu‚Äôest-ce que MVVM ? MVVM = Model-View-ViewModel\nC‚Äôest un patron de conception (design pattern) qui organise le code d‚Äôune application WPF en 3 couches :\nCouche Responsabilit√© Fichier Model Les donn√©es brutes (classes m√©tier) Personne.cs, Produit.cs View L‚Äôinterface graphique (XAML) MainWindow.xaml ViewModel Logique de pr√©sentation, data binding MainViewModel.cs Pourquoi MVVM ? Probl√®me avec le code-behind (approche traditionnelle) :\n// MainWindow.xaml.cs public partial class MainWindow : Window { private void Button_Click(object sender, RoutedEventArgs e) { // Logique m√©tier m√©lang√©e avec l'UI string nom = txtNom.Text; double prix = double.Parse(txtPrix.Text); // Calculs... // Acc√®s base de donn√©es... // Mise √† jour de l'interface... } } Probl√®mes :\nLogique m√©lang√©e avec l‚Äôinterface Difficile √† tester Difficile √† r√©utiliser Code-behind devient √©norme Avec MVVM :\n‚úÖ S√©paration claire des responsabilit√©s ‚úÖ Code testable (ViewModel peut √™tre test√© sans UI) ‚úÖ R√©utilisable ‚úÖ Code-behind quasi vide Architecture MVVM View (XAML)\r‚Üï Data Binding\rViewModel (Logique de pr√©sentation)\r‚Üï Model (Donn√©es) R√®gles :\nLa View ne contient QUE du XAML (et un code-behind minimal) Le ViewModel ne conna√Æt PAS la View (pas de MessageBox, pas de txtNom.Text) Le Model ne conna√Æt ni View ni ViewModel Exemple complet MVVM : Gestion de produits √âtape 1 : Le Model Produit.cs\npublic class Produit { public int Id { get; set; } public string Nom { get; set; } public double Prix { get; set; } public int Stock { get; set; } } C‚Äôest juste une classe de donn√©es, rien de sp√©cial.\n√âtape 2 : Le ViewModel ProduitViewModel.cs\nusing System.Collections.ObjectModel; using System.ComponentModel; using System.Runtime.CompilerServices; public class ProduitViewModel : INotifyPropertyChanged { // Collection observable pour la liste public ObservableCollection\u003cProduit\u003e Produits { get; set; } // Produit s√©lectionn√© dans la liste private Produit produitSelectionne; public Produit ProduitSelectionne { get { return produitSelectionne; } set { produitSelectionne = value; OnPropertyChanged(); } } // Champs pour le nouveau produit private string nouveauNom; public string NouveauNom { get { return nouveauNom; } set { nouveauNom = value; OnPropertyChanged(); } } private double nouveauPrix; public double NouveauPrix { get { return nouveauPrix; } set { nouveauPrix = value; OnPropertyChanged(); } } private int nouveauStock; public int NouveauStock { get { return nouveauStock; } set { nouveauStock = value; OnPropertyChanged(); } } // Constructeur public ProduitViewModel() { Produits = new ObservableCollection\u003cProduit\u003e { new Produit { Id = 1, Nom = \"Clavier\", Prix = 49.99, Stock = 15 }, new Produit { Id = 2, Nom = \"Souris\", Prix = 29.99, Stock = 25 }, new Produit { Id = 3, Nom = \"√âcran\", Prix = 299.99, Stock = 8 } }; } // M√©thodes publiques (appel√©es par les boutons via Commands) public void AjouterProduit() { var nouveau = new Produit { Id = Produits.Count + 1, Nom = NouveauNom, Prix = NouveauPrix, Stock = NouveauStock }; Produits.Add(nouveau); // R√©initialiser les champs NouveauNom = \"\"; NouveauPrix = 0; NouveauStock = 0; } public void SupprimerProduit() { if (ProduitSelectionne != null) { Produits.Remove(ProduitSelectionne); } } // INotifyPropertyChanged public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = \"\") { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } √âtape 3 : La View MainWindow.xaml\n\u003cWindow x:Class=\"GestionProduits.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"Gestion de Produits - MVVM\" Height=\"500\" Width=\"700\"\u003e \u003cGrid Margin=\"15\"\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"50\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003c/Grid.RowDefinitions\u003e \u003c!-- Titre --\u003e \u003cTextBlock Grid.Row=\"0\" Text=\"üì¶ Gestion de Produits\" FontSize=\"24\" FontWeight=\"Bold\" VerticalAlignment=\"Center\" /\u003e \u003c!-- Contenu --\u003e \u003cGrid Grid.Row=\"1\" Margin=\"0,10,0,0\"\u003e \u003cGrid.ColumnDefinitions\u003e \u003cColumnDefinition Width=\"2*\" /\u003e \u003cColumnDefinition Width=\"*\" /\u003e \u003c/Grid.ColumnDefinitions\u003e \u003c!-- Liste des produits (gauche) --\u003e \u003cDataGrid Grid.Column=\"0\" ItemsSource=\"{Binding Produits}\" SelectedItem=\"{Binding ProduitSelectionne}\" AutoGenerateColumns=\"False\" Margin=\"0,0,10,0\"\u003e \u003cDataGrid.Columns\u003e \u003cDataGridTextColumn Header=\"ID\" Binding=\"{Binding Id}\" Width=\"50\" /\u003e \u003cDataGridTextColumn Header=\"Nom\" Binding=\"{Binding Nom}\" Width=\"*\" /\u003e \u003cDataGridTextColumn Header=\"Prix\" Binding=\"{Binding Prix, StringFormat={}{0:C}}\" Width=\"100\" /\u003e \u003cDataGridTextColumn Header=\"Stock\" Binding=\"{Binding Stock}\" Width=\"80\" /\u003e \u003c/DataGrid.Columns\u003e \u003c/DataGrid\u003e \u003c!-- Panneau de contr√¥le (droite) --\u003e \u003cBorder Grid.Column=\"1\" BorderBrush=\"LightGray\" BorderThickness=\"1\" Padding=\"10\"\u003e \u003cStackPanel\u003e \u003cTextBlock Text=\"Ajouter un produit\" FontWeight=\"Bold\" FontSize=\"16\" Margin=\"0,0,0,15\" /\u003e \u003cLabel Content=\"Nom :\" /\u003e \u003cTextBox Text=\"{Binding NouveauNom}\" Height=\"30\" Margin=\"0,0,0,10\" /\u003e \u003cLabel Content=\"Prix :\" /\u003e \u003cTextBox Text=\"{Binding NouveauPrix}\" Height=\"30\" Margin=\"0,0,0,10\" /\u003e \u003cLabel Content=\"Stock :\" /\u003e \u003cTextBox Text=\"{Binding NouveauStock}\" Height=\"30\" Margin=\"0,0,0,20\" /\u003e \u003cButton Content=\"Ajouter\" Height=\"40\" Background=\"Green\" Foreground=\"White\" Click=\"BtnAjouter_Click\" Margin=\"0,0,0,10\" /\u003e \u003cButton Content=\"Supprimer\" Height=\"40\" Background=\"Red\" Foreground=\"White\" Click=\"BtnSupprimer_Click\" /\u003e \u003c/StackPanel\u003e \u003c/Border\u003e \u003c/Grid\u003e \u003c/Grid\u003e \u003c/Window\u003e √âtape 4 : Code-behind (minimal) MainWindow.xaml.cs\nusing System.Windows; namespace GestionProduits { public partial class MainWindow : Window { private ProduitViewModel viewModel; public MainWindow() { InitializeComponent(); // Cr√©er et assigner le ViewModel viewModel = new ProduitViewModel(); this.DataContext = viewModel; } private void BtnAjouter_Click(object sender, RoutedEventArgs e) { viewModel.AjouterProduit(); } private void BtnSupprimer_Click(object sender, RoutedEventArgs e) { viewModel.SupprimerProduit(); } } } ObservableCollection vs List Pourquoi ObservableCollection et pas List ?\n// ‚ùå Avec List - l'interface ne se met pas √† jour public List\u003cProduit\u003e Produits { get; set; } // ‚úÖ Avec ObservableCollection - l'interface se met √† jour automatiquement public ObservableCollection\u003cProduit\u003e Produits { get; set; } ObservableCollection\u003cT\u003e impl√©mente automatiquement INotifyCollectionChanged :\nQuand on ajoute un √©l√©ment : l‚Äôinterface se met √† jour Quand on supprime un √©l√©ment : l‚Äôinterface se met √† jour Commands (am√©lioration avanc√©e) Dans un MVVM pur, on ne devrait pas avoir de Click=\"...\" dans le XAML. √Ä la place, on utilise des Commands.\nRelayCommand.cs (classe utilitaire) :\nusing System; using System.Windows.Input; public class RelayCommand : ICommand { private Action execute; private Func\u003cbool\u003e canExecute; public RelayCommand(Action execute, Func\u003cbool\u003e canExecute = null) { this.execute = execute; this.canExecute = canExecute; } public event EventHandler CanExecuteChanged { add { CommandManager.RequerySuggested += value; } remove { CommandManager.RequerySuggested -= value; } } public bool CanExecute(object parameter) { return canExecute == null || canExecute(); } public void Execute(object parameter) { execute(); } } ProduitViewModel avec Commands :\npublic class ProduitViewModel : INotifyPropertyChanged { // ... propri√©t√©s ... public ICommand AjouterCommand { get; } public ICommand SupprimerCommand { get; } public ProduitViewModel() { // ... initialisation ... AjouterCommand = new RelayCommand(AjouterProduit); SupprimerCommand = new RelayCommand(SupprimerProduit, () =\u003e ProduitSelectionne != null); } // ... m√©thodes ... } XAML avec Commands :\n\u003cButton Content=\"Ajouter\" Command=\"{Binding AjouterCommand}\" /\u003e \u003cButton Content=\"Supprimer\" Command=\"{Binding SupprimerCommand}\" /\u003e Avantage : Aucun code-behind n√©cessaire !",
    "description": "Le patron MVVM (Model-View-ViewModel) Qu‚Äôest-ce que MVVM ? MVVM = Model-View-ViewModel\nC‚Äôest un patron de conception (design pattern) qui organise le code d‚Äôune application WPF en 3 couches :\nCouche Responsabilit√© Fichier Model Les donn√©es brutes (classes m√©tier) Personne.cs, Produit.cs View L‚Äôinterface graphique (XAML) MainWindow.xaml ViewModel Logique de pr√©sentation, data binding MainViewModel.cs Pourquoi MVVM ? Probl√®me avec le code-behind (approche traditionnelle) :",
    "tags": [],
    "title": "MVVM",
    "uri": "/420-413/mvvm/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Mini-projets progressifs Mini-projet 1 : Calculatrice avec historique Niveau : ‚≠ê‚≠ê Interm√©diaire\nObjectifs p√©dagogiques Patron Commande (annuler/refaire) INotifyPropertyChanged Data Binding de base Sp√©cifications Fonctionnalit√©s :\nOp√©rations : Addition, Soustraction, Multiplication, Division Historique des calculs Annuler/Refaire les op√©rations Effacer l‚Äôhistorique Interface :\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ CALCULATRICE ‚îÇ\r‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r‚îÇ R√©sultat: [0] ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ [7] [8] [9] [√∑] ‚îÇ\r‚îÇ [4] [5] [6] [√ó] ‚îÇ\r‚îÇ [1] [2] [3] [-] ‚îÇ\r‚îÇ [0] [.] [=] [+] ‚îÇ\r‚îÇ ‚îÇ\r‚îÇ [‚Ü© Annuler] [‚Ü™ Refaire] [C] ‚îÇ\r‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r‚îÇ HISTORIQUE ‚îÇ\r‚îÇ - 5 + 3 = 8 ‚îÇ\r‚îÇ - 8 √ó 2 = 16 ‚îÇ\r‚îÇ - 16 √∑ 4 = 4 ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Structure du projet // Models/Operation.cs public class Operation { public double Operande1 { get; set; } public double Operande2 { get; set; } public string Operateur { get; set; } public double Resultat { get; set; } public override string ToString() { return $\"{Operande1} {Operateur} {Operande2} = {Resultat}\"; } } // Commands/ICommande.cs public interface ICommande { void Executer(); void Annuler(); } // Commands/CommandeCalculer.cs public class CommandeCalculer : ICommande { private CalculatriceViewModel viewModel; private Operation operation; private double resultatPrecedent; public CommandeCalculer(CalculatriceViewModel vm, Operation op) { viewModel = vm; operation = op; resultatPrecedent = vm.Resultat; } public void Executer() { // Calculer selon l'op√©rateur switch (operation.Operateur) { case \"+\": operation.Resultat = operation.Operande1 + operation.Operande2; break; // ... autres op√©rations } viewModel.Resultat = operation.Resultat; viewModel.Historique.Add(operation); } public void Annuler() { viewModel.Resultat = resultatPrecedent; viewModel.Historique.Remove(operation); } } // ViewModels/CalculatriceViewModel.cs public class CalculatriceViewModel : BaseViewModel { private double resultat; public double Resultat { get =\u003e resultat; set =\u003e SetProperty(ref resultat, value); } public ObservableCollection\u003cOperation\u003e Historique { get; set; } private Stack\u003cICommande\u003e historiqueCommandes = new Stack\u003cICommande\u003e(); private Stack\u003cICommande\u003e commandesAnnulees = new Stack\u003cICommande\u003e(); public ICommand CalculerCommand { get; } public ICommand AnnulerCommand { get; } public ICommand RefaireCommand { get; } // ... impl√©mentation } Crit√®res de r√©ussite Les 4 op√©rations fonctionnent correctement L‚Äôhistorique se met √† jour automatiquement Annuler restaure le r√©sultat pr√©c√©dent Refaire r√©applique l‚Äôop√©ration annul√©e Gestion des erreurs (division par z√©ro) Mini-projet 2 : Gestionnaire de t√¢ches avec priorit√©s Niveau : ‚≠ê‚≠ê‚≠ê Interm√©diaire-Avanc√©\nObjectifs p√©dagogiques MVVM complet ObservableCollection Filtrage et tri Sauvegarde/chargement (JSON) Sp√©cifications Fonctionnalit√©s :\nAjouter/modifier/supprimer des t√¢ches Marquer comme termin√© Assigner des priorit√©s (Haute, Moyenne, Basse) Filtrer par statut et priorit√© Trier par date, priorit√©, ou titre Recherche par mots-cl√©s Statistiques (nombre de t√¢ches par statut/priorit√©) Sauvegarder/charger depuis un fichier Interface :\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r‚îÇ GESTIONNAIRE DE T√ÇCHES ‚îÇ\r‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r‚îÇ [üîç Rechercher...] [Filtre: Tous ‚ñº] [Tri: Date ‚ñº]‚îÇ\r‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r‚îÇ ‚òê Terminer le rapport [üî¥ Haute] 2024-02-20 ‚îÇ\r‚îÇ ‚òë R√©pondre aux emails [üü° Moyenne] 2024-02-19 ‚îÇ\r‚îÇ ‚òê R√©viser pour l'examen [üî¥ Haute] 2024-02-25 ‚îÇ\r‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r‚îÇ Nouvelle t√¢che: ‚îÇ\r‚îÇ Titre: [____________________] ‚îÇ\r‚îÇ Priorit√©: [Moyenne ‚ñº] ‚îÇ\r‚îÇ Date limite: [üìÖ 2024-02-20] ‚îÇ\r‚îÇ [‚ûï Ajouter] [‚úèÔ∏è Modifier] [üóëÔ∏è Supprimer] ‚îÇ\r‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r‚îÇ üìä STATISTIQUES ‚îÇ\r‚îÇ Total: 3 | En cours: 2 | Termin√©es: 1 ‚îÇ\r‚îÇ üî¥ Haute: 2 üü° Moyenne: 1 üü¢ Basse: 0 ‚îÇ\r‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Structure du projet // Models/Tache.cs public class Tache : BaseViewModel { public int Id { get; set; } private string titre; public string Titre { get =\u003e titre; set =\u003e SetProperty(ref titre, value); } private bool estTerminee; public bool EstTerminee { get =\u003e estTerminee; set =\u003e SetProperty(ref estTerminee, value); } private Priorite priorite; public Priorite Priorite { get =\u003e priorite; set =\u003e SetProperty(ref priorite, value); } private DateTime dateLimite; public DateTime DateLimite { get =\u003e dateLimite; set =\u003e SetProperty(ref dateLimite, value); } public DateTime DateCreation { get; set; } } // Models/Priorite.cs (enum) public enum Priorite { Basse, Moyenne, Haute } // Services/ITacheRepository.cs public interface ITacheRepository { List\u003cTache\u003e ChargerTaches(); void SauvegarderTaches(List\u003cTache\u003e taches); } // Services/TacheRepository.cs public class TacheRepository : ITacheRepository { private readonly string cheminFichier = \"taches.json\"; public List\u003cTache\u003e ChargerTaches() { if (!File.Exists(cheminFichier)) return new List\u003cTache\u003e(); string json = File.ReadAllText(cheminFichier); return JsonSerializer.Deserialize\u003cList\u003cTache\u003e\u003e(json); } public void SauvegarderTaches(List\u003cTache\u003e taches) { string json = JsonSerializer.Serialize(taches, new JsonSerializerOptions { WriteIndented = true }); File.WriteAllText(cheminFichier, json); } } // ViewModels/TachesViewModel.cs public class TachesViewModel : BaseViewModel { private readonly ITacheRepository repository; private ObservableCollection\u003cTache\u003e toutesLesTaches; public ObservableCollection\u003cTache\u003e TachesAffichees { get; set; } // Propri√©t√©s de filtrage private string rechercheTexte; public string RechercheTexte { get =\u003e rechercheTexte; set { SetProperty(ref rechercheTexte, value); AppliquerFiltres(); } } private string filtreStatut = \"Tous\"; public string FiltreStatut { get =\u003e filtreStatut; set { SetProperty(ref filtreStatut, value); AppliquerFiltres(); } } // Statistiques public int NombreTotal =\u003e toutesLesTaches.Count; public int NombreEnCours =\u003e toutesLesTaches.Count(t =\u003e !t.EstTerminee); public int NombreTerminees =\u003e toutesLesTaches.Count(t =\u003e t.EstTerminee); public int NombreHaute =\u003e toutesLesTaches.Count(t =\u003e t.Priorite == Priorite.Haute); // Commandes public ICommand AjouterCommand { get; } public ICommand ModifierCommand { get; } public ICommand SupprimerCommand { get; } public ICommand SauvegarderCommand { get; } // Constructeur avec injection de d√©pendances public TachesViewModel(ITacheRepository repository) { this.repository = repository; TachesAffichees = new ObservableCollection\u003cTache\u003e(); toutesLesTaches = new ObservableCollection\u003cTache\u003e(); // S'abonner aux changements pour mettre √† jour les stats toutesLesTaches.CollectionChanged += (s, e) =\u003e MettreAJourStatistiques(); // Initialiser les commandes AjouterCommand = new RelayCommand(AjouterTache, PeutAjouter); SupprimerCommand = new RelayCommand(SupprimerTache, PeutSupprimer); SauvegarderCommand = new RelayCommand(Sauvegarder); // Charger les t√¢ches ChargerTaches(); } private void ChargerTaches() { var taches = repository.ChargerTaches(); toutesLesTaches.Clear(); foreach (var tache in taches) { toutesLesTaches.Add(tache); } AppliquerFiltres(); } private void AppliquerFiltres() { TachesAffichees.Clear(); var resultats = toutesLesTaches.AsEnumerable(); // Filtre de recherche if (!string.IsNullOrWhiteSpace(RechercheTexte)) { resultats = resultats.Where(t =\u003e t.Titre.Contains(RechercheTexte, StringComparison.OrdinalIgnoreCase)); } // Filtre de statut if (FiltreStatut == \"En cours\") resultats = resultats.Where(t =\u003e !t.EstTerminee); else if (FiltreStatut == \"Termin√©es\") resultats = resultats.Where(t =\u003e t.EstTerminee); foreach (var tache in resultats) { TachesAffichees.Add(tache); } } private void MettreAJourStatistiques() { OnPropertyChanged(nameof(NombreTotal)); OnPropertyChanged(nameof(NombreEnCours)); OnPropertyChanged(nameof(NombreTerminees)); OnPropertyChanged(nameof(NombreHaute)); } private void Sauvegarder() { repository.SauvegarderTaches(toutesLesTaches.ToList()); } } Crit√®res de r√©ussite CRUD complet (Create, Read, Update, Delete) Filtres et recherche fonctionnels Statistiques mises √† jour automatiquement Sauvegarde/chargement persistant Interface responsive Validation des donn√©es Mini-projet 3 : Application de chat avec patron Observateur Niveau : ‚≠ê‚≠ê‚≠ê Avanc√©\nObjectifs p√©dagogiques Patron Observateur avanc√© Services avec injection de d√©pendances Gestion d‚Äô√©tat complexe Temps r√©el (simulation) Sp√©cifications Fonctionnalit√©s :\nSalons de discussion multiples Envoi/r√©ception de messages Notifications en temps r√©el Liste des utilisateurs connect√©s Indicateur ‚Äúen train d‚Äô√©crire‚Ä¶‚Äù Historique des messages Recherche dans les messages Architecture :\n- IChatService (abstraction)\r- ChatService (impl√©mentation r√©elle)\r- FakeChatService (pour tests)\r- Observateurs:\r- IMessageObservateur\r- IUtilisateurObservateur\r- INotificationObservateur Structure du projet // Models/Message.cs public class Message { public int Id { get; set; } public string Expediteur { get; set; } public string Contenu { get; set; } public DateTime Horodatage { get; set; } public string SalonId { get; set; } } // Models/Salon.cs public class Salon { public string Id { get; set; } public string Nom { get; set; } public ObservableCollection\u003cMessage\u003e Messages { get; set; } public ObservableCollection\u003cstring\u003e UtilisateursConnectes { get; set; } } // Services/IChatService.cs public interface IChatService { void AbonnerMessages(IMessageObservateur observateur); void DesabonnerMessages(IMessageObservateur observateur); void EnvoyerMessage(string salonId, string expediteur, string contenu); List\u003cMessage\u003e ObtenirHistorique(string salonId); void RejoindreSalon(string salonId, string utilisateur); void QuitterSalon(string salonId, string utilisateur); } // Services/ChatService.cs public class ChatService : IChatService { private List\u003cIMessageObservateur\u003e observateursMessages = new List\u003cIMessageObservateur\u003e(); private Dictionary\u003cstring, Salon\u003e salons = new Dictionary\u003cstring, Salon\u003e(); public void AbonnerMessages(IMessageObservateur observateur) { observateursMessages.Add(observateur); } public void EnvoyerMessage(string salonId, string expediteur, string contenu) { var message = new Message { Id = GenererId(), SalonId = salonId, Expediteur = expediteur, Contenu = contenu, Horodatage = DateTime.Now }; if (!salons.ContainsKey(salonId)) salons[salonId] = new Salon { Id = salonId, Messages = new ObservableCollection\u003cMessage\u003e() }; salons[salonId].Messages.Add(message); // Notifier tous les observateurs foreach (var obs in observateursMessages) { obs.NouveauMessage(message); } } // Simulation de messages entrants (autre utilisateur) public void SimulerReception(string salonId) { var random = new Random(); var expediteurs = new[] { \"Alice\", \"Bob\", \"Charlie\" }; var messages = new[] { \"Salut!\", \"Comment √ßa va?\", \"Avez-vous vu le dernier rapport?\" }; string expediteur = expediteurs[random.Next(expediteurs.Length)]; string contenu = messages[random.Next(messages.Length)]; EnvoyerMessage(salonId, expediteur, contenu); } } // Observateurs/IMessageObservateur.cs public interface IMessageObservateur { void NouveauMessage(Message message); } // ViewModels/ChatViewModel.cs public class ChatViewModel : BaseViewModel, IMessageObservateur { private readonly IChatService chatService; private Salon salonActuel; public Salon SalonActuel { get =\u003e salonActuel; set =\u003e SetProperty(ref salonActuel, value); } public ObservableCollection\u003cSalon\u003e Salons { get; set; } private string messageActuel; public string MessageActuel { get =\u003e messageActuel; set =\u003e SetProperty(ref messageActuel, value); } private string utilisateurActuel; public string UtilisateurActuel { get; set; } public ICommand EnvoyerMessageCommand { get; } public ICommand ChangerSalonCommand { get; } public ChatViewModel(IChatService chatService) { this.chatService = chatService; // S'abonner aux nouveaux messages chatService.AbonnerMessages(this); Salons = new ObservableCollection\u003cSalon\u003e(); EnvoyerMessageCommand = new RelayCommand(EnvoyerMessage, PeutEnvoyer); ChangerSalonCommand = new RelayCommand\u003cSalon\u003e(ChangerSalon); InitialiserSalons(); } private void InitialiserSalons() { Salons.Add(new Salon { Id = \"general\", Nom = \"G√©n√©ral\", Messages = new ObservableCollection\u003cMessage\u003e() }); Salons.Add(new Salon { Id = \"technique\", Nom = \"Technique\", Messages = new ObservableCollection\u003cMessage\u003e() }); SalonActuel = Salons[0]; } // Impl√©mentation de IMessageObservateur public void NouveauMessage(Message message) { // Trouver le salon correspondant var salon = Salons.FirstOrDefault(s =\u003e s.Id == message.SalonId); if (salon != null) { // WPF n√©cessite d'√™tre sur le thread UI Application.Current.Dispatcher.Invoke(() =\u003e { salon.Messages.Add(message); // Notification si ce n'est pas le salon actuel if (salon != SalonActuel) { // Afficher une notification } }); } } private void EnvoyerMessage() { chatService.EnvoyerMessage(SalonActuel.Id, UtilisateurActuel, MessageActuel); MessageActuel = \"\"; } private bool PeutEnvoyer() { return !string.IsNullOrWhiteSpace(MessageActuel); } } XAML sugg√©r√© \u003cGrid\u003e \u003cGrid.ColumnDefinitions\u003e \u003cColumnDefinition Width=\"200\"/\u003e \u003cColumnDefinition Width=\"*\"/\u003e \u003c/Grid.ColumnDefinitions\u003e \u003c!-- Liste des salons --\u003e \u003cListBox Grid.Column=\"0\" ItemsSource=\"{Binding Salons}\" SelectedItem=\"{Binding SalonActuel}\" DisplayMemberPath=\"Nom\"/\u003e \u003c!-- Zone de chat --\u003e \u003cGrid Grid.Column=\"1\"\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"*\"/\u003e \u003cRowDefinition Height=\"Auto\"/\u003e \u003c/Grid.RowDefinitions\u003e \u003c!-- Messages --\u003e \u003cListBox Grid.Row=\"0\" ItemsSource=\"{Binding SalonActuel.Messages}\"\u003e \u003cListBox.ItemTemplate\u003e \u003cDataTemplate\u003e \u003cStackPanel Margin=\"5\"\u003e \u003cTextBlock Text=\"{Binding Expediteur}\" FontWeight=\"Bold\"/\u003e \u003cTextBlock Text=\"{Binding Contenu}\"/\u003e \u003cTextBlock Text=\"{Binding Horodatage}\" FontSize=\"10\" Foreground=\"Gray\"/\u003e \u003c/StackPanel\u003e \u003c/DataTemplate\u003e \u003c/ListBox.ItemTemplate\u003e \u003c/ListBox\u003e \u003c!-- Zone de saisie --\u003e \u003cStackPanel Grid.Row=\"1\" Orientation=\"Horizontal\" Margin=\"5\"\u003e \u003cTextBox Text=\"{Binding MessageActuel, UpdateSourceTrigger=PropertyChanged}\" Width=\"400\"/\u003e \u003cButton Content=\"Envoyer\" Command=\"{Binding EnvoyerMessageCommand}\" Width=\"80\" Margin=\"5,0,0,0\"/\u003e \u003c/StackPanel\u003e \u003c/Grid\u003e \u003c/Grid\u003e Crit√®res de r√©ussite Plusieurs salons fonctionnent ind√©pendamment Messages apparaissent en temps r√©el Notification pour nouveau message Changement de salon fluide Historique conserv√© Tests unitaires du ChatService Mini-projet 4 : Gestion d‚Äôinventaire avec commandes et injection Niveau : ‚≠ê‚≠ê‚≠ê‚≠ê Avanc√©\nObjectifs p√©dagogiques Architecture compl√®te MVVM Patron Commande complet Injection de d√©pendances avanc√©e Repository pattern Validation Export/Import de donn√©es Sp√©cifications Fonctionnalit√©s :\nGestion compl√®te de produits (CRUD) Cat√©gories de produits Gestion des stocks (entr√©es/sorties) Alertes de stock faible Historique des mouvements Recherche et filtres avanc√©s Export Excel/CSV Rapports statistiques Architecture :\nServices/\r- IProduitRepository\r- ICategorieRepository - IExportService\r- IValidationService\rCommands/\r- CommandeAjouterProduit\r- CommandeModifierProduit\r- CommandeSupprimerProduit\r- CommandeAjusterStock\rViewModels/\r- MainViewModel (orchestrateur)\r- ProduitsViewModel\r- CategoriesViewModel\r- StockViewModel\r- RapportsViewModel Exemple de structure partielle // Models/Produit.cs public class Produit : BaseViewModel { public int Id { get; set; } private string nom; public string Nom { get =\u003e nom; set =\u003e SetProperty(ref nom, value); } private decimal prix; public decimal Prix { get =\u003e prix; set =\u003e SetProperty(ref prix, value); } private int quantiteStock; public int QuantiteStock { get =\u003e quantiteStock; set { SetProperty(ref quantiteStock, value); OnPropertyChanged(nameof(EstEnRupture)); OnPropertyChanged(nameof(EstStockFaible)); } } public int SeuilAlerte { get; set; } = 10; public bool EstEnRupture =\u003e QuantiteStock == 0; public bool EstStockFaible =\u003e QuantiteStock \u003e 0 \u0026\u0026 QuantiteStock \u003c= SeuilAlerte; private Categorie categorie; public Categorie Categorie { get =\u003e categorie; set =\u003e SetProperty(ref categorie, value); } } // Services/IProduitRepository.cs public interface IProduitRepository { Task\u003cList\u003cProduit\u003e\u003e ObtenirTousAsync(); Task\u003cProduit\u003e ObtenirParIdAsync(int id); Task\u003cProduit\u003e AjouterAsync(Produit produit); Task ModifierAsync(Produit produit); Task SupprimerAsync(int id); Task\u003cList\u003cProduit\u003e\u003e RechercherAsync(string critere); } // Services/IExportService.cs public interface IExportService { void ExporterCSV(List\u003cProduit\u003e produits, string cheminFichier); void ExporterExcel(List\u003cProduit\u003e produits, string cheminFichier); } // Commands/CommandeAjouterProduit.cs public class CommandeAjouterProduit : ICommande { private readonly IProduitRepository repository; private readonly ObservableCollection\u003cProduit\u003e collection; private Produit produit; private Produit produitAjoute; public CommandeAjouterProduit(IProduitRepository repository, ObservableCollection\u003cProduit\u003e collection, Produit produit) { this.repository = repository; this.collection = collection; this.produit = produit; } public async void Executer() { produitAjoute = await repository.AjouterAsync(produit); collection.Add(produitAjoute); } public async void Annuler() { await repository.SupprimerAsync(produitAjoute.Id); collection.Remove(produitAjoute); } } // ViewModels/ProduitsViewModel.cs public class ProduitsViewModel : BaseViewModel { private readonly IProduitRepository repository; private readonly IValidationService validationService; private readonly GestionnaireCommandes gestionnaireCommandes; public ObservableCollection\u003cProduit\u003e Produits { get; set; } public ObservableCollection\u003cProduit\u003e ProduitsAffichees { get; set; } public ObservableCollection\u003cCategorie\u003e Categories { get; set; } // Propri√©t√©s pour le formulaire private Produit produitSelectionne; public Produit ProduitSelectionne { get =\u003e produitSelectionne; set =\u003e SetProperty(ref produitSelectionne, value); } // Statistiques public int NombreProduits =\u003e Produits.Count; public int NombreRuptures =\u003e Produits.Count(p =\u003e p.EstEnRupture); public int NombreAlertes =\u003e Produits.Count(p =\u003e p.EstStockFaible); public decimal ValeurTotaleStock =\u003e Produits.Sum(p =\u003e p.Prix * p.QuantiteStock); // Commandes public ICommand AjouterCommand { get; } public ICommand ModifierCommand { get; } public ICommand SupprimerCommand { get; } public ICommand AnnulerCommand { get; } public ICommand RefaireCommand { get; } public ICommand ExporterCommand { get; } // Constructeur avec injection public ProduitsViewModel(IProduitRepository repository, IValidationService validationService) { this.repository = repository; this.validationService = validationService; this.gestionnaireCommandes = new GestionnaireCommandes(); Produits = new ObservableCollection\u003cProduit\u003e(); ProduitsAffichees = new ObservableCollection\u003cProduit\u003e(); AjouterCommand = new RelayCommand(AjouterProduit, PeutAjouter); AnnulerCommand = new RelayCommand(() =\u003e gestionnaireCommandes.Annuler()); ChargerProduitsAsync(); } private async void ChargerProduitsAsync() { var produits = await repository.ObtenirTousAsync(); Produits.Clear(); foreach (var p in produits) { Produits.Add(p); } AppliquerFiltres(); } private void AjouterProduit() { // Valider d'abord var erreurs = validationService.ValiderProduit(ProduitSelectionne); if (erreurs.Any()) { // Afficher les erreurs return; } // Cr√©er et ex√©cuter la commande var commande = new CommandeAjouterProduit(repository, Produits, ProduitSelectionne); gestionnaireCommandes.ExecuterCommande(commande); MettreAJourStatistiques(); } } Crit√®res de r√©ussite Architecture propre avec injection de d√©pendances Toutes les op√©rations CRUD avec annuler/refaire Validation compl√®te des donn√©es Export fonctionnel Statistiques en temps r√©el Tests unitaires complets Documentation du code Mini-projet 5 : Application de blog avec architecture compl√®te Niveau : ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Expert\nObjectifs p√©dagogiques Architecture N-tiers compl√®te Tous les patrons int√©gr√©s API REST simul√©e Navigation multi-vues Authentification Gestion des erreurs avanc√©e Sp√©cifications Fonctionnalit√©s :\nAuthentification (login/logout) Gestion d‚Äôarticles (CRUD) Commentaires Cat√©gories et tags Recherche full-text Draft/Publi√© R√¥les (Admin, √âditeur, Lecteur) Historique des modifications Upload d‚Äôimages Export PDF d‚Äôarticle Architecture compl√®te :\nPresentation/\r- Views/\r- LoginView\r- ArticlesListView\r- ArticleDetailView\r- EditorView\r- ViewModels/\r- LoginViewModel\r- ArticlesViewModel\r- ArticleDetailViewModel\rBusiness/\r- Services/\r- IAuthenticationService\r- IArticleService\r- ICommentaireService\r- Commands/\r- Validators/\rData/\r- Repositories/\r- IArticleRepository\r- IUtilisateurRepository\r- Models/\rInfrastructure/\r- API/\r- ApiClient\r- Storage/\r- Logging/ Je vous fournis un squelette de d√©part‚Ä¶ // Models/Article.cs public class Article : BaseViewModel { public int Id { get; set; } private string titre; public string Titre { get =\u003e titre; set =\u003e SetProperty(ref titre, value); } private string contenu; public string Contenu { get =\u003e contenu; set =\u003e SetProperty(ref contenu, value); } private StatutArticle statut; public StatutArticle Statut { get =\u003e statut; set =\u003e SetProperty(ref statut, value); } public Utilisateur Auteur { get; set; } public DateTime DateCreation { get; set; } public DateTime? DatePublication { get; set; } public DateTime DateModification { get; set; } public ObservableCollection\u003cCommentaire\u003e Commentaires { get; set; } public ObservableCollection\u003cTag\u003e Tags { get; set; } public Categorie Categorie { get; set; } } public enum StatutArticle { Brouillon, EnRevision, Publie, Archive } // Services/IArticleService.cs public interface IArticleService { Task\u003cList\u003cArticle\u003e\u003e ObtenirArticlesAsync(FiltreBlog filtre); Task\u003cArticle\u003e ObtenirArticleAsync(int id); Task\u003cArticle\u003e CreerArticleAsync(Article article); Task ModifierArticleAsync(Article article); Task SupprimerArticleAsync(int id); Task\u003cbool\u003e PublierArticleAsync(int id); Task\u003cList\u003cArticle\u003e\u003e RechercherAsync(string termes); } // ViewModels/MainViewModel.cs public class MainViewModel : BaseViewModel { private readonly INavigationService navigationService; private readonly IAuthenticationService authService; private BaseViewModel vueActuelle; public BaseViewModel VueActuelle { get =\u003e vueActuelle; set =\u003e SetProperty(ref vueActuelle, value); } private Utilisateur utilisateurConnecte; public Utilisateur UtilisateurConnecte { get =\u003e utilisateurConnecte; set =\u003e SetProperty(ref utilisateurConnecte, value); } public ICommand NaviguerVersArticlesCommand { get; } public ICommand NaviguerVersNouvelArticleCommand { get; } public ICommand DeconnecterCommand { get; } public MainViewModel(INavigationService navigationService, IAuthenticationService authService) { this.navigationService = navigationService; this.authService = authService; NaviguerVersArticlesCommand = new RelayCommand(() =\u003e navigationService.NaviguerVers\u003cArticlesViewModel\u003e()); DeconnecterCommand = new RelayCommand(Deconnecter); // V√©rifier si l'utilisateur est d√©j√† connect√© UtilisateurConnecte = authService.ObtenirUtilisateurActuel(); if (UtilisateurConnecte == null) navigationService.NaviguerVers\u003cLoginViewModel\u003e(); else navigationService.NaviguerVers\u003cArticlesViewModel\u003e(); } } // Services/NavigationService.cs public interface INavigationService { void NaviguerVers\u003cTViewModel\u003e() where TViewModel : BaseViewModel; void NaviguerVers\u003cTViewModel\u003e(object parametre) where TViewModel : BaseViewModel; void NaviguerRetour(); } public class NavigationService : INavigationService { private readonly Func\u003cType, BaseViewModel\u003e viewModelFactory; private readonly MainViewModel mainViewModel; private Stack\u003cBaseViewModel\u003e historique = new Stack\u003cBaseViewModel\u003e(); public NavigationService(Func\u003cType, BaseViewModel\u003e viewModelFactory, MainViewModel mainViewModel) { this.viewModelFactory = viewModelFactory; this.mainViewModel = mainViewModel; } public void NaviguerVers\u003cTViewModel\u003e() where TViewModel : BaseViewModel { var viewModel = viewModelFactory(typeof(TViewModel)); if (mainViewModel.VueActuelle != null) historique.Push(mainViewModel.VueActuelle); mainViewModel.VueActuelle = viewModel; } public void NaviguerRetour() { if (historique.Count \u003e 0) mainViewModel.VueActuelle = historique.Pop(); } } XAML avec navigation \u003c!-- MainWindow.xaml --\u003e \u003cWindow\u003e \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"Auto\"/\u003e \u003cRowDefinition Height=\"*\"/\u003e \u003c/Grid.RowDefinitions\u003e \u003c!-- Barre de navigation --\u003e \u003cStackPanel Grid.Row=\"0\" Orientation=\"Horizontal\" Background=\"#2196F3\"\u003e \u003cButton Content=\"Articles\" Command=\"{Binding NaviguerVersArticlesCommand}\"/\u003e \u003cButton Content=\"Nouvel Article\" Command=\"{Binding NaviguerVersNouvelArticleCommand}\"/\u003e \u003cTextBlock Text=\"{Binding UtilisateurConnecte.Nom}\" Foreground=\"White\" VerticalAlignment=\"Center\" Margin=\"20,0\"/\u003e \u003cButton Content=\"D√©connexion\" Command=\"{Binding DeconnecterCommand}\"/\u003e \u003c/StackPanel\u003e \u003c!-- Zone de contenu dynamique --\u003e \u003cContentControl Grid.Row=\"1\" Content=\"{Binding VueActuelle}\"\u003e \u003cContentControl.Resources\u003e \u003c!-- Mapper les ViewModels aux Views --\u003e \u003cDataTemplate DataType=\"{x:Type vm:ArticlesViewModel}\"\u003e \u003cviews:ArticlesView /\u003e \u003c/DataTemplate\u003e \u003cDataTemplate DataType=\"{x:Type vm:ArticleDetailViewModel}\"\u003e \u003cviews:ArticleDetailView /\u003e \u003c/DataTemplate\u003e \u003cDataTemplate DataType=\"{x:Type vm:LoginViewModel}\"\u003e \u003cviews:LoginView /\u003e \u003c/DataTemplate\u003e \u003c/ContentControl.Resources\u003e \u003c/ContentControl\u003e \u003c/Grid\u003e \u003c/Window\u003e Configuration de l‚Äôinjection de d√©pendances // App.xaml.cs public partial class App : Application { private ServiceProvider serviceProvider; protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); var services = new ServiceCollection(); // Repositories services.AddSingleton\u003cIArticleRepository, ArticleRepository\u003e(); services.AddSingleton\u003cIUtilisateurRepository, UtilisateurRepository\u003e(); // Services services.AddSingleton\u003cIAuthenticationService, AuthenticationService\u003e(); services.AddTransient\u003cIArticleService, ArticleService\u003e(); services.AddTransient\u003cIExportService, ExportService\u003e(); // ViewModels services.AddSingleton\u003cMainViewModel\u003e(); services.AddTransient\u003cArticlesViewModel\u003e(); services.AddTransient\u003cArticleDetailViewModel\u003e(); services.AddTransient\u003cLoginViewModel\u003e(); // Navigation services.AddSingleton\u003cINavigationService\u003e(provider =\u003e { var mainVM = provider.GetRequiredService\u003cMainViewModel\u003e(); return new NavigationService( type =\u003e (BaseViewModel)provider.GetRequiredService(type), mainVM ); }); serviceProvider = services.BuildServiceProvider(); // Lancer la fen√™tre principale var mainWindow = new MainWindow { DataContext = serviceProvider.GetRequiredService\u003cMainViewModel\u003e() }; mainWindow.Show(); } } Crit√®res de r√©ussite Architecture N-tiers compl√®te Navigation fluide entre vues Authentification fonctionnelle CRUD complet avec validation Gestion des r√¥les Export PDF Gestion des erreurs Logging Tests unitaires complets Tests d‚Äôint√©gration Conclusion des mini-projets Ces 5 mini-projets couvrent progressivement tous les concepts enseign√©s :\nCalculatrice : Introduction aux commandes et historique T√¢ches : MVVM complet avec sauvegarde Chat : Observateur en temps r√©el Inventaire : Architecture compl√®te avec injection Blog : Application professionnelle compl√®te Chaque projet construit sur les acquis du pr√©c√©dent et introduit de nouveaux concepts.",
    "description": "Mini-projets progressifs Mini-projet 1 : Calculatrice avec historique Niveau : ‚≠ê‚≠ê Interm√©diaire\nObjectifs p√©dagogiques Patron Commande (annuler/refaire) INotifyPropertyChanged Data Binding de base Sp√©cifications Fonctionnalit√©s :",
    "tags": [],
    "title": "Mini-projets",
    "uri": "/420-413/mini_projets/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "Noms Significatifs et Fonctions Claires üìã Objectifs de cette semaine Apprendre √† :\nIdentifier et corriger les noms non significatifs Reconna√Ætre et r√©soudre les fonctions trop longues √âliminer les commentaires inutiles en √©crivant du code auto-explicatif üí° Citation de la semaine ‚ÄúLe code est lu beaucoup plus souvent qu‚Äôil n‚Äôest √©crit. Facilitez la lecture, pas l‚Äô√©criture.‚Äù\n‚Äî Robert C. Martin (Uncle Bob), Clean Code\nüî¥ Code Smell #1 : Noms Non Significatifs Qu‚Äôest-ce qu‚Äôun nom non significatif ? Un nom non significatif est un nom de variable, m√©thode ou classe qui ne r√©v√®le pas clairement son intention ou son r√¥le. Il force le lecteur √† deviner ou √† chercher dans le contexte pour comprendre.\n‚ùå Exemple de Code Probl√©matique public class Program { static void Main() { // Que repr√©sentent ces variables ??? var d = 30; var temp = new List\u003cint[]\u003e(); for (int i = 0; i \u003c 100; i++) { var x = new int[3]; x[0] = i; x[1] = i * 2; x[2] = i % d; if (x[2] == 0) { temp.Add(x); } } // Afficher les r√©sultats foreach (var t in temp) { Console.WriteLine($\"{t[0]} - {t[1]} - {t[2]}\"); } } } ü§î Probl√®mes identifi√©s d : Que signifie ‚Äúd‚Äù ? Jour ? Distance ? Diviseur ? temp : Temporaire de quoi ? Quelle est sa vraie signification ? x : Qu‚Äôest-ce que ce tableau repr√©sente ? t : M√™me probl√®me dans la boucle i : Dans ce contexte, que repr√©sente-t-il vraiment ? Indices magiques : Que signifient [0], [1], [2] ? ‚úÖ Code Corrig√© (Version Clean Code) public class Program { static void Main() { // VERSION CLEAN CODE const int NombreJoursDansUnMois = 30; List\u003cCommande\u003e commandesDivisiblesParTrente = new List\u003cCommande\u003e(); for (int numeroCommande = 0; numeroCommande \u003c 100; numeroCommande++) { var commande = new Commande { Numero = numeroCommande, MontantDouble = numeroCommande * 2, ResteModulo = numeroCommande % NombreJoursDansUnMois }; if (commande.EstDivisibleParTrente()) { commandesDivisiblesParTrente.Add(commande); } } AfficherCommandes(commandesDivisiblesParTrente); } private static void AfficherCommandes(List\u003cCommande\u003e commandes) { foreach (var commande in commandes) { Console.WriteLine(commande.ObtenirDescription()); } } } public class Commande { public int Numero { get; set; } public int MontantDouble { get; set; } public int ResteModulo { get; set; } public bool EstDivisibleParTrente() { return ResteModulo == 0; } public string ObtenirDescription() { return $\"Commande #{Numero} - Montant: {MontantDouble} - Reste: {ResteModulo}\"; } } üìä Comparaison Avant/Apr√®s Avant (üòû Mauvais) Apr√®s (‚úÖ Bon) Am√©lioration d nombreDeJoursDansUnMois Intention claire temp commandesDivisiblesParTrente But explicite x commande (objet Commande) Type et r√¥le clairs x[0], x[1], x[2] commande.Numero, commande.MontantDouble Propri√©t√©s nomm√©es i numeroCommande Contexte pr√©cis t commande Nom significatif üîç Exercice Pratique #1 Corrigez ce code :\npublic void Process(int a, int b) { var r = 0; for (int i = a; i \u003c= b; i++) { if (i % 2 == 0) { r += i; } } Console.WriteLine(r); } Solution :\npublic void AfficherSommeNombresPairs(int nombreDebut, int nombreFin) { int sommePairs = 0; for (int nombre = nombreDebut; nombre \u003c= nombreFin; nombre++) { if (NombreEstPair(nombre)) { sommePairs += nombre; } } Console.WriteLine($\"Somme des nombres pairs : {sommePairs}\"); } private bool NombreEstPair(int nombre) { return nombre % 2 == 0; } üî¥ Code Smell #2 : Fonctions Trop Longues Qu‚Äôest-ce qu‚Äôune fonction trop longue ? Une fonction qui fait trop de choses, contient trop de lignes de code, ou a trop de niveaux d‚Äôindentation. R√®gle g√©n√©rale : une fonction devrait tenir sur un √©cran sans d√©filement.\nR√®gle d‚Äôor : Une fonction = Une responsabilit√©\n‚ùå Exemple de Code Probl√©matique public class GestionnaireCommandes { public void TraiterCommande(int idCommande) { // Cette fonction fait BEAUCOUP TROP de choses ! // 1. R√©cup√©ration des donn√©es var commande = new Commande(); using (var connection = new SqlConnection(\"connectionString\")) { connection.Open(); var cmd = new SqlCommand($\"SELECT * FROM Commandes WHERE Id = {idCommande}\", connection); var reader = cmd.ExecuteReader(); if (reader.Read()) { commande.Id = (int)reader[\"Id\"]; commande.ClientId = (int)reader[\"ClientId\"]; commande.MontantTotal = (decimal)reader[\"MontantTotal\"]; commande.DateCommande = (DateTime)reader[\"DateCommande\"]; } } // 2. Validation if (commande.MontantTotal \u003c= 0) { Console.WriteLine(\"Erreur: Montant invalide\"); return; } if (commande.DateCommande \u003e DateTime.Now) { Console.WriteLine(\"Erreur: Date future\"); return; } // 3. Calcul des taxes decimal tps = commande.MontantTotal * 0.05m; decimal tvq = commande.MontantTotal * 0.09975m; decimal total = commande.MontantTotal + tps + tvq; // 4. V√©rification du client var client = new Client(); using (var connection = new SqlConnection(\"connectionString\")) { connection.Open(); var cmd = new SqlCommand($\"SELECT * FROM Clients WHERE Id = {commande.ClientId}\", connection); var reader = cmd.ExecuteReader(); if (reader.Read()) { client.Nom = (string)reader[\"Nom\"]; client.Email = (string)reader[\"Email\"]; client.Actif = (bool)reader[\"Actif\"]; } } if (!client.Actif) { Console.WriteLine(\"Erreur: Client inactif\"); return; } // 5. Application de rabais decimal rabais = 0; if (commande.MontantTotal \u003e 1000) { rabais = total * 0.10m; } else if (commande.MontantTotal \u003e 500) { rabais = total * 0.05m; } total -= rabais; // 6. Enregistrement de la facture using (var connection = new SqlConnection(\"connectionString\")) { connection.Open(); var cmd = new SqlCommand( $\"INSERT INTO Factures (CommandeId, MontantHT, TPS, TVQ, Rabais, Total) \" + $\"VALUES ({commande.Id}, {commande.MontantTotal}, {tps}, {tvq}, {rabais}, {total})\", connection); cmd.ExecuteNonQuery(); } // 7. Envoi d'email var smtp = new SmtpClient(\"smtp.server.com\"); var message = new MailMessage(); message.To.Add(client.Email); message.Subject = \"Facture\"; message.Body = $\"Votre facture de {total:C} est pr√™te\"; smtp.Send(message); // 8. Logging Console.WriteLine($\"Commande {idCommande} trait√©e avec succ√®s\"); File.AppendAllText(\"log.txt\", $\"{DateTime.Now}: Commande {idCommande} OK\\n\"); } } ü§î Probl√®mes identifi√©s 91 lignes dans une seule m√©thode ! 8 responsabilit√©s diff√©rentes dans une fonction Violation du principe SRP (Single Responsibility Principle) Difficile √† tester : comment tester juste une partie ? Difficile √† maintenir : modifier une partie risque de casser le reste Code dupliqu√© : connexion DB r√©p√©t√©e 3 fois M√©lange de niveaux d‚Äôabstraction : d√©tails DB + logique m√©tier ‚úÖ Code Corrig√© (Version Clean Code) public class GestionnaireCommandes { private readonly ICommandeRepository _commandeRepository; private readonly IClientRepository _clientRepository; private readonly IFactureRepository _factureRepository; private readonly ICalculateurTaxes _calculateurTaxes; private readonly ICalculateurRabais _calculateurRabais; private readonly IServiceEmail _serviceEmail; private readonly ILogger _logger; public GestionnaireCommandes( ICommandeRepository commandeRepository, IClientRepository clientRepository, IFactureRepository factureRepository, ICalculateurTaxes calculateurTaxes, ICalculateurRabais calculateurRabais, IServiceEmail serviceEmail, ILogger logger) { _commandeRepository = commandeRepository; _clientRepository = clientRepository; _factureRepository = factureRepository; _calculateurTaxes = calculateurTaxes; _calculateurRabais = calculateurRabais; _serviceEmail = serviceEmail; _logger = logger; } // ========================================== // M√âTHODE PRINCIPALE - Claire et concise // ========================================== public void TraiterCommande(int idCommande) { var commande = RecupererCommande(idCommande); ValiderCommande(commande); var client = RecupererClient(commande.ClientId); ValiderClient(client); var facture = CreerFacture(commande); EnregistrerFacture(facture); EnvoyerEmailConfirmation(client, facture); LoggerTraitement(idCommande); } // ========================================== // M√âTHODES PRIV√âES - Une responsabilit√© chacune // ========================================== private Commande RecupererCommande(int idCommande) { var commande = _commandeRepository.ObtenirParId(idCommande); if (commande == null) { throw new CommandeIntrouvableException($\"Commande {idCommande} introuvable\"); } return commande; } private void ValiderCommande(Commande commande) { if (commande.MontantTotal \u003c= 0) { throw new CommandeInvalideException(\"Le montant doit √™tre positif\"); } if (commande.DateCommande \u003e DateTime.Now) { throw new CommandeInvalideException(\"La date ne peut √™tre future\"); } } private Client RecupererClient(int clientId) { var client = _clientRepository.ObtenirParId(clientId); if (client == null) { throw new ClientIntrouvableException($\"Client {clientId} introuvable\"); } return client; } private void ValiderClient(Client client) { if (!client.Actif) { throw new ClientInactifException($\"Le client {client.Nom} est inactif\"); } } private Facture CreerFacture(Commande commande) { var montantHT = commande.MontantTotal; var taxes = _calculateurTaxes.CalculerTaxes(montantHT); var montantAvecTaxes = montantHT + taxes.TPS + taxes.TVQ; var rabais = _calculateurRabais.CalculerRabais(montantAvecTaxes); var montantFinal = montantAvecTaxes - rabais; return new Facture { CommandeId = commande.Id, MontantHorsTaxes = montantHT, TPS = taxes.TPS, TVQ = taxes.TVQ, Rabais = rabais, MontantTotal = montantFinal }; } private void EnregistrerFacture(Facture facture) { _factureRepository.Enregistrer(facture); } private void EnvoyerEmailConfirmation(Client client, Facture facture) { var contenuEmail = new EmailFacture { Destinataire = client.Email, NomClient = client.Nom, MontantTotal = facture.MontantTotal }; _serviceEmail.EnvoyerEmailFacture(contenuEmail); } private void LoggerTraitement(int idCommande) { _logger.LogInformation($\"Commande {idCommande} trait√©e avec succ√®s\"); } } // ========================================== // CLASSES DE SUPPORT (extraites) // ========================================== public class CalculateurTaxes : ICalculateurTaxes { private const decimal TauxTPS = 0.05m; // Taxe f√©d√©rale (5%) private const decimal TauxTVQ = 0.09975m; // Taxe provinciale Qu√©bec (9.975%) public TaxesCalculees CalculerTaxes(decimal montantHorsTaxes) { return new TaxesCalculees { TPS = montantHorsTaxes * TauxTPS, TVQ = montantHorsTaxes * TauxTVQ }; } } public class CalculateurRabais : ICalculateurRabais { private const decimal SeuilRabaisEleve = 1000m; private const decimal SeuilRabaisMoyen = 500m; private const decimal TauxRabaisEleve = 0.10m; private const decimal TauxRabaisMoyen = 0.05m; public decimal CalculerRabais(decimal montant) { if (montant \u003e SeuilRabaisEleve) { return montant * TauxRabaisEleve; } if (montant \u003e SeuilRabaisMoyen) { return montant * TauxRabaisMoyen; } return 0; } } üìä Comparaison Avant/Apr√®s Aspect Avant (üòû) Apr√®s (‚úÖ) Lignes par m√©thode 91 lignes 5-15 lignes max Responsabilit√©s 8 dans une m√©thode 1 par m√©thode Testabilit√© Tr√®s difficile Facile (chaque partie) Lisibilit√© N√©cessite d√©filement Chaque m√©thode visible d‚Äôun coup Maintenance Risqu√© S√ªr et cibl√© R√©utilisabilit√© Aucune Chaque m√©thode r√©utilisable üéØ R√®gles pour les Fonctions Propres ‚úÖ Principes √† suivre : Une fonction = Une responsabilit√© // ‚úÖ BON - Fait une seule chose public decimal CalculerPrixAvecTaxes(decimal prixHT) { return prixHT * 1.14975m; // TPS + TVQ du Qu√©bec } // ‚ùå MAUVAIS - Fait plusieurs choses public decimal CalculerEtEnregistrerPrixAvecTaxes(decimal prixHT) { var prixTTC = prixHT * 1.14975m; // Enregistrement en DB // Envoi d'email // Logging return prixTTC; } Petite taille : 5-20 lignes id√©alement // ‚úÖ BON - Court et clair public bool UtilisateurEstEligibleAuRabais(Utilisateur user) { return user.EstMembre \u0026\u0026 user.AncienneteEnMois \u003e= 6 \u0026\u0026 user.MontantAchatsTotal \u003e 1000; } Un seul niveau d‚Äôabstraction // ‚úÖ BON - M√™me niveau d'abstraction public void TraiterInscription(Utilisateur user) { ValiderDonneesUtilisateur(user); EnregistrerUtilisateur(user); EnvoyerEmailBienvenue(user); } // ‚ùå MAUVAIS - Niveaux d'abstraction m√©lang√©s public void TraiterInscription(Utilisateur user) { // Haut niveau ValiderDonneesUtilisateur(user); // Bas niveau (d√©tails d'impl√©mentation) using (var connection = new SqlConnection(\"...\")) { connection.Open(); var cmd = new SqlCommand(\"INSERT...\", connection); cmd.ExecuteNonQuery(); } // Haut niveau EnvoyerEmailBienvenue(user); } Peu de param√®tres : 0-3 id√©alement // ‚úÖ BON - 2 param√®tres public decimal CalculerRemise(decimal montant, TypeClient typeClient) { // ... } // ‚ö†Ô∏è ACCEPTABLE - 3 param√®tres public void CreerCommande(int clientId, List\u003cProduit\u003e produits, AdresseLivraison adresse) { // ... } // ‚ùå MAUVAIS - Trop de param√®tres public void CreerCommande(int clientId, string nom, string prenom, string email, string telephone, string rue, string ville, string codePostal, List\u003cProduit\u003e produits) { // Utilisez plut√¥t un objet } // ‚úÖ MIEUX - Objet de param√®tres public void CreerCommande(InformationsCommande infos) { // ... } Pas d‚Äôeffets de bord // ‚ùå MAUVAIS - Effet de bord cach√© private int compteur = 0; // Variable de classe public bool ValiderUtilisateur(Utilisateur user) { compteur++; // ‚ö†Ô∏è Effet de bord : modifie l'√©tat return user.Email != null \u0026\u0026 user.Age \u003e= 18; } // ‚úÖ BON - Fonction pure public bool ValiderUtilisateur(Utilisateur user) { return user.Email != null \u0026\u0026 user.Age \u003e= 18; } üîç Exercice Pratique #2 D√©composez cette fonction :\npublic void ProcessOrder(int orderId) { var order = db.Orders.Find(orderId); if (order == null) return; var customer = db.Customers.Find(order.CustomerId); if (customer == null) return; var total = 0m; foreach (var item in order.Items) { total += item.Price * item.Quantity; } var tax = total * 0.15m; var finalTotal = total + tax; if (finalTotal \u003e 1000) { finalTotal *= 0.9m; } order.Total = finalTotal; db.SaveChanges(); SendEmail(customer.Email, $\"Your order total: {finalTotal:C}\"); } Solution :\npublic void TraiterCommande(int idCommande) { var commande = RecupererCommande(idCommande); var client = RecupererClient(commande.ClientId); var montantTotal = CalculerMontantTotal(commande); EnregistrerMontantCommande(commande, montantTotal); EnvoyerEmailConfirmation(client, montantTotal); } private Commande RecupererCommande(int idCommande) { var commande = db.Orders.Find(idCommande); if (commande == null) { throw new CommandeIntrouvableException($\"Commande {idCommande} introuvable\"); } return commande; } private Client RecupererClient(int clientId) { var client = db.Customers.Find(clientId); if (client == null) { throw new ClientIntrouvableException($\"Client {clientId} introuvable\"); } return client; } private decimal CalculerMontantTotal(Commande commande) { var sousTotal = CalculerSousTotal(commande.Items); var montantAvecTaxes = AjouterTaxes(sousTotal); var montantFinal = AppliquerRabaisSiEligible(montantAvecTaxes); return montantFinal; } private decimal CalculerSousTotal(List\u003cItem\u003e items) { return items.Sum(item =\u003e item.Price * item.Quantity); } private decimal AjouterTaxes(decimal montant) { const decimal TauxTaxe = 0.15m; return montant * (1 + TauxTaxe); } private decimal AppliquerRabaisSiEligible(decimal montant) { const decimal SeuilRabais = 1000m; const decimal TauxRabais = 0.10m; if (montant \u003e SeuilRabais) { return montant * (1 - TauxRabais); } return montant; } private void EnregistrerMontantCommande(Commande commande, decimal montant) { commande.Total = montant; db.SaveChanges(); } private void EnvoyerEmailConfirmation(Client client, decimal montant) { var message = $\"Votre commande : {montant:C}\"; SendEmail(client.Email, message); } üî¥ Code Smell #3 : Commentaires Inutiles ou Mensongers Qu‚Äôest-ce qu‚Äôun commentaire inutile ? Un commentaire qui :\nD√©crit ce que le code fait d√©j√† clairement Est obsol√®te ou faux Compense un code mal √©crit Pourrait √™tre remplac√© par un bon nom de variable/m√©thode R√®gle d‚Äôor : Le meilleur commentaire est celui que vous n‚Äôavez pas besoin d‚Äô√©crire\n‚ùå Exemple de Code Probl√©matique public class GestionnaireUtilisateurs { // Cette m√©thode calcule l'√¢ge de l'utilisateur public int CalculerAge(DateTime dateNaissance) { // Obtenir la date d'aujourd'hui DateTime aujourd'hui = DateTime.Today; // Calculer l'√¢ge int age = aujourd'hui.Year - dateNaissance.Year; // V√©rifier si l'anniversaire est pass√© cette ann√©e if (dateNaissance.Date \u003e aujourd'hui.AddYears(-age)) { age--; // Soustraire 1 si anniversaire pas encore pass√© } // Retourner l'√¢ge return age; } // TODO: Corriger ce bug (√©crit il y a 2 ans...) // HACK: Solution temporaire en attendant le refactoring // NOTE: Ne fonctionne pas pour les clients VIP public decimal CalculerPrix(Produit p, Client c) { decimal prix = p.PrixBase; // Appliquer le rabais if (c.Type == \"VIP\") { prix = prix * 0.8m; // 20% de rabais } else if (c.Type == \"Premium\") { prix = prix * 0.9m; // 10% de rabais } // Sinon, pas de rabais return prix; } // ========================================== // SECTION: Validation // ========================================== // Valide l'email public bool ValiderEmail(string email) { // V√©rifier si email est null if (email == null) { return false; // Retourner faux } // V√©rifier si email contient @ if (!email.Contains(\"@\")) { return false; // Retourner faux } // L'email est valide return true; // Retourner vrai } /** * Cette m√©thode envoie un email √† l'utilisateur * Param√®tres: * - destinataire: l'adresse email du destinataire * - sujet: le sujet de l'email * - corps: le corps du message * Retour: * - bool: true si envoy√©, false sinon * Auteur: Jean Dupont * Date: 15/01/2022 * Modifi√© par: Marie Martin * Date: 03/05/2023 */ public bool EnvoyerEmail(string destinataire, string sujet, string corps) { // Code d'envoi d'email return true; } // M√©thode obsol√®te - NE PLUS UTILISER // Utiliser NouvelleMethode() √† la place public void AncienneMethode() { // Cette m√©thode ne devrait plus √™tre utilis√©e // mais on la garde pour compatibilit√© } } ü§î Probl√®mes identifi√©s Commentaires redondants : ‚ÄúCette m√©thode calcule l‚Äô√¢ge‚Äù ‚Üí Le nom le dit d√©j√† ! Commentaires √©vidents : ‚ÄúObtenir la date d‚Äôaujourd‚Äôhui‚Äù ‚Üí Le code est clair TODO/HACK vieux : Jamais r√©solus, induisent en erreur Commentaires qui mentent : ‚ÄúNe fonctionne pas pour VIP‚Äù mais le code le g√®re ! Commentaires de s√©paration : Headers inutiles Documentation excessive : Javadoc inutile pour m√©thode simple Code comment√© : M√©thode obsol√®te devrait √™tre supprim√©e Explications du ‚Äúcomment‚Äù : Au lieu du ‚Äúpourquoi‚Äù ‚úÖ Code Corrig√© (Version Clean Code) public class GestionnaireUtilisateurs { // ========================================== // M√âTHODE 1 : Calcul d'√¢ge // Aucun commentaire n√©cessaire - le code parle de lui-m√™me // ========================================== public int CalculerAge(DateTime dateNaissance) { var aujourdHui = DateTime.Today; var age = aujourdHui.Year - dateNaissance.Year; if (AnniversairePasEncorePasseCetteAnnee(dateNaissance, aujourdHui, age)) { age--; } return age; } private bool AnniversairePasEncorePasseCetteAnnee(DateTime dateNaissance, DateTime aujourdHui, int age) { return dateNaissance.Date \u003e aujourdHui.AddYears(-age); } // ========================================== // M√âTHODE 2 : Calcul de prix // Code auto-document√© avec extraction de m√©thodes // ========================================== public decimal CalculerPrix(Produit produit, Client client) { var prixBase = produit.PrixBase; var tauxRabais = ObtenirTauxRabais(client.Type); return AppliquerRabais(prixBase, tauxRabais); } private decimal ObtenirTauxRabais(TypeClient typeClient) { return typeClient switch { TypeClient.VIP =\u003e 0.20m, // 20% pour VIP TypeClient.Premium =\u003e 0.10m, // 10% pour Premium _ =\u003e 0m // Pas de rabais par d√©faut }; } private decimal AppliquerRabais(decimal prixBase, decimal tauxRabais) { return prixBase * (1 - tauxRabais); } // ========================================== // M√âTHODE 3 : Validation email // Nom de m√©thode explicite + extraction de conditions // ========================================== public bool EmailEstValide(string email) { return email != null \u0026\u0026 email.Contains(\"@\"); } // OU version plus robuste public bool EmailEstValide_Version2(string email) { if (EstVideOuNull(email)) { return false; } return ContientArobase(email) \u0026\u0026 ContientPoint(email); } private bool EstVideOuNull(string texte) =\u003e string.IsNullOrWhiteSpace(texte); private bool ContientArobase(string email) =\u003e email.Contains(\"@\"); private bool ContientPoint(string email) =\u003e email.Contains(\".\"); // ========================================== // M√âTHODE 4 : Envoi email // Signature claire = documentation suffisante // ========================================== public bool EnvoyerEmail(string destinataire, string sujet, string corps) { // Code d'envoi return true; } // ========================================== // M√âTHODE OBSOL√àTE : Marqu√©e avec attribut, pas commentaire // ========================================== [Obsolete(\"Utilisez NouvelleMethode() √† la place\", error: true)] public void AncienneMethode() { throw new NotSupportedException(\"Cette m√©thode est obsol√®te\"); } public void NouvelleMethode() { // Nouvelle impl√©mentation } } üéØ Quand les Commentaires SONT Utiles Certains commentaires sont pr√©cieux et doivent √™tre gard√©s :\n‚úÖ 1. Explication du ‚ÄúPOURQUOI‚Äù (pas du ‚ÄúQUOI‚Äù) // ‚úÖ BON - Explique une d√©cision non-√©vidente public decimal CalculerFraisLivraison(decimal montantCommande) { // Nous offrons la livraison gratuite au-dessus de 50$ pour encourager // les achats plus importants et am√©liorer la satisfaction client // (d√©cision marketing du 15/01/2024) if (montantCommande \u003e= 50) { return 0; } return 5.99m; } // ‚ùå MAUVAIS - D√©crit ce que le code fait d√©j√† public decimal CalculerFraisLivraison(decimal montantCommande) { // V√©rifier si le montant est sup√©rieur ou √©gal √† 50 if (montantCommande \u003e= 50) { return 0; // Retourner 0 } return 5.99m; // Sinon retourner 5.99 } ‚úÖ 2. Avertissements sur les Cons√©quences // ‚úÖ BON - Avertit d'un comportement important public void SupprimerToutesLesDonnees() { // ATTENTION: Cette op√©ration est IRR√âVERSIBLE et supprime // toutes les donn√©es de production. √Ä utiliser uniquement // dans le cadre de la proc√©dure de r√©initialisation annuelle. database.DeleteAll(); } ‚úÖ 3. TODO L√©gitimes (avec date et contexte) // ‚úÖ BON - TODO avec contexte et √©ch√©ance public class ServicePaiement { // TODO (2024-02-15): Migrer vers la nouvelle API Stripe v3 // D√©pendance: Attente de la mise √† jour du SDK // Responsable: √©quipe-backend@example.com public bool ProcesserPaiement(CarteBancaire carte) { // Utilisation de l'ancienne API (v2) return StripeV2.Charge(carte); } } // ‚ùå MAUVAIS - TODO vague et sans contexte public bool ProcesserPaiement(CarteBancaire carte) { // TODO: am√©liorer return StripeV2.Charge(carte); } ‚úÖ 4. Explication d‚Äôun Algorithme Complexe // ‚úÖ BON - Explique un algorithme non-trivial public int CalculerJourPaques(int annee) { // Algorithme de Gauss pour calculer la date de P√¢ques // Formule math√©matique complexe bas√©e sur les cycles lunaires // R√©f√©rence: https://fr.wikipedia.org/wiki/Calcul_de_la_date_de_P√¢ques int a = annee % 19; int b = annee / 100; int c = annee % 100; // ... suite de l'algorithme complexe } ‚úÖ 5. Exigences L√©gales ou M√©tier // ‚úÖ BON - R√©f√©rence l√©gale importante public decimal CalculerTaxes(decimal montant) { // Conform√©ment √† la loi C-45 (Qu√©bec), les taux de taxes sont: // TPS f√©d√©rale: 5% (depuis 01/01/2008) // TVQ provinciale: 9.975% (depuis 01/01/2013) // Ces taux peuvent changer - voir: revenuquebec.ca const decimal TauxTPS = 0.05m; const decimal TauxTVQ = 0.09975m; return montant * (1 + TauxTPS + TauxTVQ); } üìä Guide de D√©cision : Commentaire ou Refactoring ? Vous voulez √©crire un commentaire ?\r‚îÇ\r‚îú‚îÄ D√©crit-il ce que le code fait ?\r‚îÇ ‚îî‚îÄ OUI ‚Üí ‚ùå Ne commentez pas, am√©liorez le code\r‚îÇ ‚îî‚îÄ Renommez variables/m√©thodes pour √™tre auto-document√©\r‚îÇ\r‚îú‚îÄ Explique-t-il POURQUOI (d√©cision m√©tier, contrainte) ?\r‚îÇ ‚îî‚îÄ OUI ‚Üí ‚úÖ Commentaire utile, gardez-le\r‚îÇ\r‚îú‚îÄ Compense-t-il un code mal √©crit ?\r‚îÇ ‚îî‚îÄ OUI ‚Üí ‚ùå Ne commentez pas, refactorez\r‚îÇ\r‚îú‚îÄ Contient-il un TODO/FIXME ?\r‚îÇ ‚îú‚îÄ Avec date, contexte et responsable ‚Üí ‚úÖ OK\r‚îÇ ‚îî‚îÄ Vague ou ancien ‚Üí ‚ùå Supprimez ou corrigez\r‚îÇ\r‚îî‚îÄ Explique-t-il un algorithme complexe ?\r‚îî‚îÄ OUI ‚Üí ‚úÖ Commentaire utile avec r√©f√©rence üîç Exercice Pratique #3 Nettoyez ce code :\n// Classe pour g√©rer les utilisateurs public class UserManager { // Constructeur public UserManager() { // Initialiser } // Cette m√©thode v√©rifie si l'utilisateur peut se connecter public bool CanLogin(User u) { // V√©rifier si l'utilisateur n'est pas null if (u == null) { return false; // Retourner faux } // V√©rifier si l'utilisateur est actif if (!u.IsActive) { return false; // Retourner faux } // V√©rifier le mot de passe // TODO: ajouter v√©rification 2FA if (u.Password == null || u.Password.Length \u003c 8) { return false; // Mot de passe trop court } // Tout est OK return true; // Retourner vrai } // HACK: Temporaire jusqu'√† refonte // Ne fonctionne pas pour admin public void DeleteUser(int id) { // Code de suppression } } Solution :\npublic class GestionnaireUtilisateurs { private const int LongueurMinimaleMotDePasse = 8; public bool UtilisateurPeutSeConnecter(Utilisateur utilisateur) { return UtilisateurExiste(utilisateur) \u0026\u0026 UtilisateurEstActif(utilisateur) \u0026\u0026 MotDePasseEstValide(utilisateur.MotDePasse); } private bool UtilisateurExiste(Utilisateur utilisateur) { return utilisateur != null; } private bool UtilisateurEstActif(Utilisateur utilisateur) { return utilisateur.EstActif; } private bool MotDePasseEstValide(string motDePasse) { return !string.IsNullOrEmpty(motDePasse) \u0026\u0026 motDePasse.Length \u003e= LongueurMinimaleMotDePasse; } // TODO (2024-02-15): Ajouter authentification √† deux facteurs (2FA) // Ticket: SECURITY-123 // Responsable: √©quipe-s√©curit√©@example.com public void SupprimerUtilisateur(int idUtilisateur) { // Impl√©mentation } } üìù R√©sum√© de la Semaine Les 3 Code Smells √âtudi√©s Noms Non Significatifs\n‚ùå Variables d‚Äôune lettre, abr√©viations obscures ‚úÖ Noms r√©v√©lant l‚Äôintention, pronon√ßables, cherchables Fonctions Trop Longues\n‚ùå Fonction qui fait tout, 100+ lignes ‚úÖ Petites fonctions (5-20 lignes), une responsabilit√©, un niveau d‚Äôabstraction Commentaires Inutiles\n‚ùå Commentaires redondants, obsol√®tes, compensant du mauvais code ‚úÖ Code auto-document√©, commentaires expliquant le POURQUOI Citations √† Retenir ‚ÄúLe code propre est simple et direct. Il se lit comme une prose bien √©crite.‚Äù ‚Äî Grady Booch\n‚ÄúUn commentaire mensonger est pire que pas de commentaire du tout.‚Äù ‚Äî Robert C. Martin\nChecklist Avant de Commiter du Code Mes variables ont des noms significatifs et r√©v√®lent leur intention Mes m√©thodes font UNE SEULE chose Mes m√©thodes ont moins de 20 lignes Mes m√©thodes ont 3 param√®tres ou moins J‚Äôai √©limin√© les commentaires qui d√©crivent ce que le code fait Mes commentaires (s‚Äôil y en a) expliquent le POURQUOI Mon code se lit comme une histoire claire üéØ D√©fi de la Semaine Trouvez dans votre propre code :\n3 variables avec des noms non significatifs ‚Üí Renommez-les 1 fonction longue (\u003e30 lignes) ‚Üí D√©composez-la 5 commentaires inutiles ‚Üí Supprimez-les en rendant le code auto-document√© Partagez vos avant/apr√®s avec la classe la semaine prochaine !\nüîú Aper√ßu Semaine Prochaine La semaine prochaine, nous aborderons :\nCode Duplication (DRY Principle) Classes trop grandes Couplage fort vs Couplage faible ‚ÄúLaissez le code plus propre que vous ne l‚Äôavez trouv√©.‚Äù ‚Äî R√®gle du Boy Scout",
    "description": "Noms Significatifs et Fonctions Claires üìã Objectifs de cette semaine Apprendre √† :\nIdentifier et corriger les noms non significatifs Reconna√Ætre et r√©soudre les fonctions trop longues √âliminer les commentaires inutiles en √©crivant du code auto-explicatif üí° Citation de la semaine ‚ÄúLe code est lu beaucoup plus souvent qu‚Äôil n‚Äôest √©crit. Facilitez la lecture, pas l‚Äô√©criture.‚Äù",
    "tags": [],
    "title": "Rubrique  - Semaine 2",
    "uri": "/420-413/rubrique/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-413/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Plans de cours üìã Samuel Fostin√© : Plan de cours\nHoraire et disponibilit√©s des enseignants ‚úîÔ∏è Samuel Fostin√© : Lien vers mon horaire et mes disponibilit√©s\nSamuel Fostin√© Nom de l‚Äô√©valuation Pond√©ration Semaine de l‚Äô√©valuation 10 quiz (8 meilleures notes) 15 % Semaine 2 √† 14 Examen 1 20% Semaine 4 Examen 2 25 % Semaine 12 Projet remise 1 5 % Semaine 6 Projet remise 2 5 % Semaine 8 Projet remise 3 5 % Semaine 10 Projet remise 4 5 % Semaine 13 Projet remise final 20 % Semaine 15",
    "description": "Plans de cours üìã Samuel Fostin√© : Plan de cours\nHoraire et disponibilit√©s des enseignants ‚úîÔ∏è Samuel Fostin√© : Lien vers mon horaire et mes disponibilit√©s\nSamuel Fostin√© Nom de l‚Äô√©valuation Pond√©ration Semaine de l‚Äô√©valuation 10 quiz (8 meilleures notes) 15 % Semaine 2 √† 14 Examen 1 20% Semaine 4 Examen 2 25 % Semaine 12 Projet remise 1 5 % Semaine 6 Projet remise 2 5 % Semaine 8 Projet remise 3 5 % Semaine 10 Projet remise 4 5 % Semaine 13 Projet remise final 20 % Semaine 15",
    "tags": [],
    "title": "D√©veloppement d'applications pour entreprise",
    "uri": "/420-413/index.html"
  },
  {
    "breadcrumb": "D√©veloppement d'applications pour entreprise",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-413/tags/index.html"
  }
]
