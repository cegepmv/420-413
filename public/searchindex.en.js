var relearn_searchindex = [
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Table des matiÃ¨res Introduction Ã  Agile Quâ€™est-ce que Scrum ? Les RÃ´les Scrum Les Artefacts Scrum Les CÃ©rÃ©monies Scrum Epics, Stories et Sprints Exercice Pratique pour Ã‰tudiants Introduction Ã  Agile Quâ€™est-ce que lâ€™Agile ? Agile est un ensemble de valeurs et de principes qui servent de philosophie de travail pour le dÃ©veloppement de produits et de projets. La mÃ©thodologie Agile a rÃ©volutionnÃ© la faÃ§on dont le travail est effectuÃ©, non seulement dans le dÃ©veloppement logiciel, mais aussi dans dâ€™autres domaines.\nLes principes fondamentaux dâ€™Agile Lâ€™approche Agile met lâ€™accent sur :\nLes personnes dâ€™abord : Mettre les utilisateurs finaux au centre de la conversation La flexibilitÃ© : CapacitÃ© Ã  rÃ©pondre au changement rapidement La livraison continue : Fournir de la valeur rÃ©guliÃ¨rement plutÃ´t quâ€™en une seule fois La collaboration : Travail dâ€™Ã©quipe transparent et communication ouverte Lâ€™amÃ©lioration continue : RÃ©flexion constante pour optimiser les processus Les 4 C de Scrum Les principes directeurs qui guident les Ã©quipes Scrum :\nCommunication : Dialogue transparent et ouvert Collaboration : Soutien mutuel et travail dâ€™Ã©quipe Commitment (Engagement) : DÃ©vouement aux objectifs Continuous Improvement (AmÃ©lioration continue) : RÃ©flexion rÃ©guliÃ¨re pour amÃ©liorer les processus Quâ€™est-ce que Scrum ? Scrum est lâ€™un des frameworks agiles les plus populaires. Il aide les Ã©quipes Ã  organiser et Ã  gÃ©rer leur travail Ã  travers des valeurs, des principes et des pratiques structurÃ©es.\nLa rÃ¨gle 3:5:3 de Scrum Scrum est structurÃ© autour de :\n3 rÃ´les : Product Owner, Scrum Master, Ã‰quipe de dÃ©veloppement 5 Ã©vÃ©nements : Sprint, Planification de sprint, Daily Scrum, Revue de sprint, RÃ©trospective 3 artefacts : Product Backlog, Sprint Backlog, IncrÃ©ment CaractÃ©ristiques clÃ©s de Scrum Sprints : Cycles de travail fixes (gÃ©nÃ©ralement 1 Ã  4 semaines) Ã‰quipes auto-organisÃ©es : Les Ã©quipes dÃ©cident comment accomplir leur travail Transparence : VisibilitÃ© sur le travail en cours et les obstacles Inspection et adaptation : Ã‰valuation rÃ©guliÃ¨re et ajustement des processus Les RÃ´les Scrum 1. Product Owner (PropriÃ©taire du produit) ResponsabilitÃ©s principales :\nGestion du Product Backlog : Maintenir et prioriser la liste de toutes les fonctionnalitÃ©s et exigences Vision du produit : DÃ©finir la direction et les objectifs du produit ReprÃ©sentant du client : Comprendre et communiquer les besoins des utilisateurs Priorisation : DÃ©cider quelles fonctionnalitÃ©s apportent le plus de valeur Gestion des versions : Planifier les releases (bien que le sprint ne soit pas un cycle de release) Clarification des exigences : RÃ©pondre aux questions de lâ€™Ã©quipe sur le backlog Profil : Le Product Owner se concentre sur la stratÃ©gie et les besoins mÃ©tier. Il nâ€™est pas un chef de projet traditionnel, mais plutÃ´t un facilitateur entre les parties prenantes et lâ€™Ã©quipe de dÃ©veloppement.\n2. Scrum Master ResponsabilitÃ©s principales :\nFacilitation des cÃ©rÃ©monies : Sâ€™assurer que les rÃ©unions sont productives et limitÃ©es dans le temps Suppression des obstacles : Ã‰liminer les blocages qui empÃªchent lâ€™Ã©quipe dâ€™avancer Coaching : Former lâ€™Ã©quipe aux principes Agile et Scrum Protection de lâ€™Ã©quipe : ProtÃ©ger lâ€™Ã©quipe des distractions externes Promotion de lâ€™amÃ©lioration continue : Encourager la rÃ©flexion et lâ€™optimisation Facilitation de la collaboration : Favoriser la communication entre tous les membres CompÃ©tences essentielles :\nLeadership serviteur (servant leadership) Empathie et intelligence Ã©motionnelle CompÃ©tences en facilitation de rÃ©unions AdaptabilitÃ© Communication efficace Connaissances techniques (optionnel mais utile) Ã€ noter : Le Scrum Master nâ€™est pas un gestionnaire traditionnel. Son rÃ´le est dâ€™habiliter lâ€™Ã©quipe Ã  sâ€™auto-organiser et Ã  rÃ©ussir. Les Scrum Masters ne sont pas remplacÃ©s par lâ€™IA car leur travail nÃ©cessite jugement humain, empathie et adaptabilitÃ©.\n3. Lâ€™Ã‰quipe de DÃ©veloppement (Development Team) CaractÃ©ristiques :\nTaille optimale : 5 Ã  11 membres (idÃ©alement 7) Cross-fonctionnelle : PossÃ¨de toutes les compÃ©tences nÃ©cessaires pour livrer lâ€™incrÃ©ment Auto-organisÃ©e : DÃ©cide comment accomplir le travail ResponsabilitÃ© collective : Tous sont responsables de la livraison Composition : Contrairement Ã  ce que le nom suggÃ¨re, lâ€™Ã©quipe de dÃ©veloppement nâ€™inclut pas seulement des programmeurs. Elle peut comprendre :\nDÃ©veloppeurs Designers RÃ©dacteurs Testeurs Analystes Tout autre rÃ´le nÃ©cessaire pour livrer le produit Leadership distribuÃ© : Il nâ€™y a pas de leader traditionnel dans une Ã©quipe Scrum. Le leadership est distribuÃ© : le Scrum Master dirige le processus, le Product Owner dirige la vision produit, et lâ€™Ã©quipe de dÃ©veloppement est collectivement responsable de la livraison.\nLes Artefacts Scrum Les artefacts Scrum reprÃ©sentent le travail ou la valeur et sont conÃ§us pour maximiser la transparence.\n1. Product Backlog (Backlog produit) DÃ©finition : Liste ordonnÃ©e et Ã©volutive de tout ce qui pourrait Ãªtre nÃ©cessaire dans le produit. Câ€™est la source unique de vÃ©ritÃ© pour les exigences.\nCaractÃ©ristiques :\nVivant et dynamique : Constamment mis Ã  jour en fonction des retours et des apprentissages PriorisÃ© : Les Ã©lÃ©ments sont classÃ©s par valeur mÃ©tier et urgence DÃ©taillÃ© au sommet : Les Ã©lÃ©ments en haut sont plus dÃ©taillÃ©s que ceux en bas PropriÃ©tÃ© : GÃ©rÃ© par le Product Owner (bien que dâ€™autres puissent y contribuer) Contenu typique :\nUser Stories Bugs AmÃ©liorations techniques Recherches nÃ©cessaires 2. Sprint Backlog DÃ©finition : Ensemble des Ã©lÃ©ments du Product Backlog sÃ©lectionnÃ©s pour le sprint, plus un plan pour livrer lâ€™incrÃ©ment et atteindre lâ€™objectif du sprint.\nCaractÃ©ristiques :\nEngagement de lâ€™Ã©quipe : Lâ€™Ã©quipe sâ€™engage Ã  livrer ces Ã©lÃ©ments durant le sprint Flexible pendant le sprint : Peut Ãªtre ajustÃ© si nÃ©cessaire, en accord avec lâ€™Ã©quipe Visible et transparent : GÃ©nÃ©ralement affichÃ© sur un tableau Scrum (physique ou numÃ©rique) Ã‰tats typiques :\nÃ€ faire (To Do) En cours (In Progress) TerminÃ© (Done) 3. IncrÃ©ment DÃ©finition : La somme de tous les Ã©lÃ©ments du Product Backlog complÃ©tÃ©s durant un sprint et tous les sprints prÃ©cÃ©dents. Câ€™est le produit potentiellement livrable.\nCritÃ¨res :\nDÃ©finition de â€œDoneâ€ : Doit respecter la dÃ©finition dâ€™achÃ¨vement de lâ€™Ã©quipe Utilisable : Doit Ãªtre dans un Ã©tat utilisable, mÃªme si le Product Owner dÃ©cide de ne pas le livrer Cumulatif : Chaque incrÃ©ment sâ€™ajoute aux prÃ©cÃ©dents Les CÃ©rÃ©monies Scrum Les cÃ©rÃ©monies (ou Ã©vÃ©nements) Scrum crÃ©ent une rÃ©gularitÃ© et aident les Ã©quipes Ã  maintenir une communication transparente. Elles sont time-boxed (limitÃ©es dans le temps) et ont des objectifs spÃ©cifiques.\n1. Sprint Planning (Planification de Sprint) Objectif : DÃ©finir ce qui peut Ãªtre livrÃ© dans le sprint et comment ce travail sera accompli.\nDurÃ©e : Maximum 8 heures pour un sprint dâ€™un mois (proportionnel pour des sprints plus courts, ex : 4 heures pour 2 semaines)\nParticipants :\nProduct Owner (prÃ©sente le Product Backlog) Scrum Master (facilite) Ã‰quipe de dÃ©veloppement complÃ¨te Structure typique :\nPartie 1 - Quoi ? (1Ã¨re moitiÃ©)\nLe Product Owner prÃ©sente les Ã©lÃ©ments prioritaires du Product Backlog Lâ€™Ã©quipe pose des questions pour clarifier les exigences Lâ€™Ã©quipe sÃ©lectionne les Ã©lÃ©ments quâ€™elle pense pouvoir complÃ©ter DÃ©finition de lâ€™objectif du sprint (Sprint Goal) Partie 2 - Comment ? (2Ã¨me moitiÃ©)\nLâ€™Ã©quipe dÃ©compose les Ã©lÃ©ments sÃ©lectionnÃ©s en tÃ¢ches Estimation de lâ€™effort (story points, heures, etc.) Identification des dÃ©pendances et des risques CrÃ©ation du Sprint Backlog RÃ©sultat :\nSprint Backlog complet Objectif du sprint clair Engagement de lâ€™Ã©quipe 2. Daily Scrum (MÃªlÃ©e quotidienne / Standup) Objectif : Synchroniser les activitÃ©s et crÃ©er un plan pour les prochaines 24 heures. Identifier rapidement les obstacles.\nDurÃ©e : Maximum 15 minutes (dâ€™oÃ¹ lâ€™appellation â€œstandupâ€ - debout pour garder la rÃ©union courte)\nFrÃ©quence : Chaque jour Ã  la mÃªme heure, au mÃªme endroit\nParticipants :\nÃ‰quipe de dÃ©veloppement (obligatoire) Scrum Master (facilite si nÃ©cessaire) Product Owner (optionnel, en observateur) Format classique - Les 3 questions : Chaque membre de lâ€™Ã©quipe rÃ©pond Ã  :\nQuâ€™ai-je accompli hier qui a aidÃ© lâ€™Ã©quipe Ã  atteindre lâ€™objectif du sprint ? Que vais-je faire aujourdâ€™hui pour aider lâ€™Ã©quipe Ã  atteindre lâ€™objectif du sprint ? Y a-t-il des obstacles qui mâ€™empÃªchent ou qui empÃªchent lâ€™Ã©quipe dâ€™atteindre lâ€™objectif ? Bonnes pratiques :\nRester debout pour maintenir lâ€™Ã©nergie et la briÃ¨vetÃ© Se concentrer sur les progrÃ¨s, pas sur un rapport de statut dÃ©taillÃ© Ton lÃ©ger et amusant, mais informatif ResponsabilitÃ© implicite devant les pairs Les discussions dÃ©taillÃ©es se font aprÃ¨s le standup Ne pas rÃ©server de salle de confÃ©rence - le faire prÃ¨s du tableau Scrum Ã€ Ã©viter :\nTransformer le standup en rÃ©union dâ€™une heure Rapports dÃ©taillÃ©s au Scrum Master ou Product Owner RÃ©solution de problÃ¨mes complexes (reporter aprÃ¨s) 3. Sprint Review (Revue de Sprint) Objectif : Inspecter lâ€™incrÃ©ment et adapter le Product Backlog si nÃ©cessaire. Obtenir des retours des parties prenantes.\nDurÃ©e : Maximum 4 heures pour un sprint dâ€™un mois (proportionnel pour sprints plus courts)\nParticipants :\nÃ‰quipe Scrum complÃ¨te Parties prenantes Clients (si possible) Management Structure typique :\nIntroduction (Product Owner)\nRappel de lâ€™objectif du sprint Ã‰lÃ©ments complÃ©tÃ©s vs planifiÃ©s DÃ©monstration (Ã‰quipe de dÃ©veloppement)\nPrÃ©sentation de lâ€™incrÃ©ment fonctionnel FonctionnalitÃ©s en action, pas de slides PowerPoint Les parties prenantes testent et manipulent le produit Discussion (Tous)\nRetours et questions Ce qui fonctionne bien Suggestions dâ€™amÃ©liorations Discussion sur le marchÃ© ou lâ€™utilisation potentielle Mise Ã  jour du Product Backlog (Product Owner)\nAjustement des prioritÃ©s basÃ© sur les retours Nouvelles idÃ©es de fonctionnalitÃ©s RÃ©vision de la timeline si nÃ©cessaire RÃ©sultat :\nProduct Backlog rÃ©visÃ© ComprÃ©hension partagÃ©e de ce qui a Ã©tÃ© accompli Retours prÃ©cieux pour orienter le prochain sprint Philosophie : La revue nâ€™est PAS une porte de validation (gate). Câ€™est une opportunitÃ© dâ€™inspection et dâ€™adaptation collaborative. IdÃ©alement, les Ã©quipes livrent frÃ©quemment tout au long du sprint, permettant Ã  la revue de porter sur lâ€™usage rÃ©el par les clients.\n4. Sprint Retrospective (RÃ©trospective) Objectif : RÃ©flÃ©chir sur le sprint Ã©coulÃ© et identifier des amÃ©liorations concrÃ¨tes pour le prochain sprint. Câ€™est le cÅ“ur de lâ€™amÃ©lioration continue.\nDurÃ©e : Maximum 3 heures pour un sprint dâ€™un mois (1,5 heure pour 2 semaines)\nTiming : AprÃ¨s la Sprint Review, avant la prochaine Sprint Planning\nParticipants :\nÃ‰quipe de dÃ©veloppement Scrum Master (facilite) Product Owner (optionnel mais recommandÃ©) Structure typique :\nPrÃ©parer le terrain (5-10 minutes)\nCrÃ©er un environnement sÃ»r et ouvert Rappeler la prime directive : â€œNous croyons que tous ont fait de leur mieuxâ€ Collecter des donnÃ©es (20-30 minutes)\nCe qui a bien fonctionnÃ© Ce qui nâ€™a pas fonctionnÃ© Puzzles ou questions GÃ©nÃ©rer des insights (20-30 minutes)\nIdentifier les patterns Analyser les causes profondes Discussions en groupe DÃ©cider quoi faire (15-20 minutes)\nSÃ©lectionner 1-3 actions dâ€™amÃ©lioration DÃ©finir des actions concrÃ¨tes et mesurables Assigner des responsables ClÃ´ture (5-10 minutes)\nRÃ©sumer les dÃ©cisions ApprÃ©ciation de lâ€™Ã©quipe Techniques populaires :\nStart, Stop, Continue : Quoi commencer Ã  faire, arrÃªter de faire, continuer de faire Glad, Sad, Mad : Ce qui nous rend heureux, triste ou en colÃ¨re 4Ls : Liked, Learned, Lacked, Longed for Sailboat : Vents favorables (ce qui nous aide), ancres (ce qui nous freine) Bonnes pratiques :\nCe nâ€™est PAS seulement un moment pour se plaindre Focus sur les solutions, pas seulement les problÃ¨mes MÃªme si tout va bien, continuer les rÃ©trospectives Varier les formats pour maintenir lâ€™engagement Suivre les actions dÃ©cidÃ©es lors de la prochaine rÃ©tro RÃ©sultat :\n1-3 amÃ©liorations concrÃ¨tes identifiÃ©es Plan dâ€™action pour le prochain sprint Engagement de lâ€™Ã©quipe envers lâ€™amÃ©lioration Citation clÃ© : â€œLâ€™amÃ©lioration continue est ce qui soutient et stimule le dÃ©veloppement au sein dâ€™une Ã©quipe agile, et les rÃ©trospectives en sont un Ã©lÃ©ment clÃ©.â€\n5. Product Backlog Refinement (Affinement du Backlog) Note : Bien que non officielle dans le Scrum Guide original, cette cÃ©rÃ©monie est largement adoptÃ©e.\nObjectif : Ajouter des dÃ©tails, des estimations et de lâ€™ordre aux Ã©lÃ©ments du Product Backlog pour prÃ©parer les futurs sprints.\nDurÃ©e : GÃ©nÃ©ralement 1-2 heures par semaine (environ 10% de la capacitÃ© du sprint)\nParticipants :\nProduct Owner (dirige) Ã‰quipe de dÃ©veloppement Scrum Master (facilite si nÃ©cessaire) ActivitÃ©s :\nClarification : Discuter des user stories Ã  venir DÃ©composition : Diviser les grandes stories en plus petites Estimation : Estimer lâ€™effort nÃ©cessaire (story points) CritÃ¨res dâ€™acceptation : DÃ©finir la â€œDefinition of Doneâ€ pour chaque story Priorisation : RÃ©organiser selon la valeur mÃ©tier RÃ©sultat : Un backlog â€œprÃªtâ€ (ready) avec des Ã©lÃ©ments clairs et estimÃ©s pour la prochaine planification de sprint.\nEpics, Stories et Sprints User Stories (Histoires Utilisateur) DÃ©finition : Une user story est une description concise dâ€™une fonctionnalitÃ© du point de vue de lâ€™utilisateur final. Elle utilise un langage non technique pour fournir du contexte Ã  lâ€™Ã©quipe.\nFormat standard :\nEn tant que [persona/rÃ´le],\rJe veux [objectif/dÃ©sir],\rAfin de [bÃ©nÃ©fice/valeur]. Exemple :\nEn tant que client rÃ©gulier,\rJe veux sauvegarder des articles dans une liste de souhaits,\rAfin de pouvoir les acheter plus tard. Composantes dâ€™une bonne user story - INVEST :\nIndÃ©pendante : Peut Ãªtre dÃ©veloppÃ©e sans dÃ©pendre dâ€™autres stories NÃ©gociable : Les dÃ©tails peuvent Ãªtre discutÃ©s et ajustÃ©s ValorisÃ©e : Apporte de la valeur claire Ã  lâ€™utilisateur Estimable : Lâ€™Ã©quipe peut estimer lâ€™effort nÃ©cessaire Small (Petite) : Peut Ãªtre complÃ©tÃ©e en un sprint Testable : Des critÃ¨res dâ€™acceptation clairs existent CritÃ¨res dâ€™acceptation : Conditions spÃ©cifiques qui doivent Ãªtre remplies pour que la story soit considÃ©rÃ©e comme â€œDoneâ€. Exemple :\nUser Story : Connexion utilisateur\rCritÃ¨res d'acceptation :\r- L'utilisateur peut entrer son email et mot de passe\r- Un message d'erreur s'affiche si les identifiants sont incorrects\r- L'utilisateur est redirigÃ© vers le tableau de bord aprÃ¨s connexion rÃ©ussie\r- Un lien \"Mot de passe oubliÃ©\" est visible\r- La session reste active pendant 24 heures Taille : Une story doit pouvoir Ãªtre complÃ©tÃ©e dans un sprint. Si une story prend des semaines ou des mois, elle devrait Ãªtre dÃ©composÃ©e ou considÃ©rÃ©e comme un epic.\nQuand utiliser les stories :\nDÃ©veloppement de nouvelles fonctionnalitÃ©s AmÃ©lioration dâ€™expÃ©rience utilisateur Corrections de bugs (format adaptÃ©) Travail qui peut Ãªtre complÃ©tÃ© en une ou deux semaines Epics DÃ©finition : Un epic est un grand corps de travail qui peut Ãªtre dÃ©composÃ© en plusieurs user stories plus petites. Les epics reprÃ©sentent souvent une fonctionnalitÃ© majeure ou un objectif important.\nCaractÃ©ristiques :\nLarge portÃ©e : Trop grand pour Ãªtre complÃ©tÃ© en un seul sprint DÃ©composable : Se divise en plusieurs stories Ã‰volutif : Les stories associÃ©es peuvent Ãªtre ajoutÃ©es ou retirÃ©es selon les retours Multi-sprints : GÃ©nÃ©ralement livrÃ© sur plusieurs sprints Flexible : La portÃ©e sâ€™adapte selon les retours clients et le rythme de lâ€™Ã©quipe Exemple dâ€™epic et ses stories :\nEPIC : SystÃ¨me d'authentification utilisateur\rStories :\râ”œâ”€ Story 1 : ImplÃ©menter la fonctionnalitÃ© de connexion\râ”œâ”€ Story 2 : CrÃ©er la fonctionnalitÃ© de rÃ©initialisation de mot de passe\râ”œâ”€ Story 3 : Ajouter l'authentification Ã  deux facteurs\râ”œâ”€ Story 4 : DÃ©velopper la dÃ©connexion automatique aprÃ¨s inactivitÃ©\râ””â”€ Story 5 : CrÃ©er la gestion de sessions utilisateur Quand crÃ©er un epic :\nVous avez un grand volume de travail qui nÃ©cessite plusieurs sprints Vous remarquez un pattern parmi plusieurs user stories Vous voulez regrouper des stories liÃ©es sous une mÃªme initiative Techniques pour dÃ©composer un epic en stories :\nPar rÃ´le utilisateur : CrÃ©er une story pour chaque persona\nâ€œConnexion rapide pour nouveaux visiteursâ€ â€œConnexion rapide pour clients rÃ©guliersâ€ Par Ã©tapes du processus : Une story par Ã©tape\nâ€œSaisie des identifiantsâ€ â€œValidation des identifiantsâ€ â€œCrÃ©ation de sessionâ€ Par CRUD (Create, Read, Update, Delete) :\nâ€œCrÃ©er un compte utilisateurâ€ â€œAfficher le profil utilisateurâ€ â€œModifier les informations du profilâ€ â€œSupprimer un compteâ€ Par plateforme :\nâ€œConnexion sur mobileâ€ â€œConnexion sur webâ€ â€œConnexion sur tabletteâ€ Par critÃ¨res de temps :\nStories qui peuvent Ãªtre complÃ©tÃ©es en un sprint ou moins Estimation des epics : Les epics sont gÃ©nÃ©ralement estimÃ©s avec des tailles T-shirt (XS, S, M, L, XL) ou en nombre de sprints nÃ©cessaires, plutÃ´t quâ€™en story points prÃ©cis.\nSprints DÃ©finition : Un sprint est une pÃ©riode time-boxed (durÃ©e fixe) pendant laquelle une Ã©quipe Scrum travaille pour complÃ©ter une quantitÃ© dÃ©finie de travail. Câ€™est le cÅ“ur de Scrum.\nCaractÃ©ristiques :\nDurÃ©e fixe : GÃ©nÃ©ralement 1, 2 ou 4 semaines (2 semaines est le plus courant) Objectif clair : Chaque sprint a un Sprint Goal spÃ©cifique Cadence rÃ©guliÃ¨re : Lâ€™Ã©quipe opÃ¨re perpÃ©tuellement sur cette cadence Livrable : Produit un incrÃ©ment potentiellement livrable Anatomie dâ€™un sprint :\nSprint de 2 semaines (exemple)\rJour 1 :\râ””â”€ Sprint Planning (4h)\rJours 2-10 :\râ”œâ”€ Daily Scrum (15 min/jour)\râ””â”€ Travail de dÃ©veloppement\rJour 10 :\râ”œâ”€ Sprint Review (2h)\râ””â”€ Sprint Retrospective (1.5h)\rJour 11 :\râ””â”€ DÃ©but du prochain sprint Pourquoi des sprints fixes ?\nPrÃ©visibilitÃ© : Aide Ã  prÃ©voir la vÃ©locitÃ© future Rythme : CrÃ©e un battement rÃ©gulier pour lâ€™Ã©quipe Focus : Limite le travail en cours Livraison rÃ©guliÃ¨re : Valeur livrÃ©e frÃ©quemment Feedback rapide : Retours rÃ©guliers des parties prenantes Sprint Goal (Objectif du Sprint) : Une dÃ©claration courte dÃ©crivant ce que le sprint vise Ã  accomplir. Il fournit une orientation et permet une certaine flexibilitÃ© dans lâ€™implÃ©mentation.\nExemple de Sprint Goals :\nâ€œPermettre aux utilisateurs de crÃ©er et gÃ©rer leur profilâ€ â€œAmÃ©liorer la performance de chargement des pages de 50%â€ â€œImplÃ©menter le systÃ¨me de paiement de baseâ€ VÃ©locitÃ© (Velocity) : Mesure de la quantitÃ© de travail quâ€™une Ã©quipe peut accomplir durant un sprint, gÃ©nÃ©ralement exprimÃ©e en story points.\nCalculÃ©e en additionnant les points de toutes les stories complÃ©tÃ©es UtilisÃ©e pour prÃ©voir combien de travail peut Ãªtre fait dans les futurs sprints Devient plus prÃ©cise au fil du temps Que se passe-t-il si le travail nâ€™est pas terminÃ© ?\nÃ€ la fin du sprint, vous avez plusieurs options :\nRetourner au backlog : Lâ€™histoire retourne dans le Product Backlog DÃ©placer au prochain sprint : Si presque terminÃ©e et toujours prioritaire CrÃ©er un nouveau sprint : Jira peut crÃ©er automatiquement Important : Tous les sous-tÃ¢ches doivent Ãªtre complÃ©tÃ©es pour fermer un sprint.\nInitiatives DÃ©finition : Une initiative est une collection dâ€™epics qui travaillent ensemble vers un objectif stratÃ©gique commun, souvent Ã  lâ€™Ã©chelle de lâ€™entreprise.\nHiÃ©rarchie complÃ¨te :\nINITIATIVE (1 an)\râ”‚\râ”œâ”€ EPIC 1 (1-3 mois)\râ”‚ â”œâ”€ Story 1.1 (1 sprint)\râ”‚ â”œâ”€ Story 1.2 (1 sprint)\râ”‚ â””â”€ Story 1.3 (1 sprint)\râ”‚\râ”œâ”€ EPIC 2 (1-3 mois)\râ”‚ â”œâ”€ Story 2.1 (1 sprint)\râ”‚ â””â”€ Story 2.2 (1 sprint)\râ”‚\râ””â”€ EPIC 3 (1-3 mois)\râ”œâ”€ Story 3.1 (1 sprint)\râ”œâ”€ Story 3.2 (1 sprint)\râ””â”€ Story 3.3 (1 sprint) Exemple concret - Entreprise de fusÃ©es spatiales :\nINITIATIVE : RÃ©duire le coÃ»t par lancement de 5% cette annÃ©e\râ”œâ”€ EPIC 1 : Optimiser la consommation de carburant\râ”‚ â”œâ”€ Story : Analyser les donnÃ©es de consommation des 10 derniers lancements\râ”‚ â”œâ”€ Story : DÃ©velopper un algorithme d'optimisation de trajectoire\râ”‚ â””â”€ Story : Tester le nouvel algorithme en simulation\râ”‚\râ”œâ”€ EPIC 2 : Automatiser les vÃ©rifications prÃ©-lancement\râ”‚ â”œâ”€ Story : CrÃ©er un systÃ¨me de diagnostic automatique\râ”‚ â”œâ”€ Story : ImplÃ©menter des capteurs IoT supplÃ©mentaires\râ”‚ â””â”€ Story : DÃ©velopper le tableau de bord de monitoring\râ”‚\râ””â”€ EPIC 3 : AmÃ©liorer la rÃ©utilisabilitÃ© des composants\râ”œâ”€ Story : Concevoir un systÃ¨me de rÃ©cupÃ©ration amÃ©liorÃ©\râ”œâ”€ Story : DÃ©velopper les tests de rÃ©sistance des matÃ©riaux\râ””â”€ Story : CrÃ©er le processus de reconditionnement Timeframes typiques :\nStory : 1-2 semaines (1 sprint) Epic : 1-3 mois (plusieurs sprints) Initiative : 6-12 mois (plusieurs quarters) Relation entre Backlog, Stories, Epics et Sprints Product Backlog : Contient toutes les stories et epics priorisÃ©s\nSprint Backlog : Contient les stories sÃ©lectionnÃ©es pour le sprint actuel\nFlux de travail typique :\nLe Product Owner ajoute un epic au Product Backlog Lâ€™epic est dÃ©composÃ© en stories pendant le Backlog Refinement Les stories sont estimÃ©es et priorisÃ©es Pendant Sprint Planning, les stories en haut du backlog sont sÃ©lectionnÃ©es pour le sprint Ces stories deviennent le Sprint Backlog Lâ€™Ã©quipe complÃ¨te les stories durant le sprint Les stories complÃ©tÃ©es contribuent Ã  lâ€™avancement de lâ€™epic Le processus se rÃ©pÃ¨te jusquâ€™Ã  ce que lâ€™epic soit complÃ©tÃ© Exercice Pratique pour Ã‰tudiants ğŸ¯ Exercice : â€œLe Festival Ã‰tudiantâ€ Contexte Votre classe est responsable de lâ€™organisation dâ€™un festival Ã©tudiant qui aura lieu dans 6 semaines (3 sprints de 2 semaines). Le festival comprendra de la musique, de la nourriture, des activitÃ©s et des compÃ©titions.\nObjectif PÃ©dagogique Cet exercice permet aux Ã©tudiants de :\nPratiquer tous les rÃ´les Scrum Vivre toutes les cÃ©rÃ©monies CrÃ©er et gÃ©rer des epics, stories et sprints ExpÃ©rimenter la collaboration agile Comprendre lâ€™importance de lâ€™adaptation ğŸ“‹ Phase 1 : Mise en Place (30 minutes) Ã‰tape 1 : Formation des Ã©quipes (10 min) Formez des Ã©quipes de 5-7 Ã©tudiants Chaque Ã©quipe reprÃ©sente une â€œÃ©quipe Scrumâ€ Ã‰tape 2 : Attribution des rÃ´les (10 min) Chaque Ã©quipe assigne les rÃ´les (rotation Ã  chaque sprint) :\n1 Product Owner : ReprÃ©sente les Ã©tudiants qui participeront au festival 1 Scrum Master : Facilite les cÃ©rÃ©monies et supprime les obstacles 3-5 DÃ©veloppeurs : Ã‰quipe qui exÃ©cute le travail Ã‰tape 3 : CrÃ©ation de la vision (10 min) Le Product Owner de chaque Ã©quipe dÃ©finit :\nLa vision du festival Les contraintes (budget fictif, espace, rÃ¨glements) Les attentes des â€œutilisateursâ€ (Ã©tudiants participants) ğŸ“ Phase 2 : CrÃ©ation du Product Backlog (45 minutes) Ã‰tape 1 : Identifier les Epics (15 min) Lâ€™Ã©quipe identifie les grands domaines du festival. Exemples dâ€™epics :\nEPIC 1 : Programmation musicale\rEPIC 2 : Stands de nourriture et boissons\rEPIC 3 : ActivitÃ©s et animations\rEPIC 4 : Marketing et communication\rEPIC 5 : Logistique et infrastructure\rEPIC 6 : Gestion budgÃ©taire Ã‰tape 2 : DÃ©composer en User Stories (25 min) Pour chaque epic, crÃ©ez des user stories au format : â€œEn tant que [persona], je veux [objectif], afin de [bÃ©nÃ©fice]â€\nExemples de stories pour EPIC 1 (Programmation musicale) :\nStory 1.1 : En tant que participant, je veux voir la liste des groupes qui se produiront, afin de dÃ©cider si je veux assister au festival.\rStory 1.2 : En tant que participant, je veux connaÃ®tre l'horaire des performances, afin de planifier ma journÃ©e.\rStory 1.3 : En tant qu'organisateur, je veux crÃ©er une scÃ¨ne avec systÃ¨me audio, afin que les groupes puissent performer.\rStory 1.4 : En tant que participant malentendant, je veux avoir accÃ¨s Ã  une interprÃ©tation en langue des signes, afin de profiter des spectacles. Exemples pour EPIC 4 (Marketing et communication) :\nStory 4.1 : En tant qu'Ã©tudiant potentiel, je veux voir des affiches dans l'Ã©cole, afin d'Ãªtre informÃ© du festival.\rStory 4.2 : En tant qu'Ã©tudiant, je veux pouvoir acheter des billets en ligne, afin d'Ã©viter les files d'attente.\rStory 4.3 : En tant qu'organisateur, je veux crÃ©er une page Instagram pour l'Ã©vÃ©nement, afin de gÃ©nÃ©rer de l'engouement. Ã‰tape 3 : Ajouter les critÃ¨res dâ€™acceptation (15 min) Pour chaque story, dÃ©finissez 2-3 critÃ¨res dâ€™acceptation.\nExemple pour Story 1.1 :\nCritÃ¨res d'acceptation :\râœ“ Une liste de minimum 3 groupes est confirmÃ©e\râœ“ Une courte bio de chaque groupe est disponible\râœ“ Des liens vers la musique de chaque groupe sont fournis\râœ“ Les genres musicaux sont clairement indiquÃ©s Ã‰tape 4 : Estimation (10 min) Utilisez la technique du Planning Poker :\nCartes avec valeurs : 1, 2, 3, 5, 8, 13, 20 Chaque membre estime silencieusement RÃ©vÃ¨le simultanÃ©ment Discussion sur les Ã©carts Consensus Note : Pour lâ€™exercice, 1 point = 1 heure de travail fictif\nğŸš€ Phase 3 : Sprint 1 (1 semaine simulÃ©e = 1 heure de classe) Sprint Planning - Partie 1 : Quoi ? (15 min) Le Product Owner prÃ©sente les stories prioritaires (5 min)\nLit chaque story Explique la valeur RÃ©pond aux questions DÃ©finir le Sprint Goal (5 min) Exemple : â€œCrÃ©er lâ€™infrastructure de base et la stratÃ©gie marketing initialeâ€\nSÃ©lectionner les stories (5 min)\nLâ€™Ã©quipe choisit les stories quâ€™elle peut complÃ©ter BasÃ© sur la vÃ©locitÃ© estimÃ©e (pour Sprint 1, estimez conservativement) Exemple : Si lâ€™Ã©quipe pense pouvoir faire 15 points, sÃ©lectionner des stories totalisant 12-15 points Sprint Planning - Partie 2 : Comment ? (10 min) DÃ©composer en tÃ¢ches Pour chaque story sÃ©lectionnÃ©e, crÃ©er des tÃ¢ches concrÃ¨tes.\nExemple pour Story 1.1 (Liste des groupes) :\nTÃ¢ches :\râ–¡ Contacter 5 groupes potentiels\râ–¡ NÃ©gocier les cachetsfictifs\râ–¡ Obtenir les confirmations Ã©crites\râ–¡ RÃ©diger les biographies\râ–¡ Collecter les liens musicaux\râ–¡ CrÃ©er la page web de prÃ©sentation Attribution initiale (optionnel)\nLes dÃ©veloppeurs peuvent sâ€™assigner des tÃ¢ches Ou dÃ©cider de sâ€™organiser jour par jour Daily Scrum (Simulation - 3 fois pendant le sprint - 5 min chaque) Simulation 1 - DÃ©but du sprint : Chaque dÃ©veloppeur rÃ©pond :\nQuâ€™ai-je choisi de faire aujourdâ€™hui ? Comment vais-je contribuer au Sprint Goal ? Y a-t-il des obstacles anticipÃ©s ? Simulation 2 - Milieu du sprint :\nQuâ€™ai-je accompli depuis hier ? Que vais-je faire aujourdâ€™hui ? Y a-t-il des obstacles ? Exemple de dÃ©roulement :\nMarie : \"Hier j'ai contactÃ© 5 groupes. Aujourd'hui je vais nÃ©gocier avec les 2 qui ont rÃ©pondu positivement. Aucun obstacle.\"\rJean : \"Hier j'ai commencÃ© la page web de prÃ©sentation. Aujourd'hui je vais finir le design et intÃ©grer les infos. J'ai besoin des biographies de Marie pour avancer.\"\rSophie : \"Hier j'ai crÃ©Ã© la page Instagram et postÃ© 2 visuels. Aujourd'hui je vais crÃ©er les affiches Ã  imprimer. Pas d'obstacle.\" Simulation 3 - Fin du sprint :\nQuâ€™ai-je accompli depuis hier ? Que reste-t-il Ã  finaliser ? Quelles stories sont â€œDoneâ€ ? RÃ´le du Scrum Master pendant les Standups :\nSâ€™assurer que câ€™est rapide (15 min max) Noter les obstacles mentionnÃ©s Faciliter les conversations bloquÃ©es Reporter les discussions dÃ©taillÃ©es aprÃ¨s le standup Travail du Sprint (Simulation - 15 min) Les Ã©quipes â€œtravaillentâ€ sur leurs tÃ¢ches. Pour lâ€™exercice :\nCrÃ©er des maquettes rapides (dessins, documents) Lister les Ã©tapes quâ€™ils feraient rÃ©ellement DÃ©placer les stories sur le tableau Scrum (Ã€ faire â†’ En cours â†’ Done) Simuler des obstacles (ex : â€œLe budget pour un groupe est insuffisantâ€) Tableau Scrum Ã  utiliser :\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ TO DO â”‚ IN PROGRESS â”‚ TESTING â”‚ DONE â”‚\râ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\râ”‚ Story 1.1 â”‚ â”‚ â”‚ â”‚\râ”‚ Story 4.1 â”‚ â”‚ â”‚ â”‚\râ”‚ Story 5.1 â”‚ â”‚ â”‚ â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Sprint Review (10 min) Introduction par le Product Owner (2 min)\nRappel du Sprint Goal Vue dâ€™ensemble de ce qui a Ã©tÃ© planifiÃ© DÃ©monstration par lâ€™Ã©quipe (5 min)\nChaque story â€œDoneâ€ est dÃ©montrÃ©e Montrer les livrables concrets (maquettes, plans, documents) Les â€œparties prenantesâ€ (autres Ã©quipes) posent des questions Feedback et mise Ã  jour du backlog (3 min)\nRecueillir les retours Ajuster les prioritÃ©s si nÃ©cessaire Identifier de nouvelles stories Ã  ajouter Exemple de dÃ©monstration :\nDÃ©veloppeur : \"Nous avons complÃ©tÃ© la Story 1.1. Voici la maquette de la page web qui prÃ©sente les 3 groupes confirmÃ©s. Chaque groupe a une bio de 50 mots et 2 liens vers leur musique.\"\rPartie prenante : \"Super ! Est-ce que les horaires de chaque groupe seront sur cette page aussi ?\"\rProduct Owner : \"Bonne question. J'ajoute une story pour Ã§a au backlog.\" Sprint Retrospective (10 min) PrÃ©parer le terrain (2 min) Le Scrum Master crÃ©e un environnement sÃ»r et rappelle la prime directive.\nFormat Start-Stop-Continue (6 min)\nLâ€™Ã©quipe identifie :\nSTART (Commencer Ã  faire) :\nQuelles nouvelles pratiques adopter ? Exemple : â€œCommencer Ã  prÃ©parer les questions avant le standupâ€ STOP (ArrÃªter de faire) :\nQuoi cesser car inefficace ? Exemple : â€œArrÃªter de vÃ©rifier nos tÃ©lÃ©phones pendant les rÃ©unionsâ€ CONTINUE (Continuer Ã  faire) :\nCe qui fonctionne bien et doit continuer Exemple : â€œContinuer Ã  se rÃ©partir les tÃ¢ches Ã©quitablementâ€ SÃ©lectionner 2 actions concrÃ¨tes (2 min)\nVoter sur les amÃ©liorations prioritaires DÃ©finir comment les implÃ©menter au prochain sprint Assigner un responsable pour chaque action Exemple de rÃ©trospective :\nSTART :\r- Faire un backlog refinement mid-sprint pour clarifier les stories Ã  venir\r- Utiliser un timer pour les standups\rSTOP :\r- Attendre la derniÃ¨re minute pour demander de l'aide\r- Avoir des rÃ©unions en retard\rCONTINUE :\r- CÃ©lÃ©brer les petites victoires\r- Partager les connaissances entre membres\rActions choisies pour Sprint 2 :\r1. Jean sera responsable du timer pendant les standups âœ“\r2. Marie organisera un refinement Ã  mi-sprint âœ“ ğŸ”„ Phase 4 : Sprints 2 et 3 (mÃªme structure) Sprint 2 et 3 suivent la mÃªme structure :\nSprint Planning Daily Scrums (3 simulations) Travail du sprint Sprint Review Sprint Retrospective ParticularitÃ©s Ã  introduire :\nSprint 2 - Changements et adaptation :\nLe professeur introduit un â€œchangement de prioritÃ©â€ (simulation rÃ©aliste) Exemple : â€œUn groupe annule, il faut trouver un remplaÃ§ant rapidementâ€ Lâ€™Ã©quipe doit adapter son Sprint Backlog Discussion : Comment gÃ©rer le changement en Scrum ? Sprint 3 - Finalisation et livraison :\nFocus sur la complÃ©tion de lâ€™incrÃ©ment final PrÃ©paration dâ€™une dÃ©mo complÃ¨te du festival planifiÃ© RÃ©trospective globale sur les 3 sprints ğŸ“Š Phase 5 : PrÃ©sentation Finale et DÃ©briefing (45 minutes) PrÃ©sentations des Ã©quipes (25 min - 5 min par Ã©quipe) Chaque Ã©quipe prÃ©sente :\nLeur festival final (2 min)\nQuâ€™est-ce qui a Ã©tÃ© livrÃ© ? Quels epics sont complÃ©tÃ©s ? MÃ©triques Scrum (1 min)\nVÃ©locitÃ© par sprint Graphique burndown Nombre de stories complÃ©tÃ©es Apprentissages clÃ©s (2 min)\nQuâ€™ont-ils appris sur Scrum ? Quels dÃ©fis ont-ils rencontrÃ©s ? Discussion de classe (20 min) Questions Ã  discuter :\nSur les rÃ´les :\nQuel rÃ´le avez-vous trouvÃ© le plus difficile ? Pourquoi ? Comment le Product Owner a-t-il gÃ©rÃ© les prioritÃ©s conflictuelles ? Comment le Scrum Master a-t-il supprimÃ© les obstacles ? Sur les cÃ©rÃ©monies :\nQuelle cÃ©rÃ©monie a Ã©tÃ© la plus utile ? Avez-vous trouvÃ© certaines rÃ©unions trop longues ou inutiles ? Comment les Daily Scrums ont-ils amÃ©liorÃ© la communication ? Sur les artefacts :\nComment le Product Backlog a-t-il Ã©voluÃ© ? Avez-vous bien estimÃ© votre vÃ©locitÃ© ? Quâ€™avez-vous appris sur la dÃ©composition des epics ? Sur lâ€™agilitÃ© :\nComment avez-vous rÃ©agi aux changements ? Quâ€™est-ce qui a facilitÃ© ou empÃªchÃ© lâ€™adaptation ? En quoi Scrum est-il diffÃ©rent dâ€™une gestion de projet traditionnelle ? Applications rÃ©elles :\nComment pourriez-vous utiliser Scrum dans dâ€™autres contextes ? Quelles limitations de Scrum avez-vous observÃ©es ? Dans quels types de projets Scrum serait-il inadaptÃ© ? ğŸ“ Livrables de lâ€™exercice Chaque Ã©quipe doit produire :\nProduct Backlog complet (Excel ou Jira)\nTous les epics Toutes les stories avec critÃ¨res dâ€™acceptation Estimations Sprint Backlogs (3)\nStories sÃ©lectionnÃ©es pour chaque sprint TÃ¢ches dÃ©taillÃ©es Attribution Graphiques de suivi\nBurndown chart pour chaque sprint VÃ©locitÃ© par sprint Graphique dâ€™avancement des epics Notes de rÃ©trospectives (3)\nCe qui a bien fonctionnÃ© Ce qui nâ€™a pas fonctionnÃ© Actions dâ€™amÃ©lioration identifiÃ©es PrÃ©sentation finale\nPlan du festival DÃ©mos visuelles (affiches, site web mockup, etc.) RÃ©trospective globale Conclusion Scrum et Agile ne sont pas juste des processus, ce sont des mentalitÃ©s. Le succÃ¨s de Scrum repose sur :\nLa transparence : VisibilitÃ© sur le travail et les obstacles Lâ€™inspection : Ã‰valuation rÃ©guliÃ¨re des progrÃ¨s et du processus Lâ€™adaptation : Ajustement continu basÃ© sur lâ€™apprentissage La collaboration : Travail dâ€™Ã©quipe et communication ouverte La livraison de valeur : Focus constant sur ce qui compte pour lâ€™utilisateur Les cÃ©rÃ©monies Scrum ne sont pas des rÃ©unions bureaucratiques - elles sont des opportunitÃ©s dâ€™inspection et dâ€™adaptation qui permettent aux Ã©quipes de livrer mieux et plus rapidement.\nEn pratiquant Scrum Ã  travers cet exercice, vous dÃ©veloppez non seulement des compÃ©tences en gestion de projet, mais aussi en communication, collaboration, et rÃ©solution de problÃ¨mes - des compÃ©tences essentielles dans tous les domaines professionnels.\nRessources complÃ©mentaires Documentation officielle :\nScrum Guide : https://scrumguides.org/ Documentation Atlassian : https://www.atlassian.com/agile/scrum Outils populaires :\nJira : Pour la gestion de projets Scrum Trello : Alternative plus simple Miro/Mural : Pour les rÃ©trospectives et brainstorming Confluence : Pour la documentation dâ€™Ã©quipe Lectures recommandÃ©es :\nâ€œScrum: The Art of Doing Twice the Work in Half the Timeâ€ - Jeff Sutherland â€œUser Stories Appliedâ€ - Mike Cohn â€œThe Phoenix Projectâ€ - Gene Kim (DevOps et Agile) Certifications :\nCertified ScrumMaster (CSM) Professional Scrum Master (PSM) SAFe Agilist (pour lâ€™Agile Ã  lâ€™Ã©chelle) Document crÃ©Ã© sur la base des meilleures pratiques Scrum et Agile dâ€™Atlassian Version : 2.0 | FÃ©vrier 2026",
    "description": "Table des matiÃ¨res Introduction Ã  Agile Quâ€™est-ce que Scrum ? Les RÃ´les Scrum Les Artefacts Scrum Les CÃ©rÃ©monies Scrum Epics, Stories et Sprints Exercice Pratique pour Ã‰tudiants Introduction Ã  Agile Quâ€™est-ce que lâ€™Agile ? Agile est un ensemble de valeurs et de principes qui servent de philosophie de travail pour le dÃ©veloppement de produits et de projets. La mÃ©thodologie Agile a rÃ©volutionnÃ© la faÃ§on dont le travail est effectuÃ©, non seulement dans le dÃ©veloppement logiciel, mais aussi dans dâ€™autres domaines.",
    "tags": [],
    "title": "DÃ©finitions",
    "uri": "/420-413/agile_scrum/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "SystÃ¨me dâ€™authentification WPF - Epics, FonctionnalitÃ©s et User Stories Table des matiÃ¨res Vue dâ€™ensemble des Epics EPIC-01 : Authentification de base EPIC-02 : Validation et sÃ©curitÃ© EPIC-03 : ExpÃ©rience utilisateur EPIC-04 : RÃ©cupÃ©ration et aide EPIC-05 : Navigation et flux Tableau rÃ©capitulatif Roadmap recommandÃ©e 1. Vue dâ€™ensemble des Epics Epic ID Nom PrioritÃ© Stories Valeur mÃ©tier EPIC-01 Authentification de base ğŸ”´ Critique 6 FonctionnalitÃ© cÅ“ur EPIC-02 Validation et sÃ©curitÃ© ğŸ”´ Critique 7 Protection des donnÃ©es EPIC-03 ExpÃ©rience utilisateur ğŸŸ¡ Haute 5 Satisfaction client EPIC-04 RÃ©cupÃ©ration et aide ğŸŸ¢ Moyenne 3 Support autonome EPIC-05 Navigation et flux ğŸ”´ Critique 4 Parcours utilisateur TOTAL 25 2. EPIC-01 : Authentification de base Objectif : Permettre aux utilisateurs de sâ€™authentifier et dâ€™accÃ©der Ã  lâ€™application de maniÃ¨re sÃ©curisÃ©e.\nValeur mÃ©tier : Sans cette fonctionnalitÃ©, lâ€™application ne peut pas fonctionner. Câ€™est le cÅ“ur du systÃ¨me.\nFonctionnalitÃ©s de lâ€™Epic F-01.1 : Connexion utilisateur Permettre Ã  un utilisateur existant de se connecter avec ses identifiants.\nF-01.2 : CrÃ©ation de compte Permettre Ã  un nouvel utilisateur de crÃ©er un compte dans le systÃ¨me.\nF-01.3 : Gestion des sessions Maintenir la session utilisateur active aprÃ¨s connexion.\nUser Stories - EPIC-01 US-01.1 : Saisie des identifiants de connexion FonctionnalitÃ© : F-01.1 - Connexion utilisateur\nEn tant quâ€™ utilisateur enregistrÃ©\nJe veux saisir mon email et mon mot de passe\nAfin de me connecter Ã  mon compte\nCritÃ¨res dâ€™acceptation :\nUn champ â€œEmailâ€ est prÃ©sent et fonctionnel Un champ â€œMot de passeâ€ masque les caractÃ¨res saisis Les deux champs acceptent la saisie au clavier Le champ email accepte jusquâ€™Ã  100 caractÃ¨res Le champ mot de passe accepte jusquâ€™Ã  50 caractÃ¨res ScÃ©narios de test :\nâœ… Saisir un email valide âœ… Saisir un mot de passe âœ… VÃ©rifier que le mot de passe est masquÃ© US-01.2 : VÃ©rification des identifiants FonctionnalitÃ© : F-01.1 - Connexion utilisateur\nEn tant quâ€™ utilisateur enregistrÃ©\nJe veux que le systÃ¨me vÃ©rifie mes identifiants\nAfin de accÃ©der Ã  mon compte si ils sont corrects\nCritÃ¨res dâ€™acceptation :\nLe systÃ¨me vÃ©rifie lâ€™email dans la base de donnÃ©es Le systÃ¨me compare le mot de passe hashÃ© Si correct, lâ€™utilisateur est redirigÃ© vers la page principale Si incorrect, un message dâ€™erreur sâ€™affiche Le message dâ€™erreur ne rÃ©vÃ¨le pas si câ€™est lâ€™email ou le mot de passe qui est incorrect ScÃ©narios de test :\nâœ… Connexion avec identifiants valides âŒ Connexion avec email invalide âŒ Connexion avec mot de passe invalide âŒ Connexion avec email inexistant US-01.3 : Saisie des informations de crÃ©ation de compte FonctionnalitÃ© : F-01.2 - CrÃ©ation de compte\nEn tant que nouvel utilisateur\nJe veux saisir mes informations personnelles\nAfin de crÃ©er un nouveau compte\nCritÃ¨res dâ€™acceptation :\nUn champ â€œNom completâ€ est prÃ©sent Un champ â€œEmailâ€ est prÃ©sent Un champ â€œMot de passeâ€ est prÃ©sent Un champ â€œConfirmer mot de passeâ€ est prÃ©sent Tous les champs sont obligatoires ScÃ©narios de test :\nâœ… Remplir tous les champs avec des donnÃ©es valides âŒ Tenter de soumettre avec des champs vides âŒ Soumettre avec seulement certains champs remplis US-01.4 : CrÃ©ation du compte dans le systÃ¨me FonctionnalitÃ© : F-01.2 - CrÃ©ation de compte\nEn tant que nouvel utilisateur\nJe veux que mon compte soit crÃ©Ã© dans le systÃ¨me\nAfin de pouvoir me connecter par la suite\nCritÃ¨res dâ€™acceptation :\nLe systÃ¨me crÃ©e un nouvel enregistrement dans la base de donnÃ©es Le mot de passe est hashÃ© avant dâ€™Ãªtre stockÃ© Un ID unique est gÃ©nÃ©rÃ© pour lâ€™utilisateur La date de crÃ©ation est enregistrÃ©e Lâ€™utilisateur reÃ§oit une confirmation visuelle Lâ€™utilisateur est automatiquement connectÃ© aprÃ¨s crÃ©ation ScÃ©narios de test :\nâœ… CrÃ©er un compte avec toutes les informations valides âœ… VÃ©rifier que le compte existe dans la base de donnÃ©es âœ… VÃ©rifier que le mot de passe est hashÃ© US-01.5 : UnicitÃ© de lâ€™email FonctionnalitÃ© : F-01.2 - CrÃ©ation de compte\nEn tant que systÃ¨me\nJe veux vÃ©rifier que lâ€™email nâ€™existe pas dÃ©jÃ \nAfin de garantir un email unique par utilisateur\nCritÃ¨res dâ€™acceptation :\nLe systÃ¨me vÃ©rifie lâ€™email dans la base avant crÃ©ation Si lâ€™email existe, un message dâ€™erreur sâ€™affiche Le message suggÃ¨re de se connecter Ã  la place Le message propose un lien â€œMot de passe oubliÃ©?â€ ScÃ©narios de test :\nâŒ Tenter de crÃ©er un compte avec un email existant âœ… CrÃ©er un compte avec un email non utilisÃ© âœ… VÃ©rifier le message dâ€™erreur appropriÃ© US-01.6 : Maintien de la session FonctionnalitÃ© : F-01.3 - Gestion des sessions\nEn tant quâ€™ utilisateur connectÃ©\nJe veux que ma session reste active\nAfin de ne pas avoir Ã  me reconnecter constamment\nCritÃ¨res dâ€™acceptation :\nUn token de session est gÃ©nÃ©rÃ© Ã  la connexion La session reste active pendant 30 minutes dâ€™inactivitÃ© Lâ€™activitÃ© de lâ€™utilisateur prolonge la session Lâ€™utilisateur peut se dÃ©connecter manuellement ScÃ©narios de test :\nâœ… Rester connectÃ© pendant 15 minutes âœ… VÃ©rifier que la session expire aprÃ¨s 30 minutes dâ€™inactivitÃ© âœ… Utiliser lâ€™application et vÃ©rifier la prolongation 3. EPIC-02 : Validation et sÃ©curitÃ© Objectif : Garantir lâ€™intÃ©gritÃ© des donnÃ©es et la sÃ©curitÃ© des comptes utilisateurs.\nValeur mÃ©tier : ProtÃ¨ge lâ€™application contre les failles de sÃ©curitÃ© et garantit la qualitÃ© des donnÃ©es.\nFonctionnalitÃ©s de lâ€™Epic F-02.1 : Validation des champs VÃ©rifier que tous les champs requis sont remplis et ont le bon format.\nF-02.2 : Validation du mot de passe Assurer que les mots de passe respectent les critÃ¨res de sÃ©curitÃ©.\nF-02.3 : Protection contre les attaques ImplÃ©menter des mesures de sÃ©curitÃ© contre les attaques courantes.\nUser Stories - EPIC-02 US-02.1 : Validation champs obligatoires FonctionnalitÃ© : F-02.1 - Validation des champs\nEn tant quâ€™ utilisateur\nJe veux Ãªtre averti si jâ€™ai oubliÃ© de remplir un champ\nAfin de corriger mon erreur avant de soumettre\nCritÃ¨res dâ€™acceptation :\nLes champs vides affichent un message dâ€™erreur Le bouton de soumission est dÃ©sactivÃ© si des champs sont vides Le message dâ€™erreur disparaÃ®t quand le champ est rempli Chaque champ a un message dâ€™erreur spÃ©cifique ScÃ©narios de test :\nâŒ Soumettre le formulaire avec email vide âŒ Soumettre le formulaire avec mot de passe vide âŒ Soumettre le formulaire avec tous les champs vides âœ… Remplir tous les champs et voir les erreurs disparaÃ®tre US-02.2 : Validation format email FonctionnalitÃ© : F-02.1 - Validation des champs\nEn tant quâ€™ utilisateur\nJe veux Ãªtre averti si mon email nâ€™a pas le bon format\nAfin de entrer une adresse email valide\nCritÃ¨res dâ€™acceptation :\nLâ€™email doit contenir un @ Lâ€™email doit contenir un point aprÃ¨s le @ Lâ€™email ne peut pas commencer ou finir par @ Un message dâ€™erreur sâ€™affiche pour les formats invalides La validation se fait en temps rÃ©el pendant la saisie ScÃ©narios de test :\nâŒ Entrer â€œemailâ€ (sans @) âŒ Entrer â€œemail@domainâ€ (sans extension) âŒ Entrer â€œ@domain.comâ€ (sans nom) âœ… Entrer â€œemail@domain.comâ€ US-02.3 : Force du mot de passe - Longueur FonctionnalitÃ© : F-02.2 - Validation du mot de passe\nEn tant que nouvel utilisateur\nJe veux savoir si mon mot de passe est assez long\nAfin de crÃ©er un mot de passe sÃ©curisÃ©\nCritÃ¨res dâ€™acceptation :\nLe mot de passe doit contenir minimum 8 caractÃ¨res Un message dâ€™erreur sâ€™affiche si trop court Le compteur de caractÃ¨res est visible Le message disparaÃ®t quand la longueur est suffisante ScÃ©narios de test :\nâŒ Entrer un mot de passe de 5 caractÃ¨res âŒ Entrer un mot de passe de 7 caractÃ¨res âœ… Entrer un mot de passe de 8 caractÃ¨res âœ… Entrer un mot de passe de 20 caractÃ¨res US-02.4 : Force du mot de passe - ComplexitÃ© FonctionnalitÃ© : F-02.2 - Validation du mot de passe\nEn tant que nouvel utilisateur\nJe veux voir la force de mon mot de passe\nAfin de crÃ©er un mot de passe robuste\nCritÃ¨res dâ€™acceptation :\nUn indicateur visuel montre la force (Faible/Moyen/Fort/Excellent) La force augmente avec les majuscules La force augmente avec les chiffres La force augmente avec les caractÃ¨res spÃ©ciaux Un code couleur accompagne lâ€™indicateur (rouge/orange/vert/bleu) ScÃ©narios de test :\nMot de passe â€œpasswordâ€ â†’ Faible (rouge) Mot de passe â€œPassword1â€ â†’ Moyen (orange) Mot de passe â€œPassword1!â€ â†’ Fort (vert) Mot de passe â€œP@ssw0rd!2024â€ â†’ Excellent (bleu) US-02.5 : Confirmation du mot de passe FonctionnalitÃ© : F-02.2 - Validation du mot de passe\nEn tant que nouvel utilisateur\nJe veux confirmer mon mot de passe\nAfin de mâ€™assurer de ne pas avoir fait de faute de frappe\nCritÃ¨res dâ€™acceptation :\nUn champ â€œConfirmer le mot de passeâ€ est prÃ©sent Un message dâ€™erreur sâ€™affiche si les mots de passe diffÃ¨rent La validation se fait en temps rÃ©el Une icÃ´ne de validation (âœ“) apparaÃ®t quand ils correspondent ScÃ©narios de test :\nâŒ Entrer deux mots de passe diffÃ©rents âœ… Entrer deux mots de passe identiques âœ… Modifier le premier et voir lâ€™erreur apparaÃ®tre US-02.6 : Exigences du mot de passe visibles FonctionnalitÃ© : F-02.2 - Validation du mot de passe\nEn tant que nouvel utilisateur\nJe veux voir les exigences du mot de passe\nAfin de savoir ce qui est attendu\nCritÃ¨res dâ€™acceptation :\nUne liste des exigences est visible prÃ¨s du champ mot de passe Chaque exigence est cochÃ©e (âœ“) quand respectÃ©e Les exigences incluent : longueur, majuscule, minuscule, chiffre, spÃ©cial Les exigences sont mises Ã  jour en temps rÃ©el ScÃ©narios de test :\nChamp vide â†’ Aucune exigence cochÃ©e Entrer â€œpasswordâ€ â†’ Longueur et minuscule cochÃ©es Entrer â€œPassword1!â€ â†’ Toutes les exigences cochÃ©es US-02.7 : Limitation des tentatives de connexion FonctionnalitÃ© : F-02.3 - Protection contre les attaques\nEn tant que systÃ¨me\nJe veux limiter les tentatives de connexion Ã©chouÃ©es\nAfin de protÃ©ger contre les attaques par force brute\nCritÃ¨res dâ€™acceptation :\nAprÃ¨s 5 tentatives Ã©chouÃ©es, le compte est temporairement verrouillÃ© Le verrouillage dure 15 minutes Un message informe lâ€™utilisateur du verrouillage Un compteur de tentatives restantes est visible ScÃ©narios de test :\nâŒ Ã‰chouer 3 fois â†’ Voir â€œ2 tentatives restantesâ€ âŒ Ã‰chouer 5 fois â†’ Compte verrouillÃ© â±ï¸ Attendre 15 minutes â†’ Pouvoir rÃ©essayer 4. EPIC-03 : ExpÃ©rience utilisateur Objectif : AmÃ©liorer le confort et la satisfaction des utilisateurs lors de lâ€™authentification.\nValeur mÃ©tier : Augmente la rÃ©tention utilisateur et rÃ©duit les frustrations.\nFonctionnalitÃ©s de lâ€™Epic F-03.1 : MÃ©morisation des informations Permettre aux utilisateurs de sauvegarder leurs prÃ©fÃ©rences.\nF-03.2 : Feedback visuel Fournir des retours visuels clairs sur les actions.\nF-03.3 : AccessibilitÃ© Assurer que lâ€™interface est accessible Ã  tous.\nUser Stories - EPIC-03 US-03.1 : Se souvenir de moi FonctionnalitÃ© : F-03.1 - MÃ©morisation des informations\nEn tant quâ€™ utilisateur rÃ©gulier\nJe veux cocher â€œSe souvenir de moiâ€\nAfin de ne pas avoir Ã  saisir mon email Ã  chaque connexion\nCritÃ¨res dâ€™acceptation :\nUne case Ã  cocher â€œSe souvenir de moiâ€ est prÃ©sente Si cochÃ©e, lâ€™email est sauvegardÃ© localement (de faÃ§on sÃ©curisÃ©e) Ã€ la prochaine ouverture, lâ€™email est prÃ©-rempli Lâ€™utilisateur peut dÃ©cocher pour supprimer lâ€™email sauvegardÃ© ScÃ©narios de test :\nâœ… Cocher â€œSe souvenirâ€ et se connecter âœ… Fermer et rouvrir â†’ Email prÃ©-rempli âœ… Se connecter sans cocher â†’ Email non sauvegardÃ© US-03.2 : Indicateur de chargement FonctionnalitÃ© : F-03.2 - Feedback visuel\nEn tant quâ€™ utilisateur\nJe veux voir un indicateur pendant la connexion\nAfin de savoir que ma requÃªte est en cours de traitement\nCritÃ¨res dâ€™acceptation :\nUn indicateur de chargement (spinner) apparaÃ®t lors de la connexion Le bouton â€œSe connecterâ€ est dÃ©sactivÃ© pendant le chargement Un overlay empÃªche les clics pendant le traitement Un texte â€œConnexion en coursâ€¦â€ est affichÃ© ScÃ©narios de test :\nâœ… Cliquer sur â€œSe connecterâ€ et voir le spinner âœ… VÃ©rifier que le bouton est grisÃ© âœ… Tenter de cliquer pendant le chargement â†’ Aucun effet US-03.3 : Messages dâ€™erreur clairs FonctionnalitÃ© : F-03.2 - Feedback visuel\nEn tant quâ€™ utilisateur\nJe veux des messages dâ€™erreur comprÃ©hensibles\nAfin de savoir exactement ce qui ne va pas\nCritÃ¨res dâ€™acceptation :\nLes messages dâ€™erreur sont en franÃ§ais clair Chaque erreur a un message spÃ©cifique (pas de â€œErreur gÃ©nÃ©riqueâ€) Les messages sont affichÃ©s dans une boÃ®te colorÃ©e (rouge) Une icÃ´ne dâ€™avertissement accompagne le message ScÃ©narios de test :\nEmail invalide â†’ â€œFormat dâ€™email invalideâ€ Mot de passe trop court â†’ â€œLe mot de passe doit contenir au moins 8 caractÃ¨resâ€ Mots de passe diffÃ©rents â†’ â€œLes mots de passe ne correspondent pasâ€ US-03.4 : Acceptation des conditions FonctionnalitÃ© : F-03.1 - MÃ©morisation des informations\nEn tant que nouvel utilisateur\nJe veux accepter les conditions dâ€™utilisation\nAfin de crÃ©er mon compte en toute transparence\nCritÃ¨res dâ€™acceptation :\nUne case â€œJâ€™accepte les conditions dâ€™utilisationâ€ est prÃ©sente Le bouton de crÃ©ation est dÃ©sactivÃ© si non cochÃ©e Un lien â€œVoir les conditionsâ€ ouvre une fenÃªtre Les conditions sont affichÃ©es de maniÃ¨re lisible ScÃ©narios de test :\nâŒ Tenter de crÃ©er un compte sans cocher âœ… Cocher la case â†’ Bouton activÃ© âœ… Cliquer sur â€œVoir les conditionsâ€ â†’ FenÃªtre sâ€™ouvre US-03.5 : Affichage/masquage du mot de passe FonctionnalitÃ© : F-03.2 - Feedback visuel\nEn tant quâ€™ utilisateur\nJe veux pouvoir afficher temporairement mon mot de passe\nAfin de vÃ©rifier ce que jâ€™ai tapÃ©\nCritÃ¨res dâ€™acceptation :\nUne icÃ´ne â€œÅ“ilâ€ est prÃ©sente Ã  cÃ´tÃ© du champ mot de passe Cliquer sur lâ€™icÃ´ne affiche le mot de passe en clair Cliquer Ã  nouveau le masque Un tooltip indique â€œAfficher le mot de passeâ€ ScÃ©narios de test :\nâœ… Entrer un mot de passe (masquÃ©) âœ… Cliquer sur lâ€™Å“il â†’ Voir le texte en clair âœ… Cliquer Ã  nouveau â†’ MasquÃ© de nouveau 5. EPIC-04 : RÃ©cupÃ©ration et aide Objectif : Aider les utilisateurs qui rencontrent des problÃ¨mes dâ€™accÃ¨s Ã  leur compte.\nValeur mÃ©tier : RÃ©duit les demandes de support et amÃ©liore lâ€™autonomie des utilisateurs.\nFonctionnalitÃ©s de lâ€™Epic F-04.1 : RÃ©cupÃ©ration de mot de passe Permettre aux utilisateurs de rÃ©initialiser leur mot de passe oubliÃ©.\nF-04.2 : Support et aide Fournir de lâ€™aide contextuelle aux utilisateurs.\nUser Stories - EPIC-04 US-04.1 : Lien mot de passe oubliÃ© FonctionnalitÃ© : F-04.1 - RÃ©cupÃ©ration de mot de passe\nEn tant quâ€™ utilisateur ayant oubliÃ© son mot de passe\nJe veux cliquer sur â€œMot de passe oubliÃ©?â€\nAfin de accÃ©der Ã  la rÃ©cupÃ©ration\nCritÃ¨res dâ€™acceptation :\nUn lien â€œMot de passe oubliÃ©?â€ est visible sur la page de connexion Le lien est clairement identifiable (soulignÃ© ou en couleur) Le clic ouvre une nouvelle fenÃªtre de rÃ©cupÃ©ration Le lien est accessible au clavier (Tab + Enter) ScÃ©narios de test :\nâœ… Cliquer sur le lien â†’ FenÃªtre sâ€™ouvre âœ… Naviguer au clavier et appuyer sur Enter âœ… VÃ©rifier que la fenÃªtre de rÃ©cupÃ©ration sâ€™affiche US-04.2 : Demande de rÃ©initialisation FonctionnalitÃ© : F-04.1 - RÃ©cupÃ©ration de mot de passe\nEn tant quâ€™ utilisateur\nJe veux entrer mon email pour demander une rÃ©initialisation\nAfin de recevoir un lien de rÃ©initialisation\nCritÃ¨res dâ€™acceptation :\nUn champ email est prÃ©sent dans la fenÃªtre de rÃ©cupÃ©ration Un bouton â€œEnvoyer le lienâ€ est prÃ©sent Le systÃ¨me vÃ©rifie que lâ€™email existe dans la base Un email est envoyÃ© avec un lien temporaire (valide 1 heure) Un message de confirmation sâ€™affiche ScÃ©narios de test :\nâœ… Entrer un email existant â†’ Email envoyÃ© âŒ Entrer un email inexistant â†’ Message â€œEmail non trouvÃ©â€ âœ… VÃ©rifier le message de confirmation US-04.3 : Aide contextuelle FonctionnalitÃ© : F-04.2 - Support et aide\nEn tant quâ€™ utilisateur confus\nJe veux voir des tooltips dâ€™aide\nAfin de comprendre ce quâ€™on attend de moi\nCritÃ¨res dâ€™acceptation :\nDes icÃ´nes â€œ?â€ sont prÃ©sentes prÃ¨s des champs complexes Survoler lâ€™icÃ´ne affiche un tooltip explicatif Les tooltips expliquent les exigences en langage simple Les tooltips restent affichÃ©s tant que la souris est dessus ScÃ©narios de test :\nâœ… Survoler â€œ?â€ prÃ¨s du mot de passe â†’ Voir les exigences âœ… Survoler â€œ?â€ prÃ¨s de lâ€™email â†’ Voir le format attendu âœ… DÃ©placer la souris â†’ Tooltip disparaÃ®t 6. EPIC-05 : Navigation et flux Objectif : Assurer une navigation fluide et intuitive entre les diffÃ©rentes pages du systÃ¨me dâ€™authentification.\nValeur mÃ©tier : AmÃ©liore lâ€™expÃ©rience utilisateur et rÃ©duit les abandons.\nFonctionnalitÃ©s de lâ€™Epic F-05.1 : Navigation entre pages Permettre aux utilisateurs de naviguer facilement entre connexion et inscription.\nF-05.2 : Raccourcis clavier Faciliter les actions avec le clavier.\nUser Stories - EPIC-05 US-05.1 : Navigation vers crÃ©ation de compte FonctionnalitÃ© : F-05.1 - Navigation entre pages\nEn tant que nouvel utilisateur\nJe veux cliquer sur â€œCrÃ©er un compteâ€\nAfin de accÃ©der Ã  la page dâ€™inscription\nCritÃ¨res dâ€™acceptation :\nUn lien/bouton â€œCrÃ©er un compteâ€ est visible en bas de la page de connexion Le texte est clair : â€œPas encore de compte? CrÃ©er un compteâ€ Le clic charge la page de crÃ©ation de compte La transition est fluide (pas de flash) ScÃ©narios de test :\nâœ… Cliquer sur â€œCrÃ©er un compteâ€ â†’ Page dâ€™inscription sâ€™affiche âœ… VÃ©rifier que les champs de connexion sont rÃ©initialisÃ©s âœ… VÃ©rifier la fluiditÃ© de la transition US-05.2 : Navigation vers connexion FonctionnalitÃ© : F-05.1 - Navigation entre pages\nEn tant quâ€™ utilisateur ayant dÃ©jÃ  un compte\nJe veux cliquer sur â€œSe connecterâ€\nAfin de revenir Ã  la page de connexion\nCritÃ¨res dâ€™acceptation :\nUn lien â€œDÃ©jÃ  un compte? Se connecterâ€ est visible sur la page dâ€™inscription Le clic charge la page de connexion Les donnÃ©es saisies dans lâ€™inscription ne sont pas perdues si on revient ScÃ©narios de test :\nâœ… Cliquer sur â€œSe connecterâ€ â†’ Page de connexion sâ€™affiche âœ… Remplir un formulaire, naviguer, revenir â†’ DonnÃ©es prÃ©servÃ©es âœ… VÃ©rifier la fluiditÃ© de la transition US-05.3 : Touche Enter pour soumettre FonctionnalitÃ© : F-05.2 - Raccourcis clavier\nEn tant quâ€™ utilisateur\nJe veux appuyer sur Enter pour me connecter\nAfin de soumettre rapidement le formulaire\nCritÃ¨res dâ€™acceptation :\nAppuyer sur Enter dans nâ€™importe quel champ soumet le formulaire Le comportement est identique Ã  cliquer sur le bouton La validation se fait avant la soumission Si des erreurs existent, Enter ne soumet pas ScÃ©narios de test :\nâœ… Remplir email et mot de passe, appuyer sur Enter â†’ Connexion âŒ Laisser un champ vide, appuyer sur Enter â†’ Erreur affichÃ©e âœ… VÃ©rifier que Ã§a fonctionne depuis les deux champs US-05.4 : Navigation au clavier FonctionnalitÃ© : F-05.2 - Raccourcis clavier\nEn tant quâ€™ utilisateur utilisant le clavier\nJe veux naviguer entre les champs avec Tab\nAfin de remplir le formulaire sans la souris\nCritÃ¨res dâ€™acceptation :\nTab passe au champ suivant dans lâ€™ordre logique Shift+Tab revient au champ prÃ©cÃ©dent Les boutons et liens sont accessibles avec Tab Le focus est visuellement visible (contour) ScÃ©narios de test :\nâœ… Appuyer sur Tab rÃ©pÃ©titivement â†’ Parcourt tous les champs âœ… Utiliser Shift+Tab â†’ Retour en arriÃ¨re âœ… VÃ©rifier que le focus est visible âœ… Atteindre le bouton et appuyer sur Enter â†’ Soumission 7. Tableau rÃ©capitulatif Vue dâ€™ensemble par Epic Epic FonctionnalitÃ©s User Stories Points estimÃ©s PrioritÃ© EPIC-01: Authentification de base 3 6 21 ğŸ”´ Critique EPIC-02: Validation et sÃ©curitÃ© 3 7 28 ğŸ”´ Critique EPIC-03: ExpÃ©rience utilisateur 3 5 13 ğŸŸ¡ Haute EPIC-04: RÃ©cupÃ©ration et aide 2 3 8 ğŸŸ¢ Moyenne EPIC-05: Navigation et flux 2 4 8 ğŸ”´ Critique TOTAL 13 25 78 DÃ©tail des User Stories ID Epic Titre PrioritÃ© ComplexitÃ© Effort US-01.1 EPIC-01 Saisie des identifiants de connexion ğŸ”´ Faible 2 US-01.2 EPIC-01 VÃ©rification des identifiants ğŸ”´ Moyenne 5 US-01.3 EPIC-01 Saisie des informations de crÃ©ation ğŸ”´ Faible 2 US-01.4 EPIC-01 CrÃ©ation du compte dans le systÃ¨me ğŸ”´ Haute 8 US-01.5 EPIC-01 UnicitÃ© de lâ€™email ğŸ”´ Moyenne 3 US-01.6 EPIC-01 Maintien de la session ğŸ”´ Faible 1 US-02.1 EPIC-02 Validation champs obligatoires ğŸ”´ Faible 3 US-02.2 EPIC-02 Validation format email ğŸ”´ Moyenne 3 US-02.3 EPIC-02 Force mot de passe - Longueur ğŸ”´ Faible 2 US-02.4 EPIC-02 Force mot de passe - ComplexitÃ© ğŸ”´ Moyenne 5 US-02.5 EPIC-02 Confirmation du mot de passe ğŸ”´ Faible 2 US-02.6 EPIC-02 Exigences mot de passe visibles ğŸ”´ Moyenne 5 US-02.7 EPIC-02 Limitation tentatives connexion ğŸ”´ Haute 8 US-03.1 EPIC-03 Se souvenir de moi ğŸŸ¡ Moyenne 3 US-03.2 EPIC-03 Indicateur de chargement ğŸŸ¡ Faible 2 US-03.3 EPIC-03 Messages dâ€™erreur clairs ğŸŸ¡ Faible 2 US-03.4 EPIC-03 Acceptation des conditions ğŸŸ¡ Faible 2 US-03.5 EPIC-03 Affichage/masquage mot de passe ğŸŸ¡ Moyenne 4 US-04.1 EPIC-04 Lien mot de passe oubliÃ© ğŸŸ¢ Faible 1 US-04.2 EPIC-04 Demande de rÃ©initialisation ğŸŸ¢ Haute 5 US-04.3 EPIC-04 Aide contextuelle ğŸŸ¢ Faible 2 US-05.1 EPIC-05 Navigation vers crÃ©ation compte ğŸ”´ Faible 2 US-05.2 EPIC-05 Navigation vers connexion ğŸ”´ Faible 2 US-05.3 EPIC-05 Touche Enter pour soumettre ğŸ”´ Faible 2 US-05.4 EPIC-05 Navigation au clavier ğŸ”´ Faible 2 8. Roadmap recommandÃ©e Sprint 1 (2 semaines) - MVP Core Objectif : Connexion et crÃ©ation de compte fonctionnels\nStories incluses :\nEPIC-01 : US-01.1, US-01.2, US-01.3, US-01.4, US-01.5 (5 stories) EPIC-05 : US-05.1, US-05.2 (2 stories) Effort total : 22 points\nLivrable : Utilisateurs peuvent crÃ©er un compte et se connecter\nSprint 2 (2 semaines) - SÃ©curitÃ© et Validation Objectif : SÃ©curiser lâ€™application et valider les donnÃ©es\nStories incluses :\nEPIC-02 : US-02.1, US-02.2, US-02.3, US-02.4, US-02.5, US-02.6, US-02.7 (7 stories) EPIC-01 : US-01.6 (1 story) Effort total : 29 points\nLivrable : Application sÃ©curisÃ©e avec validation complÃ¨te\nSprint 3 (1 semaine) - ExpÃ©rience utilisateur Objectif : AmÃ©liorer le confort dâ€™utilisation\nStories incluses :\nEPIC-03 : US-03.1, US-03.2, US-03.3, US-03.4, US-03.5 (5 stories) EPIC-05 : US-05.3, US-05.4 (2 stories) Effort total : 17 points\nLivrable : Application polie avec excellente UX\nSprint 4 (1 semaine) - Support et finition Objectif : Ajouter les fonctionnalitÃ©s de support\nStories incluses :\nEPIC-04 : US-04.1, US-04.2, US-04.3 (3 stories) Effort total : 8 points\nLivrable : Application complÃ¨te et autonome\nTimeline visuelle Sprint 1 (2 sem) | Sprint 2 (2 sem) | Sprint 3 (1 sem) | Sprint 4 (1 sem)\râ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\rMVP Core | SÃ©curitÃ© | UX | Support\r7 stories | 8 stories | 7 stories | 3 stories\r22 points | 29 points | 17 points | 8 points\râ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\rTOTAL: 6 semaines, 25 stories, 76 points CritÃ¨res de succÃ¨s du projet Techniques :\n100% des User Stories implÃ©mentÃ©es Tests unitaires \u003e 80% de couverture Temps de rÃ©ponse \u003c 2 secondes Aucune faille de sÃ©curitÃ© critique Utilisateur :\nTaux de crÃ©ation de compte rÃ©ussie \u003e 95% Taux de connexion rÃ©ussie \u003e 98% Satisfaction utilisateur \u003e 4/5 Support tickets \u003c 5% des utilisateurs MÃ©tier :\nAuthentification fonctionnelle SÃ©curitÃ© conforme aux standards ExpÃ©rience utilisateur fluide Application maintenable et Ã©volutive",
    "description": "SystÃ¨me dâ€™authentification WPF - Epics, FonctionnalitÃ©s et User Stories Table des matiÃ¨res Vue dâ€™ensemble des Epics EPIC-01 : Authentification de base EPIC-02 : Validation et sÃ©curitÃ© EPIC-03 : ExpÃ©rience utilisateur EPIC-04 : RÃ©cupÃ©ration et aide EPIC-05 : Navigation et flux Tableau rÃ©capitulatif Roadmap recommandÃ©e 1. Vue dâ€™ensemble des Epics Epic ID Nom PrioritÃ© Stories Valeur mÃ©tier EPIC-01 Authentification de base ğŸ”´ Critique 6 FonctionnalitÃ© cÅ“ur EPIC-02 Validation et sÃ©curitÃ© ğŸ”´ Critique 7 Protection des donnÃ©es EPIC-03 ExpÃ©rience utilisateur ğŸŸ¡ Haute 5 Satisfaction client EPIC-04 RÃ©cupÃ©ration et aide ğŸŸ¢ Moyenne 3 Support autonome EPIC-05 Navigation et flux ğŸ”´ Critique 4 Parcours utilisateur TOTAL 25 2. EPIC-01 : Authentification de base Objectif : Permettre aux utilisateurs de sâ€™authentifier et dâ€™accÃ©der Ã  lâ€™application de maniÃ¨re sÃ©curisÃ©e.",
    "tags": [],
    "title": "Interfaces Humain Machine",
    "uri": "/420-413/projets/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "1. Introduction Ã  Visual Studio 2022 Quâ€™est-ce que Visual Studio ? Visual Studio 2022 est lâ€™Environnement de DÃ©veloppement IntÃ©grÃ© (IDE) de Microsoft dÃ©diÃ© au dÃ©veloppement dâ€™applications sur les plateformes .NET. Il offre un ensemble complet dâ€™outils pour coder, tester, dÃ©boguer, dÃ©ployer et collaborer efficacement.\nLes Ã©ditions de Visual Studio 2022 Ã‰dition Public cible Community Gratuit : Ã©tudiants, dÃ©veloppeurs open source et particuliers. Professional DÃ©veloppeurs professionnels et petites Ã©quipes. Enterprise Grandes Ã©quipes : outils avancÃ©s de test, performance et intÃ©gration continue. 2. Installation et Configuration Ã‰tapes dâ€™installation TÃ©lÃ©chargement : Se rendre sur visualstudio.microsoft.com/fr pour choisir sa version. SÃ©lection des charges de travail : Pour le dÃ©veloppement C# (Windows Forms ou WPF), il est impÃ©ratif de sÃ©lectionner .NET Desktop Development. Si vous disposez dÃ©jÃ  de Visual Studio, vous pouvez ajouter la charge de travail de dÃ©veloppement de bureau .NET comme suit :\nLancez Visual Studio Installer. Si vous y Ãªtes invitÃ©, autorisez le programme dâ€™installation Ã  se mettre Ã  jour. Si une mise Ã  jour pour Visual Studio est disponible, un bouton Mettre Ã  jour sâ€™affiche. SÃ©lectionnez-la pour la mettre Ã  jour avant de modifier lâ€™installation. Recherchez votre installation de Visual Studio et sÃ©lectionnez le bouton Modifier . Sâ€™il nâ€™est pas dÃ©jÃ  sÃ©lectionnÃ©, sÃ©lectionnez la charge de travail de dÃ©veloppement du bureau .NET , puis sÃ©lectionnez le bouton Modifier . Sinon, fermez simplement la fenÃªtre de dialogue. Personnalisation Lâ€™interface est entiÃ¨rement personnalisable : thÃ¨mes, raccourcis clavier et extensions. Pour un environnement complet, il est recommandÃ© dâ€™installer Git pour la gestion de versions.\nCaution Note sur lâ€™IA : Des outils comme GitHub Copilot sont disponibles, mais ils ne doivent pas Ãªtre utilisÃ©s dans le cadre de ce cours afin de ne pas nuire Ã  lâ€™apprentissage des concepts fondamentaux.\n3. FonctionnalitÃ©s principales Source : https://learn.microsoft.com/fr-fr/visualstudio/get-started/media/visual-studio-overview.png?view=vs-2022\nLâ€™Ã©diteur de texte Lâ€™Ã©diteur de texte de Visual Studio est un puissant outil permettant de saisir le code de lâ€™application.\nVoici quelques fonctionnalitÃ©s de lâ€™Ã©diteur de texte:\nLes mots-clÃ©s et les types sont colorÃ©s pour faciliter la lecture et la comprÃ©hension du code. La qualitÃ© du document en cours de visualisation est annoncÃ©e grÃ¢ce Ã  lâ€™icÃ´ne en bas du document pour indiquer sâ€™il contient des suggestions, des avertissements ou des erreurs. Lâ€™intellisense permet dâ€™afficher les classes et leurs membres en rapport avec le code saisi ainsi que les paramÃ¨tres et les surcharges possibles pour les mÃ©thodes Lâ€™intellicode vous permet dâ€™assurer la prÃ©cision et la cohÃ©rence de lâ€™exÃ©cution du code qui peut remplir une ligne entiÃ¨re Ã  la fois. Lâ€™IA dÃ©tecte votre contexte de code, notamment les noms de variables, les fonctions et le type de code que vous Ã©crivez, pour vous donner les meilleures suggestions. Encore mieuxÂ : IntelliCode sâ€™exÃ©cute sur votre ordinateur, ce qui garantit que votre code privÃ© reste privÃ©. Autres outils de Visual Studio Code 2022 Gestion de builds : CrÃ©ation de configurations adaptÃ©es aux environnements de dÃ©veloppement ou de production.\nDÃ©bogage et tests : DÃ©bogueur intÃ©grÃ© pour lâ€™exÃ©cution pas Ã  pas et outils de tests unitaires (NUnit, xUnit). Le mode dÃ©bogage peut Ãªtre lancÃ© en allant sur DÃ©boguer -\u003e DÃ©marrer le dÃ©bogage ou juste F5\nCollaboration : IntÃ©gration native de Git/GitHub et support de Live Share pour le dÃ©veloppement collaboratif en temps rÃ©el.\n4. Exploration de lâ€™interface Lors du lancement, la fenÃªtre de dÃ©marrage propose quatre options principales:\nClone a repository : RÃ©cupÃ©rer du code depuis GitHub ou Azure DevOps. Open a project or solution : Ouvrir un fichier projet local. Open a local folder : Naviguer et Ã©diter du code dans nâ€™importe quel dossier. Create a new project : Commencer Ã  partir dâ€™un modÃ¨le prÃ©dÃ©fini. ` 5. Projets et Solutions CrÃ©er votre solution et projet DÃ©marrez Visual Studio et sÃ©lectionnez CrÃ©er un projet. Dans la fenÃªtre CrÃ©er un projet, recherchez et sÃ©lectionnez un modÃ¨le dâ€™application console C#, puis sÃ©lectionnez Suivant.. Configurez votre projet (nom, emplacement). Ã€ cette Ã©tape, vous pouvez dÃ©cidez de placer la solution .sln et le projet .csproj. Puis sÃ©lectionnez Suivant. Dans la fenÃªtre Informations supplÃ©mentaires , vÃ©rifiez que .NET 8.0 apparaÃ®t dans le menu dÃ©roulant Framework, puis sÃ©lectionnez CrÃ©er. DiffÃ©rences fondamentales entre projet et solution Un projet est un ensemble de fichiers qui seront compilÃ©s en un seul assemblage. Une solution est un ensemble dâ€™un ou plusieurs projets. Un projet dâ€™application exÃ©cutable possÃ¨de un point dâ€™entrÃ©e. Câ€™est la mÃ©thode Main. Cette mÃ©thode doit Ãªtre publique et statique en utilisant les mots-clÃ©s public et static, qui spÃ©cifient respectivement que la mÃ©thode est accessible depuis lâ€™application et en dehors, que la mÃ©thode est globale et que la classe nâ€™a pas besoin dâ€™Ãªtre instanciÃ©e pour pouvoir lâ€™appeler. Une solution possÃ¨de aussi un projet de dÃ©marrage. Ce projet est identifiable dans lâ€™explorateur de solutions, car son nom est en gras. Pour modifier cette propriÃ©tÃ©, un clic droit sur le projet permet de sÃ©lectionner DÃ©finir en tant que projet de dÃ©marrage dans le menu contextuel. Le point dâ€™entrÃ©e (MÃ©thode Main) Un projet exÃ©cutable possÃ¨de une mÃ©thode Main. Elle doit Ãªtre dÃ©finie comme suit:\npublic : Accessible depuis lâ€™application et lâ€™extÃ©rieur. static : La mÃ©thode est globale et la classe nâ€™a pas besoin dâ€™Ãªtre instanciÃ©e pour lâ€™appeler. Projet de dÃ©marrage : Dans une solution, le projet de dÃ©marrage apparaÃ®t en gras dans lâ€™explorateur de solutions. On peut le modifier via un clic droit -\u003e DÃ©finir en tant que projet de dÃ©marrage.\n6. ExÃ©cution et DÃ©bogage Lancement : Cliquez sur la flÃ¨che verte ou appuyez sur F5. Points dâ€™arrÃªt (Breakpoints) : Permettent dâ€™interrompre lâ€™exÃ©cution pour examiner lâ€™Ã©tat des variables Ã  des endroits prÃ©cis.\nLes diffÃ©rents fichiers compris dans la solution Le fichier program.cs qui contient le code qui est compilÃ© et exÃ©cutÃ© Quand on fait un clic droit sur le projet, ensuite on choisit â€œOuvrir le dossier dans lâ€™Explorateur de fichiersâ€,Â on peut voir le fichier du projet dont lâ€™extension est csproj. Un niveau plus haut, on voit le fichier de la solution dont lâ€™extension est sln. Plus bas, dans le dossier bin -\u003e Debug -\u003e net8.0, on peut voir le fichier exÃ©cutable .exe qui est lâ€™application qui vient dâ€™Ãªtre crÃ©Ã©e. Si on double-clique sur lâ€™exÃ©cutable, on ouvre lâ€™application. On peut aussi ouvrir la ligne de commande cmd et exÃ©cuter lâ€™application enÂ tapant le nom de lâ€™exÃ©cutable. Ressources supplÃ©mentaires Documentation Visual Studio Documentation IntelliCode",
    "description": "1. Introduction Ã  Visual Studio 2022 Quâ€™est-ce que Visual Studio ? Visual Studio 2022 est lâ€™Environnement de DÃ©veloppement IntÃ©grÃ© (IDE) de Microsoft dÃ©diÃ© au dÃ©veloppement dâ€™applications sur les plateformes .NET. Il offre un ensemble complet dâ€™outils pour coder, tester, dÃ©boguer, dÃ©ployer et collaborer efficacement.",
    "tags": [],
    "title": "Intro Ã  Visual Studio 2022",
    "uri": "/420-413/intro/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Introduction Ã  .NET .NET : Un Ã©cosystÃ¨me pour le dÃ©veloppement dÊ¼applications qui prend en charge plusieurs langages, dont C#, F#, et VB.NET. Il fournit des outils, des bibliothÃ¨ques, et un environnement dÊ¼exÃ©cution pour faciliter le dÃ©veloppement dâ€™applications.\nLa plateforme .NET La plateforme .NET repose sur une architecture en couches qui permet lâ€™exÃ©cution de code Ã©crit dans diffÃ©rents langages (C#, F#, VB.NET) de maniÃ¨re unifiÃ©e et performante.\n1. Les composants fondamentaux Lâ€™architecture sâ€™appuie principalement sur deux piliers :\nCLR (Common Language Runtime) : Câ€™est le moteur/coeur dâ€™exÃ©cution. Il gÃ¨re lâ€™exÃ©cution des programmes, la mÃ©moire (Garbage Collector), la sÃ©curitÃ© et la compilation Ã  la volÃ©e (JIT). Moteur dâ€™exÃ©cution : Le CLR est responsable de charger et exÃ©cuter des programmes .NET et assure la gestion de la mÃ©moire, la sÃ©curitÃ©, et la gestion des exceptions. Conversion IL -\u003e Code natif : Le code C# est dâ€™abord compilÃ© en Intermediate Language (IL), puis converti en code machine natif par le CLR. Gestion de la mÃ©moire : Le CLR gÃ¨re automatiquement la mÃ©moire via la garbage collection (collecte des objets non utilisÃ©s). SÃ©curitÃ© : Le CLR applique des rÃ¨gles de sÃ©curitÃ© pour exÃ©cuter les programmes de maniÃ¨re sÃ©curisÃ©e. BCL (Base Class Library) : Une immense bibliothÃ¨que de classes rÃ©utilisables qui fournit les fonctionnalitÃ©s de base (gestion des fichiers, rÃ©seau, dates, collections, etc.). 2. Le MÃ©canisme de Compilation du Code Source C# Code source C# : Lorsquâ€™un programme C# est Ã©crit, le code source est dâ€™abord compilÃ© en IL (Intermediate Language). Le compilateur C# sâ€™appelle Roslyn Le CIL (Common Intermediate Language) : Le compilateur ne crÃ©e pas tout de suite un programme fini. Il traduit votre C# en un langage intermÃ©diaire (autrefois appelÃ© MSIL). Pourquoi ? Parce que ce langage est universel au sein de lâ€™Ã©cosystÃ¨me .NET. Que vous Ã©criviez en C#, F# ou VB.NET, tout finit en CIL. Cela permet Ã  diffÃ©rents langages de fonctionner ensemble.\nEn plus du code IL, le compilateur gÃ©nÃ¨re des informations cruciales :\nMÃ©tadonnÃ©es : Une description de chaque classe, mÃ©thode et variable dÃ©finie dans votre code.\nManifeste : La â€œcarte dâ€™identitÃ©â€ du programme (nom, version, bibliothÃ¨ques externes nÃ©cessaires).\nAssembly : Le code et les ressources sont stockÃ©s dans un fichier assembly (gÃ©nÃ©ralement avec lâ€™extension .dll ou .exe). Un assembly contient un manifeste qui dÃ©crit ses types, sa version, et ses mÃ©tadonnÃ©es. Compilation Just-In-Time (JIT) : Lorsque le programme est exÃ©cutÃ©, le CLR charge lÊ¼assembly, et le code IL est compilÃ© en code natif via la compilation JIT. ParticularitÃ© : Le JIT ne compile que les morceaux de code au fur et Ã  mesure quâ€™ils sont appelÃ©s (â€œJuste Ã  tempsâ€). Si une fonction nâ€™est jamais utilisÃ©e pendant une session, elle nâ€™est jamais compilÃ©e en code machine, ce qui Ã©conomise des ressources.",
    "description": "Introduction Ã  .NET .NET : Un Ã©cosystÃ¨me pour le dÃ©veloppement dÊ¼applications qui prend en charge plusieurs langages, dont C#, F#, et VB.NET. Il fournit des outils, des bibliothÃ¨ques, et un environnement dÊ¼exÃ©cution pour faciliter le dÃ©veloppement dâ€™applications.\nLa plateforme .NET La plateforme .NET repose sur une architecture en couches qui permet lâ€™exÃ©cution de code Ã©crit dans diffÃ©rents langages (C#, F#, VB.NET) de maniÃ¨re unifiÃ©e et performante.",
    "tags": [],
    "title": "Architecture .NET",
    "uri": "/420-413/architecture/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Introduction Ã  C# C# (prononcÃ© â€œC Sharpâ€) est un langage de programmation moderne, orientÃ© objet et fortement typÃ©. C# est dÃ©veloppÃ© par Microsoft en 2000 et est principalement utilisÃ© pour le dÃ©veloppement dÊ¼applications sous la plateforme .NET. La syntaxe de C# est influencÃ©e par C, C++ et Java, mais elle prÃ©sente certaines spÃ©cificitÃ©s qui lui sont propres.\nC# est un langage sensible Ã  la casse.\nLâ€™extension des fichiers C# est .cs\nCaractÃ©ristiques principales: OrientÃ© objet: tout est basÃ© sur des classes et des objets TypÃ© statiquement: les types de variables doivent Ãªtre dÃ©clarÃ©s GÃ©rÃ©: la mÃ©moire est gÃ©rÃ©e automatiquement par le garbage collector Polyvalent: applications desktop, web, mobile, jeux vidÃ©o (Unity) Moderne: syntaxe claire et Ã©volutive Domaines dâ€™utilisation: Avec C#, on peut crÃ©er :\nğŸ–¥ï¸ des applications console\nğŸ–¥ï¸ Applications Windows (WPF, WinForms)\nğŸŒ des sites Web et des API\nğŸ“± des applications mobiles\nğŸ® des jeux (Unity utilise C#)\nğŸ‘‰ Bref : un langage, plusieurs carriÃ¨res possibles.\nStructure de base dâ€™un programme C# Un programme C# est composÃ© de plusieurs Ã©lÃ©ments clÃ©s : lâ€™espace de noms (namespace), les classes, et la mÃ©thode Main, qui est le point dâ€™entrÃ©e de lâ€™application.\nusing System; // Importation des bibliothÃ¨ques namespace MyProgram // DÃ©finition de l'espace de noms { class Program // DÃ©finition de la classe { static void Main(string[] args) // MÃ©thode Main, point d'entrÃ©e du programme { Console.WriteLine(\"Hello, World!\"); // Affichage d'un message et aller Ã  la prochaine ligne } } } using : UtilisÃ© pour importer des bibliothÃ¨ques externes (par exemple, System contient des classes utiles comme Console). namespace : Un conteneur logique pour les classes et autres types. En dâ€™autres termes, câ€™est une faÃ§on dâ€™organiser le code. Pense Ã  un namespace comme : un dossier une section ou un casier pour ranger des classes. Sans namespaces, ce serait le chaos total ğŸ˜±. Imagine des milliers de classes, toutes avec des noms simples comme Console, List, Button. Sans namespace : ğŸ’¥ conflits de noms ğŸ’¥ code impossible Ã  lire ğŸ’¥ dÃ©veloppeurs en dÃ©pression class : Un modÃ¨le pour crÃ©er des objets. Tout programme C# doit contenir au moins une classe. Main : La mÃ©thode Main est le point de dÃ©part dâ€™une application C#. Câ€™est ici que lâ€™exÃ©cution du programme commence. Les identifiants ou les identificateurs Ce sont les noms donnÃ©s aux classes et Ã  leurs membres. Un identifiant doit Ãªtre composÃ© dâ€™un seul mot commenÃ§ant par une lettre ou un caractÃ¨re underscore (_). Mais, il peut contenir aussi un chiffre qui ne doit pas se placer au dÃ©but de lâ€™identifiant. Ils peuvent Ãªtre composÃ©s de lettres majuscules et minuscules, mais le langage C# Ã©tant sensible Ã  la casse, les majuscules et minuscules doivent Ãªtre respectÃ©es pour faire rÃ©fÃ©rence au bon identifiant Par exemple: les identifiants suivants ne sont pas les mÃªmes monIdentifiant et MonIdentifiant. Les mots-clÃ©s Les mots clÃ©s sont des noms rÃ©servÃ©s par le langage C#, qui ont des significations spÃ©cifiques pour le compilateur. Ils ne peuvent pas Ãªtre utilisÃ©s comme identifiants dans votre programme, sauf sâ€™ils incluent @ comme prÃ©fixe. Par exemple, @if est un identifiant valide, mais pas if, car if est un mot clÃ©.\nPar dÃ©faut, les mots-clÃ©s sont colorÃ©s en bleu dans lâ€™Ã©diteur de Visual Studio. Le caractÃ¨re @ peut Ã©galement prÃ©fixer des identifiants qui nâ€™ont aucun conflit avec les mots-clÃ©s. Ainsi @monIdentifiant et monIdentifiant seront interprÃ©tÃ©s de la mÃªme maniÃ¨re (la mÃªme variable). Les commentaires C# prend en charge deux formes diffÃ©rentes de commentaires:\nLes commentaires sur une seule ligne commencent par // et se terminent Ã  la fin de cette ligne de code. Les commentaires multilignes commencent par /* et se terminent par */ Le commentaire sur plusieurs lignes peut Ã©galement Ãªtre utilisÃ© pour insÃ©rer du texte dans une ligne de code. Ã‰tant donnÃ© que ces commentaires ont un caractÃ¨re de fermeture explicite, vous pouvez inclure plus de code exÃ©cutable aprÃ¨s le commentaire:\npublic static int additioner(int nombre1, int nombre2) { return nombre1 /* premiÃ¨re opÃ©rande */ + nombre2 /* deuxiÃ¨me opÃ©rande*/; } Le commentaire sur une seule ligne peut apparaÃ®tre aprÃ¨s le code exÃ©cutable sur la mÃªme ligne. Le commentaire se termine Ã  la fin de la ligne de texte :\nfloat temperature = 34.4f; // Si nous n'ajoutons pas le f ou le F aprÃ¨s la valeur, nous obtiendrons une erreur",
    "description": "Introduction Ã  C# C# (prononcÃ© â€œC Sharpâ€) est un langage de programmation moderne, orientÃ© objet et fortement typÃ©. C# est dÃ©veloppÃ© par Microsoft en 2000 et est principalement utilisÃ© pour le dÃ©veloppement dÊ¼applications sous la plateforme .NET. La syntaxe de C# est influencÃ©e par C, C++ et Java, mais elle prÃ©sente certaines spÃ©cificitÃ©s qui lui sont propres.",
    "tags": [],
    "title": "Intro et syntaxe du C#",
    "uri": "/420-413/intro_syntaxe_c_sharp/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "1. DÃ©claration de variables et types de donnÃ©es C# est un langage fortement typÃ©, ce qui signifie que chaque variable doit Ãªtre dÃ©clarÃ©e avec un type spÃ©cifique. Voici quelques types de base :\nint age = 25; // Entier double price = 19.99; // Nombre Ã  virgule flottante char grade = 'A'; // CaractÃ¨re unique string name = \"John\"; // ChaÃ®ne de caractÃ¨res bool isActive = true; // BoolÃ©en (vrai ou faux) Une variable peut Ãªtre dÃ©clarÃ©e et initialisÃ©e avec la mÃªme instruction.\nstring salutation = \"Bonjour tout le monde!\";\nIl est Ã©galement possible de dÃ©clarer et dâ€™initier plusieurs variables en une seule instruction, Ã  la condition quâ€™elles soient du mÃªme type. Dans ce cas, les variables sont sÃ©parÃ©es par une virgule. bool joyeux = true, content = true;\nUne variable peut Ã©galement Ãªtre marquÃ©e par le mot-clÃ© const qui spÃ©cifie que la valeur de la variable ne peut pas Ãªtre modifiÃ©e pendant lâ€™exÃ©cution. Câ€™est une variable en lecture seule. const double Pi = 3.14;\nLâ€™infÃ©rence de type (var) : Le mot-clÃ© var permet au compilateur de deviner le type de la variable lors de lâ€™initialisation. Attention : le type reste fixe aprÃ¨s lâ€™assignation.\nvar total = 15.5; // Le compilateur dÃ©duit 'double'\nğŸ’¡ Voici quelques conventions de codage applicables aux variables : La rÃ¨gle dâ€™or : Camel Case Pour les variables locales (celles dÃ©finies Ã  lâ€™intÃ©rieur dâ€™une mÃ©thode), la convention universelle en C# est le camelCase. Par exempleÂ :Â string thisIsCamelCase;. Le premier mot commence par une lettre minuscule.\nChaque mot suivant commence par une lettre majuscule.\nOn ne doit pas utiliser de chiffres au dÃ©but du nom.\nLe trait de soulignement (_) est proscrit pour le moment.\nint nombreEtudiants; // Correct\tstring codePermanent; // Correct double soldeBanque;\t// Correct int NombreEtudiants; // (PascalCase) Incorrect (ou non conventionnel) string code_permanent; // (snake_case) non conventionnel) double soldebanque; // (tout en minuscule) Incorrect (ou non conventionnel) SÃ©mantique (Donner du sens)\nUne variable doit dÃ©crire son contenu sans ambiguÃ¯tÃ©. En programmation professionnelle, on Ã©vite les noms dâ€™une seule lettre.\nÃ‰vitez : string s = \"Informatique\";\nPrivilÃ©giez : string nomProgramme = \"Informatique\";\nTableau rÃ©capitulatif des conventions de nommage C# Ã‰lÃ©ment Convention Exemple Variable locale camelCase uniteDisponible ParamÃ¨tre de mÃ©thode camelCase (int quantiteItems) Constante PascalCase TauxTaxeFederale Classe PascalCase GestionnaireEtudiant MÃ©thode PascalCase CalculerSalaire() 2. Les types de base Les types de donnÃ©es permettent de stocker des valeurs dans lâ€™application. Les langages .NET Ã©tant fortement typÃ©s, il nâ€™est pas toujours possible de convertir un type de donnÃ©es Ã  un autre. Les conversions permettent de convertir les types de donnÃ©es. Cela est possible, car tous les types du Framework .NET dÃ©rivent du type Object qui est le type de case de tous les autres types Les types numÃ©riques Les types numÃ©riques sont dÃ©composÃ©s en deux parties: Les entiers et les dÃ©cimaux. Chacun dispose dâ€™un ensemble de types pour reprÃ©senter les donnÃ©es de la maniÃ¨re la plus judicieuse en fonction des besoins.\nLes entiers Une valeur peut Ãªtre assignÃ©e Ã  un entier avec une notation dÃ©cimale:\nint nombre = 10; //Notation dÃ©cimale La notation hexadÃ©cimale peut Ãªtre utilisÃ©e et elle doit Ãªtre prÃ©cÃ©dÃ©e du prÃ©fixe 0x:\nint nombre = 0x4B; // Notation hexadÃ©cimale Ã©quivalente Ã  75 La notation binaire peut Ãªtre utilisÃ©e et elle doit Ãªtre prÃ©cÃ©dÃ©e du prÃ©fixe 0b:\nint nombre = 0b1101; // Notation binaire Ã©quivalente Ã  13 Les dÃ©cimaux Les boolÃ©ens Un boolÃ©en est un type qui permet de reprÃ©senter une valeur qui est soit true, soit false. Le type .NET correspondant est System.Boolean et son nom C# est bool. Il est possible dâ€™assigner Ã  un boolÃ©en le rÃ©sultat dâ€™une comparaison:\nint nombre = 8; bool estPair = nombre % 2 == 0; Les chaÃ®nes de caractÃ¨res Le type System.String (string) est un type de rÃ©fÃ©rence qui reprÃ©sente une sÃ©rie de types System.Char (char)\nUne variable de type char est assignÃ©e avec un caractÃ¨re placÃ© entre guillemets simples:\nchar premiereLettre = 'a'; Une variable de type string est assignÃ©e avec une chaÃ®ne de caractÃ¨re placÃ©e entre des guillemets doubles\nstring salutation = \"Bonjour tout le monde!\"; La propriÃ©tÃ© Length permet de savoir quelle est la longueur dâ€™un string\nConsole.WriteLine(\"Hello\".Length); // RÃ©sultat: 5 DÃ©claration des chaines de caractÃ¨res // DÃ©clarer sans initialiser. string message1; // Initialiser Ã  null. string message2 = null; // Initialise comme une chaÃ®ne vide (empty string). // Utilise la constante Empty au lieu de \"\". string message3 = System.String.Empty; // Initialiser avec une chaÃ®ne de caractÃ¨res normale. string vieuxChemin = \"c:\\\\Program Files\\\\Microsoft Visual Studio 8.0\"; // Initialiser avec un littÃ©ral de chaÃ®ne verbatim (pratique pour les chemins). string nouveauChemin = @\"c:\\Program Files\\Microsoft Visual Studio 9.0\"; // Utilisez System.String si vous prÃ©fÃ©rez. System.String salutation = \"Hello World!\"; // Dans les variables locales (c'est-Ã -dire dans le corps d'une mÃ©thode), // vous pouvez utiliser le typage implicite. var temporaire = \"I'm still a strongly-typed System.String!\"; // Utilisez une chaÃ®ne const pour empÃªcher la variable de stocker une autre valeur. const string MessagePermanent = \"Tu ne peux pas te dÃ©barrasser de moi!\"; // Utilisez le constructeur String uniquement lors de la crÃ©ation // d'une chaÃ®ne Ã  partir d'un char*, char[] ou sbyte*. char[] lettres = { 'A', 'B', 'C' }; string alphabet = new string(lettres); Quelques propriÃ©tÃ©s et mÃ©thodes de la classe string Soit la variable suivanteÂ : string salutation = \"Bonjour tout le monde!\";\nLa nombre de caractÃ¨re:\nint nombreCaractere = salutation.Length; // 22 Convertir tous les caractÃ¨res de la chaÃ®ne en majuscule:\nstring salutationMajuscule = salutation.ToUpper(); //Â BONJOUR TOUT LE MONDE! Convertir tous les caractÃ¨res de la chaÃ®ne en lettre minuscule\nstringÂ salutationMinuscule = salutation.ToLower(); // bonjour tout le monde! VÃ©rifier si le string contient une sous-chaÃ®ne de caractÃ¨re ou un mot\nbool contientBonjour = salutation.Contains(\"bonjour\"); contientBonjour = salutation.Contains(\"Bonjour\");Â //true Remplacer toutes les occurrences dâ€™un caractÃ¨re dans la chaÃ®ne par un autre\nstring salut =Â salutation.Replace(\"Bonjour\", \"Salut\") //Â Salut tout le monde! Retourne une partie de la chaine, le 0 est lâ€™index du dÃ©but, et le 7 est leÂ nombre de caractÃ¨re Ã  considÃ©rer\nstring bonjour =Â salutation.Substring(0, 7); // Bonjour Admettons que jâ€™ajoute un autre string, pour ConcatÃ©ner les strings\nstring question = \"Comment allez-vous?\"; StringÂ nouvelleSalutationÂ =Â string.Concat(salutation, \" \", question);Â //Bonjour tout le monde!Â Comment allez-vous? Formatter la chaine de caractÃ¨re pour remplacer les expressions de type {0}, {1}, {2}, {3}, etc. PrÃ©sentes dans la chaÃ®ne par les valeurs passÃ©es en paramÃ¨tres lors de lâ€™appel de la fonction.\nstring firstName = \"Sara\"; int count = 25; float temperature = 34.4f; Console.WriteLine(\"Bonjour, {0}! Tu as {1} messages dans ta boÃ®te. La tempÃ©rature est {2} celsius.\", prenom, count, temperature); Lâ€™interpolation de string Soit les variables suivantes:\nstring nom = \"Samuel\"; int age = 28; On aimerait crÃ©er le string: Je mâ€™appelle Marc, jâ€™ai 20 ans. Si on utilise lâ€™addition des chaÃ®nes de caractÃ¨res, on aurait:\nstring presentation = \"Je m'appelle \" + nom + \", j'ai \" +Â age + \" ans.\"; En utilisant la mÃ©thode string.format:\nstring presentation = string.Format(\"Je m'appelle {0}, j'ai {1} ans. \",Â nom, age); En utilisant lâ€™interpolation:\nstring presentation = $\"Je m'appelle {nom}, j'ai {age} ans. \"; Convertir une chaÃ®ne de caractÃ¨res aux autres types Utiliser la mÃ©thode Parse pour convertir un string vers un autre type\nint age = int.Parse(\"35\");Â bool vrai = bool.Parse(\"true\"); Il se peut quâ€™on essaie de convertir une valeur incorrecte. Par exemple, si on essaie de convertir la chaÃ®ne de caractÃ¨re â€œSamuelâ€ en int. On aura une erreur lors de lâ€™exÃ©cution. Pour Ã©viter dâ€™avoir une erreur, on utilise TryParse pour vÃ©rifier si la chaÃ®ne de caractÃ¨re peut se convertirÂ au type dÃ©sirÃ© Type implicite et explicite Jusquâ€™Ã  maintenant, on a vu diffÃ©rents types explicites qui existent, par exemple : int, double, bool, string, etc. Depuis C# 3, C# permet dâ€™utiliser un type implicite. De ce fait, le programmeur demande Ã  C# de trouver le type associÃ© Ã  la variable.\nOn utilise le mot-clÃ© var pour dÃ©finir une variable implicite\nvar nombre = 6; // C# sait que c'est un int var content = true; // C# sait que c'est un boolÃ©en varÂ salutation = \"Bonjour\"; // sait que c'est un string Par contre, si on dÃ©clare une variable implicite sans lâ€™initialiser, C# donnera une erreur de compilation.\n// âŒ Erreur de compilation : \"Implicitly-typed variables must be initialized\" var message; // âœ… Correct : Le compilateur voit \"Bonjour\" et dÃ©duit que 'message' est de type string var message = \"Bonjour\"; Avec string message;, vous dites explicitement au compilateur : â€œRÃ©serve une boÃ®te pour du texteâ€. Avec var message;, vous ne lui donnez aucun indice. Le compilateur refuse de deviner ou de laisser la variable â€œsans typeâ€ jusquâ€™Ã  plus tard.*",
    "description": "1. DÃ©claration de variables et types de donnÃ©es C# est un langage fortement typÃ©, ce qui signifie que chaque variable doit Ãªtre dÃ©clarÃ©e avec un type spÃ©cifique. Voici quelques types de base :\nint age = 25; // Entier double price = 19.99; // Nombre Ã  virgule flottante char grade = 'A'; // CaractÃ¨re unique string name = \"John\"; // ChaÃ®ne de caractÃ¨res bool isActive = true; // BoolÃ©en (vrai ou faux) Une variable peut Ãªtre dÃ©clarÃ©e et initialisÃ©e avec la mÃªme instruction.\nstring salutation = \"Bonjour tout le monde!\";",
    "tags": [],
    "title": "Variables",
    "uri": "/420-413/variables/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Les opÃ©rateurs OpÃ©rateurs ArithmÃ©tiques en C# OpÃ©rateur Nom Description Exemple RÃ©sultat + Addition Somme de deux valeurs int x = 10 + 5; 15 - Soustraction DiffÃ©rence entre deux valeurs int x = 20 - 8; 12 * Multiplication Produit de deux valeurs double x = 5.5 * 2; 11.0 / Division Quotient de la division int x = 10 / 3; 3 (Entier) % Modulo Reste de la division entiÃ¨re int x = 10 % 3; 1 OpÃ©rateurs dâ€™incrÃ©mentation et de dÃ©crÃ©mentation OpÃ©rateur Nom Position Description Exemple RÃ©sultat (x) ++x PrÃ©-incrÃ©mentation Avant IncrÃ©mente, puis retourne la valeur int y = ++x; AugmentÃ© de 1 x++ Post-incrÃ©mentation AprÃ¨s Retourne la valeur, puis incrÃ©mente int y = x++; AugmentÃ© de 1 --x PrÃ©-dÃ©crÃ©mentation Avant DÃ©crÃ©mente, puis retourne la valeur int y = --x; DiminuÃ© de 1 x-- Post-dÃ©crÃ©mentation AprÃ¨s Retourne la valeur, puis dÃ©crÃ©mente int y = x--; DiminuÃ© de 1 Pourquoi la position est-elle importante ? La diffÃ©rence rÃ©side dans la valeur retournÃ©e par lâ€™expression au moment de lâ€™exÃ©cution :\nPrÃ© (++x) : Câ€™est le mode â€œMise Ã  jour dâ€™abordâ€. On change la valeur et on utilise le nouveau rÃ©sultat tout de suite. Post (x++) : Câ€™est le mode â€œUtilisation dâ€™abordâ€. On utilise la valeur actuelle dans le calcul, et lâ€™ajout de 1 se fait juste aprÃ¨s. Exemple de comparaison : int a = 10; int b = 10; int resultatA = ++a; // a devient 11, puis resultatA reÃ§oit 11. int resultatB = b++; // resultatB reÃ§oit 10, puis b devient 11. // Ã€ la fin : // a est 11, resultatA est 11 // b est 11, resultatB est 10 OpÃ©rateurs Logiques en C# Les opÃ©rateurs logiques permettent de tester plusieurs conditions Ã  la fois et retournent toujours une valeur boolÃ©enne (true ou false).\nOpÃ©rateur Nom Description Exemple \u0026\u0026 ET (AND) Retourne true si toutes les conditions sont vraies. (age \u003e= 18 \u0026\u0026 aPermis) || OU (OR) Retourne true si au moins une des conditions est vraie. (estSamedi || estDimanche) ! NON (NOT) Inverse lâ€™Ã©tat logique (vrai devient faux et inversement). !estConnecte ^ OU exclusif (XOR) Retourne true si une seule des deux conditions est vraie. (estOptionA ^ estOptionB) Tables de vÃ©ritÃ© (RÃ©sumÃ©) A B A \u0026\u0026 B A || B A ^ B !A true true true true false false true false false true true false false true false true true true false false false false false true Le concept de â€œCourt-circuitâ€ (Short-circuit) Les opÃ©rateurs \u0026\u0026 et || sont dits â€œintelligentsâ€ en C# :\nAvec \u0026\u0026 : Si la premiÃ¨re condition est fausse, C# nâ€™Ã©value mÃªme pas la deuxiÃ¨me (car le rÃ©sultat sera forcÃ©ment faux). Avec || : Si la premiÃ¨re condition est vraie, C# sâ€™arrÃªte lÃ  (car le rÃ©sultat sera forcÃ©ment vrai). Astuce : Placez toujours la condition la plus â€œlourdeâ€ ou risquÃ©e en deuxiÃ¨me position pour profiter du court-circuit.\nOpÃ©rateurs logiques : Court-circuit vs Ã‰valuation complÃ¨te Il existe deux variantes pour les opÃ©rateurs ET et OU. La diffÃ©rence rÃ©side dans la gestion de la deuxiÃ¨me condition.\nType ET OU Comportement Court-circuit \u0026\u0026 || Ã‰value la 2e condition uniquement si nÃ©cessaire. Ã‰valuation complÃ¨te \u0026 | Ã‰value toujours les deux conditions, sans exception. Pourquoi utiliser lâ€™Ã©valuation complÃ¨te (\u0026 et |) ? Lâ€™utilisation de \u0026 et | sur des boolÃ©ens est plus rare, mais elle est nÃ©cessaire si la deuxiÃ¨me condition contient un effet de bord (une action qui doit absolument se produire, comme une incrÃ©mentation ou lâ€™appel dâ€™une mÃ©thode).\nExemple de diffÃ©rence : int compteur = 0; bool conditionFausse = false; // Cas 1 : Court-circuit (\u0026\u0026) if (conditionFausse \u0026\u0026 ++compteur \u003e 0) { /* ... */ } Console.WriteLine(compteur); // Affiche 0 (le ++ n'a jamais Ã©tÃ© exÃ©cutÃ©) // Cas 2 : Ã‰valuation complÃ¨te (\u0026) if (conditionFausse \u0026 ++compteur \u003e 0) { /* ... */ } Console.WriteLine(compteur); // Affiche 1 (le ++ a Ã©tÃ© exÃ©cutÃ© malgrÃ© le faux) OpÃ©rateurs de comparaison en C# Les opÃ©rateurs de comparaison permettent de vÃ©rifier la relation entre deux expressions. Le rÃ©sultat est toujours une valeur boolÃ©enne (true ou false).\nOpÃ©rateur Nom Description Exemple RÃ©sultat == Ã‰galitÃ© true si les valeurs sont identiques 5 == 5 true != InÃ©galitÃ© true si les valeurs sont diffÃ©rentes 5 != 3 true \u003e Plus grand que true si la gauche est strictement supÃ©rieure 10 \u003e 5 true \u003c Plus petit que true si la gauche est strictement infÃ©rieure 2 \u003c 1 false \u003e= Plus grand ou Ã©gal true si la gauche est supÃ©rieure ou Ã©gale 5 \u003e= 5 true \u003c= Plus petit ou Ã©gal true si la gauche est infÃ©rieure ou Ã©gale 4 \u003c= 3 false Confusion entre = et == Câ€™est lâ€™erreur la plus frÃ©quente chez les dÃ©butants :\n= est lâ€™opÃ©rateur dâ€™assignation (on donne une valeur Ã  une variable). == est lâ€™opÃ©rateur de comparaison (on vÃ©rifie si deux valeurs sont Ã©gales). Comparaison de chaÃ®nes de caractÃ¨res (string) En C#, lâ€™opÃ©rateur == fonctionne pour comparer le contenu des chaÃ®nes de caractÃ¨res. Attention : la comparaison est sensible Ã  la casse.\nstring nomUn = \"Bob\"; string nomDeux = \"bob\"; bool sontEgaux = (nomUn == nomDeux); // RÃ©sultat: false",
    "description": "Les opÃ©rateurs OpÃ©rateurs ArithmÃ©tiques en C# OpÃ©rateur Nom Description Exemple RÃ©sultat + Addition Somme de deux valeurs int x = 10 + 5; 15 - Soustraction DiffÃ©rence entre deux valeurs int x = 20 - 8; 12 * Multiplication Produit de deux valeurs double x = 5.5 * 2; 11.0 / Division Quotient de la division int x = 10 / 3; 3 (Entier) % Modulo Reste de la division entiÃ¨re int x = 10 % 3; 1 OpÃ©rateurs dâ€™incrÃ©mentation et de dÃ©crÃ©mentation OpÃ©rateur Nom Position Description Exemple RÃ©sultat (x) ++x PrÃ©-incrÃ©mentation Avant IncrÃ©mente, puis retourne la valeur int y = ++x; AugmentÃ© de 1 x++ Post-incrÃ©mentation AprÃ¨s Retourne la valeur, puis incrÃ©mente int y = x++; AugmentÃ© de 1 --x PrÃ©-dÃ©crÃ©mentation Avant DÃ©crÃ©mente, puis retourne la valeur int y = --x; DiminuÃ© de 1 x-- Post-dÃ©crÃ©mentation AprÃ¨s Retourne la valeur, puis dÃ©crÃ©mente int y = x--; DiminuÃ© de 1 Pourquoi la position est-elle importante ? La diffÃ©rence rÃ©side dans la valeur retournÃ©e par lâ€™expression au moment de lâ€™exÃ©cution :",
    "tags": [],
    "title": "OpÃ©rateurs",
    "uri": "/420-413/operateurs/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "1. Structures Conditionnelles 1.1 If-Else Similitudes avec Java : La syntaxe de base est identique.\n// Calcul de rabais selon la quantitÃ© et le montant int quantite = 15; double montantTotal = 250.50; double rabais = 0.0; if (quantite \u003e= 20 \u0026\u0026 montantTotal \u003e= 500) { rabais = 0.20; // 20% pour commandes importantes } else if (quantite \u003e= 10 || montantTotal \u003e= 200) { rabais = 0.10; // 10% pour commandes moyennes } else { rabais = 0.0; // Pas de rabais } double montantFinal = montantTotal * (1 - rabais); Console.WriteLine($\"Montant final: {montantFinal} $\"); âœ… Bonne pratique - Accolades obligatoires\nint stock = 5; int quantite = 10; // âœ… BIEN - Toujours utiliser des accolades if (quantite \u003e stock) { Console.WriteLine(\"Stock insuffisant\"); } // âŒ Ã‰VITER - MÃªme si syntaxiquement valide if (quantite \u003e stock) Console.WriteLine(\"Stock insuffisant\"); 1.2 OpÃ©rateur Ternaire Identique Ã  Java, mais C# encourage son utilisation judicieuse.\n// Calcul de frais d'expÃ©dition // Calcul des frais d'expÃ©dition double montantCommande = 45.00; double fraisExpedition = montantCommande \u003e= 50 ? 0.0 : 5.99; Console.WriteLine($\"Frais d'expÃ©dition : {fraisExpedition:C}\"); // DÃ©termination du statut de paiement int joursRetard = 15; string statutPaiement = joursRetard \u003e 0 ? \"En retard\" : \"Ã€ jour\"; Console.WriteLine($\"Statut : {statutPaiement}\"); âœ… Bonne pratique - Ternaires imbriquÃ©s\nint noteExamen = 85; // âœ… Acceptable pour des cas simples (Logique linÃ©aire) string mention = noteExamen \u003e= 90 ? \"A\" : noteExamen \u003e= 80 ? \"B\" : noteExamen \u003e= 70 ? \"C\" : noteExamen \u003e= 60 ? \"D\" : \"F\"; Console.WriteLine($\"RÃ©sultat : {mention}\"); // âŒ Ã€ Ã‰VITER - Trop complexe, rend le dÃ©bogage difficile int heuresTravaillees = 45; int heuresSupplementaires = 5; bool estWeekend = true; // Cette structure imbriquÃ©e est une \"dette technique\" immÃ©diate double tauxHoraire = heuresTravaillees \u003e 40 ? (estWeekend ? 30.0 : 25.0) : (heuresSupplementaires \u003e 0 ? 22.0 : 20.0); // Difficile Ã  lire et Ã  maintenir ! 1.3 Switch Statement DiffÃ©rence majeure avec Java : Pas de â€œfall-throughâ€ implicite en C#.\nint jour = 3; switch (jour) { case 1: Console.WriteLine(\"Lundi\"); break; // break obligatoire case 2: Console.WriteLine(\"Mardi\"); break; case 3: Console.WriteLine(\"Mercredi\"); break; case 4: Console.WriteLine(\"Jeudi\"); break; case 5: Console.WriteLine(\"Vendredi\"); break; default: Console.WriteLine(\"Weekend ou invalide\"); break; } Fall-through explicite en C#\nint jour = 6; switch (jour) { case 6: case 7: Console.WriteLine(\"Weekend\"); break; // Un seul break pour les deux cas case 1: case 2: case 3: case 4: case 5: Console.WriteLine(\"Jour de semaine\"); break; default: Console.WriteLine(\"Jour invalide\"); break; } âœ… Bonne pratique - Switch avec char et string\n// Switch avec char char noteLettre = 'B'; switch (noteLettre) { case 'A': Console.WriteLine(\"Excellent\"); break; case 'B': Console.WriteLine(\"TrÃ¨s bien\"); break; case 'C': Console.WriteLine(\"Bien\"); break; default: Console.WriteLine(\"Ã€ amÃ©liorer\"); break; } // Switch avec string string commande = \"start\"; switch (commande) { case \"start\": Console.WriteLine(\"DÃ©marrage...\"); break; case \"stop\": Console.WriteLine(\"ArrÃªt...\"); break; case \"pause\": Console.WriteLine(\"Pause...\"); break; default: Console.WriteLine(\"Commande inconnue\"); break; } 1.4 Switch Expression (C# 8.0+) NouveautÃ© C#\n// Syntaxe concise et fonctionnelle int numeroDuJour = 3; string nomJour = numeroDuJour switch { 1 =\u003e \"Lundi\", 2 =\u003e \"Mardi\", 3 =\u003e \"Mercredi\", 4 =\u003e \"Jeudi\", 5 =\u003e \"Vendredi\", 6 =\u003e \"Weekend\", 7 =\u003e \"Weekend\", _ =\u003e \"Invalide\" }; Console.WriteLine(nomJour); âœ… Bonne pratique - Switch expression pour calculer des valeurs\n// Utilisation de valeurs discrÃ¨tes (cas prÃ©cis) int numeroJour = 3; string typeJour = numeroJour switch { 1 or 2 =\u003e \"DÃ©but de semaine\", 3 or 4 =\u003e \"Milieu de semaine\", 5 =\u003e \"Fin de semaine\", 6 or 7 =\u003e \"Weekend\", _ =\u003e \"Invalide\" }; Console.WriteLine(typeJour); // Pour les comparaisons de ranges, utiliser if-else iint age = 25; double prixBillet; if (age \u003c 5) prixBillet = 0.0; else if (age \u003c 18) prixBillet = 8.50; else if (age \u003c 65) prixBillet = 12.00; else prixBillet = 9.00; Console.WriteLine($\"Prix du billet : {prixBillet} $\"); âœ… Bonne pratique - Switch expression avec valeurs multiples\nchar lettre = 'e'; // âœ… Version optimisÃ©e (C# 9+) : Plus lisible et moins de rÃ©pÃ©titions bool estUneVoyelle = lettre switch { 'a' or 'e' or 'i' or 'o' or 'u' or 'A' or 'E' or 'I' or 'O' or 'U' =\u003e true, _ =\u003e false }; Console.WriteLine($\"Est une voyelle : {estUneVoyelle}\"); âœ… Bonne pratique - Quand utiliser switch vs if-else\nint note = 85; // La switch expression agit comme une \"table de correspondance\" string mention = note switch { \u003e= 90 =\u003e \"A\", \u003e= 80 =\u003e \"B\", \u003e= 70 =\u003e \"C\", \u003e= 60 =\u003e \"D\", _ =\u003e \"F\" // Le discard (_) est obligatoire pour couvrir tous les cas }; Console.WriteLine($\"Mention obtenue : {mention}\"); double solde = 1500.50; int nombreTransactions = 25; bool aUnDecouvert = false; double fraisMensuels = 0.0; // Logique dÃ©cisionnelle basÃ©e sur plusieurs critÃ¨res if (solde \u003e= 5000 \u0026\u0026 nombreTransactions \u003e 50) { fraisMensuels = 0.0; // Compte premium gratuit } else if (solde \u003e= 1000 || nombreTransactions \u003c= 10) { fraisMensuels = 5.0; // Frais rÃ©duits (fidÃ©litÃ© ou faible usage) } else if (aUnDecouvert) { fraisMensuels = 25.0; // PÃ©nalitÃ© pour dÃ©couvert } else { fraisMensuels = 12.0; // Frais standards } // Utilisation du format monÃ©taire :C (trÃ¨s pratique en .NET 8) Console.WriteLine($\"Frais mensuels : {fraisMensuels:C}\"); 2. Structures ItÃ©ratives 2.1 Boucle While Identique Ã  Java.\nint i = 0; while (i \u003c 5) { Console.WriteLine(i); i++; } âœ… Bonne pratique - While avec condition claire\nint somme = 0; int nombre = 1; while (somme \u003c 100) { somme += number; nombre++; } Console.WriteLine($\"Somme: {somme}, Dernier nombre: {nombre}\"); âœ… Bonne pratique - Ã‰viter les boucles infinies\n// âŒ DANGEREUX // while (true) // { // // Sans condition de sortie claire // } // âœ… MIEUX - Avec limite de sÃ©curitÃ© int maxTentatives = 10; int tentatives = 0; bool succes = false; // âœ… Utilisation d'une boucle While avec deux conditions de sortie while (tentatives \u003c maxTentatives \u0026\u0026 !succes) { Console.Write(\"Entrez un nombre entre 1 et 10 : \"); string saisie = Console.ReadLine(); // âœ… int.TryParse Ã©vite que le programme plante si l'utilisateur tape du texte // Le \"out int nombre\" dÃ©clare la variable uniquement si la conversion rÃ©ussit if (int.TryParse(saisie, out int nombre) \u0026\u0026 nombre \u003e= 1 \u0026\u0026 nombre \u003c= 10) { succes = true; Console.WriteLine(\"Valide !\"); } else { tentatives++; Console.WriteLine($\"Invalide. Tentatives restantes : {maxTentatives - tentatives}\"); } } 2.2 Boucle Do-While Identique Ã  Java.\nint i = 0; do { Console.WriteLine(i); i++; } while (i \u003c 5); âœ… Bonne pratique - Utiliser do-while pour validation Utilisation pour la validation de saisie : Cette structure garantit que lâ€™utilisateur verra le message au moins une fois.\nint nombre; string saisie; do { Console.Write(\"Entrez un nombre positif : \"); saisie = Console.ReadLine(); // On boucle tant que la saisie n'est pas un entier OU que le nombre est \u003c= 0 } while (!int.TryParse(saisie, out nombre) || nombre \u003c= 0); Console.WriteLine($\"Vous avez entrÃ© : {nombre}\"); Exemple - Menu simple\nint choix; do { Console.WriteLine(\"\\n--- MENU ---\"); Console.WriteLine(\"1. Addition\"); Console.WriteLine(\"2. Soustraction\"); Console.WriteLine(\"3. Quitter\"); Console.Write(\"Votre choix : \"); //si l'utilisateur ne tape pas un chiffre et que la conversion ne fonction pas, choix va avoir la valeur par dÃ©faut 0 int.TryParse(Console.ReadLine(), out choix); switch (choix) { case 1: Console.WriteLine(\"Addition sÃ©lectionnÃ©e\"); break; case 2: Console.WriteLine(\"Soustraction sÃ©lectionnÃ©e\"); break; case 3: Console.WriteLine(\"Au revoir !\"); break; default: Console.WriteLine(\"Choix invalide, veuillez recommencer.\"); break; } // La boucle continue tant que l'utilisateur n'a pas choisi de quitter (3) } while (choix != 3); 2.3 Boucle For Identique Ã  Java.\nfor (int i = 0; i \u003c 10; i++) { Console.WriteLine(i); } âœ… Bonne pratique - DÃ©clarer la variable dans la boucle\n// âœ… BIEN - PortÃ©e limitÃ©e for (int i = 0; i \u003c 10; i++) { Console.WriteLine(i); } // i n'existe plus ici // âŒ Ã‰VITER - PortÃ©e trop large int j; for (j = 0; j \u003c 10; j++) { Console.WriteLine(j); } // j existe encore ici ItÃ©rer sur un tableau\nLa boucle for est privilÃ©giÃ©e lorsque lâ€™indexation est nÃ©cessaire ou pour manipuler des structures multidimensionnelles.\nint[] nombres = { 10, 20, 30, 40, 50 }; // Calcul de la somme int somme = 0; for (int i = 0; i \u003c nombres.Length; i++) { somme += nombres[i]; } Console.WriteLine($\"Somme : {somme}\"); // Recherche d'un Ã©lÃ©ment int valeurRecherchee = 30; int indexTrouve = -1; for (int i = 0; i \u003c nombres.Length; i++) { if (nombres[i] == valeurRecherchee) { indexTrouve = i; break; // On quitte la boucle dÃ¨s qu'on a trouvÃ© } } if (indexTrouve != -1) { Console.WriteLine($\"TrouvÃ© Ã  l'index {indexTrouve}\"); } âœ… Bonne pratique - Ã‰viter de modifier le compteur dans la boucle\nint[] values = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // âŒ MAUVAIS - Difficile Ã  comprendre for (int i = 0; i \u003c values.Length; i++) { Console.WriteLine(values[i]); if (values[i] % 2 == 0) i++; // Modifie le flux de contrÃ´le - confus! } // âœ… MIEUX - Intention claire for (int i = 0; i \u003c values.Length; i++) { Console.WriteLine(values[i]); if (values[i] % 2 == 0 \u0026\u0026 i + 1 \u003c values.Length) { i++; // Saute le prochain si pair } } Boucles imbriquÃ©es - Tableaux 2D\nint[,] matrice = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; // Affichage de la matrice ligne par ligne for (int ligne = 0; ligne \u003c 3; ligne++) { for (int col = 0; col \u003c 3; col++) { Console.Write($\"{matrice[ligne, col]} \"); } Console.WriteLine(); // Saut de ligne aprÃ¨s chaque rangÃ©e } 2.4 Boucle Foreach DiffÃ©rence avec Java : Mot-clÃ© foreach au lieu de for. Câ€™est lâ€™outil le plus sÃ»r car il Ã©limine les erreurs de dÃ©passement dâ€™index (le fameux IndexOutOfRangeException).\n// Java: for (String name : names) // C#: string[] noms = { \"Alice\", \"Bob\", \"Charlie\" }; foreach (string nom in noms) { Console.WriteLine(nom); } âœ… Bonne pratique - PrÃ©fÃ©rer foreach quand appropriÃ©\niint[] nombres = { 1, 2, 3, 4, 5 }; // âœ… BIEN - Plus lisible, idÃ©al pour le calcul ou l'affichage int somme = 0; foreach (int n in nombres) { somme += n; } Console.WriteLine($\"Somme : {somme}\"); // âŒ Ã€ Ã‰VITER - Sauf si vous avez besoin de l'index 'i' (ex: modification) int sommeAlternative = 0; for (int i = 0; i \u003c nombres.Length; i++) { sommeAlternative += nombres[i]; } Exemples pratiques avec foreach\n// Affichage de prix formatÃ©s (Symbole $ au lieu de :C) double[] prixUnitaires = { 19.99, 29.99, 39.99, 49.99 }; foreach (double p in prixUnitaires) { Console.WriteLine($\"Prix : {p} $\"); } // Comptage avec condition (Filtrage simple) int[] scores = { 45, 78, 92, 65, 88, 54, 91 }; int reussites = 0; foreach (int s in scores) { if (s \u003e= 60) { reussites++; } } Console.WriteLine($\"{reussites} Ã©tudiants ont rÃ©ussi.\"); // Recherche du maximum int[] valeurs = { 23, 67, 12, 89, 45, 34 }; int maximum = valeurs[0]; foreach (int v in valeurs) { if (v \u003e maximum) { maximum = v; } } Console.WriteLine($\"Valeur maximale : {maximum}\"); âš ï¸ Important - Foreach est read-only\nIl est impossible de modifier directement lâ€™Ã©lÃ©ment de la collection Ã  lâ€™intÃ©rieur dâ€™un foreach. Le compilateur .NET 8 bloquera le code.\nint[] chiffres = { 1, 2, 3 }; // âŒ ERREUR DE COMPILATION - On ne peut pas modifier 'c' /* foreach (int c in chiffres) { c = c * 2; } */ // âœ… SOLUTION - Utiliser 'for' pour modifier le contenu du tableau for (int i = 0; i \u003c chiffres.Length; i++) { chiffres[i] = chiffres[i] * 2; } // VÃ©rification (Lecture simple via foreach) foreach (int c in chiffres) { Console.WriteLine(c); // Affiche : 2, 4, 6 } Foreach avec tableaux multidimensionnels\nint[,] matrice = { { 1, 2, 3 }, { 4, 5, 6 } }; // Foreach parcourt automatiquement toutes les lignes et colonnes foreach (int valeur in matrice) { Console.Write($\"{valeur} \"); } // RÃ©sultat : 1 2 3 4 5 6 3. Instructions de ContrÃ´le de Flux 3.1 Break Identique Ã  Java - Sort de la boucle ou du switch.\n// Recherche d'un Ã©lÃ©ment dans un tableau int[] nombres = { 5, 12, 8, 3, 19, 7 }; int cible = 19; int position = -1; for (int i = 0; i \u003c nombres.Length; i++) { if (nombres[i] == cible) { position = i; break; // âœ… SuccÃ¨s : On arrÃªte de chercher pour Ã©conomiser des ressources } } if (position != -1) { Console.WriteLine($\"TrouvÃ© Ã  la position {position}\"); } else { Console.WriteLine(\"L'Ã©lÃ©ment n'a pas Ã©tÃ© trouvÃ©.\"); } Break dans switch\nint operation = 2; int nombre1 = 10; int nombre2 = 5; int resultat = 0; switch (operation) { case 1: resultat = nombre1 + nombre2; break; // Sort du switch aprÃ¨s l'addition case 2: resultat = nombre1 - nombre2; break; // Sort du switch aprÃ¨s la soustraction case 3: resultat = nombre1 * nombre2; break; // Sort du switch aprÃ¨s la multiplication default: Console.WriteLine(\"OpÃ©ration invalide\"); break; } Console.WriteLine($\"RÃ©sultat : {resultat}\"); 3.2 Continue Identique Ã  Java - Passe Ã  lâ€™itÃ©ration suivante.\n// Afficher seulement les nombres impairs for (int i = 0; i \u003c 10; i++) { if (i % 2 == 0) continue; // Saute les nombres pairs Console.WriteLine(i); } // Affiche: 1, 3, 5, 7, 9 Continue pour filtrage simple\nint[] notes = { 45, 78, 0, 92, -1, 65, 88 }; // âœ… BIEN - Utilisation de continue pour filtrer (Style \"Guard Clause\") foreach (int note in notes) { // Si la note est hors limite, on l'ignore immÃ©diatement if (note \u003c 0 || note \u003e 100) continue; // Le code principal reste ici, sans Ãªtre cachÃ© dans un bloc 'if' Console.WriteLine($\"Note valide : {note}\"); } Exemple - Somme conditionnelle\nint[] nombres = { 5, -3, 12, 0, 8, -7, 15 }; int sommePositifs = 0; foreach (int n in nombres) { // Si le nombre est nÃ©gatif ou nul, on passe directement au suivant if (n \u003c= 0) continue; // On ne traite que les valeurs qui nous intÃ©ressent sommePositifs += n; } Console.WriteLine($\"Somme des nombres positifs : {sommePositifs}\"); 4. Gestion des Exceptions 4.1 Try-Catch-Finally TrÃ¨s similaire Ã  Java.\ntry { int result = 10 / 0; // GÃ©nÃ¨re une exception } catch (DivideByZeroException ex) { Console.WriteLine($\"Erreur: {ex.Message}\"); } catch (Exception ex) { Console.WriteLine($\"Erreur gÃ©nÃ©rale: {ex.Message}\"); } finally { Console.WriteLine(\"Toujours exÃ©cutÃ©\"); }",
    "description": "1. Structures Conditionnelles 1.1 If-Else Similitudes avec Java : La syntaxe de base est identique.\n// Calcul de rabais selon la quantitÃ© et le montant int quantite = 15; double montantTotal = 250.50; double rabais = 0.0; if (quantite \u003e= 20 \u0026\u0026 montantTotal \u003e= 500) { rabais = 0.20; // 20% pour commandes importantes } else if (quantite \u003e= 10 || montantTotal \u003e= 200) { rabais = 0.10; // 10% pour commandes moyennes } else { rabais = 0.0; // Pas de rabais } double montantFinal = montantTotal * (1 - rabais); Console.WriteLine($\"Montant final: {montantFinal} $\"); âœ… Bonne pratique - Accolades obligatoires",
    "tags": [],
    "title": "Structures de contrÃ´les",
    "uri": "/420-413/structures_de_controles/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "En C#, on distingue deux grandes familles pour stocker des groupes de donnÃ©es : les Tableaux (taille fixe) et les Collections (taille dynamique).\nLes tableaux (Array) Un tableau est une structure de donnÃ©es de taille fixe stockÃ©e de maniÃ¨re contiguÃ« en mÃ©moire.\n1. DÃ©claration et initialisation Syntaxe de base // DÃ©claration d'un tableau int[] nombres; // DÃ©claration avec initialisation de la taille int[] nombres = new int[5]; // DÃ©claration avec initialisation des valeurs int[] nombres = new int[] { 10, 20, 30, 40, 50 }; // Syntaxe courte (recommandÃ©e) int[] nombres = { 10, 20, 30, 40, 50 }; Le piÃ¨ge de lâ€™immuabilitÃ© : Si vous crÃ©ez int[] tab = new int[3], vous ne pourrez jamais y mettre un 4e Ã©lÃ©ment. Pour â€œagrandirâ€ un tableau, il faut en crÃ©er un nouveau, copier les donnÃ©es, puis ajouter le nouvel Ã©lÃ©ment. Câ€™est pourquoi nous utilisons les Collections pour les donnÃ©es dynamiques.\nPoints importants Ã  retenir Les tableaux ont une taille fixe dÃ©finie Ã  la crÃ©ation Les collections (comme List\u003cT\u003e) peuvent changer de taille dynamiquement Les propriÃ©tÃ©s en C# (comme .Length, .Count) nâ€™ont pas de parenthÃ¨ses C# offre LINQ (Language Integrated Query) pour manipuler les collections facilement Les collections sont dans le namespace System.Collections.Generic 2. Exemples pratiques Exemple 1 : Gestion des notes dâ€™Ã©tudiants using System; class GestionNotes { static void Main() { // DÃ©claration d'un tableau de notes double[] notesEtudiants = { 85.5, 92.0, 78.5, 88.0, 95.5 }; // Afficher toutes les notes Console.WriteLine(\"=== Notes des Ã©tudiants ===\"); for (int i = 0; i \u003c notesEtudiants.Length; i++) { Console.WriteLine($\"Ã‰tudiant {i + 1}: {notesEtudiants[i]}%\"); } // Calculer la moyenne double somme = 0; foreach (double note in notesEtudiants) { somme += note; } double moyenne = somme / notesEtudiants.Length; Console.WriteLine($\"\\nMoyenne de la classe: {moyenne:F2}%\"); } } Sortie :\n=== Notes des Ã©tudiants ===\rÃ‰tudiant 1: 85.5%\rÃ‰tudiant 2: 92%\rÃ‰tudiant 3: 78.5%\rÃ‰tudiant 4: 88%\rÃ‰tudiant 5: 95.5%\rMoyenne de la classe: 87.90% Exemple 2 : Tableau de chaÃ®nes de caractÃ¨res using System; class GestionPrenoms { static void Main() { // Tableau de prÃ©noms string[] prenoms = { \"Alice\", \"Bernard\", \"Catherine\", \"David\", \"Ã‰milie\" }; // Afficher les prÃ©noms avec leur longueur Console.WriteLine(\"=== Liste des prÃ©noms ===\"); foreach (string prenom in prenoms) { Console.WriteLine($\"{prenom} - {prenom.Length} lettres\"); } // Trouver le prÃ©nom le plus long string prenomPlusLong = prenoms[0]; foreach (string prenom in prenoms) { if (prenom.Length \u003e prenomPlusLong.Length) { prenomPlusLong = prenom; } } Console.WriteLine($\"\\nPrÃ©nom le plus long: {prenomPlusLong}\"); } } 3. Tableaux multidimensionnels Tableau Ã  deux dimensions (matrice) using System; class Matrice { static void Main() { // DÃ©claration d'une matrice 3x3 int[,] matrice = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } }; // Affichage de la matrice Console.WriteLine(\"=== Matrice 3x3 ===\"); for (int ligne = 0; ligne \u003c 3; ligne++) { for (int colonne = 0; colonne \u003c 3; colonne++) { Console.Write($\"{matrice[ligne, colonne]}\\t\"); } Console.WriteLine(); } // Calculer la somme de chaque ligne Console.WriteLine(\"\\n=== Somme par ligne ===\"); for (int ligne = 0; ligne \u003c 3; ligne++) { int somme = 0; for (int colonne = 0; colonne \u003c 3; colonne++) { somme += matrice[ligne, colonne]; } Console.WriteLine($\"Ligne {ligne + 1}: {somme}\"); } } } Tableau dentelÃ© (jagged array) using System; class TableauDentele { static void Main() { // Tableau oÃ¹ chaque ligne peut avoir une longueur diffÃ©rente int[][] notesParCours = new int[3][]; notesParCours[0] = new int[] { 85, 90, 78 }; // 3 notes notesParCours[1] = new int[] { 92, 88 }; // 2 notes notesParCours[2] = new int[] { 95, 87, 91, 89 }; // 4 notes // Affichage Console.WriteLine(\"=== Notes par cours ===\"); for (int cours = 0; cours \u003c notesParCours.Length; cours++) { Console.Write($\"Cours {cours + 1}: \"); foreach (int note in notesParCours[cours]) { Console.Write($\"{note} \"); } Console.WriteLine(); } } } 4. MÃ©thodes utiles pour les tableaux using System; class MethodesTableaux { static void Main() { int[] nombres = { 45, 12, 78, 34, 90, 23, 67 }; // Longueur du tableau Console.WriteLine($\"Nombre d'Ã©lÃ©ments: {nombres.Length}\"); // Trier le tableau Array.Sort(nombres); Console.WriteLine(\"\\nTableau triÃ©:\"); AfficherTableau(nombres); // Inverser l'ordre Array.Reverse(nombres); Console.WriteLine(\"\\nTableau inversÃ©:\"); AfficherTableau(nombres); // Rechercher un Ã©lÃ©ment int valeurRecherchee = 78; int index = Array.IndexOf(nombres, valeurRecherchee); Console.WriteLine($\"\\nIndex de {valeurRecherchee}: {index}\"); // Copier un tableau int[] copie = new int[nombres.Length]; Array.Copy(nombres, copie, nombres.Length); Console.WriteLine(\"\\nCopie du tableau:\"); AfficherTableau(copie); } static void AfficherTableau(int[] tableau) { foreach (int nombre in tableau) { Console.Write($\"{nombre} \"); } Console.WriteLine(); } } Les Collections Les collections en C# offrent plus de flexibilitÃ© que les tableaux. Elles peuvent changer de taille dynamiquement et offrent des mÃ©thodes pratiques pour manipuler les donnÃ©es.\n1. List - La collection la plus utilisÃ©e Syntaxe de base using System; using System.Collections.Generic; class ExempleList { static void Main() { // CrÃ©ation d'une liste vide List fruits = new List(); // CrÃ©ation avec valeurs initiales List nombres = new List { 1, 2, 3, 4, 5 }; // Ajout d'Ã©lÃ©ments fruits.Add(\"Pomme\"); fruits.Add(\"Banane\"); fruits.Add(\"Orange\"); // Affichage Console.WriteLine(\"=== Liste de fruits ===\"); foreach (string fruit in fruits) { Console.WriteLine(fruit); } // Nombre d'Ã©lÃ©ments Console.WriteLine($\"\\nNombre de fruits: {fruits.Count}\"); } } Exemple 2 : Gestion dâ€™un inventaire simple using System; using System.Collections.Generic; class GestionInventaire { static void Main() { // CrÃ©ation de listes pour stocker les informations List nomsProduits = new List(); List prixProduits = new List(); List quantitesProduits = new List(); // Ajout de produits nomsProduits.Add(\"Ordinateur portable\"); prixProduits.Add(1299.99); quantitesProduits.Add(15); nomsProduits.Add(\"Souris sans fil\"); prixProduits.Add(29.99); quantitesProduits.Add(50); nomsProduits.Add(\"Clavier mÃ©canique\"); prixProduits.Add(149.99); quantitesProduits.Add(25); // Affichage de l'inventaire Console.WriteLine(\"=== INVENTAIRE ===\"); for (int i = 0; i \u003c nomsProduits.Count; i++) { Console.WriteLine($\"{nomsProduits[i]} - {prixProduits[i]:C} - QtÃ©: {quantitesProduits[i]}\"); } // Calculer la valeur totale de l'inventaire double valeurTotale = 0; for (int i = 0; i \u003c nomsProduits.Count; i++) { valeurTotale += prixProduits[i] * quantitesProduits[i]; } Console.WriteLine($\"\\nValeur totale de l'inventaire: {valeurTotale:C}\"); } } MÃ©thodes importantes de List using System; using System.Collections.Generic; class MethodesList { static void Main() { List etudiants = new List { \"Alice\", \"Bernard\", \"Catherine\", \"David\" }; // Add - Ajouter un Ã©lÃ©ment Ã  la fin etudiants.Add(\"Ã‰milie\"); // Insert - InsÃ©rer Ã  une position spÃ©cifique etudiants.Insert(1, \"FranÃ§ois\"); // Remove - Retirer un Ã©lÃ©ment spÃ©cifique etudiants.Remove(\"Bernard\"); // RemoveAt - Retirer Ã  un index spÃ©cifique etudiants.RemoveAt(0); // Contains - VÃ©rifier si un Ã©lÃ©ment existe bool existe = etudiants.Contains(\"Catherine\"); Console.WriteLine($\"Catherine est dans la liste: {existe}\"); // IndexOf - Trouver l'index d'un Ã©lÃ©ment int index = etudiants.IndexOf(\"David\"); Console.WriteLine($\"Index de David: {index}\"); // Clear - Vider la liste // etudiants.Clear(); // Sort - Trier la liste etudiants.Sort(); // Reverse - Inverser l'ordre etudiants.Reverse(); // Count - Nombre d'Ã©lÃ©ments Console.WriteLine($\"Nombre d'Ã©tudiants: {etudiants.Count}\"); // Affichage final Console.WriteLine(\"\\n=== Liste finale ===\"); foreach (string etudiant in etudiants) { Console.WriteLine(etudiant); } } } 2. Dictionary\u003cTKey, TValue\u003e - Paires clÃ©-valeur using System; using System.Collections.Generic; class ExempleDictionnaire { static void Main() { // CrÃ©ation d'un dictionnaire pour stocker des codes postaux Dictionary codesPostaux = new Dictionary(); // Ajout d'Ã©lÃ©ments codesPostaux.Add(\"MontrÃ©al\", \"H1A\"); codesPostaux.Add(\"QuÃ©bec\", \"G1A\"); codesPostaux.Add(\"Laval\", \"H7A\"); codesPostaux.Add(\"Gatineau\", \"J8T\"); // AccÃ¨s Ã  une valeur Console.WriteLine($\"Code postal de MontrÃ©al: {codesPostaux[\"MontrÃ©al\"]}\"); // VÃ©rifier si une clÃ© existe if (codesPostaux.ContainsKey(\"QuÃ©bec\")) { Console.WriteLine($\"Code postal de QuÃ©bec: {codesPostaux[\"QuÃ©bec\"]}\"); } // Parcourir le dictionnaire Console.WriteLine(\"\\n=== Tous les codes postaux ===\"); foreach (KeyValuePair paire in codesPostaux) { Console.WriteLine($\"{paire.Key}: {paire.Value}\"); } // Modifier une valeur codesPostaux[\"MontrÃ©al\"] = \"H2X\"; // Retirer un Ã©lÃ©ment codesPostaux.Remove(\"Gatineau\"); Console.WriteLine($\"\\nNombre de villes: {codesPostaux.Count}\"); } } Exemple pratique : SystÃ¨me de notes using System; using System.Collections.Generic; class SystemeNotes { static void Main() { // Dictionnaire: nom de l'Ã©tudiant -\u003e liste de notes Dictionary\u003e notesEtudiants = new Dictionary\u003e(); // Ajout des Ã©tudiants et leurs notes notesEtudiants.Add(\"Alice\", new List { 85.5, 92.0, 88.5 }); notesEtudiants.Add(\"Bernard\", new List { 78.0, 82.5, 80.0 }); notesEtudiants.Add(\"Catherine\", new List { 95.0, 93.5, 97.0 }); // Afficher les notes et moyennes Console.WriteLine(\"=== NOTES ET MOYENNES ===\\n\"); foreach (KeyValuePair\u003e etudiant in notesEtudiants) { string nom = etudiant.Key; List notes = etudiant.Value; Console.WriteLine($\"Ã‰tudiant: {nom}\"); Console.Write(\"Notes: \"); foreach (double note in notes) { Console.Write($\"{note}% \"); } // Calculer la moyenne double somme = 0; foreach (double note in notes) { somme += note; } double moyenne = somme / notes.Count; Console.WriteLine($\"\\nMoyenne: {moyenne:F2}%\\n\"); } } } 3. Queue - File dâ€™attente (FIFO) using System; using System.Collections.Generic; class ExempleQueue { static void Main() { // CrÃ©ation d'une file d'attente Queue fileAttente = new Queue(); // Enqueue - Ajouter Ã  la fin de la file fileAttente.Enqueue(\"Client 1\"); fileAttente.Enqueue(\"Client 2\"); fileAttente.Enqueue(\"Client 3\"); fileAttente.Enqueue(\"Client 4\"); Console.WriteLine($\"Nombre de clients: {fileAttente.Count}\"); // Peek - Voir le premier Ã©lÃ©ment sans le retirer string premier = fileAttente.Peek(); Console.WriteLine($\"Prochain client Ã  servir: {premier}\"); // Dequeue - Retirer et retourner le premier Ã©lÃ©ment Console.WriteLine(\"\\n=== Service des clients ===\"); while (fileAttente.Count \u003e 0) { string client = fileAttente.Dequeue(); Console.WriteLine($\"Servir: {client}\"); } Console.WriteLine($\"\\nClients restants: {fileAttente.Count}\"); } } 4. Stack - Pile (LIFO) using System; using System.Collections.Generic; class ExempleStack { static void Main() { // CrÃ©ation d'une pile Stack historiqueNavigation = new Stack(); // Push - Ajouter au sommet de la pile historiqueNavigation.Push(\"Page d'accueil\"); historiqueNavigation.Push(\"Page de recherche\"); historiqueNavigation.Push(\"Page de rÃ©sultats\"); historiqueNavigation.Push(\"Page de dÃ©tails\"); Console.WriteLine($\"Nombre de pages visitÃ©es: {historiqueNavigation.Count}\"); // Peek - Voir le sommet sans retirer string pageActuelle = historiqueNavigation.Peek(); Console.WriteLine($\"Page actuelle: {pageActuelle}\"); // Pop - Retirer et retourner l'Ã©lÃ©ment du sommet Console.WriteLine(\"\\n=== Navigation arriÃ¨re ===\"); while (historiqueNavigation.Count \u003e 0) { string page = historiqueNavigation.Pop(); Console.WriteLine($\"Retour Ã : {page}\"); } } } 5. HashSet - Ensemble (pas de doublons) using System; using System.Collections.Generic; class ExempleHashSet { static void Main() { // CrÃ©ation d'un ensemble HashSet tagsUniques = new HashSet(); // Add - Ajouter un Ã©lÃ©ment (ignore les doublons) tagsUniques.Add(\"programmation\"); tagsUniques.Add(\"csharp\"); tagsUniques.Add(\"collections\"); tagsUniques.Add(\"csharp\"); // Sera ignorÃ© (doublon) tagsUniques.Add(\"dotnet\"); Console.WriteLine($\"Nombre de tags uniques: {tagsUniques.Count}\"); // Affichage Console.WriteLine(\"\\n=== Tags ===\"); foreach (string tag in tagsUniques) { Console.WriteLine($\"- {tag}\"); } // Contains - VÃ©rifier l'existence bool existe = tagsUniques.Contains(\"csharp\"); Console.WriteLine($\"\\nLe tag 'csharp' existe: {existe}\"); // OpÃ©rations sur les ensembles HashSet autresTags = new HashSet { \"csharp\", \"java\", \"python\" }; // Union tagsUniques.UnionWith(autresTags); Console.WriteLine($\"\\nAprÃ¨s union: {tagsUniques.Count} tags\"); // Intersection HashSet langages = new HashSet { \"csharp\", \"java\", \"python\" }; HashSet appris = new HashSet { \"csharp\", \"javascript\" }; langages.IntersectWith(appris); Console.WriteLine(\"\\n=== Langages en commun ===\"); foreach (string langage in langages) { Console.WriteLine(langage); } } }",
    "description": "En C#, on distingue deux grandes familles pour stocker des groupes de donnÃ©es : les Tableaux (taille fixe) et les Collections (taille dynamique).\nLes tableaux (Array) Un tableau est une structure de donnÃ©es de taille fixe stockÃ©e de maniÃ¨re contiguÃ« en mÃ©moire.\n1. DÃ©claration et initialisation Syntaxe de base // DÃ©claration d'un tableau int[] nombres; // DÃ©claration avec initialisation de la taille int[] nombres = new int[5]; // DÃ©claration avec initialisation des valeurs int[] nombres = new int[] { 10, 20, 30, 40, 50 }; // Syntaxe courte (recommandÃ©e) int[] nombres = { 10, 20, 30, 40, 50 }; Le piÃ¨ge de lâ€™immuabilitÃ© : Si vous crÃ©ez int[] tab = new int[3], vous ne pourrez jamais y mettre un 4e Ã©lÃ©ment. Pour â€œagrandirâ€ un tableau, il faut en crÃ©er un nouveau, copier les donnÃ©es, puis ajouter le nouvel Ã©lÃ©ment. Câ€™est pourquoi nous utilisons les Collections pour les donnÃ©es dynamiques.",
    "tags": [],
    "title": "Tableaux et collections",
    "uri": "/420-413/tableaux_collections/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Table des matiÃ¨res Introduction Syntaxe de base ParamÃ¨tres de mÃ©thodes ParamÃ¨tres par rÃ©fÃ©rence (ref) ParamÃ¨tres de sortie (out) ParamÃ¨tres optionnels Surcharge de mÃ©thodes PortÃ©e des variables Exercices Introduction Les mÃ©thodes (aussi appelÃ©es fonctions) sont des blocs de code rÃ©utilisables qui effectuent une tÃ¢che spÃ©cifique. Elles permettent de :\nOrganiser le code de maniÃ¨re logique Ã‰viter la rÃ©pÃ©tition de code Faciliter la maintenance et la lecture du programme Diviser un problÃ¨me complexe en sous-problÃ¨mes plus simples Avantages des mÃ©thodes RÃ©utilisabilitÃ© : Ã‰crire une fois, utiliser plusieurs fois LisibilitÃ© : Code plus clair et organisÃ© Maintenance : Plus facile de corriger ou modifier le code Tests : Plus facile de tester des petites unitÃ©s de code Syntaxe de base Structure dâ€™une mÃ©thode modificateurAcces [static] typeRetour NomMethode(typeParam1 param1, typeParam2 param2) { // Corps de la mÃ©thode // Instructions Ã  exÃ©cuter return valeur; // Si la mÃ©thode retourne une valeur } Composantes :\nmodificateurAcces : ContrÃ´le la visibilitÃ© de la mÃ©thode (public, private, protected, internal) static : Indique que la mÃ©thode appartient Ã  la classe, pas Ã  une instance (obligatoire pour lâ€™instant) typeRetour : Le type de donnÃ©es que la mÃ©thode retourne (int, string, double, void, etc.) NomMethode : Le nom de la mÃ©thode (convention : commence par une majuscule en C#) ParamÃ¨tres : Les donnÃ©es dâ€™entrÃ©e (optionnels) Corps : Le code qui sâ€™exÃ©cute quand la mÃ©thode est appelÃ©e return : Retourne une valeur (sauf si void) Les modificateurs dâ€™accÃ¨s Modificateur Description Utilisation public Accessible partout Pour les mÃ©thodes utilisÃ©es par dâ€™autres classes private Accessible seulement dans la classe actuelle Pour les mÃ©thodes internes (par dÃ©faut) protected Accessible dans la classe et ses classes dÃ©rivÃ©es Pour lâ€™hÃ©ritage (POO) internal Accessible dans le mÃªme assembly Pour les mÃ©thodes partagÃ©es dans un projet Note : Pour lâ€™instant, nous utilisons principalement static avec nos mÃ©thodes car nous ne travaillons pas encore avec la programmation orientÃ©e objet. Les mÃ©thodes static peuvent Ãªtre appelÃ©es directement sans crÃ©er dâ€™objet.\nExemples de dÃ©clarations de mÃ©thodes // MÃ©thode publique statique qui retourne un entier public static int CalculerSomme(int a, int b) { return a + b; } // MÃ©thode privÃ©e statique qui ne retourne rien (void) private static void AfficherMessage() { Console.WriteLine(\"Message privÃ©\"); } // MÃ©thode publique statique avec plusieurs paramÃ¨tres public static double CalculerMoyenne(double note1, double note2, double note3) { return (note1 + note2 + note3) / 3; } // MÃ©thode publique statique sans paramÃ¨tres public static void AfficherBienvenue() { Console.WriteLine(\"Bienvenue!\"); } Exemple simple : MÃ©thode sans paramÃ¨tres using System; class Programme { public static void AfficherMessage() { Console.WriteLine(\"Bonjour du CÃ‰GEP!\"); Console.WriteLine(\"Bienvenue dans le cours de C#\"); } static void Main() { AfficherMessage(); // Appel de la mÃ©thode AfficherMessage(); // On peut l'appeler plusieurs fois } } Sortie :\nBonjour du CÃ‰GEP!\rBienvenue dans le cours de C#\rBonjour du CÃ‰GEP!\rBienvenue dans le cours de C# Exemple : MÃ©thode avec retour using System; class Programme { public static int ObtenirAnneeActuelle() { return 2024; } static void Main() { int annee = ObtenirAnneeActuelle(); Console.WriteLine($\"Nous sommes en {annee}\"); } } ParamÃ¨tres de mÃ©thodes Les paramÃ¨tres permettent de passer des donnÃ©es Ã  une mÃ©thode.\nPassage par valeur (comportement par dÃ©faut) Quand vous passez une variable Ã  une mÃ©thode, C# crÃ©e une copie de la valeur. Les modifications dans la mÃ©thode nâ€™affectent pas la variable originale.\nusing System; class Programme { public static void AugmenterNombre(int nombre) { nombre = nombre + 10; Console.WriteLine($\"Dans la mÃ©thode: {nombre}\"); } static void Main() { int valeur = 5; Console.WriteLine($\"Avant l'appel: {valeur}\"); AugmenterNombre(valeur); Console.WriteLine($\"AprÃ¨s l'appel: {valeur}\"); } } Sortie :\nAvant l'appel: 5\rDans la mÃ©thode: 15\rAprÃ¨s l'appel: 5 Explication : La variable valeur nâ€™a pas changÃ© car la mÃ©thode a travaillÃ© avec une copie.\nExemple : Calculer lâ€™aire dâ€™un rectangle using System; class Programme { public static double CalculerAireRectangle(double longueur, double largeur) { double aire = longueur * largeur; return aire; } static void Main() { double resultat = CalculerAireRectangle(5.5, 3.2); Console.WriteLine($\"L'aire du rectangle est: {resultat:F2} mÂ²\"); // Appel avec d'autres valeurs resultat = CalculerAireRectangle(10.0, 7.5); Console.WriteLine($\"L'aire du rectangle est: {resultat:F2} mÂ²\"); } } Exemple : MÃ©thode avec plusieurs paramÃ¨tres using System; class Programme { public static void AfficherInfoEtudiant(string nom, string prenom, int age, double moyenne) { Console.WriteLine(\"=== FICHE Ã‰TUDIANT ===\"); Console.WriteLine($\"Nom: {nom}\"); Console.WriteLine($\"PrÃ©nom: {prenom}\"); Console.WriteLine($\"Ã‚ge: {age} ans\"); Console.WriteLine($\"Moyenne: {moyenne:F1}%\"); Console.WriteLine(\"=====================\"); } static void Main() { AfficherInfoEtudiant(\"Tremblay\", \"Alice\", 19, 87.5); AfficherInfoEtudiant(\"Lavoie\", \"Bernard\", 20, 82.3); } } ParamÃ¨tres par rÃ©fÃ©rence (ref) Le mot-clÃ© ref permet de passer une variable par rÃ©fÃ©rence plutÃ´t que par valeur. Cela signifie que la mÃ©thode travaille directement avec la variable originale, pas avec une copie.\nCaractÃ©ristiques de ref La variable DOIT Ãªtre initialisÃ©e avant lâ€™appel Les modifications dans la mÃ©thode affectent la variable originale Le mot-clÃ© ref doit apparaÃ®tre Ã  la dÃ©finition ET Ã  lâ€™appel de la mÃ©thode Syntaxe public static void NomMethode(ref int parametre) { parametre = parametre * 2; } // Appel int nombre = 10; NomMethode(ref nombre); // Utiliser 'ref' lors de l'appel Exemple : Ã‰changer deux valeurs using System; class Programme { public static void EchangerValeurs(ref int a, ref int b) { int temporaire = a; a = b; b = temporaire; Console.WriteLine($\"Dans la mÃ©thode - a: {a}, b: {b}\"); } static void Main() { int x = 10; int y = 20; Console.WriteLine($\"Avant l'Ã©change - x: {x}, y: {y}\"); EchangerValeurs(ref x, ref y); Console.WriteLine($\"AprÃ¨s l'Ã©change - x: {x}, y: {y}\"); } } Sortie :\nAvant l'Ã©change - x: 10, y: 20\rDans la mÃ©thode - a: 20, b: 10\rAprÃ¨s l'Ã©change - x: 20, y: 10 Exemple : Doubler une valeur using System; class Programme { public static void DoublerValeur(ref int nombre) { nombre = nombre * 2; } static void Main() { int valeur = 15; Console.WriteLine($\"Valeur initiale: {valeur}\"); DoublerValeur(ref valeur); Console.WriteLine($\"Valeur aprÃ¨s doublement: {valeur}\"); } } Sortie :\nValeur initiale: 15\rValeur aprÃ¨s doublement: 30 Exemple : Modifier plusieurs valeurs using System; class Programme { public static void AppliquerTaxes(ref double prix, double tauxTPS, double tauxTVQ) { double tps = prix * tauxTPS; double tvq = prix * tauxTVQ; prix = prix + tps + tvq; } static void Main() { double prixProduit = 100.00; Console.WriteLine($\"Prix avant taxes: {prixProduit:C}\"); AppliquerTaxes(ref prixProduit, 0.05, 0.09975); Console.WriteLine($\"Prix aprÃ¨s taxes: {prixProduit:C}\"); } } ParamÃ¨tres de sortie (out) Le mot-clÃ© out est similaire Ã  ref, mais avec des diffÃ©rences importantes :\nDiffÃ©rences entre ref et out CaractÃ©ristique ref out Initialisation avant appel REQUISE Pas nÃ©cessaire Assignation dans la mÃ©thode Optionnelle OBLIGATOIRE Utilisation principale Modifier une valeur existante Retourner plusieurs valeurs CaractÃ©ristiques de out La variable Nâ€™A PAS BESOIN dâ€™Ãªtre initialisÃ©e avant lâ€™appel La mÃ©thode DOIT assigner une valeur au paramÃ¨tre out UtilisÃ© principalement pour retourner plusieurs valeurs dâ€™une mÃ©thode Le mot-clÃ© out doit apparaÃ®tre Ã  la dÃ©finition ET Ã  lâ€™appel Syntaxe public static void CalculerStatistiques(int[] nombres, out double moyenne, out int maximum) { // La mÃ©thode DOIT assigner des valeurs Ã  moyenne et maximum moyenne = ...; maximum = ...; } // Appel double moy; int max; CalculerStatistiques(tableau, out moy, out max); Exemple : Retourner plusieurs valeurs using System; class Programme { public static void CalculerRectangle(double longueur, double largeur, out double aire, out double perimetre) { aire = longueur * largeur; perimetre = 2 * (longueur + largeur); } static void Main() { double surfaceResultat; double perimetreResultat; CalculerRectangle(5.0, 3.0, out surfaceResultat, out perimetreResultat); Console.WriteLine($\"Aire: {surfaceResultat} mÂ²\"); Console.WriteLine($\"PÃ©rimÃ¨tre: {perimetreResultat} m\"); } } Sortie :\nAire: 15 mÂ²\rPÃ©rimÃ¨tre: 16 m DÃ©claration inline (C# 7.0+) Depuis C# 7.0, vous pouvez dÃ©clarer les variables out directement dans lâ€™appel :\nusing System; class Programme { public static void DiviserAvecReste(int dividende, int diviseur, out int quotient, out int reste) { quotient = dividende / diviseur; reste = dividende % diviseur; } static void Main() { // DÃ©claration inline - plus concis! DiviserAvecReste(17, 5, out int q, out int r); Console.WriteLine($\"17 Ã· 5 = {q} reste {r}\"); } } Exemple : Statistiques dâ€™un tableau using System; class Programme { public static void CalculerStatistiques(int[] nombres, out double moyenne, out int minimum, out int maximum) { // Calcul de la somme et moyenne int somme = 0; foreach (int nombre in nombres) { somme += nombre; } moyenne = (double)somme / nombres.Length; // Trouver min et max minimum = nombres[0]; maximum = nombres[0]; foreach (int nombre in nombres) { if (nombre \u003c minimum) minimum = nombre; if (nombre \u003e maximum) maximum = nombre; } } static void Main() { int[] notes = { 85, 92, 78, 95, 88, 76, 90 }; CalculerStatistiques(notes, out double moy, out int min, out int max); Console.WriteLine(\"=== STATISTIQUES DES NOTES ===\"); Console.WriteLine($\"Moyenne: {moy:F2}%\"); Console.WriteLine($\"Note minimale: {min}%\"); Console.WriteLine($\"Note maximale: {max}%\"); } } Exemple : Validation dâ€™entrÃ©e avec TryParse La mÃ©thode TryParse utilise out pour retourner le rÃ©sultat de la conversion :\nusing System; class Programme { static void Main() { Console.Write(\"Entrez votre Ã¢ge: \"); string entree = Console.ReadLine(); // TryParse retourne true si la conversion rÃ©ussit // et met le rÃ©sultat dans la variable 'age' if (int.TryParse(entree, out int age)) { Console.WriteLine($\"Votre Ã¢ge est: {age} ans\"); if (age \u003e= 18) Console.WriteLine(\"Vous Ãªtes majeur\"); else Console.WriteLine(\"Vous Ãªtes mineur\"); } else { Console.WriteLine(\"EntrÃ©e invalide!\"); } } } Exemple : Analyse de chaÃ®ne using System; class Programme { public static bool ExtraireNomPrenom(string nomComplet, out string nom, out string prenom) { string[] parties = nomComplet.Split(' '); if (parties.Length \u003e= 2) { prenom = parties[0]; nom = parties[1]; return true; } else { nom = \"\"; prenom = \"\"; return false; } } static void Main() { string nomComplet = \"Alice Tremblay\"; if (ExtraireNomPrenom(nomComplet, out string n, out string p)) { Console.WriteLine($\"PrÃ©nom: {p}\"); Console.WriteLine($\"Nom: {n}\"); } else { Console.WriteLine(\"Format invalide\"); } } } ParamÃ¨tres optionnels Les paramÃ¨tres optionnels ont des valeurs par dÃ©faut et peuvent Ãªtre omis lors de lâ€™appel.\nRÃ¨gles Les paramÃ¨tres optionnels doivent Ãªtre Ã  la fin de la liste de paramÃ¨tres Vous devez fournir une valeur par dÃ©faut Si omis lors de lâ€™appel, la valeur par dÃ©faut est utilisÃ©e Syntaxe public static void NomMethode(int obligatoire, int optionnel = 10) { // Corps de la mÃ©thode } // Appels possibles NomMethode(5); // optionnel = 10 (valeur par dÃ©faut) NomMethode(5, 20); // optionnel = 20 Exemple : Afficher un message personnalisÃ© using System; class Programme { public static void AfficherBienvenue(string nom, string titre = \"Ã‰tudiant\") { Console.WriteLine($\"Bonjour {titre} {nom}!\"); } static void Main() { AfficherBienvenue(\"Alice\"); // Utilise \"Ã‰tudiant\" par dÃ©faut AfficherBienvenue(\"Bernard\", \"Professeur\"); // Utilise \"Professeur\" AfficherBienvenue(\"Catherine\", \"Directrice\"); } } Sortie :\nBonjour Ã‰tudiant Alice!\rBonjour Professeur Bernard!\rBonjour Directrice Catherine! Exemple : Calcul avec taux par dÃ©faut using System; class Programme { public static double CalculerPrixTotal(double prixBase, double tauxTaxe = 0.15) { return prixBase * (1 + tauxTaxe); } static void Main() { // Utilise le taux par dÃ©faut (15%) double total1 = CalculerPrixTotal(100.00); Console.WriteLine($\"Prix avec taxe par dÃ©faut: {total1:C}\"); // SpÃ©cifie un taux diffÃ©rent double total2 = CalculerPrixTotal(100.00, 0.20); Console.WriteLine($\"Prix avec 20% de taxe: {total2:C}\"); } } Exemple : Affichage formatÃ© using System; class Programme { public static void AfficherLigne(string texte, char caractere = '-', int longueur = 40) { Console.WriteLine(texte); Console.WriteLine(new string(caractere, longueur)); } static void Main() { AfficherLigne(\"Titre 1\"); // - et 40 par dÃ©faut AfficherLigne(\"Titre 2\", '='); // = et 40 AfficherLigne(\"Titre 3\", '*', 30); // * et 30 } } Sortie :\nTitre 1\r----------------------------------------\rTitre 2\r========================================\rTitre 3\r****************************** Surcharge de mÃ©thodes La surcharge (overloading) permet dâ€™avoir plusieurs mÃ©thodes avec le mÃªme nom mais des signatures diffÃ©rentes.\nQuâ€™est-ce quâ€™une signature? La signature dâ€™une mÃ©thode inclut :\nLe nom de la mÃ©thode Le nombre de paramÃ¨tres Le type des paramÃ¨tres Lâ€™ordre des paramÃ¨tres Note : Le type de retour ne fait PAS partie de la signature.\nExemple : Calculer lâ€™aire de diffÃ©rentes formes using System; class Programme { // Aire d'un carrÃ© public static double CalculerAire(double cote) { return cote * cote; } // Aire d'un rectangle public static double CalculerAire(double longueur, double largeur) { return longueur * largeur; } // Aire d'un cercle public static double CalculerAire(double rayon, bool estCercle) { return Math.PI * rayon * rayon; } static void Main() { double aireCarre = CalculerAire(5.0); Console.WriteLine($\"Aire du carrÃ©: {aireCarre:F2} mÂ²\"); double aireRectangle = CalculerAire(5.0, 3.0); Console.WriteLine($\"Aire du rectangle: {aireRectangle:F2} mÂ²\"); double aireCercle = CalculerAire(4.0, true); Console.WriteLine($\"Aire du cercle: {aireCercle:F2} mÂ²\"); } } Exemple : Afficher diffÃ©rents types using System; class Programme { public static void Afficher(int nombre) { Console.WriteLine($\"Nombre entier: {nombre}\"); } public static void Afficher(double nombre) { Console.WriteLine($\"Nombre dÃ©cimal: {nombre:F2}\"); } public static void Afficher(string texte) { Console.WriteLine($\"Texte: {texte}\"); } public static void Afficher(int[] tableau) { Console.Write(\"Tableau: \"); foreach (int n in tableau) { Console.Write($\"{n} \"); } Console.WriteLine(); } static void Main() { Afficher(42); Afficher(3.14159); Afficher(\"Bonjour!\"); Afficher(new int[] { 1, 2, 3, 4, 5 }); } } Exemple : CrÃ©er un message de bienvenue using System; class Programme { // Version simple public static string CreerBienvenue(string nom) { return $\"Bienvenue {nom}!\"; } // Version avec prÃ©nom et nom public static string CreerBienvenue(string prenom, string nom) { return $\"Bienvenue {prenom} {nom}!\"; } // Version avec titre public static string CreerBienvenue(string prenom, string nom, string titre) { return $\"Bienvenue {titre} {prenom} {nom}!\"; } static void Main() { Console.WriteLine(CreerBienvenue(\"Alice\")); Console.WriteLine(CreerBienvenue(\"Alice\", \"Tremblay\")); Console.WriteLine(CreerBienvenue(\"Alice\", \"Tremblay\", \"Dr.\")); } } PortÃ©e des variables La portÃ©e (scope) dâ€™une variable dÃ©termine oÃ¹ elle peut Ãªtre utilisÃ©e dans le code.\nVariables locales Les variables dÃ©clarÃ©es Ã  lâ€™intÃ©rieur dâ€™une mÃ©thode sont locales Ã  cette mÃ©thode.\nusing System; class Programme { public static void Methode1() { int x = 10; // Variable locale Ã  Methode1 Console.WriteLine($\"Dans Methode1: x = {x}\"); } public static void Methode2() { int x = 20; // Variable diffÃ©rente, locale Ã  Methode2 Console.WriteLine($\"Dans Methode2: x = {x}\"); } static void Main() { Methode1(); Methode2(); // Console.WriteLine(x); // ERREUR: x n'existe pas ici } } PortÃ©e de bloc Les variables dÃ©clarÃ©es dans un bloc { } ne sont visibles que dans ce bloc.\nusing System; class Programme { static void Main() { int nombre = 10; if (nombre \u003e 5) { int resultat = nombre * 2; // Variable locale au bloc if Console.WriteLine($\"RÃ©sultat: {resultat}\"); } // Console.WriteLine(resultat); // ERREUR: resultat n'existe plus for (int i = 0; i \u003c 3; i++) // i existe seulement dans le for { Console.WriteLine($\"i = {i}\"); } // Console.WriteLine(i); // ERREUR: i n'existe plus } } Exemple : PortÃ©e et mÃ©thodes using System; class Programme { public static int CalculerCarre(int nombre) { int resultat = nombre * nombre; // Variable locale return resultat; } static void Main() { int valeur = 5; int carre = CalculerCarre(valeur); Console.WriteLine($\"Le carrÃ© de {valeur} est {carre}\"); // Console.WriteLine(resultat); // ERREUR: resultat est local Ã  CalculerCarre } } Bonnes pratiques 1. Nommage des mÃ©thodes Utilisez des verbes qui dÃ©crivent lâ€™action Commencez par une majuscule (convention C#) Soyez descriptif // Bon public static void CalculerMoyenne() public static bool VerifierAge() public static string ObtenirNomComplet() // Ã€ Ã©viter public static void calc() public static bool check() public static string get() 2. Une mÃ©thode = une tÃ¢che Chaque mÃ©thode devrait faire une seule chose et la faire bien.\n// Bon - une mÃ©thode par tÃ¢che public static double CalculerMoyenne(int[] notes) { // Calcule seulement la moyenne } public static void AfficherResultats(double moyenne) { // Affiche seulement les rÃ©sultats } // Moins bon - fait trop de choses public static void CalculerEtAfficher(int[] notes) { // Calcule ET affiche } 3. Limiter le nombre de paramÃ¨tres Si une mÃ©thode a trop de paramÃ¨tres (plus de 4-5), considÃ©rez regrouper les donnÃ©es.\n// Peut devenir difficile Ã  gÃ©rer public static void CreerEtudiant(string nom, string prenom, int age, string adresse, string telephone, string courriel) { // Beaucoup de paramÃ¨tres! } 4. Utiliser des noms de paramÃ¨tres significatifs // Bon public static double CalculerPrixTotal(double prixBase, double tauxTaxe) { return prixBase * (1 + tauxTaxe); } // Moins clair public static double Calculer(double p, double t) { return p * (1 + t); } RÃ©capitulatif : ref vs out Utilisez ref quand : Vous voulez modifier une valeur existante La variable doit Ãªtre initialisÃ©e avant lâ€™appel Vous voulez que les changements affectent la variable originale Utilisez out quand : Vous voulez retourner plusieurs valeurs dâ€™une mÃ©thode La variable nâ€™a pas besoin dâ€™Ãªtre initialisÃ©e avant lâ€™appel La mÃ©thode va crÃ©er/calculer une nouvelle valeur Tableau comparatif Aspect Passage par valeur ref out Initialisation requise Non Oui Non Modifie lâ€™original Non Oui Oui Doit assigner dans mÃ©thode Non Non Oui Usage principal Donner des donnÃ©es Modifier des donnÃ©es Retourner plusieurs valeurs Exercices Exercice 1 : MÃ©thode simple DifficultÃ© : Facile\nCrÃ©ez une mÃ©thode AfficherTableMultiplication qui prend un nombre en paramÃ¨tre et affiche sa table de multiplication de 1 Ã  10.\nExemple de sortie pour le nombre 5 :\n5 x 1 = 5\r5 x 2 = 10\r5 x 3 = 15\r...\r5 x 10 = 50 Exercice 2 : MÃ©thode avec retour DifficultÃ© : Facile\nCrÃ©ez une mÃ©thode EstPair qui prend un nombre entier en paramÃ¨tre et retourne true sâ€™il est pair, false sinon.\nIndice : Un nombre est pair si nombre % 2 == 0\nExercice 3 : MÃ©thode avec plusieurs paramÃ¨tres DifficultÃ© : Facile\nCrÃ©ez une mÃ©thode CalculerMoyenne qui prend trois notes (double) en paramÃ¨tres et retourne leur moyenne.\nExercice 4 : Utilisation de ref DifficultÃ© : Moyenne\nCrÃ©ez une mÃ©thode AugmenterDe10Pourcent qui prend un prix en paramÃ¨tre (ref double) et lâ€™augmente de 10%.\nTestez avec un prix initial de 100.00$ et vÃ©rifiez que la variable originale est bien modifiÃ©e.\nExercice 5 : Utilisation de out - Division DifficultÃ© : Moyenne\nCrÃ©ez une mÃ©thode DiviserEntiers qui prend deux entiers (dividende et diviseur) et retourne le quotient ET le reste en utilisant des paramÃ¨tres out.\nExemple : 17 divisÃ© par 5 donne quotient = 3 et reste = 2\nIndice : Utilisez les opÃ©rateurs / pour le quotient et % pour le reste.\nExercice 6 : Utilisation de out - Statistiques DifficultÃ© : Moyenne\nCrÃ©ez une mÃ©thode AnalyserTableau qui prend un tableau dâ€™entiers et retourne (via out) :\nLa somme de tous les Ã©lÃ©ments La moyenne Le nombre dâ€™Ã©lÃ©ments Testez avec le tableau : {10, 20, 30, 40, 50}\nExercice 7 : ParamÃ¨tres optionnels DifficultÃ© : Moyenne\nCrÃ©ez une mÃ©thode AfficherFacture qui prend :\nLe montant (obligatoire) Le taux de TPS (optionnel, dÃ©faut = 0.05) Le taux de TVQ (optionnel, dÃ©faut = 0.09975) La mÃ©thode calcule et affiche le montant avant taxes, les taxes, et le total.\nExercice 8 : Surcharge de mÃ©thodes DifficultÃ© : Moyenne\nCrÃ©ez trois versions surchargÃ©es dâ€™une mÃ©thode CalculerVolume :\nVolume dâ€™un cube : CalculerVolume(double cote) Volume dâ€™un parallÃ©lÃ©pipÃ¨de : CalculerVolume(double longueur, double largeur, double hauteur) Volume dâ€™un cylindre : CalculerVolume(double rayon, double hauteur, bool estCylindre) Formules :\nCube : cÃ´tÃ©Â³ ParallÃ©lÃ©pipÃ¨de : longueur Ã— largeur Ã— hauteur Cylindre : Ï€ Ã— rayonÂ² Ã— hauteur Exercice 9 : Validation avec TryParse DifficultÃ© : Moyenne\nCrÃ©ez un programme qui demande Ã  lâ€™utilisateur dâ€™entrer un nombre. Utilisez int.TryParse avec un paramÃ¨tre out pour valider lâ€™entrÃ©e. Si lâ€™entrÃ©e est valide, affichez le carrÃ© du nombre. Sinon, affichez un message dâ€™erreur.\nExercice 10 : Calculatrice simple DifficultÃ© : Difficile\nCrÃ©ez les mÃ©thodes suivantes pour une calculatrice :\nAdditionner(double a, double b) - retourne a + b Soustraire(double a, double b) - retourne a - b Multiplier(double a, double b) - retourne a Ã— b Diviser(double a, double b, out bool succes) - retourne a Ã· b et indique si la division a rÃ©ussi (pas de division par zÃ©ro) CrÃ©ez un menu qui permet Ã  lâ€™utilisateur de choisir une opÃ©ration et dâ€™entrer deux nombres.\nExercice 11 : Analyse de texte DifficultÃ© : Difficile\nCrÃ©ez une mÃ©thode AnalyserTexte qui prend une chaÃ®ne de caractÃ¨res et retourne (via out) :\nLe nombre de caractÃ¨res Le nombre de mots Le nombre de voyelles Indice : Utilisez .Split(' ') pour sÃ©parer les mots, et une boucle pour compter les voyelles (a, e, i, o, u).\nExercice 12 : Conversion de tempÃ©rature DifficultÃ© : Difficile\nCrÃ©ez les mÃ©thodes suivantes avec surcharge :\nConvertirTemperature(double celsius) - convertit Celsius â†’ Fahrenheit ConvertirTemperature(double fahrenheit, bool versCelsius) - convertit Fahrenheit â†’ Celsius Puis crÃ©ez une mÃ©thode ConvertirAvecValidation qui utilise un paramÃ¨tre out bool pour indiquer si la tempÃ©rature est physiquement possible (au-dessus du zÃ©ro absolu : -273.15Â°C ou -459.67Â°F).\nFormules :\nC â†’ F : (C Ã— 9/5) + 32 F â†’ C : (F - 32) Ã— 5/9 Conclusion Les mÃ©thodes sont un outil fondamental en programmation. Vous avez appris :\nâœ… Syntaxe de base : Comment crÃ©er et appeler des mÃ©thodes\nâœ… ParamÃ¨tres : Passage par valeur vs passage par rÃ©fÃ©rence\nâœ… ref : Modifier des variables existantes\nâœ… out : Retourner plusieurs valeurs\nâœ… ParamÃ¨tres optionnels : Valeurs par dÃ©faut\nâœ… Surcharge : Plusieurs mÃ©thodes avec le mÃªme nom\nâœ… PortÃ©e : OÃ¹ les variables sont accessibles\nConcepts clÃ©s Ã  retenir Une mÃ©thode = une tÃ¢che : Gardez vos mÃ©thodes simples et ciblÃ©es Nommage clair : Le nom doit dÃ©crire ce que fait la mÃ©thode ref pour modifier, out pour retourner : Choisissez selon votre besoin RÃ©utilisabilitÃ© : Ã‰crivez une fois, utilisez plusieurs fois",
    "description": "Table des matiÃ¨res Introduction Syntaxe de base ParamÃ¨tres de mÃ©thodes ParamÃ¨tres par rÃ©fÃ©rence (ref) ParamÃ¨tres de sortie (out) ParamÃ¨tres optionnels Surcharge de mÃ©thodes PortÃ©e des variables Exercices Introduction Les mÃ©thodes (aussi appelÃ©es fonctions) sont des blocs de code rÃ©utilisables qui effectuent une tÃ¢che spÃ©cifique. Elles permettent de :",
    "tags": [],
    "title": "Les mÃ©thodes en c#",
    "uri": "/420-413/methodes/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "PremiÃ¨re partie 1 : Calculatrice Simple Concepts pratiquÃ©s : Variables, opÃ©rateurs arithmÃ©tiques, types numÃ©riques\nDescription : CrÃ©ez un programme qui demande Ã  lâ€™utilisateur deux nombres et une opÃ©ration (+, -, *, /), puis affiche le rÃ©sultat.\nFonctionnalitÃ©s requises :\nDemander deux nombres dÃ©cimaux Ã  lâ€™utilisateur Demander lâ€™opÃ©ration souhaitÃ©e Effectuer le calcul appropriÃ© Afficher le rÃ©sultat avec 2 dÃ©cimales GÃ©rer la division par zÃ©ro Exemple dâ€™exÃ©cution :\nEntrez le premier nombre : 15.5\rEntrez le deuxiÃ¨me nombre : 3.2\rChoisissez l'opÃ©ration (+, -, *, /) : *\rRÃ©sultat : 15.5 * 3.2 = 49.60 2 : Convertisseur de TempÃ©rature Concepts pratiquÃ©s : Variables, opÃ©rateurs, formules mathÃ©matiques, casting\nDescription : DÃ©veloppez un convertisseur qui transforme une tempÃ©rature de Celsius vers Fahrenheit et Kelvin.\nFonctionnalitÃ©s requises :\nDemander une tempÃ©rature en Celsius Calculer lâ€™Ã©quivalent en Fahrenheit : F = (C Ã— 9/5) + 32 Calculer lâ€™Ã©quivalent en Kelvin : K = C + 273.15 Afficher les trois tempÃ©ratures avec 2 dÃ©cimales Exemple dâ€™exÃ©cution :\nEntrez la tempÃ©rature en Celsius : 25\r25.00Â°C = 77.00Â°F = 298.15K 3 : VÃ©rificateur de Nombre Pair ou Impair Concepts pratiquÃ©s : Variables, opÃ©rateur modulo, structure if/else\nDescription : CrÃ©ez un programme qui dÃ©termine si un nombre entier est pair ou impair.\nFonctionnalitÃ©s requises :\nDemander un nombre entier Ã  lâ€™utilisateur Utiliser lâ€™opÃ©rateur modulo (%) pour vÃ©rifier la paritÃ© Afficher si le nombre est pair ou impair Bonus : indiquer si le nombre est positif, nÃ©gatif ou zÃ©ro Exemple dâ€™exÃ©cution :\nEntrez un nombre entier : 42\rLe nombre 42 est pair et positif. 4 : Calculateur dâ€™IMC (Indice de Masse Corporelle) Concepts pratiquÃ©s : Variables, opÃ©rateurs, structures de contrÃ´le if/else if\nDescription : DÃ©veloppez un calculateur dâ€™IMC qui catÃ©gorise le rÃ©sultat selon les normes de santÃ©.\nFonctionnalitÃ©s requises :\nDemander le poids en kg et la taille en mÃ¨tres Calculer lâ€™IMC : IMC = poids / (taille Ã— taille) CatÃ©goriser le rÃ©sultat : Moins de 18.5 : Insuffisance pondÃ©rale 18.5 Ã  24.9 : Poids normal 25 Ã  29.9 : Surpoids 30 ou plus : ObÃ©sitÃ© Afficher lâ€™IMC et la catÃ©gorie Exemple dâ€™exÃ©cution :\nEntrez votre poids (kg) : 70\rEntrez votre taille (m) : 1.75\rVotre IMC est de 22.86 - Poids normal 5 : Jeu du Plus ou Moins Concepts pratiquÃ©s : Variables, Random, boucles while, structures if/else\nDescription : CrÃ©ez un jeu oÃ¹ lâ€™ordinateur choisit un nombre alÃ©atoire entre 1 et 100, et lâ€™utilisateur doit le deviner.\nFonctionnalitÃ©s requises :\nGÃ©nÃ©rer un nombre alÃ©atoire entre 1 et 100 Utiliser une boucle pour permettre plusieurs tentatives Indiquer si la proposition est trop haute ou trop basse Compter le nombre de tentatives Afficher un message de victoire avec le nombre de coups Exemple dâ€™exÃ©cution :\nJ'ai choisi un nombre entre 1 et 100. Devinez !\rVotre proposition : 50\rTrop bas !\rVotre proposition : 75\rTrop haut !\rVotre proposition : 63\rBravo ! Vous avez trouvÃ© en 3 coups ! 6 : Calculateur de Facture avec Pourboire Concepts pratiquÃ©s : Variables, opÃ©rateurs, types dÃ©cimaux, formatage\nDescription : DÃ©veloppez un programme qui calcule le montant total dâ€™une facture incluant taxes et pourboire.\nFonctionnalitÃ©s requises :\nDemander le montant de base de la facture Demander le pourcentage de taxes (ex: 15%) Demander le pourcentage de pourboire (ex: 18%) Calculer le montant des taxes Calculer le montant du pourboire (sur le sous-total avec taxes) Afficher le dÃ©tail complet de la facture Exemple dâ€™exÃ©cution :\nMontant de base : 50.00$\rPourcentage de taxes : 15\rPourcentage de pourboire : 18\r--- Facture dÃ©taillÃ©e ---\rMontant de base : 50.00$\rTaxes (15%) : 7.50$\rSous-total : 57.50$\rPourboire (18%) : 10.35$\rTOTAL Ã€ PAYER : 67.85$ 7 : Validateur de Mot de Passe Concepts pratiquÃ©s : Variables string, opÃ©rateurs logiques, structures if/else, mÃ©thodes de string\nDescription : CrÃ©ez un validateur qui vÃ©rifie si un mot de passe respecte certains critÃ¨res de sÃ©curitÃ©.\nFonctionnalitÃ©s requises :\nDemander un mot de passe Ã  lâ€™utilisateur VÃ©rifier que le mot de passe : Contient au moins 8 caractÃ¨res Contient au moins une majuscule Contient au moins une minuscule Contient au moins un chiffre Afficher si le mot de passe est valide ou non Lister les critÃ¨res non respectÃ©s Exemple dâ€™exÃ©cution :\nEntrez un mot de passe : Hello123\râœ“ Au moins 8 caractÃ¨res\râœ“ Contient une majuscule\râœ“ Contient une minuscule\râœ“ Contient un chiffre\rMot de passe valide ! 8 : ChronomÃ©treur de Temps de RÃ©action Concepts pratiquÃ©s : Variables, Random, DateTime, boucles, opÃ©rateurs de comparaison\nDescription : DÃ©veloppez un mini-jeu qui teste le temps de rÃ©action de lâ€™utilisateur.\nFonctionnalitÃ©s requises :\nAfficher â€œPrÃ©parez-vousâ€¦â€ Attendre un dÃ©lai alÃ©atoire (2 Ã  5 secondes) Afficher â€œMAINTENANT !â€ et enregistrer lâ€™heure Attendre que lâ€™utilisateur appuie sur EntrÃ©e Calculer et afficher le temps de rÃ©action en millisecondes Proposer de rejouer Exemple dâ€™exÃ©cution :\nPrÃ©parez-vous...\rMAINTENANT !\r[utilisateur appuie sur EntrÃ©e]\rVotre temps de rÃ©action : 342 ms\rExcellent !\rVoulez-vous rejouer ? (o/n) 9 : Convertisseur de Devises Concepts pratiquÃ©s : Variables, opÃ©rateurs, switch/case, types dÃ©cimaux\nDescription : CrÃ©ez un convertisseur qui transforme un montant en dollars canadiens vers diffÃ©rentes devises.\nFonctionnalitÃ©s requises :\nDemander un montant en CAD Proposer plusieurs devises (USD, EUR, GBP, JPY) Utiliser un switch pour sÃ©lectionner le taux de change appropriÃ© Calculer et afficher la conversion Utiliser des taux de change rÃ©alistes Exemple dâ€™exÃ©cution :\nMontant en CAD : 100\rChoisissez la devise :\r1. USD (Dollar amÃ©ricain)\r2. EUR (Euro)\r3. GBP (Livre sterling)\r4. JPY (Yen japonais)\rVotre choix : 1\r100.00 CAD = 72.50 USD 10 : Calculateur de Note Finale Concepts pratiquÃ©s : Variables, opÃ©rateurs, structures if/else, moyenne pondÃ©rÃ©e\nDescription : DÃ©veloppez un programme qui calcule la note finale dâ€™un Ã©tudiant selon diffÃ©rents critÃ¨res pondÃ©rÃ©s.\nFonctionnalitÃ©s requises :\nDemander les notes pour : Examens (40% de la note finale) Devoirs (30% de la note finale) Participation (10% de la note finale) final (20% de la note finale) Calculer la note finale pondÃ©rÃ©e DÃ©terminer la cote (A+, A, B+, B, C+, C, D, E) Indiquer si lâ€™Ã©tudiant a rÃ©ussi (60% et plus) Exemple dâ€™exÃ©cution :\nNote des examens (sur 100) : 85\rNote des devoirs (sur 100) : 78\rNote de participation (sur 100) : 92\rNote du final (sur 100) : 88\r--- RÃ©sultat final ---\rNote finale : 84.2 / 100\rCote : A\rStatut : RÃ©ussite 11 : Simulateur de DÃ©s Concepts pratiquÃ©s : Variables, Random, boucles for, opÃ©rateurs\nDescription : CrÃ©ez un simulateur qui lance plusieurs dÃ©s et calcule des statistiques.\nFonctionnalitÃ©s requises :\nDemander le nombre de dÃ©s Ã  lancer (1-10) Demander le nombre de faces par dÃ© (4, 6, 8, 12, 20) Lancer tous les dÃ©s Afficher le rÃ©sultat de chaque dÃ© Calculer et afficher la somme totale Afficher le rÃ©sultat minimum et maximum obtenu Exemple dâ€™exÃ©cution :\nNombre de dÃ©s : 3\rNombre de faces : 6\rLancer des dÃ©s...\rDÃ© 1 : 4\rDÃ© 2 : 6\rDÃ© 3 : 2\rSomme totale : 12\rMinimum : 2\rMaximum : 6 12 : Compteur de Voyelles et Consonnes Concepts pratiquÃ©s : Variables string, boucles foreach, switch/case, opÃ©rateurs\nDescription : DÃ©veloppez un programme qui analyse une phrase et compte les voyelles et consonnes.\nFonctionnalitÃ©s requises :\nDemander une phrase Ã  lâ€™utilisateur Parcourir chaque caractÃ¨re de la phrase Compter les voyelles (a, e, i, o, u, y - majuscules et minuscules) Compter les consonnes Compter les espaces et caractÃ¨res spÃ©ciaux Afficher les statistiques complÃ¨tes Exemple dâ€™exÃ©cution :\nEntrez une phrase : Bonjour le monde!\r--- Analyse ---\rVoyelles : 6\rConsonnes : 8\rEspaces : 2\rAutres caractÃ¨res : 1\rTotal de caractÃ¨res : 17 13 : GÃ©nÃ©rateur de Tables de Multiplication Concepts pratiquÃ©s : Variables, boucles for imbriquÃ©es, opÃ©rateurs, formatage\nDescription : CrÃ©ez un programme qui gÃ©nÃ¨re et affiche des tables de multiplication.\nFonctionnalitÃ©s requises :\nDemander quel nombre de table lâ€™utilisateur veut voir (1-12) Demander jusquâ€™Ã  quel multiplicateur (gÃ©nÃ©ralement 10 ou 12) Utiliser une boucle pour gÃ©nÃ©rer la table Afficher la table de maniÃ¨re formatÃ©e et lisible Bonus : afficher plusieurs tables cÃ´te Ã  cÃ´te Exemple dâ€™exÃ©cution :\nTable de multiplication de : 7\rJusqu'Ã  : 10\r7 x 1 = 7\r7 x 2 = 14\r7 x 3 = 21\r7 x 4 = 28\r7 x 5 = 35\r7 x 6 = 42\r7 x 7 = 49\r7 x 8 = 56\r7 x 9 = 63\r7 x 10 = 70 14 : Calculateur dâ€™Ã‚ge PrÃ©cis Concepts pratiquÃ©s : Variables, DateTime, opÃ©rateurs, structures if/else\nDescription : DÃ©veloppez un programme qui calcule lâ€™Ã¢ge prÃ©cis dâ€™une personne en annÃ©es, mois et jours.\nFonctionnalitÃ©s requises :\nDemander la date de naissance (jour, mois, annÃ©e) Utiliser DateTime pour les calculs Calculer lâ€™Ã¢ge en annÃ©es, mois et jours Calculer le nombre total de jours vÃ©cus Calculer le jour de la semaine de la naissance Afficher le prochain anniversaire Exemple dâ€™exÃ©cution :\nDate de naissance\rJour : 15\rMois : 3\rAnnÃ©e : 2005\rVous avez 20 ans, 10 mois et 15 jours\rTotal de jours vÃ©cus : 7625 jours\rVous Ãªtes nÃ©(e) un mardi\rProchain anniversaire : dans 136 jours 15 : DÃ©tecteur de Nombre Premier Concepts pratiquÃ©s : Variables, boucles for, opÃ©rateurs, structures if/else\nDescription : CrÃ©ez un programme qui dÃ©termine si un nombre est premier et trouve tous les nombres premiers dans une plage.\nFonctionnalitÃ©s requises :\nDemander un nombre Ã  lâ€™utilisateur VÃ©rifier sâ€™il est premier (divisible seulement par 1 et lui-mÃªme) Afficher tous les diviseurs du nombre Option : afficher tous les nombres premiers jusquâ€™Ã  ce nombre Optimiser lâ€™algorithme (vÃ©rifier jusquâ€™Ã  la racine carrÃ©e) Exemple dâ€™exÃ©cution :\nEntrez un nombre : 17\rLe nombre 17 est PREMIER\rDiviseurs : 1, 17\rVoulez-vous voir tous les nombres premiers jusqu'Ã  17 ? (o/n) : o\r2, 3, 5, 7, 11, 13, 17\rTotal : 7 nombres premiers 16 : Simulateur de Distributeur Bancaire Concepts pratiquÃ©s : Variables, switch/case, boucles while, opÃ©rateurs\nDescription : DÃ©veloppez un simulateur de guichet automatique avec un menu et des opÃ©rations bancaires de base.\nFonctionnalitÃ©s requises :\nDÃ©finir un solde initial (ex: 1000$) CrÃ©er un menu avec options : Consulter le solde DÃ©poser de lâ€™argent Retirer de lâ€™argent Quitter VÃ©rifier que les retraits nâ€™excÃ¨dent pas le solde Utiliser une boucle pour rÃ©pÃ©ter le menu Afficher lâ€™historique des transactions Exemple dâ€™exÃ©cution :\n=== Guichet Automatique ===\r1. Consulter le solde\r2. DÃ©poser\r3. Retirer\r4. Quitter\rVotre choix : 3\rMontant Ã  retirer : 50\rRetrait effectuÃ©. Nouveau solde : 950.00$ 17 : Convertisseur Binaire/DÃ©cimal Concepts pratiquÃ©s : Variables, boucles while, opÃ©rateurs, types numÃ©riques\nDescription : CrÃ©ez un convertisseur bidirectionnel entre nombres dÃ©cimaux et binaires.\nFonctionnalitÃ©s requises :\nProposer deux options : DÃ©cimal vers binaire Binaire vers dÃ©cimal Pour dÃ©cimal vers binaire : utiliser la division successive par 2 Pour binaire vers dÃ©cimal : utiliser les puissances de 2 Afficher les Ã©tapes de conversion Valider que lâ€™entrÃ©e binaire contient seulement 0 et 1 Exemple dâ€™exÃ©cution :\n1. DÃ©cimal vers Binaire\r2. Binaire vers DÃ©cimal\rVotre choix : 1\rEntrez un nombre dÃ©cimal : 42\rConversion de 42 en binaire :\r42 Ã· 2 = 21 reste 0\r21 Ã· 2 = 10 reste 1\r10 Ã· 2 = 5 reste 0\r5 Ã· 2 = 2 reste 1\r2 Ã· 2 = 1 reste 0\r1 Ã· 2 = 0 reste 1\rRÃ©sultat : 42 (dÃ©cimal) = 101010 (binaire) 18 : Jeu de Pierre-Papier-Ciseaux Concepts pratiquÃ©s : Variables, Random, switch/case, structures de contrÃ´le, boucles\nDescription : DÃ©veloppez le jeu classique Pierre-Papier-Ciseaux contre lâ€™ordinateur avec score.\nFonctionnalitÃ©s requises :\nCrÃ©er un menu avec les 3 choix possibles GÃ©nÃ©rer un choix alÃ©atoire pour lâ€™ordinateur DÃ©terminer le gagnant selon les rÃ¨gles : Pierre bat Ciseaux Ciseaux bat Papier Papier bat Pierre Tenir un score (victoires, dÃ©faites, Ã©galitÃ©s) Permettre de jouer plusieurs parties Afficher le score final Exemple dâ€™exÃ©cution :\n=== Pierre-Papier-Ciseaux ===\r1. Pierre\r2. Papier\r3. Ciseaux\rVotre choix : 1\rVous : Pierre\rOrdinateur : Ciseaux\rVous gagnez !\rScore - Vous: 1 | Ordi: 0 | Ã‰galitÃ©s: 0\rRejouer ? (o/n) 19 : Calculateur de Moyenne Mobile Concepts pratiquÃ©s : Variables, boucles for, opÃ©rateurs, types numÃ©riques\nDescription : CrÃ©ez un programme qui calcule la moyenne dâ€™une sÃ©rie de nombres entrÃ©s par lâ€™utilisateur.\nFonctionnalitÃ©s requises :\nDemander combien de nombres lâ€™utilisateur veut entrer Utiliser une boucle pour saisir chaque nombre Calculer la moyenne, le minimum et le maximum Calculer lâ€™Ã©cart-type (bonus) Afficher tous les nombres au-dessus et en-dessous de la moyenne Exemple dâ€™exÃ©cution :\nCombien de nombres : 5\rNombre 1 : 12\rNombre 2 : 15\rNombre 3 : 8\rNombre 4 : 20\rNombre 5 : 10\r--- Statistiques ---\rMoyenne : 13.00\rMinimum : 8\rMaximum : 20\rNombres au-dessus de la moyenne : 15, 20\rNombres en-dessous de la moyenne : 12, 8, 10 20 : GÃ©nÃ©rateur de Calendrier Mensuel Concepts pratiquÃ©s : Variables, DateTime, boucles, structures if/else, formatage\nDescription : DÃ©veloppez un programme qui affiche le calendrier dâ€™un mois donnÃ©.\nFonctionnalitÃ©s requises :\nDemander le mois et lâ€™annÃ©e DÃ©terminer le premier jour du mois (lundi, mardi, etc.) Calculer le nombre de jours dans le mois Afficher le calendrier formatÃ© avec les jours de la semaine Mettre en Ã©vidence le jour actuel si câ€™est le mois en cours Bonus : marquer les fins de semaine diffÃ©remment Exemple dâ€™exÃ©cution :\nMois (1-12) : 2\rAnnÃ©e : 2026\rFÃ©vrier 2026\rDim Lun Mar Mer Jeu Ven Sam\r1 2 3 4 5 6 7\r8 9 10 11 12 13 14\r15 16 17 18 19 20 21\r22 23 24 25 26 27 28 s AvancÃ©s Ces s intÃ¨grent tableaux, collections (List, Dictionary), mÃ©thodes et tous les concepts prÃ©cÃ©dents.\n21 : Gestionnaire de Liste de Courses Concepts pratiquÃ©s : List, mÃ©thodes, boucles, switch/case\nDescription : CrÃ©ez une application complÃ¨te pour gÃ©rer une liste de courses avec ajout, suppression et affichage.\nFonctionnalitÃ©s requises :\nCrÃ©er une List pour stocker les articles Menu avec options : Ajouter un article Supprimer un article Afficher la liste Rechercher un article Vider la liste Compter les articles Quitter CrÃ©er des mÃ©thodes pour chaque fonctionnalitÃ© Ã‰viter les doublons Trier la liste alphabÃ©tiquement (option) Structure suggÃ©rÃ©e :\nstatic List\u003cstring\u003e listeDesCourses = new List\u003cstring\u003e(); static void AjouterArticle() static void SupprimerArticle() static void AfficherListe() static void RechercherArticle() Exemple dâ€™exÃ©cution :\n=== Liste de Courses ===\r1. Ajouter un article\r2. Supprimer un article\r3. Afficher la liste\r4. Rechercher un article\r5. Vider la liste\r6. Quitter\rChoix : 1\rArticle Ã  ajouter : Lait\rArticle ajoutÃ© ! Total : 1 article(s) 22 : Carnet dâ€™Adresses Concepts pratiquÃ©s : Dictionary, mÃ©thodes, structures (ou classes), collections\nDescription : DÃ©veloppez un carnet dâ€™adresses qui stocke nom, tÃ©lÃ©phone et courriel de plusieurs contacts.\nFonctionnalitÃ©s requises :\nUtiliser un Dictionary\u003cstring, Contact\u003e (nom comme clÃ©) CrÃ©er une structure Contact avec propriÃ©tÃ©s : Nom TÃ©lÃ©phone Courriel MÃ©thodes pour : Ajouter un contact Modifier un contact Supprimer un contact Rechercher un contact Afficher tous les contacts Afficher les contacts par ordre alphabÃ©tique Structure suggÃ©rÃ©e :\nstruct Contact { public string Nom; public string Telephone; public string Courriel; } static Dictionary\u003cstring, Contact\u003e carnet = new Dictionary\u003cstring, Contact\u003e(); static void AjouterContact() static Contact RechercherContact(string nom) Exemple dâ€™exÃ©cution :\n=== Carnet d'Adresses ===\r1. Ajouter un contact\r2. Rechercher\r3. Afficher tous\r4. Quitter\rChoix : 1\rNom : Jean Tremblay\rTÃ©lÃ©phone : 514-555-1234\rCourriel : jean@email.com\rContact ajoutÃ© ! 23 : Analyseur de Texte AvancÃ© Concepts pratiquÃ©s : Tableaux, string methods, Dictionary, mÃ©thodes, LINQ\nDescription : CrÃ©ez un analyseur qui effectue des statistiques dÃ©taillÃ©es sur un texte.\nFonctionnalitÃ©s requises :\nDemander un texte Ã  lâ€™utilisateur (plusieurs phrases) CrÃ©er des mÃ©thodes pour : Compter les mots Compter les phrases Calculer la longueur moyenne des mots Trouver le mot le plus long Compter la frÃ©quence de chaque mot (Dictionary) Afficher les 5 mots les plus frÃ©quents Ignorer la ponctuation et la casse pour le comptage MÃ©thodes suggÃ©rÃ©es :\nstatic int CompterMots(string texte) static int CompterPhrases(string texte) static double LongueurMoyenneMots(string texte) static string TrouverMotLePlusLong(string texte) static Dictionary\u003cstring, int\u003e CompterFrequenceMots(string texte) static void AfficherTopMots(Dictionary\u003cstring, int\u003e frequences, int top) Exemple dâ€™exÃ©cution :\nEntrez votre texte :\rLe chat est sur le tapis. Le chat dort.\r--- Analyse ---\rNombre de mots : 9\rNombre de phrases : 2\rLongueur moyenne des mots : 3.33 lettres\rMot le plus long : tapis (5 lettres)\rMots les plus frÃ©quents :\r1. le (3 fois)\r2. chat (2 fois)\r3. est (1 fois)\r4. sur (1 fois)\r5. tapis (1 fois) 24 : Jeu du Pendu Concepts pratiquÃ©s : Tableaux char, List, mÃ©thodes, string manipulation, Random\nDescription : DÃ©veloppez le jeu classique du pendu avec une banque de mots et gestion des vies.\nFonctionnalitÃ©s requises :\nCrÃ©er un tableau de mots Ã  deviner Choisir un mot alÃ©atoirement Utiliser un tableau de char pour le mot masquÃ© GÃ©rer une List pour les lettres dÃ©jÃ  proposÃ©es Compter les erreurs (maximum 6) CrÃ©er des mÃ©thodes pour : Afficher le mot masquÃ© VÃ©rifier si une lettre est dans le mot Afficher le dessin du pendu selon les erreurs VÃ©rifier si le jeu est gagnÃ©/perdu MÃ©thodes suggÃ©rÃ©es :\nstatic string[] banqueDeMots = { \"programmation\", \"ordinateur\", \"clavier\" }; static List\u003cchar\u003e lettresProposees = new List\u003cchar\u003e(); static string ChoisirMotAleatoire() static void AfficherMotMasque(string mot) static bool VerifierLettre(string mot, char lettre) static void DessinerPendu(int erreurs) static bool EstMotTrouve(string mot) Exemple dâ€™exÃ©cution :\n=== Jeu du Pendu ===\rMot Ã  deviner : _ _ _ _ _ _ _ _ _ _ _ (11 lettres)\rErreurs : 0/6\rProposez une lettre : e\rBien jouÃ© !\rMot : _ _ _ _ _ _ _ _ _ _ e 25 : Gestionnaire de Notes dâ€™Ã‰tudiants Concepts pratiquÃ©s : Dictionary, List, mÃ©thodes, structures/classes, calculs statistiques\nDescription : CrÃ©ez un systÃ¨me complet pour gÃ©rer les notes de plusieurs Ã©tudiants dans plusieurs matiÃ¨res.\nFonctionnalitÃ©s requises :\nUtiliser un Dictionary\u003cstring, Etudiant\u003e CrÃ©er une classe/struct Etudiant avec : Nom Dictionary\u003cstring, double\u003e pour les notes par matiÃ¨re MÃ©thodes pour : Ajouter un Ã©tudiant Ajouter une note pour une matiÃ¨re Calculer la moyenne dâ€™un Ã©tudiant Calculer la moyenne de classe pour une matiÃ¨re Afficher le bulletin dâ€™un Ã©tudiant Trouver le meilleur Ã©tudiant Afficher les statistiques gÃ©nÃ©rales Structure suggÃ©rÃ©e :\nclass Etudiant { public string Nom { get; set; } public Dictionary\u003cstring, double\u003e Notes { get; set; } public double CalculerMoyenne() public void AfficherBulletin() } static Dictionary\u003cstring, Etudiant\u003e etudiants = new Dictionary\u003cstring, Etudiant\u003e(); static void AjouterEtudiant() static void AjouterNote() static double CalculerMoyenneClasse(string matiere) Exemple dâ€™exÃ©cution :\n=== Gestionnaire de Notes ===\r1. Ajouter Ã©tudiant\r2. Ajouter note\r3. Bulletin Ã©tudiant\r4. Statistiques classe\r5. Quitter\rChoix : 3\rNom de l'Ã©tudiant : Marie Dubois\r--- Bulletin de Marie Dubois ---\rMathÃ©matiques : 85\rFranÃ§ais : 92\rSciences : 78\rMoyenne gÃ©nÃ©rale : 85.0 26 : SystÃ¨me de Playlist Musicale Concepts pratiquÃ©s : List, mÃ©thodes, Random, manipulation de listes\nDescription : DÃ©veloppez un gestionnaire de playlist musicale avec lecture alÃ©atoire et rÃ©pÃ©tition.\nFonctionnalitÃ©s requises :\nCrÃ©er une List pour stocker les chansons MÃ©thodes pour : Ajouter une chanson Supprimer une chanson Afficher toute la playlist Lire la playlist en ordre Lire en mode alÃ©atoire (shuffle) Rechercher une chanson DÃ©placer une chanson (changer lâ€™ordre) Afficher le nombre total de chansons Vider la playlist Simuler la lecture avec un compteur de chansons jouÃ©es MÃ©thodes suggÃ©rÃ©es :\nstatic List\u003cstring\u003e playlist = new List\u003cstring\u003e(); static Random rand = new Random(); static void AjouterChanson() static void SupprimerChanson() static void AfficherPlaylist() static void LireEnOrdre() static void LireAleatoire() static void DeplacerChanson(int indexDepart, int indexArrivee) Exemple dâ€™exÃ©cution :\n=== Gestionnaire de Playlist ===\r1. Ajouter chanson\r2. Supprimer chanson\r3. Afficher playlist\r4. Lire en ordre\r5. Lire alÃ©atoire\r6. Quitter\rChoix : 3\r--- Ma Playlist (4 chansons) ---\r1. Bohemian Rhapsody - Queen\r2. Imagine - John Lennon\r3. Hotel California - Eagles\r4. Stairway to Heaven - Led Zeppelin\rChoix : 5\rMode lecture alÃ©atoire activÃ©...\râ™ª Lecture : Hotel California - Eagles\râ™ª Lecture : Bohemian Rhapsody - Queen\râ™ª Lecture : Stairway to Heaven - Led Zeppelin\râ™ª Lecture : Imagine - John Lennon\rPlaylist terminÃ©e ! 27 : GÃ©nÃ©rateur et Analyseur de Statistiques Concepts pratiquÃ©s : Tableaux, mÃ©thodes mathÃ©matiques, Random, tri, calculs statistiques\nDescription : CrÃ©ez un programme qui gÃ©nÃ¨re des donnÃ©es alÃ©atoires et effectue des analyses statistiques complÃ¨tes.\nFonctionnalitÃ©s requises :\nGÃ©nÃ©rer un tableau de N nombres alÃ©atoires (10-100) CrÃ©er des mÃ©thodes pour calculer : Moyenne MÃ©diane (valeur centrale aprÃ¨s tri) Mode (valeur la plus frÃ©quente) Ã‰cart-type Minimum et maximum Premier et troisiÃ¨me quartile Afficher un histogramme simple en console CrÃ©er une mÃ©thode pour trier le tableau MÃ©thodes suggÃ©rÃ©es :\nstatic double[] GenererDonnees(int taille, int min, int max) static double CalculerMoyenne(double[] donnees) static double CalculerMediane(double[] donnees) static double CalculerMode(double[] donnees) static double CalculerEcartType(double[] donnees) static void AfficherHistogramme(double[] donnees) static double[] TrierTableau(double[] donnees) Exemple dâ€™exÃ©cution :\nGÃ©nÃ©ration de 20 nombres entre 1 et 100...\rDonnÃ©es gÃ©nÃ©rÃ©es : 45, 23, 78, 45, 12, ...\r--- Statistiques ---\rMoyenne : 48.5\rMÃ©diane : 46.0\rMode : 45 (apparaÃ®t 3 fois)\rÃ‰cart-type : 24.3\rMin : 12\rMax : 98\rPremier quartile : 28.5\rTroisiÃ¨me quartile : 71.0\r--- Histogramme ---\r0-20: *** (3)\r21-40: ***** (5)\r41-60: ******* (7)\r61-80: **** (4)\r81-100: * (1) 28 : Simulateur de Loto et Statistiques Concepts pratiquÃ©s : Tableaux, List, Random, mÃ©thodes, comparaison\nDescription : CrÃ©ez un simulateur de loterie qui gÃ©nÃ¨re des numÃ©ros et vÃ©rifie les gains.\nFonctionnalitÃ©s requises :\nDemander Ã  lâ€™utilisateur de choisir 6 numÃ©ros entre 1 et 49 GÃ©nÃ©rer un tirage alÃ©atoire de 6 numÃ©ros (sans rÃ©pÃ©tition) Comparer les numÃ©ros du joueur avec le tirage Calculer le gain selon le nombre de numÃ©ros correspondants : 6 numÃ©ros : Jackpot (1 000 000$) 5 numÃ©ros : 10 000$ 4 numÃ©ros : 500$ 3 numÃ©ros : 20$ 2 numÃ©ros : 5$ MÃ©thodes pour : GÃ©nÃ©rer des numÃ©ros alÃ©atoires uniques Valider les choix de lâ€™utilisateur (pas de doublons, dans la plage) Comparer deux listes de numÃ©ros Calculer le gain Afficher les statistiques aprÃ¨s plusieurs parties MÃ©thodes suggÃ©rÃ©es :\nstatic int[] numeros_joueur = new int[6]; static int[] numeros_gagnants = new int[6]; static void ChoisirNumeros() static int[] GenererTirage() static int CompterNumerosCorrespondants() static double CalculerGain(int correspondants) static bool ContiendreNumero(int[] tableau, int numero) static void TrierTableau(int[] tableau) Exemple dâ€™exÃ©cution :\n=== Simulateur de Loto 6/49 ===\rChoisissez 6 numÃ©ros entre 1 et 49 :\rNumÃ©ro 1 : 7\rNumÃ©ro 2 : 14\rNumÃ©ro 3 : 21\rNumÃ©ro 4 : 28\rNumÃ©ro 5 : 35\rNumÃ©ro 6 : 42\rVos numÃ©ros : 7, 14, 21, 28, 35, 42\rTirage en cours...\rNumÃ©ros gagnants : 12, 14, 23, 28, 35, 41\rNumÃ©ros correspondants : 14, 28, 35\rTotal : 3 numÃ©ros\rVous gagnez : 20.00$ !\rRejouer ? (o/n) 29 : Gestion dâ€™Inventaire de Magasin Concepts pratiquÃ©s : Tableaux parallÃ¨les, mÃ©thodes, recherche, tri\nDescription : CrÃ©ez un systÃ¨me de gestion dâ€™inventaire avec produits, quantitÃ©s et prix en utilisant des tableaux parallÃ¨les.\nFonctionnalitÃ©s requises :\nUtiliser 4 tableaux parallÃ¨les pour stocker : string[] codes (codes produits) string[] noms (noms des produits) int[] quantites (quantitÃ©s en stock) double[] prix (prix unitaires) MÃ©thodes pour : Ajouter un produit Modifier un produit Supprimer un produit Rechercher par code ou nom Afficher tous les produits Afficher les produits en rupture de stock (quantitÃ© = 0) Calculer la valeur totale de lâ€™inventaire Vendre un produit (diminuer quantitÃ©) Trier les produits par prix MÃ©thodes suggÃ©rÃ©es :\nstatic string[] codes = new string[100]; static string[] noms = new string[100]; static int[] quantites = new int[100]; static double[] prix = new double[100]; static int nombreProduits = 0; static void AjouterProduit() static int RechercherParCode(string code) static void AfficherInventaire() static void ProduitsEnRupture() static double ValeurTotaleInventaire() static void VendreProduit(string code, int quantite) Exemple dâ€™exÃ©cution :\n=== Gestion d'Inventaire ===\r1. Ajouter produit\r2. Vendre\r3. Rechercher\r4. Afficher inventaire\r5. Ruptures de stock\r6. Valeur totale\r7. Quitter\rChoix : 4\r--- Inventaire (3 produits) ---\rCode Nom QtÃ© Prix Valeur\rP001 Clavier USB 25 29.99 749.75\rP002 Souris sans fil 12 19.99 239.88\rP003 Ã‰cran 24\" 0 299.99 0.00\rTotal produits : 3\rValeur totale : 989.63$ 30 : Convertisseur dâ€™UnitÃ©s Universel Concepts pratiquÃ©s : Dictionary, mÃ©thodes, conversions, switch/case\nDescription : DÃ©veloppez un convertisseur complet pour diffÃ©rentes catÃ©gories dâ€™unitÃ©s.\nFonctionnalitÃ©s requises :\nCatÃ©gories de conversion : Longueur (m, km, cm, mm, miles, yards, pieds, pouces) Poids (kg, g, mg, livres, onces) TempÃ©rature (Celsius, Fahrenheit, Kelvin) Volume (L, mL, gallons, pintes) Utiliser des Dictionary pour les facteurs de conversion MÃ©thodes pour chaque catÃ©gorie de conversion Menu pour sÃ©lectionner la catÃ©gorie Afficher toutes les conversions possibles depuis lâ€™unitÃ© saisie MÃ©thodes suggÃ©rÃ©es :\nstatic Dictionary\u003cstring, double\u003e facteursLongueur = new Dictionary\u003cstring, double\u003e { { \"m\", 1 }, { \"km\", 1000 }, { \"cm\", 0.01 }, // etc. }; static double ConvertirLongueur(double valeur, string deUnite, string versUnite) static double ConvertirTemperature(double valeur, string deUnite, string versUnite) static void AfficherToutesConversions(double valeur, string unite, string categorie) Exemple dâ€™exÃ©cution :\n=== Convertisseur d'UnitÃ©s ===\r1. Longueur\r2. Poids\r3. TempÃ©rature\r4. Volume\r5. Quitter\rChoix : 1\rValeur : 5\rUnitÃ© de dÃ©part : m\r5 mÃ¨tres =\r- 5000 millimÃ¨tres\r- 500 centimÃ¨tres\r- 0.005 kilomÃ¨tres\r- 5.468 yards\r- 16.404 pieds\r- 196.850 pouces\r- 0.003 miles 31 : GÃ©nÃ©rateur de Mots de Passe SÃ©curisÃ©s Concepts pratiquÃ©s : Tableaux, Random, mÃ©thodes, string manipulation, validation\nDescription : CrÃ©ez un gÃ©nÃ©rateur de mots de passe avec options de personnalisation et vÃ©rification de force.\nFonctionnalitÃ©s requises :\nOptions configurables : Longueur du mot de passe (8-50 caractÃ¨res) Inclure majuscules (A-Z) Inclure minuscules (a-z) Inclure chiffres (0-9) Inclure symboles (!@#$%^\u0026*) GÃ©nÃ©rer plusieurs mots de passe Ã  la fois CrÃ©er une mÃ©thode pour Ã©valuer la force du mot de passe (faible/moyen/fort) Ã‰viter les caractÃ¨res ambigus (0/O, 1/l/I) Permettre de sauvegarder les mots de passe gÃ©nÃ©rÃ©s dans une List MÃ©thodes suggÃ©rÃ©es :\nstatic char[] majuscules = \"ABCDEFGHJKLMNPQRSTUVWXYZ\".ToCharArray(); static char[] minuscules = \"abcdefghijkmnopqrstuvwxyz\".ToCharArray(); static char[] chiffres = \"23456789\".ToCharArray(); static char[] symboles = \"!@#$%^\u0026*\".ToCharArray(); static string GenererMotDePasse(int longueur, bool maj, bool min, bool chif, bool sym) static string EvaluerForce(string motDePasse) static List\u003cchar\u003e CreerPoolDeCaracteres(bool maj, bool min, bool chif, bool sym) Exemple dâ€™exÃ©cution :\n=== GÃ©nÃ©rateur de Mots de Passe ===\rLongueur (8-50) : 16\rInclure majuscules ? (o/n) : o\rInclure minuscules ? (o/n) : o\rInclure chiffres ? (o/n) : o\rInclure symboles ? (o/n) : o\rMots de passe gÃ©nÃ©rÃ©s :\r1. kT8#mPq2nL9@wXz5 (Force: Fort)\r2. Vy3$bNr7hK4\u0026qWm2 (Force: Fort)\r3. Jp6%dGt8sM3!xZn9 (Force: Fort)\rGÃ©nÃ©rer d'autres mots de passe ? (o/n) 32 : Calculatrice de PrÃªt HypothÃ©caire Concepts pratiquÃ©s : MÃ©thodes, calculs financiers, tableaux, formatage, boucles\nDescription : DÃ©veloppez une calculatrice qui calcule les paiements mensuels et gÃ©nÃ¨re un tableau dâ€™amortissement.\nFonctionnalitÃ©s requises :\nDemander : Montant du prÃªt Taux dâ€™intÃ©rÃªt annuel DurÃ©e en annÃ©es Calculer le paiement mensuel avec la formule : M = P[r(1+r)^n]/[(1+r)^n-1] M = paiement mensuel P = montant principal r = taux mensuel n = nombre de paiements Utiliser des tableaux pour stocker : double[] paiements double[] interets double[] capital double[] soldes Afficher les premiers et derniers mois Calculer le total des intÃ©rÃªts payÃ©s Option : comparer diffÃ©rents scÃ©narios MÃ©thodes suggÃ©rÃ©es :\nstatic double CalculerPaiementMensuel(double montant, double tauxAnnuel, int annees) static void GenererTableauAmortissement(double montant, double tauxAnnuel, int annees, out double[] paiements, out double[] interets, out double[] capital, out double[] soldes) static void AfficherLigneTableau(int mois, double paiement, double interet, double cap, double solde) static double CalculerTotalInterets(double[] interets) Exemple dâ€™exÃ©cution :\n=== Calculatrice HypothÃ©caire ===\rMontant du prÃªt : 300000\rTaux d'intÃ©rÃªt annuel (%) : 3.5\rDurÃ©e (annÃ©es) : 25\rPaiement mensuel : 1498.88$\rTotal des intÃ©rÃªts : 149664.00$\rTotal Ã  rembourser : 449664.00$\r--- Tableau d'amortissement (premiers mois) ---\rMois Paiement IntÃ©rÃªts Capital Solde\r1 1498.88 875.00 623.88 299376.12\r2 1498.88 873.18 625.70 298750.42\r3 1498.88 871.36 627.52 298122.90\r4 1498.88 869.53 629.35 297493.55\r5 1498.88 867.69 631.19 296862.36\r...\rAfficher tous les mois ? (o/n) 33 : SystÃ¨me de Quiz avec Banque de Questions Concepts pratiquÃ©s : Tableaux parallÃ¨les, mÃ©thodes, Random, score, validation\nDescription : CrÃ©ez un systÃ¨me de quiz interactif avec diffÃ©rentes catÃ©gories et suivi des rÃ©sultats.\nFonctionnalitÃ©s requises :\nUtiliser des tableaux parallÃ¨les pour stocker les questions : string[] questions string[] choixA, choixB, choixC, choixD int[] bonnesReponses (1-4) string[] categories CrÃ©er une banque dâ€™au moins 15 questions MÃ©thodes pour : SÃ©lectionner des questions alÃ©atoires Afficher une question avec ses choix Valider la rÃ©ponse de lâ€™utilisateur Calculer le score Afficher les statistiques finales Filtrer par catÃ©gorie MÃ©langer lâ€™ordre des questions EmpÃªcher les doublons dans un mÃªme quiz MÃ©thodes suggÃ©rÃ©es :\nstatic string[] questions = new string[50]; static string[] choixA = new string[50]; static string[] choixB = new string[50]; static string[] choixC = new string[50]; static string[] choixD = new string[50]; static int[] bonnesReponses = new int[50]; static string[] categories = new string[50]; static int nombreQuestions = 0; static void InitialiserQuestions() static int[] SelectionnerQuestionsAleatoires(int nombre) static void AfficherQuestion(int index) static bool VerifierReponse(int index, int reponseUtilisateur) static void AfficherResultats(int bonnes, int totales) Exemple dâ€™exÃ©cution :\n=== Quiz C# ===\rCatÃ©gories disponibles :\r1. Programmation C#\r2. MathÃ©matiques\r3. Culture gÃ©nÃ©rale\r4. Toutes catÃ©gories\rChoix : 1\rNombre de questions : 5\r--- Question 1/5 ---\rCatÃ©gorie : Programmation C#\rQuel est le rÃ©sultat de 5 % 2 en C# ?\r1. 2.5\r2. 1\r3. 2\r4. 0\rVotre rÃ©ponse : 2\râœ“ Correct !\rScore actuel : 1/1\r--- Question 2/5 ---\r...\r=== RÃ©sultats finaux ===\rBonnes rÃ©ponses : 4/5 (80%)\rMauvaises rÃ©ponses : 1/5 (20%)\rNote : B+ 34 : Simulateur de Compte Bancaire avec Historique Concepts pratiquÃ©s : List, mÃ©thodes, DateTime, formatage, validation\nDescription : DÃ©veloppez un simulateur de compte bancaire complet avec transactions et historique dÃ©taillÃ©.\nFonctionnalitÃ©s requises :\nVariables globales pour le compte : string numeroCompte string titulaire double solde Utiliser des List pour lâ€™historique : List typesTransactions (Depot, Retrait, etc.) List montants List dates List soldesApres List descriptions MÃ©thodes pour : DÃ©poser (ajouter Ã  lâ€™historique) Retirer (avec vÃ©rification solde, ajouter Ã  lâ€™historique) Afficher lâ€™historique complet Afficher les dÃ©pÃ´ts seulement Afficher les retraits seulement Calculer solde moyen sur une pÃ©riode Afficher les transactions dâ€™un mois spÃ©cifique Calculer des intÃ©rÃªts mensuels (bonus) MÃ©thodes suggÃ©rÃ©es :\nstatic string numeroCompte = \"12345-67890\"; static string titulaire = \"Jean Tremblay\"; static double solde = 1000.00; static List\u003cstring\u003e typesTransactions = new List\u003cstring\u003e(); static List\u003cdouble\u003e montants = new List\u003cdouble\u003e(); static List\u003cDateTime\u003e dates = new List\u003cDateTime\u003e(); static List\u003cdouble\u003e soldesApres = new List\u003cdouble\u003e(); static List\u003cstring\u003e descriptions = new List\u003cstring\u003e(); static bool Deposer(double montant, string description) static bool Retirer(double montant, string description) static void AfficherHistorique() static void FiltrerParType(string type) static void FiltrerParMois(int mois, int annee) static double CalculerSoldeMoyen() Exemple dâ€™exÃ©cution :\n=== Compte Bancaire - Jean Tremblay ===\rNumÃ©ro : 12345-67890\rSolde actuel : 1500.00$\r1. DÃ©poser\r2. Retirer\r3. Historique complet\r4. Voir dÃ©pÃ´ts uniquement\r5. Voir retraits uniquement\r6. Statistiques\r7. Quitter\rChoix : 3\r--- Historique des transactions ---\rDate Type Montant Solde Description\r2026-01-15 10:30 DÃ©pÃ´t +500.00 1500.00 Paie janvier\r2026-01-16 14:20 Retrait -50.00 1450.00 Ã‰picerie\r2026-01-18 09:15 DÃ©pÃ´t +200.00 1650.00 Remboursement\r2026-01-20 16:45 Retrait -150.00 1500.00 Facture tÃ©lÃ©phone\rTotal transactions : 4\rSolde moyen : 1537.50$ 35 : Simulateur de Machine Ã  Sous (Slot Machine) Concepts pratiquÃ©s : Random, tableaux, mÃ©thodes, boucles, calculs\nDescription : CrÃ©ez un jeu de machine Ã  sous avec 3 rouleaux et diffÃ©rentes combinaisons gagnantes.\nFonctionnalitÃ©s requises :\nDÃ©finir les symboles possibles : ğŸ’ (Cerise), ğŸ‹ (Citron), ğŸŠ (Orange), ğŸ‡ (Raisin), ğŸ’ (Diamant), 7ï¸âƒ£ (Sept) Utiliser un tableau de string pour les symboles Variables pour : Solde du joueur Mise actuelle MÃ©thodes pour : Tourner les 3 rouleaux (gÃ©nÃ©rer 3 symboles alÃ©atoires) Afficher les rouleaux VÃ©rifier les combinaisons gagnantes : 3 identiques : Jackpot (mise Ã— 50) 3 Sept : Super Jackpot (mise Ã— 100) 2 identiques : Petit gain (mise Ã— 5) 3 Diamants : Gros gain (mise Ã— 25) Calculer les gains GÃ©rer le solde du joueur Historique des gains et pertes MÃ©thodes suggÃ©rÃ©es :\nstatic string[] symboles = { \"ğŸ’\", \"ğŸ‹\", \"ğŸŠ\", \"ğŸ‡\", \"ğŸ’\", \"7ï¸âƒ£\" }; static Random rand = new Random(); static double solde = 100.00; static string[] TournerRouleaux() static void AfficherRouleaux(string[] rouleaux) static double CalculerGain(string[] rouleaux, double mise) static bool VerifierTroisIdentiques(string[] rouleaux) static bool VerifierDeuxIdentiques(string[] rouleaux) Exemple dâ€™exÃ©cution :\n=== Machine Ã  Sous ğŸ° ===\rSolde : 100.00$\rSymboles :\rğŸ’ Cerise ğŸ‹ Citron ğŸŠ Orange\rğŸ‡ Raisin ğŸ’ Diamant 7ï¸âƒ£ Sept\rEntrez votre mise (min 1$, max 10$) : 5\râ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”\râ”‚ ğŸ’ â”‚ ğŸ’ â”‚ ğŸ‹ â”‚\râ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜\rDeux cerises ! Vous gagnez 25.00$ !\rSolde : 120.00$\rRejouer ? (o/n) : o\rEntrez votre mise : 10\râ”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”\râ”‚ ğŸ’ â”‚ ğŸ’ â”‚ ğŸ’ â”‚\râ””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜\rJACKPOT ! Trois diamants !\rVous gagnez 250.00$ !\rSolde : 360.00$ 36 : Planificateur de TÃ¢ches avec PrioritÃ©s Concepts pratiquÃ©s : List, tableaux parallÃ¨les, mÃ©thodes, tri, DateTime\nDescription : DÃ©veloppez une application de gestion de tÃ¢ches avec catÃ©gories, prioritÃ©s et Ã©chÃ©ances.\nFonctionnalitÃ©s requises :\nUtiliser des List pour stocker les tÃ¢ches : List titres List descriptions List priorites (1=Basse, 2=Moyenne, 3=Haute, 4=Urgente) List categories List datesEcheance List statuts (1=Ã€ faire, 2=En cours, 3=TerminÃ©e) MÃ©thodes pour : Ajouter une tÃ¢che Modifier une tÃ¢che Marquer comme terminÃ©e Supprimer une tÃ¢che Afficher toutes les tÃ¢ches Filtrer par prioritÃ©, catÃ©gorie ou statut Trier par date dâ€™Ã©chÃ©ance ou prioritÃ© Afficher les tÃ¢ches en retard Statistiques (nombre par statut, taux de complÃ©tion) MÃ©thodes suggÃ©rÃ©es :\nstatic List\u003cstring\u003e titres = new List\u003cstring\u003e(); static List\u003cstring\u003e descriptions = new List\u003cstring\u003e(); static List\u003cint\u003e priorites = new List\u003cint\u003e(); static List\u003cstring\u003e categories = new List\u003cstring\u003e(); static List\u003cDateTime\u003e datesEcheance = new List\u003cDateTime\u003e(); static List\u003cint\u003e statuts = new List\u003cint\u003e(); static void AjouterTache() static void AfficherTaches() static void FiltrerParPriorite(int priorite) static void AfficherTachesEnRetard() static void AfficherStatistiques() static string ObtenirNomPriorite(int priorite) static string ObtenirNomStatut(int statut) static int CalculerJoursRestants(DateTime dateEcheance) Exemple dâ€™exÃ©cution :\n=== Planificateur de TÃ¢ches ===\r1. Ajouter tÃ¢che\r2. Voir toutes les tÃ¢ches\r3. Filtrer\r4. Marquer terminÃ©e\r5. TÃ¢ches en retard\r6. Statistiques\r7. Quitter\rChoix : 2\r--- Toutes les tÃ¢ches ---\r[1] [URGENTE] Terminer C# - CatÃ©gorie: Ã‰cole\rÃ‰chÃ©ance: 2026-02-05 (6 jours) - Statut: En cours\rDescription: ComplÃ©ter les 40 mini-s\r[2] [HAUTE] RÃ©viser pour examen - CatÃ©gorie: Ã‰cole\rÃ‰chÃ©ance: 2026-02-10 (11 jours) - Statut: Ã€ faire\rDescription: RÃ©viser chapitres 1 Ã  5\r[3] [MOYENNE] Faire l'Ã©picerie - CatÃ©gorie: Personnel\rÃ‰chÃ©ance: 2026-02-01 (2 jours) - Statut: Ã€ faire\rDescription: Acheter fruits et lÃ©gumes 37 : SystÃ¨me de Sondage et Analyse Concepts pratiquÃ©s : List, Dictionary, mÃ©thodes, statistiques, pourcentages\nDescription : CrÃ©ez un systÃ¨me pour crÃ©er des sondages, collecter des rÃ©ponses et analyser les rÃ©sultats.\nFonctionnalitÃ©s requises :\nUtiliser des List pour stocker les questions : List questions List option1, option2, option3, option4 Utiliser Dictionary\u003cstring, int\u003e pour compter les rÃ©ponses ClÃ© : â€œQuestion1_Option1â€, â€œQuestion1_Option2â€, etc. MÃ©thodes pour : CrÃ©er un sondage (ajouter questions et options) RÃ©pondre au sondage (un participant Ã  la fois) Afficher les rÃ©sultats : Calculer les pourcentages pour chaque option Afficher un graphique en mode texte (barres ASCII) Trouver lâ€™option la plus populaire Calculer le nombre total de participants RÃ©initialiser les rÃ©sultats MÃ©thodes suggÃ©rÃ©es :\nstatic List\u003cstring\u003e questions = new List\u003cstring\u003e(); static List\u003cstring\u003e option1 = new List\u003cstring\u003e(); static List\u003cstring\u003e option2 = new List\u003cstring\u003e(); static List\u003cstring\u003e option3 = new List\u003cstring\u003e(); static List\u003cstring\u003e option4 = new List\u003cstring\u003e(); static Dictionary\u003cstring, int\u003e reponses = new Dictionary\u003cstring, int\u003e(); static int nombreParticipants = 0; static void CreerSondage() static void RemplirSondage() static void AnalyserResultats() static void AfficherGraphique(int questionIndex) static double CalculerPourcentage(int nbReponses, int total) static string GenererBarre(double pourcentage) Exemple dâ€™exÃ©cution :\n=== SystÃ¨me de Sondage ===\r1. CrÃ©er sondage\r2. RÃ©pondre Ã  un sondage\r3. Voir rÃ©sultats\r4. Quitter\rChoix : 3\rSondage : Satisfaction des Ã©tudiants\rParticipants : 20\rQuestion 1: Comment Ã©valuez-vous la qualitÃ© du cours ?\rExcellent : â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 45% (9 rÃ©ponses)\rBon : â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 30% (6 rÃ©ponses)\rMoyen : â–ˆâ–ˆâ–ˆâ–ˆ 15% (3 rÃ©ponses)\rFaible : â–ˆâ–ˆ 10% (2 rÃ©ponses)\rQuestion 2: Recommanderiez-vous ce cours ?\rOui, certainement : â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 60% (12 rÃ©ponses)\rProbablement oui : â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 25% (5 rÃ©ponses)\rProbablement non : â–ˆâ–ˆâ–ˆâ–ˆ 10% (2 rÃ©ponses)\rNon, certainement pas : â–ˆâ–ˆ 5% (1 rÃ©ponse)\rOption la plus populaire : \"Oui, certainement\" 38 : Jeu de MÃ©moire avec Cartes Concepts pratiquÃ©s : Tableaux, List, mÃ©thodes, Random, logique de jeu, temps\nDescription : DÃ©veloppez un jeu de mÃ©moire simplifiÃ© oÃ¹ il faut retrouver les paires de nombres identiques.\nFonctionnalitÃ©s requises :\nCrÃ©er un tableau de 16 cartes (8 paires de nombres de 1 Ã  8) Utiliser des tableaux pour gÃ©rer lâ€™Ã©tat : int[] valeurs (contient les nombres 1-8 en double) bool[] estVisible (true si carte retournÃ©e) bool[] estTrouvee (true si paire trouvÃ©e) MÃ©langer les cartes au dÃ©but MÃ©thodes pour : Initialiser et mÃ©langer les cartes Afficher toutes les cartes (cachÃ©es sauf visibles et trouvÃ©es) Retourner une carte (par sa position 0-15) VÃ©rifier si deux cartes forment une paire Compter le nombre de coups VÃ©rifier si toutes les paires sont trouvÃ©es EmpÃªcher de retourner plus de 2 cartes Ã  la fois Afficher le temps Ã©coulÃ© MÃ©thodes suggÃ©rÃ©es :\nstatic int[] valeurs = new int[16]; static bool[] estVisible = new bool[16]; static bool[] estTrouvee = new bool[16]; static Random rand = new Random(); static int nombreCoups = 0; static void InitialiserJeu() static void MelangerCartes() static void AfficherCartes() static void RetournerCarte(int position) static bool VerifierPaire(int pos1, int pos2) static bool JeuTermine() Exemple dâ€™exÃ©cution :\n=== Jeu de MÃ©moire ğŸ´ ===\rPositions : 0 Ã  15\r0 1 2 3 4 5 6 7\r[?] [?] [?] [?] [?] [?] [?] [?]\r8 9 10 11 12 13 14 15\r[?] [?] [?] [?] [?] [?] [?] [?]\rPaires trouvÃ©es : 0/8\rCoups : 0\rPremiÃ¨re carte (0-15) : 3\r0 1 2 3 4 5 6 7\r[?] [?] [?] [5] [?] [?] [?] [?]\rDeuxiÃ¨me carte (0-15) : 11\r0 1 2 3 4 5 6 7\r[?] [?] [?] [5] [?] [?] [?] [?]\r8 9 10 11 12 13 14 15\r[?] [?] [?] [3] [?] [?] [?] [?]\rPas de paire ! Cartes cachÃ©es...\rPaires trouvÃ©es : 0/8\rCoups : 1 39 : Calculatrice de Budget Personnel Concepts pratiquÃ©s : List, Dictionary, mÃ©thodes, calculs financiers, DateTime\nDescription : CrÃ©ez une application complÃ¨te pour gÃ©rer un budget personnel avec revenus, dÃ©penses et analyse.\nFonctionnalitÃ©s requises :\nUtiliser des List pour stocker les transactions : List types (â€œRevenuâ€ ou â€œDepenseâ€) List montants List categories (Salaire, Ã‰picerie, Transport, Loisirs, etc.) List dates List descriptions Utiliser un Dictionary\u003cstring, double\u003e pour les budgets prÃ©vus par catÃ©gorie MÃ©thodes pour : Ajouter revenu/dÃ©pense Afficher le rÃ©sumÃ© mensuel Calculer solde actuel Afficher dÃ©penses par catÃ©gorie (avec pourcentages) Comparer budget prÃ©vu vs rÃ©el Afficher graphique en barres des dÃ©penses Identifier les plus grosses dÃ©penses Filtrer par mois MÃ©thodes suggÃ©rÃ©es :\nstatic List\u003cstring\u003e types = new List\u003cstring\u003e(); static List\u003cdouble\u003e montants = new List\u003cdouble\u003e(); static List\u003cstring\u003e categories = new List\u003cstring\u003e(); static List\u003cDateTime\u003e dates = new List\u003cDateTime\u003e(); static List\u003cstring\u003e descriptions = new List\u003cstring\u003e(); static Dictionary\u003cstring, double\u003e budgetsPrevus = new Dictionary\u003cstring, double\u003e(); static void AjouterTransaction() static double CalculerRevenusMois(int mois, int annee) static double CalculerDepensesMois(int mois, int annee) static Dictionary\u003cstring, double\u003e DepensesParCategorie(int mois, int annee) static void AfficherResumeMensuel(int mois, int annee) static void AfficherGraphiqueDepenses(Dictionary\u003cstring, double\u003e depenses, double total) static string GenererBarre(double pourcentage) Exemple dâ€™exÃ©cution :\n=== Budget Personnel - Janvier 2026 ===\rRevenus totaux : 3200.00$\rDÃ©penses totales : 2450.00$\rSolde : +750.00$\r--- DÃ©penses par catÃ©gorie ---\rLoyer : 1200.00$ (49%) â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\rÃ‰picerie : 450.00$ (18%) â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\rTransport : 200.00$ (8%) â–ˆâ–ˆâ–ˆ\rLoisirs : 300.00$ (12%) â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\rTÃ©lÃ©phone : 80.00$ (3%) â–ˆ\rAutres : 220.00$ (9%) â–ˆâ–ˆâ–ˆâ–ˆ\r--- Budget prÃ©vu vs rÃ©el ---\rÃ‰picerie : 450$ / 500$ (sous budget de 50$)\rTransport : 200$ / 150$ (dÃ©passement de 50$)\rLoisirs : 300$ / 250$ (dÃ©passement de 50$)\rPlus grosses dÃ©penses du mois :\r1. Loyer - 1200.00$ (2026-01-01)\r2. Ã‰picerie Costco - 180.00$ (2026-01-15)\r3. Restaurant - 120.00$ (2026-01-20) 40 : Simulateur de Tournoi Sportif (Round-Robin) Concepts pratiquÃ©s : List, tableaux parallÃ¨les, mÃ©thodes, algorithmes, tri\nDescription : DÃ©veloppez un systÃ¨me pour gÃ©rer un tournoi sportif oÃ¹ chaque Ã©quipe affronte toutes les autres.\nFonctionnalitÃ©s requises :\nUtiliser des tableaux/listes parallÃ¨les pour stocker les Ã©quipes : List nomsEquipes List victoires List defaites List nulles List pointsMarques List pointsEncaisses CrÃ©er des List pour les matches : List equipe1 List equipe2 List score1 List score2 List rondes MÃ©thodes pour : Ajouter des Ã©quipes GÃ©nÃ©rer le calendrier complet (round-robin) Simuler un match (alÃ©atoire ou saisie manuelle) Enregistrer les rÃ©sultats Mettre Ã  jour les classements Afficher le classement actuel Afficher les matches Ã  venir Calculer les statistiques (diffÃ©rentiel de points, taux de victoire) MÃ©thodes suggÃ©rÃ©es :\nstatic List\u003cstring\u003e nomsEquipes = new List\u003cstring\u003e(); static List\u003cint\u003e victoires = new List\u003cint\u003e(); static List\u003cint\u003e defaites = new List\u003cint\u003e(); static List\u003cint\u003e nulles = new List\u003cint\u003e(); static List\u003cint\u003e pointsMarques = new List\u003cint\u003e(); static List\u003cint\u003e pointsEncaisses = new List\u003cint\u003e(); static List\u003cstring\u003e matchEquipe1 = new List\u003cstring\u003e(); static List\u003cstring\u003e matchEquipe2 = new List\u003cstring\u003e(); static List\u003cint\u003e matchScore1 = new List\u003cint\u003e(); static List\u003cint\u003e matchScore2 = new List\u003cint\u003e(); static void AjouterEquipe(string nom) static void GenererCalendrier() static void SimulerMatch(int indexMatch) static void EnregistrerResultat(string equipe1, string equipe2, int score1, int score2) static void AfficherClassement() static int TrouverIndexEquipe(string nom) static double CalculerTauxVictoire(int index) static int CalculerPoints(int index) // Victoire = 3pts, Nulle = 1pt Exemple dâ€™exÃ©cution :\n=== Tournoi de Hockey Round-Robin ===\rParticipants : 6 Ã©quipes\rNombre total de matches : 15\r--- Classement aprÃ¨s ronde 3 ---\rPos Ã‰quipe Pts V N D PM PE Diff\r1 Canadiens MTL 9 3 0 0 15 8 +7\r2 Maple Leafs TOR 6 2 0 1 12 10 +2\r3 Bruins BOS 6 2 0 1 10 9 +1\r4 Senators OTT 3 1 0 2 9 11 -2\r5 Sabres BUF 3 1 0 2 7 10 -3\r6 Red Wings DET 0 0 0 3 5 10 -5\r--- Prochaine ronde (Ronde 4) ---\rCanadiens MTL vs Senators OTT\rMaple Leafs TOR vs Red Wings DET\rBruins BOS vs Sabres BUF\r1. Simuler ronde suivante\r2. Entrer rÃ©sultats manuellement\r3. Afficher statistiques\r4. Quitter Bonnes Pratiques Nommage : Utilisez des noms descriptifs (camelCase pour variables, PascalCase pour mÃ©thodes) Commentaires : Expliquez les parties complexes de votre code Validation : VÃ©rifiez toujours les entrÃ©es utilisateur Gestion dâ€™erreurs : Utilisez try-catch pour les opÃ©rations risquÃ©es ModularitÃ© : Divisez votre code en mÃ©thodes rÃ©utilisables Tests : Testez tous les scÃ©narios possibles DeuxiÃ¨me partie 1. Le Distributeur de Breuvages Intelligent ScÃ©nario : Vous gÃ©rez une machine qui vend du CafÃ© (2.50$), du ThÃ© (2.00$) et du Chocolat (3.00$). Exigences : CrÃ©er une mÃ©thode AfficherMenu() qui montre les choix et les prix. Lâ€™utilisateur entre un montant. Si le montant est insuffisant, redemander de lâ€™argent ou annuler. Calculer la monnaie Ã  rendre en utilisant le moins de piÃ¨ces possible (piÃ¨ces de 2$, 1$, 0.25$, 0.10$). Notions : while, switch, opÃ©rateurs modulo %. 2. Analyseur de DonnÃ©es MÃ©tÃ©o (Statistiques) ScÃ©nario : Un centre mÃ©tÃ©o a besoin dâ€™analyser les tempÃ©ratures dâ€™une semaine. Exigences : Stocker 7 valeurs double dans un tableau. MÃ©thode CalculerMoyenne(double[] temp) : retourne la moyenne. MÃ©thode TrouverExtremes(double[] temp) : affiche la plus haute et la plus basse sans Max() ou Min(). Afficher un histogramme simple dans la console (ex: 22Â°C = **********). Notions : Boucles for, algorithme de recherche de minimum/maximum. 3. Gestionnaire de Contacts avec Recherche Floue ScÃ©nario : Une liste de noms simple mais interactive. Exigences : Utiliser une List\u003cstring\u003e pour stocker les noms. Menu : 1. Ajouter, 2. Supprimer par nom, 3. Rechercher, 4. Quitter. La recherche doit afficher tous les noms qui contiennent la lettre ou la syllabe saisie (ex: â€œanâ€ trouve â€œAndrÃ©â€ et â€œChantalâ€). Notions : List\u003cT\u003e, mÃ©thode string.Contains(), foreach. 4. SystÃ¨me de Facturation de Magasin ScÃ©nario : Calculer le total dâ€™un panier dâ€™achat avec taxes. Exigences : Lâ€™utilisateur saisit des prix jusquâ€™Ã  ce quâ€™il entre -1. GÃ©rer un tableau de â€œrabaisâ€ : si le prix \u003e 100$, appliquer 10% de rÃ©duction avant taxes. MÃ©thode CalculerTaxes(double total) : retourne le montant des taxes (TPS 5%, TVQ 9.975%). Notions : Accumulateurs, constantes, mÃ©thodes de calcul. 5. Jeu du Pendu : Le DÃ©fi des CaractÃ¨res ScÃ©nario : Deviner un mot cachÃ© lettre par lettre. Exigences : Le mot secret est un char[]. CrÃ©er un second char[] rempli de _. Lâ€™Ã©tudiant doit comparer la lettre saisie avec chaque caractÃ¨re du mot secret. GÃ©rer un maximum de 6 erreurs. Notions : Tableaux de caractÃ¨res, manipulation dâ€™index. 6. Bureau de Scrutin Virtuel ScÃ©nario : Compter les votes pour une Ã©lection Ã  3 candidats. Exigences : Utiliser un Dictionary\u003cstring, int\u003e oÃ¹ la clÃ© est le nom du candidat. Boucle de vote : lâ€™utilisateur tape le nom ou le numÃ©ro du candidat. MÃ©thode AfficherGagnant() : parcourt le dictionnaire pour trouver la valeur la plus Ã©levÃ©e. Notions : Dictionnaires, itÃ©ration sur paires ClÃ©/Valeur. 7. Validateur de ComplexitÃ© de Mot de Passe ScÃ©nario : SÃ©curiser la crÃ©ation de compte. Exigences : CrÃ©er une mÃ©thode VerifierForce(string mdp) qui retourne un score de 1 Ã  5. CritÃ¨res : +1 si \u003e 8 car., +1 si majuscule, +1 si chiffre, +1 si symbole (#, !, $), +1 si \u003e 12 car. Utiliser des boucles pour inspecter chaque caractÃ¨re. Notions : char.IsUpper, char.IsDigit, char.IsPunctuation. 8. Convertisseur de Devises avec Historique ScÃ©nario : Changer de lâ€™argent et garder une trace des transactions. Exigences : Utiliser un tableau double[] fixe pour les taux (USD, EUR, GBP). Chaque conversion effectuÃ©e est ajoutÃ©e sous forme de chaÃ®ne (ex: â€œ10 CAD -\u003e 7 USDâ€) dans une List\u003cstring\u003e. Option pour afficher lâ€™historique complet Ã  la fin. Notions : Tableaux, listes, formatage de texte. 9. Bataille Navale : Tactique 1D ScÃ©nario : DÃ©truire des navires cachÃ©s dans une ligne de 10 cases. Exigences : Un tableau bool[10] oÃ¹ 3 cases alÃ©atoires sont true. Lâ€™utilisateur choisit un index. Afficher â€œTouchÃ©â€ ou â€œÃ€ lâ€™eauâ€. Le jeu sâ€™arrÃªte quand les 3 bateaux sont coulÃ©s. Notions : Random, do-while, tableaux de boolÃ©ens. 10. Calculateur de Moyennes Multidimensionnel ScÃ©nario : GÃ©rer les notes dâ€™une classe de 3 Ã©tudiants ayant chacun 4 examens. Exigences : DÃ©clarer un double[3, 4]. Remplir le tableau via des saisies utilisateur. MÃ©thode MoyenneEtudiant(int index) : calcule la moyenne dâ€™une ligne. MÃ©thode MoyenneExamen(int index) : calcule la moyenne dâ€™une colonne. Notions : Tableaux 2D, boucles imbriquÃ©es. 11. Simulateur de File dâ€™Attente (Banque) ScÃ©nario : GÃ©rer lâ€™ordre de passage des clients. Exigences : Une List\u003cstring\u003e simulant une file dâ€™attente. Options : â€œNouveau clientâ€, â€œServir prochainâ€, â€œAfficher fileâ€. â€œServir prochainâ€ doit afficher le nom et retirer le premier Ã©lÃ©ment (index 0). Notions : List.Add(), List.RemoveAt(). 12. CrÃ©ateur de Deck de Cartes et MÃ©langeur ScÃ©nario : GÃ©nÃ©rer et mÃ©langer un jeu de 52 cartes. Exigences : Deux tableaux : couleurs (Pique, Coeurâ€¦) et valeurs (As, 2, 3â€¦). GÃ©nÃ©rer les 52 combinaisons dans une List\u003cstring\u003e. Algorithme de mÃ©lange : Ã©changer chaque carte avec une autre Ã  un index alÃ©atoire. Notions : Boucles imbriquÃ©es, algorithme de permutation (Swap). 13. DÃ©tecteur de Palindromes et de â€œMirroringâ€ ScÃ©nario : Analyser si un mot est identique Ã  lâ€™envers. Exigences : Saisir un mot. CrÃ©er une mÃ©thode EstPalindrome(string mot). Inverser la chaÃ®ne manuellement dans un tableau de caractÃ¨res pour comparer. Ne pas utiliser Array.Reverse(). Notions : Boucle for dÃ©croissante, manipulation de chaÃ®nes. 14. Inventaire de Magasin (Tableaux DentelÃ©s) ScÃ©nario : GÃ©rer des rayons de diffÃ©rentes tailles. Exigences : Un tableau dentelÃ© string[][] rayons = new string[3][]. Rayon 1 : 2 produits, Rayon 2 : 5 produits, Rayon 3 : 3 produits. Lâ€™utilisateur peut modifier un produit en spÃ©cifiant [rayon, index]. Notions : Jagged Arrays, gestion des limites de tableaux. 15. Le Juste Prix (Multi-joueurs) ScÃ©nario : Deviner un prix secret gÃ©nÃ©rÃ© alÃ©atoirement. Exigences : Le programme gÃ©nÃ¨re un nombre entre 1 et 1000. Plusieurs joueurs entrent leur nom. Chacun joue Ã  tour de rÃ´le. Le programme indique â€œCâ€™est plus !â€ ou â€œCâ€™est moins !â€. Notions : Random, listes de noms, boucle de jeu. 16. SystÃ¨me de Login avec Blocage ScÃ©nario : SÃ©curiser lâ€™accÃ¨s Ã  une console. Exigences : Stocker les utilisateurs/mots de passe dans deux tableaux parallÃ¨les ou un dictionnaire. Lâ€™utilisateur a 3 tentatives. AprÃ¨s 3 erreurs, le programme se verrouille (utilise Thread.Sleep pour simuler une attente). Notions : Compteurs, conditions logiques, sÃ©curitÃ© de base. 17. Analyseur de Texte : Compteur de Mots ScÃ©nario : Analyser la structure dâ€™un paragraphe. Exigences : Lâ€™utilisateur entre un long texte. Compter le nombre de mots (dÃ©limitÃ©s par des espaces). Compter lâ€™occurrence dâ€™une lettre spÃ©cifique demandÃ©e Ã  lâ€™utilisateur. Notions : string.Split(), foreach, compteurs. 18. Calculateur dâ€™IMC Professionnel ScÃ©nario : SantÃ© et nutrition. Exigences : Saisir le nom, le poids et la taille de plusieurs patients. Calculer lâ€™IMC ($poids / taille^2$). MÃ©thode InterpreterIMC(double imc) : retourne une chaÃ®ne (Maigreur, Normal, ObÃ¨se). Notions : MÃ©thodes de retour, formules mathÃ©matiques. 19. Gestionnaire de TÃ¢ches avec PrioritÃ© ScÃ©nario : Une To-Do List intelligente. Exigences : Stocker les tÃ¢ches dans une liste. Lâ€™utilisateur peut ajouter une tÃ¢che avec un niveau dâ€™importance (Haute, Moyenne, Basse). Afficher les tÃ¢ches filtrÃ©es manuellement : dâ€™abord toutes les â€œHauteâ€, ensuite les autres. Notions : Filtrage par boucles, comparaisons de chaÃ®nes. 20. Le CarrÃ© Magique (Validation de Grille) ScÃ©nario : VÃ©rifier si une grille 3x3 est un carrÃ© magique. Exigences : Lâ€™utilisateur entre 9 nombres dans un tableau int[3, 3]. Le programme doit calculer la somme de chaque ligne, chaque colonne et des deux diagonales. Si toutes les sommes sont Ã©gales, câ€™est un carrÃ© magique ! Notions : Algorithmique avancÃ©e sur tableaux 2D.",
    "description": "PremiÃ¨re partie 1 : Calculatrice Simple Concepts pratiquÃ©s : Variables, opÃ©rateurs arithmÃ©tiques, types numÃ©riques\nDescription : CrÃ©ez un programme qui demande Ã  lâ€™utilisateur deux nombres et une opÃ©ration (+, -, *, /), puis affiche le rÃ©sultat.\nFonctionnalitÃ©s requises :\nDemander deux nombres dÃ©cimaux Ã  lâ€™utilisateur Demander lâ€™opÃ©ration souhaitÃ©e Effectuer le calcul appropriÃ© Afficher le rÃ©sultat avec 2 dÃ©cimales GÃ©rer la division par zÃ©ro Exemple dâ€™exÃ©cution :",
    "tags": [],
    "title": "SÃ©rie d'exercices 1",
    "uri": "/420-413/serie_exos_1/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Table des matiÃ¨res Introduction Ã  la POO Les Classes et les Objets Les Attributs (Champs) Les PropriÃ©tÃ©s (Properties) Lâ€™Encapsulation Les MÃ©thodes Les Constructeurs Lâ€™HÃ©ritage Le Polymorphisme 1. Introduction Ã  la POO 1.1 Quâ€™est-ce que la Programmation OrientÃ©e Objet ? La Programmation OrientÃ©e Objet (POO) est un paradigme de programmation qui organise le code autour du concept dâ€™objets plutÃ´t que de fonctions et de logique. Un objet combine des donnÃ©es (ce quâ€™il possÃ¨de) et des comportements (ce quâ€™il peut faire).\nğŸŒ Analogie du monde rÃ©el Pensez Ã  une voiture dans le monde rÃ©el :\nDonnÃ©es : couleur, marque, modÃ¨le, vitesse actuelle, niveau dâ€™essence Comportements : dÃ©marrer, accÃ©lÃ©rer, freiner, tourner, klaxonner En POO, nous modÃ©lisons ces concepts du monde rÃ©el dans notre code.\n1.2 Pourquoi utiliser la POO ? Avant la POO (Programmation procÃ©durale) :\n// Variables dispersÃ©es string voitureMarque = \"Toyota\"; string voitureModele = \"Camry\"; int voitureVitesse = 0; // Fonctions sÃ©parÃ©es void DemarrerVoiture() { /* ... */ } void AccelererVoiture(int vitesse) { /* ... */ } Avec la POO :\n// Tout est regroupÃ© logiquement class Voiture { string marque; string modele; int vitesse; void Demarrer() { /* ... */ } void Accelerer(int increment) { /* ... */ } } Avantages de la POO :\nOrganisation : Le code est structurÃ© et logique RÃ©utilisabilitÃ© : Les classes peuvent Ãªtre rÃ©utilisÃ©es MaintenabilitÃ© : Plus facile Ã  maintenir et modifier ModularitÃ© : Chaque classe a une responsabilitÃ© claire Abstraction : Cache la complexitÃ© interne 1.3 Les 4 Piliers Fondamentaux de la POO 1ï¸âƒ£ Encapsulation Regrouper les donnÃ©es et les mÃ©thodes ensemble, et contrÃ´ler lâ€™accÃ¨s aux donnÃ©es.\nExemple concret : Un compte bancaire\nVous ne pouvez pas modifier directement le solde Vous devez passer par des mÃ©thodes (dÃ©poser, retirer) Cela protÃ¨ge lâ€™intÃ©gritÃ© des donnÃ©es 2ï¸âƒ£ HÃ©ritage CrÃ©er de nouvelles classes basÃ©es sur des classes existantes.\nExemple concret : VÃ©hicules\nClasse de base : Vehicule (propriÃ©tÃ©s communes : marque, modÃ¨le) Classes dÃ©rivÃ©es : Voiture, Moto, Camion (ajoutent leurs spÃ©cificitÃ©s) 3ï¸âƒ£ Polymorphisme Utiliser une mÃªme interface pour des types diffÃ©rents.\nExemple concret : Animaux\nTous peuvent â€œÃ©mettre un sonâ€ Le chien aboie, le chat miaule, lâ€™oiseau chante MÃªme mÃ©thode, comportements diffÃ©rents 4ï¸âƒ£ Abstraction Montrer seulement lâ€™essentiel, cacher les dÃ©tails complexes.\nExemple concret : Conduire une voiture\nVous utilisez le volant, les pÃ©dales Vous nâ€™avez pas besoin de comprendre le moteur interne 2. Les Classes et les Objets 2.1 Quâ€™est-ce quâ€™une Classe ? Une classe est un plan ou un modÃ¨le qui dÃ©finit la structure et le comportement dâ€™objets. Câ€™est comme un plan dâ€™architecte pour construire une maison.\nMÃ©taphore :\nUne classe est comme un moule Ã  biscuits ğŸª Les objets sont les biscuits crÃ©Ã©s avec ce moule Tous les biscuits ont la mÃªme forme (structure), mais peuvent avoir des diffÃ©rences (valeurs) 2.2 Quâ€™est-ce quâ€™un Objet ? Un objet est une instance dâ€™une classe. Câ€™est une entitÃ© concrÃ¨te crÃ©Ã©e Ã  partir du modÃ¨le dÃ©fini par la classe.\n2.3 Anatomie dâ€™une Classe // DÃ©claration d'une classe public class Personne { // ========================================== // ATTRIBUTS (CHAMPS) - Ce que l'objet possÃ¨de // ========================================== private string nom; private string prenom; private int age; // ========================================== // PROPRIÃ‰TÃ‰S - Interface contrÃ´lÃ©e pour les attributs // ========================================== public string Nom { get { return nom; } set { nom = value; } } // ========================================== // CONSTRUCTEUR - Comment crÃ©er l'objet // ========================================== public Personne(string nom, string prenom, int age) { this.nom = nom; this.prenom = prenom; this.age = age; } // ========================================== // MÃ‰THODES - Ce que l'objet peut faire // ========================================== public void SePresenter() { Console.WriteLine($\"Bonjour, je suis {prenom} {nom}, {age} ans.\"); } } 2.4 CrÃ©ation et Utilisation dâ€™Objets class Program { static void Main() { // ========================================== // CRÃ‰ATION D'OBJETS (INSTANCIATION) // ========================================== // Syntaxe : Type nomVariable = new Constructeur(); Personne personne1 = new Personne(\"Tremblay\", \"Marie\", 25); Personne personne2 = new Personne(\"Gagnon\", \"Jean\", 30); Personne personne3 = new Personne(\"Roy\", \"Sophie\", 28); // Chaque objet est UNIQUE et INDÃ‰PENDANT // personne1, personne2, personne3 sont 3 objets diffÃ©rents // ========================================== // UTILISATION DES OBJETS // ========================================== personne1.SePresenter(); // Affiche: Bonjour, je suis Marie Tremblay, 25 ans. personne2.SePresenter(); // Affiche: Bonjour, je suis Jean Gagnon, 30 ans. // AccÃ¨s aux propriÃ©tÃ©s Console.WriteLine(personne1.Nom); // Affiche: Tremblay } } 2.5 Comprendre la MÃ©moire : RÃ©fÃ©rence vs Valeur // Les CLASSES sont des types RÃ‰FÃ‰RENCE Personne p1 = new Personne(\"Dubois\", \"Luc\", 35); Personne p2 = p1; // p2 pointe vers le MÃŠME objet que p1 p2.Nom = \"Martin\"; // Modifie l'objet Console.WriteLine(p1.Nom); // Affiche: Martin Console.WriteLine(p2.Nom); // Affiche: Martin // p1 et p2 pointent vers le mÃªme objet en mÃ©moire ! Illustration :\nMÃ©moire:\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ Objet Personne â”‚\râ”‚ Nom: \"Martin\" â”‚ â†â”€â”€ p1 pointe ici\râ”‚ Prenom: \"Luc\" â”‚ â†â”€â”€ p2 pointe ici aussi\râ”‚ Age: 35 â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 3. Les Attributs (Champs) 3.1 DÃ©finition Les attributs (ou champs ou fields) sont des variables dÃ©clarÃ©es directement dans une classe. Ils reprÃ©sentent lâ€™Ã©tat ou les donnÃ©es de lâ€™objet.\n3.2 DÃ©claration des Attributs public class CompteBancaire { // ========================================== // ATTRIBUTS PRIVÃ‰S (convention : prÃ©fixe _) // ========================================== private string _numeroCompte; private string _titulaire; private decimal _solde; private DateTime _dateOuverture; private bool _estActif; // ========================================== // ATTRIBUTS PUBLICS (Ã  Ã©viter gÃ©nÃ©ralement) // ========================================== public int nombreTransactions; // Moins sÃ©curisÃ© } 3.3 Pourquoi des Attributs PrivÃ©s ? âŒ ProblÃ¨me avec des attributs publics :\npublic class CompteBancaire { public decimal solde; // PUBLIC = DANGER ! } // Dans le code utilisateur CompteBancaire compte = new CompteBancaire(); compte.solde = -5000; // âŒ On peut mettre n'importe quoi ! compte.solde = 999999999; // âŒ Aucune validation ! âœ… Solution avec des attributs privÃ©s :\npublic class CompteBancaire { private decimal _solde; // PRIVÃ‰ = PROTÃ‰GÃ‰ public void Deposer(decimal montant) { if (montant \u003e 0) // âœ… Validation { _solde += montant; } } } 3.4 Initialisation des Attributs public class Voiture { // Initialisation lors de la dÃ©claration private string _marque = \"Inconnue\"; private int _annee = 2020; private double _kilometrage = 0.0; private bool _estDemarree = false; // Sans initialisation (valeurs par dÃ©faut) private int _nombrePortes; // 0 par dÃ©faut private string _couleur; // null par dÃ©faut } Valeurs par dÃ©faut en C# :\nint, double, float : 0 bool : false string, objets : null DateTime : 01/01/0001 00:00:00 4. Les PropriÃ©tÃ©s (Properties) 4.1 Quâ€™est-ce quâ€™une PropriÃ©tÃ© ? Une propriÃ©tÃ© est un membre de classe qui fournit un mÃ©canisme flexible pour lire et Ã©crire les valeurs des attributs privÃ©s. Câ€™est lâ€™interface publique pour accÃ©der aux donnÃ©es privÃ©es.\nAnalogie :\nLâ€™attribut privÃ© = Le coffre-fort ğŸ”’ La propriÃ©tÃ© = La porte avec code dâ€™accÃ¨s ğŸšª Le getter = Ouvrir pour voir le contenu ğŸ‘€ Le setter = Ouvrir pour modifier le contenu âœï¸ 4.2 Syntaxe ComplÃ¨te dâ€™une PropriÃ©tÃ© public class Personne { // ========================================== // ATTRIBUT PRIVÃ‰ // ========================================== private int _age; // ========================================== // PROPRIÃ‰TÃ‰ AVEC GET ET SET COMPLETS // ========================================== public int Age { // GETTER - Lit la valeur get { Console.WriteLine(\"Lecture de l'Ã¢ge\"); return _age; } // SETTER - Modifie la valeur set { Console.WriteLine($\"Modification de l'Ã¢ge: {value}\"); // VALIDATION avant d'assigner if (value \u003e= 0 \u0026\u0026 value \u003c= 150) { _age = value; } else { Console.WriteLine(\"Ã‚ge invalide!\"); } } } } // Utilisation Personne p = new Personne(); p.Age = 25; // Appelle le SETTER avec value = 25 int monAge = p.Age; // Appelle le GETTER 4.3 Types de PropriÃ©tÃ©s A) PropriÃ©tÃ© Lecture/Ã‰criture (Get/Set) public class Produit { private string _nom; public string Nom { get { return _nom; } set { _nom = value; } } } B) PropriÃ©tÃ© en Lecture Seule (Get seulement) public class Personne { private DateTime _dateNaissance; // On peut LIRE mais pas MODIFIER de l'extÃ©rieur public DateTime DateNaissance { get { return _dateNaissance; } // Pas de SET = lecture seule } public Personne(DateTime dateNaissance) { _dateNaissance = dateNaissance; // DÃ©fini dans le constructeur } } // Utilisation Personne p = new Personne(new DateTime(1990, 5, 15)); Console.WriteLine(p.DateNaissance); // âœ… OK - Lecture // p.DateNaissance = DateTime.Now; // âŒ ERREUR - Pas de setter! C) PropriÃ©tÃ© en Ã‰criture Seule (Set seulement) - RARE public class CompteSecurise { private string _motDePasse; // On peut Ã‰CRIRE mais pas LIRE (pour la sÃ©curitÃ©) public string MotDePasse { set { _motDePasse = HashPassword(value); } // Pas de GET pour des raisons de sÃ©curitÃ© } private string HashPassword(string password) { // Logique de hachage return password; // SimplifiÃ© } } D) PropriÃ©tÃ© Auto-ImplÃ©mentÃ©e (Raccourci) public class Livre { // ========================================== // PROPRIÃ‰TÃ‰ AUTO-IMPLÃ‰MENTÃ‰E // Le compilateur crÃ©e automatiquement un attribut privÃ© cachÃ© // ========================================== public string Titre { get; set; } public string Auteur { get; set; } public int NombrePages { get; set; } // Ã‰quivalent Ã  : // private string _titre; // public string Titre { get { return _titre; } set { _titre = value; } } } // Utilisation Livre livre = new Livre(); livre.Titre = \"Le Petit Prince\"; livre.Auteur = \"Antoine de Saint-ExupÃ©ry\"; livre.NombrePages = 96; E) PropriÃ©tÃ© avec Logique MÃ©tier public class Rectangle { private double _longueur; private double _largeur; public double Longueur { get { return _longueur; } set { if (value \u003e 0) _longueur = value; else throw new ArgumentException(\"La longueur doit Ãªtre positive\"); } } public double Largeur { get { return _largeur; } set { if (value \u003e 0) _largeur = value; else throw new ArgumentException(\"La largeur doit Ãªtre positive\"); } } // ========================================== // PROPRIÃ‰TÃ‰ CALCULÃ‰E (pas d'attribut associÃ©) // ========================================== public double Aire { get { return _longueur * _largeur; } // Pas de SET - calculÃ©e Ã  chaque fois } public double Perimetre { get { return 2 * (_longueur + _largeur); } } } // Utilisation Rectangle rect = new Rectangle(); rect.Longueur = 5; rect.Largeur = 3; Console.WriteLine($\"Aire: {rect.Aire}\"); // 15 Console.WriteLine($\"PÃ©rimÃ¨tre: {rect.Perimetre}\"); // 16 F) PropriÃ©tÃ© avec AccessibilitÃ© DiffÃ©rente public class CompteBancaire { private decimal _solde; // ========================================== // GET public, SET privÃ© // Tout le monde peut LIRE, seule la classe peut MODIFIER // ========================================== public decimal Solde { get { return _solde; } private set { _solde = value; } // SET PRIVÃ‰ } // MÃ©thodes publiques pour modifier le solde de maniÃ¨re contrÃ´lÃ©e public void Deposer(decimal montant) { if (montant \u003e 0) Solde += montant; // Utilise le setter privÃ© } public bool Retirer(decimal montant) { if (montant \u003e 0 \u0026\u0026 montant \u003c= Solde) { Solde -= montant; // Utilise le setter privÃ© return true; } return false; } } // Utilisation CompteBancaire compte = new CompteBancaire(); Console.WriteLine(compte.Solde); // âœ… OK - Lecture publique // compte.Solde = 1000; // âŒ ERREUR - Set est privÃ© compte.Deposer(1000); // âœ… OK - MÃ©thode publique 4.4 Le Mot-ClÃ© value Dans un setter, le mot-clÃ© value reprÃ©sente la valeur quâ€™on essaie dâ€™assigner.\npublic class Exemple { private int _nombre; public int Nombre { get { return _nombre; } set { // 'value' contient la valeur assignÃ©e Console.WriteLine($\"Valeur reÃ§ue: {value}\"); _nombre = value; } } } // Utilisation Exemple ex = new Exemple(); ex.Nombre = 42; // 'value' vaut 42 dans le setter 4.5 PropriÃ©tÃ©s: Quand Utiliser Quoi ? Situation Type de PropriÃ©tÃ© DonnÃ©es simples sans validation Auto-implÃ©mentÃ©e { get; set; } DonnÃ©es nÃ©cessitant validation PropriÃ©tÃ© complÃ¨te avec logique DonnÃ©es calculÃ©es Get seulement (calculÃ©e) DonnÃ©es dÃ©finies Ã  la crÃ©ation Get seulement + constructeur DonnÃ©es sensibles Get public, Set privÃ© Mot de passe Set seulement (Ã©criture seule) 5. Lâ€™Encapsulation 5.1 DÃ©finition Approfondie Lâ€™encapsulation est le principe qui consiste Ã  :\nRegrouper les donnÃ©es (attributs) et les comportements (mÃ©thodes) dans une classe Cacher les dÃ©tails dâ€™implÃ©mentation internes ContrÃ´ler lâ€™accÃ¨s aux donnÃ©es via une interface publique MÃ©taphore de la voiture :\nVous nâ€™avez pas besoin de comprendre comment fonctionne le moteur (dÃ©tails cachÃ©s) Vous utilisez le volant, les pÃ©dales, le levier de vitesse (interface publique) Le moteur est protÃ©gÃ© sous le capot (encapsulation) 5.2 Modificateurs dâ€™AccÃ¨s Les modificateurs dâ€™accÃ¨s contrÃ´lent QUI peut accÃ©der Ã  quoi.\nTableau Complet des Modificateurs Modificateur AccÃ¨s Usage Typique private Classe uniquement Attributs, mÃ©thodes internes protected Classe + classes dÃ©rivÃ©es MÃ©thodes partagÃ©es avec enfants internal MÃªme assembly (projet) Classes utilitaires internes protected internal Assembly OU dÃ©rivÃ©es Cas spÃ©cifiques public Partout Interface publique, API Exemples DÃ©taillÃ©s public class Voiture { // ========================================== // PRIVATE - Accessible UNIQUEMENT dans cette classe // ========================================== private string _numeroSerie; // DonnÃ©e sensible private int _temperatureMoteur; // DÃ©tail interne private void DemarrerMoteur() // MÃ©thode interne { Console.WriteLine(\"Moteur dÃ©marrÃ©\"); } // ========================================== // PROTECTED - Accessible dans cette classe ET ses dÃ©rivÃ©es // ========================================== protected double _consommationBase; // Les classes enfants peuvent y accÃ©der protected void CalculerConsommation() // MÃ©thode pour les dÃ©rivÃ©es { Console.WriteLine(\"Calcul de la consommation\"); } // ========================================== // PUBLIC - Accessible PARTOUT // ========================================== public string Marque { get; set; } // PropriÃ©tÃ© publique public string Modele { get; set; } public void Demarrer() // MÃ©thode publique (interface) { DemarrerMoteur(); // Appelle la mÃ©thode privÃ©e Console.WriteLine(\"Voiture dÃ©marrÃ©e\"); } public void Accelerer(int vitesse) { // Interface publique qui utilise des dÃ©tails privÃ©s _temperatureMoteur += 10; Console.WriteLine($\"AccÃ©lÃ©ration Ã  {vitesse} km/h\"); } } // Classe dÃ©rivÃ©e public class VoitureElectrique : Voiture { public void ChargerBatterie() { // âœ… OK - AccÃ¨s Ã  protected _consommationBase = 0.15; CalculerConsommation(); // âŒ ERREUR - Pas d'accÃ¨s Ã  private // _numeroSerie = \"123\"; // ERREUR DE COMPILATION // DemarrerMoteur(); // ERREUR DE COMPILATION // âœ… OK - AccÃ¨s Ã  public Marque = \"Tesla\"; Demarrer(); } } // Utilisation externe class Program { static void Main() { Voiture maVoiture = new Voiture(); // âœ… OK - AccÃ¨s aux membres publics maVoiture.Marque = \"Toyota\"; maVoiture.Demarrer(); maVoiture.Accelerer(50); // âŒ ERREUR - Pas d'accÃ¨s aux membres privÃ©s // maVoiture._numeroSerie = \"ABC123\"; // ERREUR // maVoiture.DemarrerMoteur(); // ERREUR // âŒ ERREUR - Pas d'accÃ¨s aux membres protected // maVoiture._consommationBase = 0.10; // ERREUR // maVoiture.CalculerConsommation(); // ERREUR } } 5.3 Exemple Complet : Compte Bancaire Bien EncapsulÃ© public class CompteBancaire { // ========================================== // ATTRIBUTS PRIVÃ‰S - Ã‰tat interne protÃ©gÃ© // ========================================== private string _numeroCompte; private string _titulaire; private decimal _solde; private List\u003cstring\u003e _historiqueTransactions; private DateTime _dateOuverture; private const decimal FRAIS_RETRAIT = 1.50m; // Constante privÃ©e // ========================================== // PROPRIÃ‰TÃ‰S PUBLIQUES - Interface contrÃ´lÃ©e // ========================================== // Lecture seule de l'extÃ©rieur public string NumeroCompte { get { return _numeroCompte; } private set { _numeroCompte = value; } } public string Titulaire { get { return _titulaire; } set { if (!string.IsNullOrWhiteSpace(value)) _titulaire = value; } } // Lecture seule - impossible de modifier directement public decimal Solde { get { return _solde; } private set { _solde = value; } } public DateTime DateOuverture { get { return _dateOuverture; } } // ========================================== // CONSTRUCTEUR // ========================================== public CompteBancaire(string titulaire, string numeroCompte) { _titulaire = titulaire; _numeroCompte = numeroCompte; _solde = 0; _dateOuverture = DateTime.Now; _historiqueTransactions = new List\u003cstring\u003e(); AjouterTransaction(\"Ouverture du compte\"); } // ========================================== // MÃ‰THODES PUBLIQUES - Actions autorisÃ©es // ========================================== public bool Deposer(decimal montant) { if (montant \u003c= 0) { Console.WriteLine(\"Le montant doit Ãªtre positif\"); return false; } _solde += montant; AjouterTransaction($\"DÃ©pÃ´t de {montant:C}\"); Console.WriteLine($\"DÃ©pÃ´t rÃ©ussi. Nouveau solde: {_solde:C}\"); return true; } public bool Retirer(decimal montant) { if (montant \u003c= 0) { Console.WriteLine(\"Le montant doit Ãªtre positif\"); return false; } decimal montantTotal = montant + FRAIS_RETRAIT; if (montantTotal \u003e _solde) { Console.WriteLine(\"Solde insuffisant\"); return false; } _solde -= montantTotal; AjouterTransaction($\"Retrait de {montant:C} (frais: {FRAIS_RETRAIT:C})\"); Console.WriteLine($\"Retrait rÃ©ussi. Nouveau solde: {_solde:C}\"); return true; } public void AfficherHistorique() { Console.WriteLine($\"\\n=== Historique du compte {_numeroCompte} ===\"); foreach (string transaction in _historiqueTransactions) { Console.WriteLine(transaction); } } // ========================================== // MÃ‰THODES PRIVÃ‰ES - DÃ©tails d'implÃ©mentation // ========================================== private void AjouterTransaction(string description) { string transaction = $\"{DateTime.Now:dd/MM/yyyy HH:mm:ss} - {description}\"; _historiqueTransactions.Add(transaction); } private bool VerifierFrauude() { // Logique complexe de vÃ©rification return true; } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { CompteBancaire compte = new CompteBancaire(\"Jean Dupont\", \"12345\"); // âœ… Interface publique propre et sÃ©curisÃ©e compte.Deposer(1000); compte.Retirer(50); compte.AfficherHistorique(); // âœ… Lecture sÃ©curisÃ©e Console.WriteLine($\"Solde actuel: {compte.Solde:C}\"); // âŒ Impossible de tricher! // compte.Solde = 9999999; // ERREUR - Setter privÃ© // compte._solde += 1000; // ERREUR - Attribut privÃ© } } 5.4 Avantages de lâ€™Encapsulation SÃ©curitÃ© : Protection des donnÃ©es contre les modifications non autorisÃ©es Validation : ContrÃ´le des valeurs assignÃ©es FlexibilitÃ© : Modification de lâ€™implÃ©mentation interne sans casser le code externe Maintenance : Code plus facile Ã  comprendre et modifier DÃ©bogage : Points de contrÃ´le clairs pour tracer les problÃ¨mes 6. Les MÃ©thodes 6.1 DÃ©finition Les mÃ©thodes sont des fonctions dÃ©finies Ã  lâ€™intÃ©rieur dâ€™une classe. Elles reprÃ©sentent les comportements ou actions que les objets peuvent effectuer.\n6.2 Syntaxe ComplÃ¨te [modificateur d'accÃ¨s] [modificateurs] [type de retour] NomMethode([paramÃ¨tres]) { // Corps de la mÃ©thode return valeur; // Si type de retour n'est pas void } 6.3 Types de MÃ©thodes A) MÃ©thode Sans Retour (void) public class Robot { public void Avancer() { Console.WriteLine(\"Le robot avance\"); // Pas de return - void signifie \"ne retourne rien\" } public void Saluer(string nom) { Console.WriteLine($\"Bonjour {nom}!\"); } } B) MÃ©thode Avec Retour public class Calculatrice { public int Additionner(int a, int b) { int resultat = a + b; return resultat; // DOIT retourner un int } public double CalculerMoyenne(double[] nombres) { double somme = 0; foreach (double nombre in nombres) { somme += nombre; } return somme / nombres.Length; } public bool EstPair(int nombre) { return nombre % 2 == 0; // Retourne true ou false } } C) MÃ©thode Avec ParamÃ¨tres public class GestionnaireEmail { // ParamÃ¨tres obligatoires public void EnvoyerEmail(string destinataire, string sujet, string message) { Console.WriteLine($\"Ã€: {destinataire}\"); Console.WriteLine($\"Sujet: {sujet}\"); Console.WriteLine($\"Message: {message}\"); } // ParamÃ¨tres avec valeurs par dÃ©faut public void EnvoyerNotification(string message, string niveau = \"INFO\") { Console.WriteLine($\"[{niveau}] {message}\"); } } // Utilisation GestionnaireEmail gestionnaire = new GestionnaireEmail(); gestionnaire.EnvoyerEmail(\"jean@example.com\", \"Bienvenue\", \"Bonjour!\"); gestionnaire.EnvoyerNotification(\"SystÃ¨me dÃ©marrÃ©\"); // Utilise niveau par dÃ©faut gestionnaire.EnvoyerNotification(\"Erreur dÃ©tectÃ©e\", \"ERREUR\"); // SpÃ©cifie le niveau D) Surcharge de MÃ©thodes (Overloading) Plusieurs mÃ©thodes avec le mÃªme nom mais des paramÃ¨tres diffÃ©rents.\npublic class Calculatrice { // MÃªme nom, paramÃ¨tres diffÃ©rents public int Additionner(int a, int b) { return a + b; } public int Additionner(int a, int b, int c) { return a + b + c; } public double Additionner(double a, double b) { return a + b; } public int Additionner(params int[] nombres) // Nombre variable de paramÃ¨tres { int somme = 0; foreach (int nombre in nombres) { somme += nombre; } return somme; } } // Utilisation Calculatrice calc = new Calculatrice(); calc.Additionner(5, 3); // Appelle la version Ã  2 int calc.Additionner(5, 3, 2); // Appelle la version Ã  3 int calc.Additionner(5.5, 3.2); // Appelle la version Ã  2 double calc.Additionner(1, 2, 3, 4, 5, 6); // Appelle la version avec params 6.4 Le Mot-ClÃ© this this fait rÃ©fÃ©rence Ã  lâ€™instance actuelle de la classe.\npublic class Personne { private string nom; private int age; public Personne(string nom, int age) { // 'this.nom' = attribut de la classe // 'nom' = paramÃ¨tre du constructeur this.nom = nom; // Distingue l'attribut du paramÃ¨tre this.age = age; } public void Comparer(Personne autre) { if (this.age \u003e autre.age) { Console.WriteLine($\"{this.nom} est plus Ã¢gÃ© que {autre.nom}\"); } } public Personne ObtenirRÃ©fÃ©rence() { return this; // Retourne l'objet lui-mÃªme } } 6.5 MÃ©thodes dâ€™Instance vs MÃ©thodes Statiques public class Utilitaires { // Attribut d'instance private int compteur = 0; // ========================================== // MÃ‰THODE D'INSTANCE - NÃ©cessite un objet // ========================================== public void Incrementer() { compteur++; // AccÃ¨de Ã  l'attribut d'instance Console.WriteLine($\"Compteur: {compteur}\"); } // ========================================== // MÃ‰THODE STATIQUE - Pas besoin d'objet // ========================================== public static int Additionner(int a, int b) { // Ne peut PAS accÃ©der aux membres d'instance // compteur++; // âŒ ERREUR! return a + b; } public static double CalculerAire(double rayon) { return Math.PI * rayon * rayon; } } // Utilisation // MÃ©thode d'instance Utilitaires util = new Utilitaires(); util.Incrementer(); // Besoin d'un objet // MÃ©thode statique int somme = Utilitaires.Additionner(5, 3); // Pas besoin d'objet double aire = Utilitaires.CalculerAire(5); 7. Les Constructeurs 7.1 DÃ©finition Approfondie Un constructeur est une mÃ©thode spÃ©ciale qui est automatiquement appelÃ©e lors de la crÃ©ation dâ€™un objet. Son rÃ´le principal est dâ€™initialiser lâ€™objet dans un Ã©tat valide.\nCaractÃ©ristiques dâ€™un constructeur :\nMÃªme nom que la classe Pas de type de retour (mÃªme pas void) Peut avoir des paramÃ¨tres Peut Ãªtre surchargÃ© (plusieurs constructeurs diffÃ©rents) AppelÃ© automatiquement avec new MÃ©taphore : Le constructeur est comme le mode dâ€™emploi dâ€™assemblage dâ€™un meuble IKEA. Il dÃ©finit comment crÃ©er et prÃ©parer lâ€™objet pour quâ€™il soit utilisable.\n7.2 Constructeur Par DÃ©faut public class Voiture { public string Marque; public string Modele; public int Annee; // ========================================== // CONSTRUCTEUR PAR DÃ‰FAUT (sans paramÃ¨tres) // ========================================== public Voiture() { Console.WriteLine(\"Construction d'une voiture...\"); Marque = \"Inconnue\"; Modele = \"Standard\"; Annee = 2020; } } // Utilisation Voiture v = new Voiture(); // Appelle le constructeur par dÃ©faut Console.WriteLine($\"{v.Marque} {v.Modele}\"); // Inconnue Standard Important : Si vous ne dÃ©finissez AUCUN constructeur, C# crÃ©e automatiquement un constructeur par dÃ©faut vide. Mais si vous dÃ©finissez au moins un constructeur, le constructeur par dÃ©faut automatique disparaÃ®t.\npublic class Exemple1 { // Pas de constructeur dÃ©fini // C# crÃ©e automatiquement : public Exemple1() { } } public class Exemple2 { public Exemple2(int valeur) { } // Le constructeur par dÃ©faut automatique N'EXISTE PLUS } // Utilisation Exemple1 e1 = new Exemple1(); // âœ… OK Exemple2 e2 = new Exemple2(); // âŒ ERREUR - Pas de constructeur sans paramÃ¨tre Exemple2 e3 = new Exemple2(5); // âœ… OK 7.3 Constructeur Avec ParamÃ¨tres public class Personne { public string Nom { get; set; } public string Prenom { get; set; } public int Age { get; set; } // ========================================== // CONSTRUCTEUR AVEC PARAMÃˆTRES // ========================================== public Personne(string nom, string prenom, int age) { Console.WriteLine(\"CrÃ©ation d'une personne...\"); // Validation avant assignation if (string.IsNullOrWhiteSpace(nom)) throw new ArgumentException(\"Le nom ne peut pas Ãªtre vide\"); if (age \u003c 0 || age \u003e 150) throw new ArgumentException(\"Ã‚ge invalide\"); Nom = nom; Prenom = prenom; Age = age; } } // Utilisation Personne p1 = new Personne(\"Tremblay\", \"Marie\", 25); // Personne p2 = new Personne(\"\", \"Jean\", 30); // âŒ Exception levÃ©e 7.4 Surcharge de Constructeurs Une classe peut avoir plusieurs constructeurs avec diffÃ©rents paramÃ¨tres.\npublic class Livre { public string Titre { get; set; } public string Auteur { get; set; } public int Annee { get; set; } public int Pages { get; set; } // ========================================== // CONSTRUCTEUR 1 : Sans paramÃ¨tres // ========================================== public Livre() { Titre = \"Sans titre\"; Auteur = \"Anonyme\"; Annee = DateTime.Now.Year; Pages = 0; Console.WriteLine(\"Livre crÃ©Ã© avec valeurs par dÃ©faut\"); } // ========================================== // CONSTRUCTEUR 2 : Titre seulement // ========================================== public Livre(string titre) { Titre = titre; Auteur = \"Anonyme\"; Annee = DateTime.Now.Year; Pages = 0; Console.WriteLine($\"Livre '{titre}' crÃ©Ã©\"); } // ========================================== // CONSTRUCTEUR 3 : Titre et Auteur // ========================================== public Livre(string titre, string auteur) { Titre = titre; Auteur = auteur; Annee = DateTime.Now.Year; Pages = 0; Console.WriteLine($\"Livre '{titre}' de {auteur} crÃ©Ã©\"); } // ========================================== // CONSTRUCTEUR 4 : Tous les paramÃ¨tres // ========================================== public Livre(string titre, string auteur, int annee, int pages) { Titre = titre; Auteur = auteur; Annee = annee; Pages = pages; Console.WriteLine($\"Livre complet crÃ©Ã©\"); } } // Utilisation - Le compilateur choisit le bon constructeur Livre l1 = new Livre(); // Constructeur 1 Livre l2 = new Livre(\"1984\"); // Constructeur 2 Livre l3 = new Livre(\"Le Petit Prince\", \"Saint-ExupÃ©ry\"); // Constructeur 3 Livre l4 = new Livre(\"Dune\", \"Frank Herbert\", 1965, 412); // Constructeur 4 7.5 ChaÃ®nage de Constructeurs avec this Pour Ã©viter la duplication de code, un constructeur peut appeler un autre constructeur de la mÃªme classe avec : this().\npublic class Rectangle { public double Longueur { get; set; } public double Largeur { get; set; } public string Couleur { get; set; } // ========================================== // CONSTRUCTEUR PRINCIPAL (le plus complet) // ========================================== public Rectangle(double longueur, double largeur, string couleur) { Console.WriteLine(\"Constructeur principal appelÃ©\"); Longueur = longueur; Largeur = largeur; Couleur = couleur; } // ========================================== // CONSTRUCTEUR qui appelle le principal // ========================================== public Rectangle(double longueur, double largeur) : this(longueur, largeur, \"Blanc\") // Appelle le constructeur principal { Console.WriteLine(\"Constructeur sans couleur\"); // Pas besoin de rÃ©pÃ©ter l'assignation de longueur et largeur } // ========================================== // CONSTRUCTEUR pour un carrÃ© // ========================================== public Rectangle(double cote) : this(cote, cote, \"Blanc\") // Appelle le constructeur principal { Console.WriteLine(\"Constructeur pour carrÃ©\"); } // ========================================== // CONSTRUCTEUR par dÃ©faut // ========================================== public Rectangle() : this(1, 1, \"Blanc\") // Appelle le constructeur principal { Console.WriteLine(\"Constructeur par dÃ©faut\"); } } // Utilisation Rectangle r1 = new Rectangle(5, 3, \"Rouge\"); // Affiche: \"Constructeur principal appelÃ©\" Rectangle r2 = new Rectangle(5, 3); // Affiche: \"Constructeur principal appelÃ©\" // \"Constructeur sans couleur\" Rectangle r3 = new Rectangle(4); // Affiche: \"Constructeur principal appelÃ©\" // \"Constructeur pour carrÃ©\" Ordre dâ€™exÃ©cution :\nLe constructeur appelÃ© avec : this() sâ€™exÃ©cute en PREMIER Puis le constructeur actuel sâ€™exÃ©cute 7.6 Constructeurs PrivÃ©s Un constructeur peut Ãªtre privÃ© pour contrÃ´ler la crÃ©ation dâ€™instances.\n// ========================================== // PATTERN SINGLETON - Une seule instance possible // ========================================== public class Configuration { private static Configuration _instance = null; public string CheminFichier { get; set; } public string Langue { get; set; } // ========================================== // CONSTRUCTEUR PRIVÃ‰ - Impossible de faire 'new Configuration()' // ========================================== private Configuration() { CheminFichier = \"config.json\"; Langue = \"fr\"; Console.WriteLine(\"Configuration crÃ©Ã©e\"); } // ========================================== // MÃ‰THODE PUBLIQUE pour obtenir l'instance unique // ========================================== public static Configuration ObtenirInstance() { if (_instance == null) { _instance = new Configuration(); } return _instance; } } // Utilisation // Configuration c1 = new Configuration(); // âŒ ERREUR - Constructeur privÃ© Configuration c1 = Configuration.ObtenirInstance(); // âœ… OK Configuration c2 = Configuration.ObtenirInstance(); // Retourne la mÃªme instance Console.WriteLine(c1 == c2); // True - MÃªme objet 7.7 Initialisation dâ€™Objets En plus des constructeurs, C# offre des syntaxes modernes pour initialiser les objets.\npublic class Produit { public string Nom { get; set; } public decimal Prix { get; set; } public string Categorie { get; set; } public Produit() { } public Produit(string nom, decimal prix) { Nom = nom; Prix = prix; } } // ========================================== // SYNTAXE 1 : Constructeur traditionnel // ========================================== Produit p1 = new Produit(\"Laptop\", 999.99m); p1.Categorie = \"Ã‰lectronique\"; // ========================================== // SYNTAXE 2 : Initialiseur d'objet (Object Initializer) // ========================================== Produit p2 = new Produit { Nom = \"Souris\", Prix = 29.99m, Categorie = \"Accessoires\" }; // ========================================== // SYNTAXE 3 : Combinaison constructeur + initialiseur // ========================================== Produit p3 = new Produit(\"Clavier\", 79.99m) { Categorie = \"Accessoires\" // Ajoute la catÃ©gorie aprÃ¨s la construction }; // ========================================== // SYNTAXE 4 : C# 9+ (sans rÃ©pÃ©ter le type) // ========================================== Produit p4 = new(\"Ã‰cran\", 299.99m) { Categorie = \"PÃ©riphÃ©riques\" }; 7.8 Exemple Complet : Classe CompteBancaire public class CompteBancaire { // ========================================== // ATTRIBUTS PRIVÃ‰S // ========================================== private string _numeroCompte; private string _titulaire; private decimal _solde; private DateTime _dateOuverture; private static int _compteurComptes = 0; // Pour gÃ©nÃ©rer des numÃ©ros uniques // ========================================== // PROPRIÃ‰TÃ‰S // ========================================== public string NumeroCompte { get { return _numeroCompte; } } public string Titulaire { get { return _titulaire; } } public decimal Solde { get { return _solde; } } public DateTime DateOuverture { get { return _dateOuverture; } } // ========================================== // CONSTRUCTEUR 1 : Complet // ========================================== public CompteBancaire(string titulaire, decimal soldeInitial, string numeroCompte) { if (string.IsNullOrWhiteSpace(titulaire)) throw new ArgumentException(\"Le titulaire ne peut pas Ãªtre vide\"); if (soldeInitial \u003c 0) throw new ArgumentException(\"Le solde initial ne peut pas Ãªtre nÃ©gatif\"); _titulaire = titulaire; _solde = soldeInitial; _numeroCompte = numeroCompte; _dateOuverture = DateTime.Now; _compteurComptes++; Console.WriteLine($\"Compte {_numeroCompte} crÃ©Ã© pour {_titulaire}\"); } // ========================================== // CONSTRUCTEUR 2 : GÃ©nÃ¨re automatiquement le numÃ©ro // ========================================== public CompteBancaire(string titulaire, decimal soldeInitial) : this(titulaire, soldeInitial, GenererNumeroCompte()) { Console.WriteLine(\"NumÃ©ro de compte gÃ©nÃ©rÃ© automatiquement\"); } // ========================================== // CONSTRUCTEUR 3 : Solde initial de 0$ // ========================================== public CompteBancaire(string titulaire) : this(titulaire, 0) { Console.WriteLine(\"Compte crÃ©Ã© avec solde initial de 0$\"); } // ========================================== // MÃ‰THODE PRIVÃ‰E pour gÃ©nÃ©rer un numÃ©ro // ========================================== private static string GenererNumeroCompte() { return $\"CA{DateTime.Now.Year}{_compteurComptes + 1:D6}\"; } // ========================================== // MÃ‰THODES // ========================================== public void Deposer(decimal montant) { if (montant \u003e 0) { _solde += montant; Console.WriteLine($\"DÃ©pÃ´t de {montant:C}. Nouveau solde: {_solde:C}\"); } } public void AfficherInfos() { Console.WriteLine($\"\\n=== Compte {_numeroCompte} ===\"); Console.WriteLine($\"Titulaire: {_titulaire}\"); Console.WriteLine($\"Solde: {_solde:C}\"); Console.WriteLine($\"Date d'ouverture: {_dateOuverture:d}\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // 3 faÃ§ons de crÃ©er un compte CompteBancaire c1 = new CompteBancaire(\"Marie Tremblay\", 1000, \"CA2024001\"); CompteBancaire c2 = new CompteBancaire(\"Jean Gagnon\", 500); CompteBancaire c3 = new CompteBancaire(\"Sophie Roy\"); c1.AfficherInfos(); c2.AfficherInfos(); c3.AfficherInfos(); c3.Deposer(250); c3.AfficherInfos(); } } 8. Lâ€™HÃ©ritage 8.1 Concept Fondamental Lâ€™hÃ©ritage est un mÃ©canisme qui permet Ã  une classe (appelÃ©e classe dÃ©rivÃ©e, classe enfant ou sous-classe) dâ€™hÃ©riter des membres (attributs et mÃ©thodes) dâ€™une autre classe (appelÃ©e classe de base, classe parent ou super-classe).\nMÃ©taphore biologique :\nVous hÃ©ritez des caractÃ©ristiques de vos parents (couleur des yeux, groupe sanguin) Mais vous avez aussi vos propres caractÃ©ristiques uniques Câ€™est la mÃªme chose en programmation Pourquoi lâ€™hÃ©ritage ?\nRÃ©utilisation du code : Ne pas rÃ©Ã©crire ce qui existe dÃ©jÃ  Organisation hiÃ©rarchique : ModÃ©liser des relations â€œest unâ€ ExtensibilitÃ© : Ajouter des fonctionnalitÃ©s sans modifier lâ€™existant Polymorphisme : Traiter diffÃ©rents objets de maniÃ¨re uniforme 8.2 Syntaxe de lâ€™HÃ©ritage // Syntaxe : class ClasseDerivee : ClasseDeBase public class Animal { // Classe de base } public class Chien : Animal { // Chien hÃ©rite de Animal } 8.3 Exemple DÃ©taillÃ© : HiÃ©rarchie de VÃ©hicules // ========================================== // CLASSE DE BASE (PARENT) // ========================================== public class Vehicule { // ========================================== // MEMBRES PROTÃ‰GÃ‰S - Accessibles aux dÃ©rivÃ©es // ========================================== protected string _marque; protected string _modele; protected int _annee; protected double _kilometrage; // ========================================== // PROPRIÃ‰TÃ‰S PUBLIQUES // ========================================== public string Marque { get { return _marque; } set { _marque = value; } } public string Modele { get { return _modele; } set { _modele = value; } } public int Annee { get; set; } public double Kilometrage { get { return _kilometrage; } protected set // Set protÃ©gÃ© { if (value \u003e= _kilometrage) // Ne peut qu'augmenter _kilometrage = value; } } // ========================================== // CONSTRUCTEUR // ========================================== public Vehicule(string marque, string modele, int annee) { Console.WriteLine(\"Constructeur de Vehicule appelÃ©\"); _marque = marque; _modele = modele; _annee = annee; _kilometrage = 0; } // ========================================== // MÃ‰THODES // ========================================== public void Demarrer() { Console.WriteLine($\"Le vÃ©hicule {_marque} {_modele} dÃ©marre.\"); } public void Rouler(double km) { _kilometrage += km; Console.WriteLine($\"Parcouru {km} km. Total: {_kilometrage} km\"); } public void AfficherInfos() { Console.WriteLine($\"\\n=== {_marque} {_modele} ===\"); Console.WriteLine($\"AnnÃ©e: {_annee}\"); Console.WriteLine($\"KilomÃ©trage: {_kilometrage} km\"); } } // ========================================== // CLASSE DÃ‰RIVÃ‰E 1 (ENFANT) // ========================================== public class Voiture : Vehicule // HÃ©rite de Vehicule { // ========================================== // MEMBRES SPÃ‰CIFIQUES Ã  Voiture // ========================================== private int _nombrePortes; private string _typeCar burant; public int NombrePortes { get { return _nombrePortes; } set { _nombrePortes = value; } } // ========================================== // CONSTRUCTEUR - Doit appeler le constructeur du parent // ========================================== public Voiture(string marque, string modele, int annee, int portes, string carburant) : base(marque, modele, annee) // Appelle le constructeur de Vehicule { Console.WriteLine(\"Constructeur de Voiture appelÃ©\"); _nombrePortes = portes; _typeCarburant = carburant; } // ========================================== // NOUVELLE MÃ‰THODE spÃ©cifique Ã  Voiture // ========================================== public void OuvrirCoffre() { Console.WriteLine(\"Coffre ouvert\"); } // ========================================== // ACCÃˆS AUX MEMBRES HÃ‰RITÃ‰S // ========================================== public void AfficherToutesInfos() { // Peut accÃ©der aux membres protected et public du parent AfficherInfos(); // MÃ©thode hÃ©ritÃ©e Console.WriteLine($\"Nombre de portes: {_nombrePortes}\"); Console.WriteLine($\"Carburant: {_typeCarburant}\"); // Peut accÃ©der aux attributs protected Console.WriteLine($\"Marque (attribut protected): {_marque}\"); } } // ========================================== // CLASSE DÃ‰RIVÃ‰E 2 // ========================================== public class Moto : Vehicule { private bool _aCompartiment; public bool ACompartiment { get; set; } public Moto(string marque, string modele, int annee, bool compartiment) : base(marque, modele, annee) { Console.WriteLine(\"Constructeur de Moto appelÃ©\"); _aCompartiment = compartiment; } public void FaireWheeling() { Console.WriteLine($\"La moto {Marque} fait un wheeling!\"); } } // ========================================== // CLASSE DÃ‰RIVÃ‰E 3 // ========================================== public class Camion : Vehicule { private double _capaciteCharge; // En tonnes public double CapaciteCharge { get; set; } public Camion(string marque, string modele, int annee, double capacite) : base(marque, modele, annee) { _capaciteCharge = capacite; } public void Charger(double poids) { if (poids \u003c= _capaciteCharge) Console.WriteLine($\"Chargement de {poids} tonnes\"); else Console.WriteLine($\"DÃ©passement de capacitÃ©!\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // CrÃ©ation d'objets dÃ©rivÃ©s Voiture voiture = new Voiture(\"Toyota\", \"Camry\", 2023, 4, \"Essence\"); Moto moto = new Moto(\"Harley-Davidson\", \"Street 750\", 2022, true); Camion camion = new Camion(\"Volvo\", \"FH16\", 2021, 20); // ========================================== // La voiture hÃ©rite de TOUT ce que Vehicule possÃ¨de // ========================================== voiture.Demarrer(); // âœ… MÃ©thode hÃ©ritÃ©e voiture.Rouler(150); // âœ… MÃ©thode hÃ©ritÃ©e voiture.AfficherInfos(); // âœ… MÃ©thode hÃ©ritÃ©e voiture.OuvrirCoffre(); // âœ… MÃ©thode spÃ©cifique Ã  Voiture // ========================================== // MÃªme chose pour la moto // ========================================== moto.Demarrer(); // âœ… MÃ©thode hÃ©ritÃ©e moto.FaireWheeling(); // âœ… MÃ©thode spÃ©cifique Ã  Moto // ========================================== // Et le camion // ========================================== camion.Demarrer(); // âœ… MÃ©thode hÃ©ritÃ©e camion.Charger(15); // âœ… MÃ©thode spÃ©cifique Ã  Camion } } Affichage :\nConstructeur de Vehicule appelÃ©\rConstructeur de Voiture appelÃ©\rConstructeur de Vehicule appelÃ©\rConstructeur de Moto appelÃ©\rConstructeur de Vehicule appelÃ©\rLe vÃ©hicule Toyota Camry dÃ©marre.\rParcouru 150 km. Total: 150 km\r=== Toyota Camry ===\rAnnÃ©e: 2023\rKilomÃ©trage: 150 km\rCoffre ouvert\r... 8.4 Le Mot-ClÃ© base Le mot-clÃ© base permet dâ€™accÃ©der aux membres de la classe parent.\npublic class Animal { protected string _nom; protected int _age; public Animal(string nom, int age) { _nom = nom; _age = age; Console.WriteLine($\"Animal {nom} crÃ©Ã©\"); } public void Manger() { Console.WriteLine($\"{_nom} mange.\"); } public virtual void Dormir() { Console.WriteLine($\"{_nom} dort paisiblement.\"); } } public class Chien : Animal { private string _race; // ========================================== // UTILISATION 1 de 'base' : Appeler le constructeur parent // ========================================== public Chien(string nom, int age, string race) : base(nom, age) // Appelle Animal(nom, age) { _race = race; Console.WriteLine($\"Chien de race {race} crÃ©Ã©\"); } // ========================================== // UTILISATION 2 de 'base' : Appeler une mÃ©thode du parent // ========================================== public override void Dormir() { Console.WriteLine($\"{_nom} le chien cherche un endroit confortable\"); base.Dormir(); // Appelle la mÃ©thode Dormir() de Animal Console.WriteLine(\"...et ronfle un peu\"); } public void AfficherTout() { // ========================================== // UTILISATION 3 de 'base' : AccÃ©der Ã  un membre parent // ========================================== Console.WriteLine($\"Nom: {_nom}\"); // Attribut hÃ©ritÃ© Console.WriteLine($\"Ã‚ge: {_age}\"); // Attribut hÃ©ritÃ© Console.WriteLine($\"Race: {_race}\"); // Attribut propre base.Manger(); // Appelle explicitement la mÃ©thode du parent } } // Utilisation Chien chien = new Chien(\"Rex\", 5, \"Labrador\"); chien.Dormir(); Affichage :\nAnimal Rex crÃ©Ã©\rChien de race Labrador crÃ©Ã©\rRex le chien cherche un endroit confortable\rRex dort paisiblement.\r...et ronfle un peu 8.5 HiÃ©rarchie Multi-Niveaux Lâ€™hÃ©ritage peut avoir plusieurs niveaux.\n// ========================================== // NIVEAU 1 : Classe de base // ========================================== public class EtreVivant { public bool EstVivant { get; set; } = true; public void Respirer() { Console.WriteLine(\"Respire...\"); } } // ========================================== // NIVEAU 2 : DÃ©rive de EtreVivant // ========================================== public class Animal : EtreVivant { public void SeDeplacer() { Console.WriteLine(\"Se dÃ©place\"); } } // ========================================== // NIVEAU 3 : DÃ©rive de Animal // ========================================== public class Mammifere : Animal { public void Allaiter() { Console.WriteLine(\"Allaite ses petits\"); } } // ========================================== // NIVEAU 4 : DÃ©rive de Mammifere // ========================================== public class Chien : Mammifere { public void Aboyer() { Console.WriteLine(\"Wouf wouf!\"); } } // Utilisation Chien chien = new Chien(); // Le chien hÃ©rite de TOUS ses ancÃªtres chien.Respirer(); // âœ… De EtreVivant (arriÃ¨re-arriÃ¨re-grand-parent) chien.SeDeplacer(); // âœ… De Animal (arriÃ¨re-grand-parent) chien.Allaiter(); // âœ… De Mammifere (grand-parent) chien.Aboyer(); // âœ… De Chien (lui-mÃªme) HiÃ©rarchie :\nEtreVivant\râ†“ hÃ©rite\rAnimal\râ†“ hÃ©rite\rMammifere\râ†“ hÃ©rite\rChien 8.6 Relations â€œEst-Unâ€ (Is-A) Lâ€™hÃ©ritage modÃ©lise une relation â€œest unâ€.\npublic class Vehicule { } public class Voiture : Vehicule { } // Une Voiture \"est un\" Vehicule âœ… // Un Vehicule \"est une\" Voiture âŒ (faux) Voiture v = new Voiture(); // v est une Voiture âœ… // v est aussi un Vehicule âœ… (par hÃ©ritage) Test mental : Si vous pouvez dire â€œX est un Yâ€, alors X peut hÃ©riter de Y.\nUn chien est un animal âœ… Une voiture est un vÃ©hicule âœ… Un Ã©tudiant est une personne âœ… Une maison est un bÃ¢timent âœ… Contre-exemples (mauvais hÃ©ritage) :\nUne maison est un toit âŒ (une maison a un toit â†’ composition, pas hÃ©ritage) Un Ã©tudiant est un cours âŒ Une voiture est un moteur âŒ (une voiture a un moteur) 8.7 Restrictions de lâ€™HÃ©ritage en C# Important : En C#, une classe ne peut hÃ©riter que dâ€™UNE SEULE classe (pas dâ€™hÃ©ritage multiple de classes).\npublic class A { } public class B { } // âŒ ERREUR - Pas d'hÃ©ritage multiple en C# public class C : A, B { } // âœ… OK - HÃ©ritage simple public class C : A { } Cependant : Une classe peut implÃ©menter plusieurs interfaces (voir section sur les interfaces).\n9. Le Polymorphisme 9.1 DÃ©finition Approfondie Le polymorphisme (du grec â€œpolyâ€ = plusieurs, â€œmorpheâ€ = forme) est la capacitÃ© pour des objets de types diffÃ©rents de rÃ©pondre Ã  la mÃªme interface ou au mÃªme appel de mÃ©thode, mais avec des comportements diffÃ©rents.\nAnalogie du monde rÃ©el : Imaginez un bouton â€œDÃ©marrerâ€ :\nSur une voiture : DÃ©marre le moteur Sur un ordinateur : Lance le systÃ¨me dâ€™exploitation Sur une cafetiÃ¨re : Commence Ã  infuser le cafÃ© MÃªme action (â€œDÃ©marrerâ€), comportements diffÃ©rents Pourquoi le polymorphisme ?\nFlexibilitÃ© : Ã‰crire du code qui fonctionne avec diffÃ©rents types ExtensibilitÃ© : Ajouter de nouveaux types sans modifier le code existant Abstraction : Manipuler des objets sans connaÃ®tre leur type exact Code rÃ©utilisable : Une mÃªme fonction pour plusieurs types 9.2 Types de Polymorphisme Il existe deux types principaux :\nPolymorphisme de compilation (surcharge de mÃ©thodes) Polymorphisme dâ€™exÃ©cution (redÃ©finition de mÃ©thodes) La Programmation OrientÃ©e Objet (POO) est un paradigme de programmation basÃ© sur le concept dâ€™objets qui contiennent des donnÃ©es (attributs) et du code (mÃ©thodes).\nLes 4 piliers de la POO : Encapsulation : Regrouper les donnÃ©es et mÃ©thodes, cacher les dÃ©tails internes HÃ©ritage : CrÃ©er de nouvelles classes Ã  partir de classes existantes Polymorphisme : Utiliser une interface commune pour des types diffÃ©rents Abstraction : Simplifier la complexitÃ© en cachant les dÃ©tails dâ€™implÃ©mentation 2. Les Classes et les Objets Quâ€™est-ce quâ€™une classe ? Une classe est un modÃ¨le ou un plan qui dÃ©finit la structure et le comportement dâ€™objets.\nQuâ€™est-ce quâ€™un objet ? Un objet est une instance dâ€™une classe, câ€™est une entitÃ© concrÃ¨te crÃ©Ã©e Ã  partir du modÃ¨le.\nSyntaxe de base // DÃ©finition d'une classe public class Personne { // Attributs (champs) public string Nom; public string Prenom; public int Age; // MÃ©thode public void SePresenter() { Console.WriteLine($\"Bonjour, je m'appelle {Prenom} {Nom} et j'ai {Age} ans.\"); } } // Utilisation class Program { static void Main() { // CrÃ©ation d'un objet (instance) Personne personne1 = new Personne(); personne1.Nom = \"Tremblay\"; personne1.Prenom = \"Marie\"; personne1.Age = 25; personne1.SePresenter(); // Affiche: Bonjour, je m'appelle Marie Tremblay et j'ai 25 ans. } } 3. Lâ€™Encapsulation Lâ€™encapsulation consiste Ã  protÃ©ger les donnÃ©es dâ€™une classe et Ã  contrÃ´ler lâ€™accÃ¨s via des propriÃ©tÃ©s.\nModificateurs dâ€™accÃ¨s Modificateur Description public Accessible partout private Accessible uniquement dans la classe protected Accessible dans la classe et ses dÃ©rivÃ©es internal Accessible dans le mÃªme assembly protected internal Combinaison de protected et internal PropriÃ©tÃ©s (Properties) public class Compte { // Champs privÃ©s private string _numeroCompte; private decimal _solde; // PropriÃ©tÃ© avec get et set public string NumeroCompte { get { return _numeroCompte; } set { _numeroCompte = value; } } // PropriÃ©tÃ© avec logique de validation public decimal Solde { get { return _solde; } private set // set privÃ© : lecture publique, Ã©criture privÃ©e { if (value \u003e= 0) _solde = value; } } // PropriÃ©tÃ© auto-implÃ©mentÃ©e (C# 3.0+) public string Titulaire { get; set; } // PropriÃ©tÃ© en lecture seule (C# 6.0+) public DateTime DateCreation { get; } = DateTime.Now; public void Deposer(decimal montant) { if (montant \u003e 0) Solde += montant; } public bool Retirer(decimal montant) { if (montant \u003e 0 \u0026\u0026 montant \u003c= Solde) { Solde -= montant; return true; } return false; } } 4. Les Constructeurs Un constructeur est une mÃ©thode spÃ©ciale appelÃ©e lors de la crÃ©ation dâ€™un objet.\nTypes de constructeurs public class Voiture { public string Marque { get; set; } public string Modele { get; set; } public int Annee { get; set; } // Constructeur par dÃ©faut (sans paramÃ¨tres) public Voiture() { Marque = \"Inconnue\"; Modele = \"Inconnu\"; Annee = 2020; } // Constructeur avec paramÃ¨tres public Voiture(string marque, string modele) { Marque = marque; Modele = modele; Annee = DateTime.Now.Year; } // Constructeur complet public Voiture(string marque, string modele, int annee) { Marque = marque; Modele = modele; Annee = annee; } // ChaÃ®nage de constructeurs avec 'this' public Voiture(string marque) : this(marque, \"Standard\", DateTime.Now.Year) { } } // Utilisation var voiture1 = new Voiture(); var voiture2 = new Voiture(\"Toyota\", \"Camry\"); var voiture3 = new Voiture(\"Honda\", \"Civic\", 2023); var voiture4 = new Voiture(\"Ford\"); 5. Lâ€™HÃ©ritage Lâ€™hÃ©ritage permet Ã  une classe (classe dÃ©rivÃ©e) dâ€™hÃ©riter des membres dâ€™une autre classe (classe de base).\nSyntaxe de base // Classe de base (parent) public class Animal { public string Nom { get; set; } public int Age { get; set; } public virtual void Manger() { Console.WriteLine($\"{Nom} est en train de manger.\"); } public virtual void Dormir() { Console.WriteLine($\"{Nom} dort.\"); } } // Classe dÃ©rivÃ©e (enfant) public class Chien : Animal { public string Race { get; set; } // Nouvelle mÃ©thode spÃ©cifique au chien public void Aboyer() { Console.WriteLine($\"{Nom} aboie: Wouf wouf!\"); } // RedÃ©finition (override) d'une mÃ©thode public override void Manger() { Console.WriteLine($\"{Nom} le chien mange des croquettes.\"); } } // Autre classe dÃ©rivÃ©e public class Chat : Animal { public bool EstDomestique { get; set; } public void Miauler() { Console.WriteLine($\"{Nom} miaule: Miaou!\"); } public override void Manger() { Console.WriteLine($\"{Nom} le chat mange du poisson.\"); } } // Utilisation var chien = new Chien { Nom = \"Rex\", Age = 5, Race = \"Labrador\" }; chien.Manger(); // Affiche: Rex le chien mange des croquettes. chien.Aboyer(); // Affiche: Rex aboie: Wouf wouf! chien.Dormir(); // Affiche: Rex dort. Le mot-clÃ© base public class Employe { public string Nom { get; set; } public decimal SalaireBase { get; set; } public Employe(string nom, decimal salaire) { Nom = nom; SalaireBase = salaire; } public virtual decimal CalculerSalaire() { return SalaireBase; } } public class Manager : Employe { public decimal Prime { get; set; } // Appel du constructeur de base avec 'base' public Manager(string nom, decimal salaire, decimal prime) : base(nom, salaire) { Prime = prime; } // Utilisation de la mÃ©thode de base avec 'base' public override decimal CalculerSalaire() { return base.CalculerSalaire() + Prime; } } Modificateur sealed Le mot-clÃ© sealed empÃªche lâ€™hÃ©ritage dâ€™une classe ou la redÃ©finition dâ€™une mÃ©thode.\n// Classe scellÃ©e - ne peut pas Ãªtre hÃ©ritÃ©e public sealed class ClasseFinale { public void Methode() { } } // ERREUR: Impossible d'hÃ©riter d'une classe sealed // public class Derivee : ClasseFinale { } public class ClasseAvecMethodeScelle : Animal { // MÃ©thode scellÃ©e - ne peut plus Ãªtre redÃ©finie dans les classes dÃ©rivÃ©es public sealed override void Manger() { Console.WriteLine(\"ImplÃ©mentation finale\"); } } 6. Le Polymorphisme Le polymorphisme permet Ã  des objets de diffÃ©rentes classes dâ€™Ãªtre traitÃ©s de maniÃ¨re uniforme via une interface commune.\nPolymorphisme par hÃ©ritage public class Forme { public virtual double CalculerAire() { return 0; } public virtual void Dessiner() { Console.WriteLine(\"Dessiner une forme gÃ©nÃ©rique\"); } } public class Cercle : Forme { public double Rayon { get; set; } public Cercle(double rayon) { Rayon = rayon; } public override double CalculerAire() { return Math.PI * Rayon * Rayon; } public override void Dessiner() { Console.WriteLine($\"Dessiner un cercle de rayon {Rayon}\"); } } public class Rectangle : Forme { public double Longueur { get; set; } public double Largeur { get; set; } public Rectangle(double longueur, double largeur) { Longueur = longueur; Largeur = largeur; } public override double CalculerAire() { return Longueur * Largeur; } public override void Dessiner() { Console.WriteLine($\"Dessiner un rectangle {Longueur}x{Largeur}\"); } } // Utilisation du polymorphisme class Program { static void Main() { // Tableau polymorphe Forme[] formes = new Forme[] { new Cercle(5), new Rectangle(4, 6), new Cercle(3) }; // MÃªme code, comportements diffÃ©rents foreach (Forme forme in formes) { forme.Dessiner(); Console.WriteLine($\"Aire: {forme.CalculerAire():F2}\"); Console.WriteLine(); } } } Mots-clÃ©s virtual, override, new public class ClasseBase { public virtual void MethodeVirtuelle() { Console.WriteLine(\"MÃ©thode virtuelle de base\"); } public void MethodeNormale() { Console.WriteLine(\"MÃ©thode normale de base\"); } } public class ClasseDerivee : ClasseBase { // Override: redÃ©finition polymorphique public override void MethodeVirtuelle() { Console.WriteLine(\"MÃ©thode redÃ©finie\"); } // New: masquage (non polymorphique) public new void MethodeNormale() { Console.WriteLine(\"MÃ©thode masquÃ©e\"); } } // Test ClasseBase obj1 = new ClasseDerivee(); obj1.MethodeVirtuelle(); // Affiche: MÃ©thode redÃ©finie (polymorphisme) obj1.MethodeNormale(); // Affiche: MÃ©thode normale de base (pas de polymorphisme) ClasseDerivee obj2 = new ClasseDerivee(); obj2.MethodeVirtuelle(); // Affiche: MÃ©thode redÃ©finie obj2.MethodeNormale(); // Affiche: MÃ©thode masquÃ©e 7. Les Classes Abstraites Une classe abstraite est une classe incomplÃ¨te qui ne peut pas Ãªtre instanciÃ©e directement. Elle sert de modÃ¨le pour dâ€™autres classes.\nCaractÃ©ristiques DÃ©clarÃ©e avec le mot-clÃ© abstract Peut contenir des mÃ©thodes abstraites (sans implÃ©mentation) et concrÃ¨tes (avec implÃ©mentation) Ne peut pas Ãªtre instanciÃ©e Les classes dÃ©rivÃ©es doivent implÃ©menter toutes les mÃ©thodes abstraites // Classe abstraite public abstract class Vehicule { public string Marque { get; set; } public string Modele { get; set; } // Constructeur (oui, les classes abstraites peuvent avoir des constructeurs) public Vehicule(string marque, string modele) { Marque = marque; Modele = modele; } // MÃ©thode abstraite (sans implÃ©mentation) public abstract void Demarrer(); // MÃ©thode abstraite public abstract double CalculerConsommation(double distance); // MÃ©thode concrÃ¨te (avec implÃ©mentation) public void AfficherInfo() { Console.WriteLine($\"VÃ©hicule: {Marque} {Modele}\"); } // MÃ©thode virtuelle (peut Ãªtre redÃ©finie) public virtual void Klaxonner() { Console.WriteLine(\"Beep beep!\"); } } // Classe dÃ©rivÃ©e - doit implÃ©menter toutes les mÃ©thodes abstraites public class Voiture : Vehicule { public int NombrePortes { get; set; } public Voiture(string marque, string modele, int portes) : base(marque, modele) { NombrePortes = portes; } // ImplÃ©mentation obligatoire public override void Demarrer() { Console.WriteLine($\"La voiture {Marque} {Modele} dÃ©marre avec la clÃ©.\"); } // ImplÃ©mentation obligatoire public override double CalculerConsommation(double distance) { return distance * 0.07; // 7L/100km } } public class Moto : Vehicule { public bool ASidecar { get; set; } public Moto(string marque, string modele) : base(marque, modele) { } public override void Demarrer() { Console.WriteLine($\"La moto {Marque} {Modele} dÃ©marre avec le kick.\"); } public override double CalculerConsommation(double distance) { return distance * 0.04; // 4L/100km } public override void Klaxonner() { Console.WriteLine(\"Beep beep! (son de moto)\"); } } // Utilisation // var v = new Vehicule(\"Test\", \"Test\"); // ERREUR: impossible d'instancier une classe abstraite var voiture = new Voiture(\"Toyota\", \"Corolla\", 4); voiture.AfficherInfo(); voiture.Demarrer(); Console.WriteLine($\"Consommation sur 100km: {voiture.CalculerConsommation(100)}L\"); var moto = new Moto(\"Harley\", \"Davidson\"); moto.Demarrer(); Exemple avancÃ© : SystÃ¨me de paiement public abstract class MoyenPaiement { public string Titulaire { get; set; } public DateTime DateTransaction { get; protected set; } public abstract bool Payer(decimal montant); public abstract bool Verifier(); public virtual void AfficherRecu(decimal montant) { Console.WriteLine($\"ReÃ§u - {Titulaire}\"); Console.WriteLine($\"Montant: {montant:C}\"); Console.WriteLine($\"Date: {DateTransaction}\"); } } public class CarteCredit : MoyenPaiement { public string Numero { get; set; } public DateTime DateExpiration { get; set; } public decimal LimiteCredit { get; set; } private decimal _soldeUtilise; public override bool Verifier() { return DateExpiration \u003e DateTime.Now; } public override bool Payer(decimal montant) { if (!Verifier()) { Console.WriteLine(\"Carte expirÃ©e\"); return false; } if (_soldeUtilise + montant \u003e LimiteCredit) { Console.WriteLine(\"Limite de crÃ©dit dÃ©passÃ©e\"); return false; } _soldeUtilise += montant; DateTransaction = DateTime.Now; Console.WriteLine($\"Paiement de {montant:C} effectuÃ© par carte de crÃ©dit\"); return true; } } public class Paypal : MoyenPaiement { public string Email { get; set; } public decimal Solde { get; private set; } public void Recharger(decimal montant) { Solde += montant; } public override bool Verifier() { return !string.IsNullOrEmpty(Email) \u0026\u0026 Email.Contains(\"@\"); } public override bool Payer(decimal montant) { if (!Verifier()) { Console.WriteLine(\"Email invalide\"); return false; } if (Solde \u003c montant) { Console.WriteLine(\"Solde insuffisant\"); return false; } Solde -= montant; DateTransaction = DateTime.Now; Console.WriteLine($\"Paiement de {montant:C} effectuÃ© via PayPal\"); return true; } } 8. Les Interfaces Une interface dÃ©finit un contrat que les classes doivent respecter. Elle ne contient que des signatures de mÃ©thodes, propriÃ©tÃ©s, Ã©vÃ©nements ou indexeurs (pas dâ€™implÃ©mentation).\nCaractÃ©ristiques DÃ©clarÃ©e avec le mot-clÃ© interface Tous les membres sont publics par dÃ©faut Une classe peut implÃ©menter plusieurs interfaces (contrairement Ã  lâ€™hÃ©ritage) Pas de champs, pas de constructeurs Convention de nommage : prÃ©fixe I (ex: IComparable) // DÃ©finition d'interfaces public interface IVolant { void Voler(); double AltitudeMax { get; } } public interface INageant { void Nager(); double ProfondeurMax { get; } } public interface IMarchant { void Marcher(); } // Classe implÃ©mentant une interface public class Oiseau : IVolant, IMarchant { public string Nom { get; set; } // ImplÃ©mentation de IVolant public double AltitudeMax { get; set; } = 1000; public void Voler() { Console.WriteLine($\"{Nom} vole dans le ciel.\"); } // ImplÃ©mentation de IMarchant public void Marcher() { Console.WriteLine($\"{Nom} marche sur le sol.\"); } } public class Canard : IVolant, INageant, IMarchant { public string Nom { get; set; } public double AltitudeMax { get; set; } = 500; public double ProfondeurMax { get; set; } = 10; public void Voler() { Console.WriteLine($\"{Nom} le canard vole.\"); } public void Nager() { Console.WriteLine($\"{Nom} le canard nage.\"); } public void Marcher() { Console.WriteLine($\"{Nom} le canard marche.\"); } } public class Poisson : INageant { public string Nom { get; set; } public double ProfondeurMax { get; set; } = 100; public void Nager() { Console.WriteLine($\"{Nom} le poisson nage sous l'eau.\"); } } // Utilisation polymorphe des interfaces class Program { static void FaireVoler(IVolant volant) { volant.Voler(); Console.WriteLine($\"Altitude maximale: {volant.AltitudeMax}m\"); } static void FaireNager(INageant nageant) { nageant.Nager(); Console.WriteLine($\"Profondeur maximale: {nageant.ProfondeurMax}m\"); } static void Main() { var oiseau = new Oiseau { Nom = \"Aigle\" }; var canard = new Canard { Nom = \"Donald\" }; var poisson = new Poisson { Nom = \"Nemo\" }; FaireVoler(oiseau); FaireVoler(canard); FaireNager(canard); FaireNager(poisson); // Collection polymorphe List\u003cINageant\u003e animauxAquatiques = new List\u003cINageant\u003e { canard, poisson }; foreach (var animal in animauxAquatiques) { animal.Nager(); } } } Interfaces vs Classes Abstraites Aspect Interface Classe Abstraite HÃ©ritage multiple âœ… Oui (une classe peut implÃ©menter plusieurs interfaces) âŒ Non (une classe ne peut hÃ©riter que dâ€™une seule classe) ImplÃ©mentation âŒ Aucune (sauf depuis C# 8.0 avec implÃ©mentation par dÃ©faut) âœ… Peut contenir des mÃ©thodes implÃ©mentÃ©es Champs âŒ Non âœ… Oui Constructeurs âŒ Non âœ… Oui Modificateurs dâ€™accÃ¨s Tous publics Peut varier Utilisation DÃ©finir un contrat/comportement DÃ©finir une base commune avec du code partagÃ© Exemple pratique : SystÃ¨me de notification public interface INotifiable { void EnvoyerNotification(string message); bool EstActif { get; set; } } public interface IConfigurable { void Configurer(Dictionary\u003cstring, string\u003e parametres); Dictionary\u003cstring, string\u003e ObtenirConfiguration(); } public class NotificationEmail : INotifiable, IConfigurable { public bool EstActif { get; set; } = true; public string AdresseEmail { get; set; } public string ServeurSMTP { get; set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"ğŸ“§ Email envoyÃ© Ã  {AdresseEmail}: {message}\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"email\")) AdresseEmail = parametres[\"email\"]; if (parametres.ContainsKey(\"smtp\")) ServeurSMTP = parametres[\"smtp\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"email\", AdresseEmail }, { \"smtp\", ServeurSMTP } }; } } public class NotificationSMS : INotifiable, IConfigurable { public bool EstActif { get; set; } = true; public string NumeroTelephone { get; set; } public string FournisseurSMS { get; set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"ğŸ“± SMS envoyÃ© au {NumeroTelephone}: {message}\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"telephone\")) NumeroTelephone = parametres[\"telephone\"]; if (parametres.ContainsKey(\"fournisseur\")) FournisseurSMS = parametres[\"fournisseur\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"telephone\", NumeroTelephone }, { \"fournisseur\", FournisseurSMS } }; } } public class GestionnaireNotifications { private List\u003cINotifiable\u003e _canaux = new List\u003cINotifiable\u003e(); public void AjouterCanal(INotifiable canal) { _canaux.Add(canal); } public void EnvoyerATous(string message) { foreach (var canal in _canaux) { canal.EnvoyerNotification(message); } } } ImplÃ©mentation explicite dâ€™interface UtilisÃ©e pour Ã©viter les conflits de noms entre plusieurs interfaces.\npublic interface IAnimal { void Manger(); } public interface IRobot { void Manger(); // MÃªme nom de mÃ©thode } public class CyberChien : IAnimal, IRobot { // ImplÃ©mentation explicite de IAnimal.Manger void IAnimal.Manger() { Console.WriteLine(\"Le cyber-chien mange de la vraie nourriture\"); } // ImplÃ©mentation explicite de IRobot.Manger void IRobot.Manger() { Console.WriteLine(\"Le cyber-chien recharge ses batteries\"); } // MÃ©thode publique normale public void SeReposer() { Console.WriteLine(\"Le cyber-chien se met en veille\"); } } // Utilisation var cyberChien = new CyberChien(); // cyberChien.Manger(); // ERREUR: ambiguÃ¯tÃ© IAnimal animal = cyberChien; animal.Manger(); // Appelle IAnimal.Manger IRobot robot = cyberChien; robot.Manger(); // Appelle IRobot.Manger cyberChien.SeReposer(); // OK 9. Concepts AvancÃ©s 9.1 Membres statiques Les membres statiques appartiennent Ã  la classe plutÃ´t quâ€™Ã  une instance.\npublic class Compteur { // Champ statique (partagÃ© par toutes les instances) private static int _nombreInstances = 0; // PropriÃ©tÃ© statique public static int NombreInstances { get { return _nombreInstances; } } // Champ d'instance public int Id { get; private set; } // Constructeur public Compteur() { _nombreInstances++; Id = _nombreInstances; } // MÃ©thode statique public static void Reinitialiser() { _nombreInstances = 0; } // MÃ©thode d'instance public void AfficherInfo() { Console.WriteLine($\"Instance #{Id} - Total: {NombreInstances}\"); } } // Constructeur statique (appelÃ© une seule fois avant la premiÃ¨re utilisation) public class Configuration { public static string CheminFichier { get; private set; } static Configuration() { Console.WriteLine(\"Initialisation de la configuration...\"); CheminFichier = \"config.json\"; } } // Utilisation var c1 = new Compteur(); // NombreInstances = 1 var c2 = new Compteur(); // NombreInstances = 2 var c3 = new Compteur(); // NombreInstances = 3 Console.WriteLine(Compteur.NombreInstances); // 3 c2.AfficherInfo(); // Instance #2 - Total: 3 9.2 Classes statiques Une classe statique ne peut contenir que des membres statiques et ne peut pas Ãªtre instanciÃ©e.\npublic static class Utilitaires { public static double CalculerMoyenne(params double[] nombres) { if (nombres.Length == 0) return 0; return nombres.Average(); } public static string FormaterMonnaie(decimal montant) { return $\"{montant:C}\"; } public static T Max\u003cT\u003e(T a, T b) where T : IComparable\u003cT\u003e { return a.CompareTo(b) \u003e 0 ? a : b; } } // Utilisation double moyenne = Utilitaires.CalculerMoyenne(10, 20, 30, 40); string prix = Utilitaires.FormaterMonnaie(99.99m); int maximum = Utilitaires.Max(5, 10); 9.3 Classes partielles (Partial Classes) Permettent de diviser la dÃ©finition dâ€™une classe en plusieurs fichiers.\n// Fichier: Personne.cs public partial class Personne { public string Nom { get; set; } public string Prenom { get; set; } partial void OnNomChanged(); } // Fichier: Personne.Methodes.cs public partial class Personne { public void SePresenter() { Console.WriteLine($\"Je suis {Prenom} {Nom}\"); } partial void OnNomChanged() { Console.WriteLine(\"Le nom a Ã©tÃ© modifiÃ©\"); } } 9.4 DÃ©lÃ©guÃ©s et Ã‰vÃ©nements (aperÃ§u) // DÃ©lÃ©guÃ© (type pointeur de fonction) public delegate void NotificationHandler(string message); public class Compte { // Ã‰vÃ©nement public event NotificationHandler SoldeModifie; private decimal _solde; public decimal Solde { get { return _solde; } set { _solde = value; // DÃ©clencher l'Ã©vÃ©nement SoldeModifie?.Invoke($\"Nouveau solde: {_solde:C}\"); } } } // Utilisation var compte = new Compte(); compte.SoldeModifie += (msg) =\u003e Console.WriteLine($\"Notification: {msg}\"); compte.Solde = 100; // DÃ©clenche l'Ã©vÃ©nement 9.5 GÃ©nÃ©riques (Generics) // Classe gÃ©nÃ©rique public class Boite\u003cT\u003e { private T _contenu; public void Ranger(T item) { _contenu = item; } public T Recuperer() { return _contenu; } } // Utilisation var boiteEntiers = new Boite\u003cint\u003e(); boiteEntiers.Ranger(42); int nombre = boiteEntiers.Recuperer(); var boiteTexte = new Boite\u003cstring\u003e(); boiteTexte.Ranger(\"Bonjour\"); string texte = boiteTexte.Recuperer(); // Classe gÃ©nÃ©rique avec contraintes public class Repository\u003cT\u003e where T : class, new() { private List\u003cT\u003e _items = new List\u003cT\u003e(); public void Ajouter(T item) { _items.Add(item); } public T Creer() { return new T(); // Possible grÃ¢ce Ã  la contrainte 'new()' } } 9.6 Extension Methods // Classe statique pour les mÃ©thodes d'extension public static class StringExtensions { // MÃ©thode d'extension (noter le 'this' devant le premier paramÃ¨tre) public static bool EstEmail(this string texte) { return texte.Contains(\"@\") \u0026\u0026 texte.Contains(\".\"); } public static string Inverser(this string texte) { char[] chars = texte.ToCharArray(); Array.Reverse(chars); return new string(chars); } public static int CompterMots(this string texte) { return texte.Split(new[] { ' ', '\\t', '\\n' }, StringSplitOptions.RemoveEmptyEntries).Length; } } // Utilisation string email = \"test@example.com\"; bool valide = email.EstEmail(); // true string mot = \"Bonjour\"; string inverse = mot.Inverser(); // \"ruojnoB\" string phrase = \"Ceci est une phrase\"; int mots = phrase.CompterMots(); // 4 9.7 Records (C# 9.0+) Les records sont des types de rÃ©fÃ©rence immuables optimisÃ©s pour stocker des donnÃ©es.\n// Record simple public record Personne(string Nom, string Prenom, int Age); // Utilisation var p1 = new Personne(\"Tremblay\", \"Marie\", 25); var p2 = new Personne(\"Tremblay\", \"Marie\", 25); Console.WriteLine(p1 == p2); // true (Ã©galitÃ© par valeur) // Expression 'with' pour crÃ©er une copie modifiÃ©e var p3 = p1 with { Age = 26 }; // Record avec propriÃ©tÃ©s additionnelles public record Employe(string Nom, string Prenom, decimal Salaire) { public string Departement { get; init; } = \"Non assignÃ©\"; public decimal CalculerSalaireAnnuel() =\u003e Salaire * 12; } RÃ©sumÃ© des concepts clÃ©s Quand utiliser quoi ? Concept Utilisation Classe normale Objets avec Ã©tat et comportement Classe abstraite Base commune avec implÃ©mentation partielle Interface Contrat sans implÃ©mentation, hÃ©ritage multiple Classe statique MÃ©thodes utilitaires sans Ã©tat Record DonnÃ©es immuables Sealed class EmpÃªcher lâ€™hÃ©ritage Partial class Diviser une classe en plusieurs fichiers Modificateurs dâ€™accÃ¨s (du plus au moins restrictif) private - Classe uniquement protected - Classe et dÃ©rivÃ©es internal - Assembly actuel protected internal - Assembly ou dÃ©rivÃ©es public - Partout Principes SOLID Single Responsibility: Une classe = une responsabilitÃ© Open/Closed: Ouvert Ã  lâ€™extension, fermÃ© Ã  la modification Liskov Substitution: Les sous-classes doivent pouvoir remplacer leurs classes de base Interface Segregation: Interfaces petites et spÃ©cifiques Dependency Inversion: DÃ©pendre des abstractions, pas des implÃ©mentations concrÃ¨tes Exercices pratiques Exercice 1 : CrÃ©er une hiÃ©rarchie de comptes bancaires CrÃ©ez une classe de base CompteBancaire et des classes dÃ©rivÃ©es CompteEpargne et CompteCourant avec des comportements diffÃ©rents.\nExercice 2 : SystÃ¨me de formes gÃ©omÃ©triques CrÃ©ez une classe abstraite Forme avec des mÃ©thodes pour calculer lâ€™aire et le pÃ©rimÃ¨tre. ImplÃ©mentez des classes concrÃ¨tes comme Cercle, Carre, Triangle.\nExercice 3 : Gestion dâ€™une bibliothÃ¨que Utilisez des interfaces IEmpruntable, IReservable pour crÃ©er un systÃ¨me de gestion de livres, DVD, magazines.\nExercice 4 : Simulateur de zoo CrÃ©ez une hiÃ©rarchie dâ€™animaux avec des interfaces pour diffÃ©rents comportements (voler, nager, grimper).",
    "description": "Table des matiÃ¨res Introduction Ã  la POO Les Classes et les Objets Les Attributs (Champs) Les PropriÃ©tÃ©s (Properties) Lâ€™Encapsulation Les MÃ©thodes Les Constructeurs Lâ€™HÃ©ritage Le Polymorphisme 1. Introduction Ã  la POO 1.1 Quâ€™est-ce que la Programmation OrientÃ©e Objet ? La Programmation OrientÃ©e Objet (POO) est un paradigme de programmation qui organise le code autour du concept dâ€™objets plutÃ´t que de fonctions et de logique. Un objet combine des donnÃ©es (ce quâ€™il possÃ¨de) et des comportements (ce quâ€™il peut faire).",
    "tags": [],
    "title": "Programmation orientÃ©e objet - partie 1",
    "uri": "/420-413/poo/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Table des matiÃ¨res Le mot-clÃ© Virtual Le mot-clÃ© Abstract Le mot-clÃ© Sealed Les Classes Abstraites Les Interfaces Membres Statiques Cours POO C# - Partie 2 : Concepts AvancÃ©s 10. Le mot-clÃ© Virtual 10.1 DÃ©finition Le mot-clÃ© virtual permet de dÃ©clarer une mÃ©thode qui peut Ãªtre redÃ©finie (override) dans les classes dÃ©rivÃ©es. Câ€™est la base du polymorphisme dâ€™exÃ©cution en C#.\nConcepts clÃ©s :\nUne mÃ©thode virtual a une implÃ©mentation dans la classe de base Les classes dÃ©rivÃ©es peuvent (mais ne sont pas obligÃ©es) la redÃ©finir Si elles ne la redÃ©finissent pas, elles utilisent lâ€™implÃ©mentation de base Analogie : Câ€™est comme une recette de base que vous pouvez personnaliser. La recette originale existe et fonctionne, mais vous pouvez lâ€™adapter Ã  votre goÃ»t.\n10.2 Syntaxe et Utilisation // ========================================== // CLASSE DE BASE avec mÃ©thode virtual // ========================================== public class Animal { protected string _nom; public Animal(string nom) { _nom = nom; } // ========================================== // MÃ‰THODE VIRTUAL - Peut Ãªtre redÃ©finie // ========================================== public virtual void EmettreS on() { Console.WriteLine($\"{_nom} Ã©met un son gÃ©nÃ©rique.\"); } // ========================================== // MÃ‰THODE NORMALE (non-virtual) - Ne peut PAS Ãªtre redÃ©finie polymorphiquement // ========================================== public void Dormir() { Console.WriteLine($\"{_nom} dort.\"); } } // ========================================== // CLASSE DÃ‰RIVÃ‰E - RedÃ©finit la mÃ©thode virtual // ========================================== public class Chien : Animal { public Chien(string nom) : base(nom) { } // ========================================== // OVERRIDE - RedÃ©finition de la mÃ©thode virtual // ========================================== public override void EmettreSound() { Console.WriteLine($\"{_nom} aboie: Wouf wouf!\"); } } public class Chat : Animal { public Chat(string nom) : base(nom) { } public override void EmettreSound() { Console.WriteLine($\"{_nom} miaule: Miaou!\"); } } public class Vache : Animal { public Vache(string nom) : base(nom) { } public override void EmettreSound() { Console.WriteLine($\"{_nom} meugle: Meuh!\"); } } // ========================================== // DÃ‰MONSTRATION DU POLYMORPHISME // ========================================== class Program { static void Main() { // CrÃ©ation d'objets de types diffÃ©rents Animal animal1 = new Chien(\"Rex\"); Animal animal2 = new Chat(\"FÃ©lix\"); Animal animal3 = new Vache(\"Marguerite\"); Animal animal4 = new Animal(\"CrÃ©ature\"); // ========================================== // POLYMORPHISME EN ACTION // MÃªme appel de mÃ©thode, comportements diffÃ©rents // ========================================== animal1.EmettreSound(); // Rex aboie: Wouf wouf! animal2.EmettreSound(); // FÃ©lix miaule: Miaou! animal3.EmettreSound(); // Marguerite meugle: Meuh! animal4.EmettreSound(); // CrÃ©ature Ã©met un son gÃ©nÃ©rique. // ========================================== // UTILISATION PRATIQUE : Tableau polymorphe // ========================================== Animal[] animaux = new Animal[] { new Chien(\"Max\"), new Chat(\"Minou\"), new Vache(\"Bella\"), new Chien(\"Rocky\") }; Console.WriteLine(\"\\n=== Concert animalier ===\"); foreach (Animal animal in animaux) { animal.EmettreSound(); // Appelle la bonne version automatiquement } } } Affichage :\nRex aboie: Wouf wouf!\rFÃ©lix miaule: Miaou!\rMarguerite meugle: Meuh!\rCrÃ©ature Ã©met un son gÃ©nÃ©rique.\r=== Concert animalier ===\rMax aboie: Wouf wouf!\rMinou miaule: Miaou!\rBella meugle: Meuh!\rRocky aboie: Wouf wouf! 10.3 Exemple Complet : SystÃ¨me de Calcul de Salaire public class Employe { public string Nom { get; set; } public decimal SalaireBase { get; set; } public Employe(string nom, decimal salaireBase) { Nom = nom; SalaireBase = salaireBase; } // ========================================== // MÃ‰THODE VIRTUAL - Calcul de base // ========================================== public virtual decimal CalculerSalaire() { Console.WriteLine($\"[Employe] Calcul standard pour {Nom}\"); return SalaireBase; } public virtual void AfficherDetails() { Console.WriteLine($\"\\n=== {Nom} ===\"); Console.WriteLine($\"Type: EmployÃ©\"); Console.WriteLine($\"Salaire de base: {SalaireBase:C}\"); Console.WriteLine($\"Salaire total: {CalculerSalaire():C}\"); } } public class Manager : Employe { public decimal Prime { get; set; } public Manager(string nom, decimal salaireBase, decimal prime) : base(nom, salaireBase) { Prime = prime; } // ========================================== // OVERRIDE - RedÃ©finition pour Manager // ========================================== public override decimal CalculerSalaire() { Console.WriteLine($\"[Manager] Calcul avec prime pour {Nom}\"); return SalaireBase + Prime; } public override void AfficherDetails() { base.AfficherDetails(); // Appelle la version de base Console.WriteLine($\"Prime: {Prime:C}\"); } } public class Vendeur : Employe { public decimal CommissionPourcentage { get; set; } public decimal VentesTotales { get; set; } public Vendeur(string nom, decimal salaireBase, decimal commission) : base(nom, salaireBase) { CommissionPourcentage = commission; } public override decimal CalculerSalaire() { Console.WriteLine($\"[Vendeur] Calcul avec commission pour {Nom}\"); decimal commission = VentesTotales * (CommissionPourcentage / 100); return SalaireBase + commission; } public override void AfficherDetails() { base.AfficherDetails(); Console.WriteLine($\"Commission: {CommissionPourcentage}%\"); Console.WriteLine($\"Ventes: {VentesTotales:C}\"); } } public class Stagiaire : Employe { public int HeuresTravaillees { get; set; } public decimal TauxHoraire { get; set; } public Stagiaire(string nom, decimal tauxHoraire) : base(nom, 0) // Pas de salaire de base { TauxHoraire = tauxHoraire; } public override decimal CalculerSalaire() { Console.WriteLine($\"[Stagiaire] Calcul horaire pour {Nom}\"); return HeuresTravaillees * TauxHoraire; } public override void AfficherDetails() { Console.WriteLine($\"\\n=== {Nom} ===\"); Console.WriteLine($\"Type: Stagiaire\"); Console.WriteLine($\"Taux horaire: {TauxHoraire:C}\"); Console.WriteLine($\"Heures travaillÃ©es: {HeuresTravaillees}h\"); Console.WriteLine($\"Salaire total: {CalculerSalaire():C}\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // ========================================== // CrÃ©ation d'employÃ©s de diffÃ©rents types // ========================================== Employe e1 = new Employe(\"Alice\", 3000); Manager m1 = new Manager(\"Bob\", 4000, 1000); Vendeur v1 = new Vendeur(\"Charlie\", 2500, 5) { VentesTotales = 50000 }; Stagiaire s1 = new Stagiaire(\"David\", 15) { HeuresTravaillees = 120 }; // ========================================== // POLYMORPHISME : Liste hÃ©tÃ©rogÃ¨ne // ========================================== List\u003cEmploye\u003e employes = new List\u003cEmploye\u003e { e1, m1, v1, s1 }; Console.WriteLine(\"=== CALCUL DES SALAIRES ===\\n\"); decimal masseSalariale = 0; foreach (Employe employe in employes) { // Appelle la bonne version de CalculerSalaire() // automatiquement selon le type rÃ©el decimal salaire = employe.CalculerSalaire(); masseSalariale += salaire; employe.AfficherDetails(); } Console.WriteLine($\"\\n=== TOTAL ===\"); Console.WriteLine($\"Masse salariale totale: {masseSalariale:C}\"); } } 10.4 RÃ¨gles Importantes de virtual et override public class ClasseBase { // âœ… MÃ©thode virtual - Peut Ãªtre redÃ©finie public virtual void Methode1() { } // âœ… MÃ©thode normale - Ne peut pas Ãªtre redÃ©finie polymorphiquement public void Methode2() { } // âœ… PropriÃ©tÃ© virtual public virtual string Propriete { get; set; } } public class ClasseDerivee : ClasseBase { // âœ… OK - Override d'une mÃ©thode virtual public override void Methode1() { } // âŒ ERREUR - Ne peut pas override une mÃ©thode non-virtual // public override void Methode2() { } // âœ… OK - Override d'une propriÃ©tÃ© virtual public override string Propriete { get; set; } // âš ï¸ ATTENTION - Masquage avec 'new' (pas polymorphique) public new void Methode2() { // Ceci n'est PAS du polymorphisme // C'est du \"masquage\" (hiding) } } DiffÃ©rence entre override et new :\npublic class Base { public virtual void Afficher() { Console.WriteLine(\"Base.Afficher()\"); } } public class Derivee1 : Base { public override void Afficher() // OVERRIDE { Console.WriteLine(\"Derivee1.Afficher()\"); } } public class Derivee2 : Base { public new void Afficher() // NEW (masquage) { Console.WriteLine(\"Derivee2.Afficher()\"); } } // Test Base b1 = new Derivee1(); b1.Afficher(); // \"Derivee1.Afficher()\" - POLYMORPHISME âœ… Base b2 = new Derivee2(); b2.Afficher(); // \"Base.Afficher()\" - PAS de polymorphisme âš ï¸ Derivee2 d2 = new Derivee2(); d2.Afficher(); // \"Derivee2.Afficher()\" - Appelle la version masquÃ©e 11. Le mot-clÃ© Abstract 11.1 DÃ©finition Le mot-clÃ© abstract permet de dÃ©clarer :\nDes classes abstraites : Classes incomplÃ¨tes qui ne peuvent pas Ãªtre instanciÃ©es Des mÃ©thodes abstraites : MÃ©thodes sans implÃ©mentation qui DOIVENT Ãªtre redÃ©finies dans les classes dÃ©rivÃ©es DiffÃ©rence avec virtual :\nvirtual : MÃ©thode avec implÃ©mentation, redÃ©finition optionnelle abstract : MÃ©thode sans implÃ©mentation, redÃ©finition obligatoire Analogie :\nUne classe abstraite est comme un plan architectural incomplet Elle dÃ©finit la structure mais certaines parties doivent Ãªtre complÃ©tÃ©es Vous ne pouvez pas habiter dans un plan, vous devez construire la maison complÃ¨te 11.2 MÃ©thodes Abstraites public abstract class Forme { protected string _nom; protected string _couleur; public Forme(string nom, string couleur) { _nom = nom; _couleur = couleur; } // ========================================== // MÃ‰THODE ABSTRAITE - Pas d'implÃ©mentation // DOIT Ãªtre redÃ©finie dans les classes dÃ©rivÃ©es // ========================================== public abstract double CalculerAire(); public abstract double CalculerPerimetre(); // ========================================== // MÃ‰THODE CONCRÃˆTE - A une implÃ©mentation // ========================================== public void AfficherInfos() { Console.WriteLine($\"\\n{_nom} ({_couleur})\"); Console.WriteLine($\"Aire: {CalculerAire():F2}\"); Console.WriteLine($\"PÃ©rimÃ¨tre: {CalculerPerimetre():F2}\"); } } // ========================================== // CLASSE DÃ‰RIVÃ‰E - DOIT implÃ©menter les mÃ©thodes abstraites // ========================================== public class Cercle : Forme { private double _rayon; public Cercle(double rayon, string couleur) : base(\"Cercle\", couleur) { _rayon = rayon; } // ========================================== // IMPLÃ‰MENTATION OBLIGATOIRE // ========================================== public override double CalculerAire() { return Math.PI * _rayon * _rayon; } public override double CalculerPerimetre() { return 2 * Math.PI * _rayon; } } public class Rectangle : Forme { private double _longueur; private double _largeur; public Rectangle(double longueur, double largeur, string couleur) : base(\"Rectangle\", couleur) { _longueur = longueur; _largeur = largeur; } public override double CalculerAire() { return _longueur * _largeur; } public override double CalculerPerimetre() { return 2 * (_longueur + _largeur); } } // ========================================== // SI on oublie d'implÃ©menter une mÃ©thode abstraite â†’ ERREUR // ========================================== /* public class Triangle : Forme // âŒ ERREUR DE COMPILATION { // Erreur: Triangle ne redÃ©finit pas les mÃ©thodes abstraites } */ // ========================================== // UTILISATION // ========================================== class Program { static void Main() { // âŒ ERREUR - Impossible d'instancier une classe abstraite // Forme f = new Forme(\"Test\", \"Rouge\"); // âœ… OK - Instanciation des classes concrÃ¨tes Forme cercle = new Cercle(5, \"Rouge\"); Forme rectangle = new Rectangle(4, 6, \"Bleu\"); // Polymorphisme cercle.AfficherInfos(); rectangle.AfficherInfos(); // Liste polymorphe List\u003cForme\u003e formes = new List\u003cForme\u003e { new Cercle(3, \"Vert\"), new Rectangle(5, 2, \"Jaune\"), new Cercle(7, \"Orange\") }; double aireTotal e = 0; foreach (Forme forme in formes) { aireTotal += forme.CalculerAire(); } Console.WriteLine($\"\\nAire totale: {aireTotal:F2}\"); } } 11.3 PropriÃ©tÃ©s Abstraites Les propriÃ©tÃ©s peuvent aussi Ãªtre abstraites.\npublic abstract class Vehicule { // ========================================== // PROPRIÃ‰TÃ‰ ABSTRAITE // ========================================== public abstract int NombreRoues { get; } public abstract string TypeCarburant { get; set; } public void AfficherInfos() { Console.WriteLine($\"VÃ©hicule Ã  {NombreRoues} roues\"); Console.WriteLine($\"Carburant: {TypeCarburant}\"); } } public class Voiture : Vehicule { public override int NombreRoues { get { return 4; } } private string _typeCarburant; public override string TypeCarburant { get { return _typeCarburant; } set { _typeCarburant = value; } } public Voiture() { _typeCarburant = \"Essence\"; } } public class Moto : Vehicule { public override int NombreRoues { get { return 2; } } public override string TypeCarburant { get; set; } = \"Essence\"; } 11.4 Combinaison de Virtual et Abstract Une classe abstraite peut contenir un mÃ©lange de mÃ©thodes abstraites, virtuelles et concrÃ¨tes.\npublic abstract class Animal { protected string _nom; public Animal(string nom) { _nom = nom; } // ========================================== // MÃ‰THODE ABSTRAITE - ImplÃ©mentation obligatoire // ========================================== public abstract void EmettreSound(); // ========================================== // MÃ‰THODE VIRTUELLE - RedÃ©finition optionnelle // ========================================== public virtual void Manger() { Console.WriteLine($\"{_nom} mange.\"); } // ========================================== // MÃ‰THODE CONCRÃˆTE - ImplÃ©mentation finale // ========================================== public void Dormir() { Console.WriteLine($\"{_nom} dort.\"); } } public class Chien : Animal { public Chien(string nom) : base(nom) { } // OBLIGATOIRE - MÃ©thode abstraite public override void EmettreSound() { Console.WriteLine($\"{_nom} aboie!\"); } // OPTIONNEL - MÃ©thode virtuelle public override void Manger() { Console.WriteLine($\"{_nom} dÃ©vore ses croquettes!\"); } // Dormir() est hÃ©ritÃ© tel quel } 12. Le mot-clÃ© Sealed 12.1 DÃ©finition Le mot-clÃ© sealed empÃªche lâ€™hÃ©ritage ou la redÃ©finition :\nClasse sealed : Aucune classe ne peut en hÃ©riter MÃ©thode sealed : Aucune classe dÃ©rivÃ©e ne peut la redÃ©finir Pourquoi utiliser sealed ?\nSÃ©curitÃ© : EmpÃªcher les modifications non dÃ©sirÃ©es Performance : Optimisations possibles par le compilateur Design : Indiquer quâ€™une classe est â€œcomplÃ¨teâ€ et finale Analogie : Câ€™est comme sceller un document avec de la cire. Une fois scellÃ©, il ne peut plus Ãªtre modifiÃ©.\n12.2 Classe Sealed // ========================================== // CLASSE SEALED - Ne peut pas Ãªtre hÃ©ritÃ©e // ========================================== public sealed class MathUtils { public static double CalculerMoyenne(params double[] nombres) { return nombres.Average(); } public static int Max(int a, int b) { return a \u003e b ? a : b; } } // âŒ ERREUR DE COMPILATION - Impossible d'hÃ©riter d'une classe sealed /* public class MesUtils : MathUtils { // Erreur: cannot derive from sealed type 'MathUtils' } */ Exemples de classes sealed dans .NET :\nString : sealed (impossible dâ€™hÃ©riter de string) Int32, Double, etc. : sealed DateTime : sealed // âŒ Impossible // public class MaChaine : String { } // âœ… Utilisation normale string texte = \"Bonjour\"; 12.3 MÃ©thode Sealed Une mÃ©thode sealed empÃªche sa redÃ©finition dans les classes dÃ©rivÃ©es ultÃ©rieures.\nImportant : Une mÃ©thode ne peut Ãªtre sealed que si elle override dÃ©jÃ  une mÃ©thode.\npublic class Animal { public virtual void EmettreSound() { Console.WriteLine(\"Son animal\"); } } public class Mammifere : Animal { // ========================================== // OVERRIDE + SEALED // Cette version est finale, ne peut plus Ãªtre redÃ©finie // ========================================== public sealed override void EmettreSound() { Console.WriteLine(\"Son de mammifÃ¨re\"); } } public class Chien : Mammifere { // âŒ ERREUR - Ne peut pas override une mÃ©thode sealed /* public override void EmettreSound() { Console.WriteLine(\"Wouf!\"); } */ // âœ… OK - MÃ©thode diffÃ©rente (pas un override) public void Aboyer() { Console.WriteLine(\"Wouf!\"); } } 12.4 Cas dâ€™Usage de Sealed Exemple 1 : Classe Utilitaire ComplÃ¨te // Classe utilitaire qui ne devrait jamais Ãªtre modifiÃ©e public sealed class ConfigurationManager { private static ConfigurationManager _instance; private Dictionary\u003cstring, string\u003e _settings; private ConfigurationManager() { _settings = new Dictionary\u003cstring, string\u003e(); ChargerConfiguration(); } public static ConfigurationManager Instance { get { if (_instance == null) _instance = new ConfigurationManager(); return _instance; } } private void ChargerConfiguration() { // Chargement de la configuration } public string ObtenirValeur(string cle) { return _settings.ContainsKey(cle) ? _settings[cle] : null; } } // Impossible d'hÃ©riter pour modifier le comportement Exemple 2 : MÃ©thode Sealed pour la SÃ©curitÃ© public class SystemeSÃ©curitÃ© { public virtual bool VerifierAcces(string utilisateur) { Console.WriteLine(\"VÃ©rification de base\"); return true; } } public class SystemeAvance : SystemeSÃ©curitÃ© { // Version finale de la vÃ©rification - ne doit plus Ãªtre modifiÃ©e public sealed override bool VerifierAcces(string utilisateur) { Console.WriteLine(\"VÃ©rification avancÃ©e (FINALE)\"); // Logique critique de sÃ©curitÃ© bool accesBase = base.VerifierAcces(utilisateur); bool verification2FA = Verifier2FA(utilisateur); bool verificationBiometrique = VerifierBiometrie(utilisateur); return accesBase \u0026\u0026 verification2FA \u0026\u0026 verificationBiometrique; } private bool Verifier2FA(string utilisateur) { return true; } private bool VerifierBiometrie(string utilisateur) { return true; } } // Aucune classe dÃ©rivÃ©e ne peut affaiblir la sÃ©curitÃ© public class SystemeTresAvance : SystemeAvance { // âŒ Ne peut pas override VerifierAcces // La sÃ©curitÃ© est garantie } 13. Les Classes Abstraites 13.1 DÃ©finition ComplÃ¨te Une classe abstraite est une classe dÃ©clarÃ©e avec le mot-clÃ© abstract qui :\nNe peut pas Ãªtre instanciÃ©e directement Peut contenir des mÃ©thodes abstraites (sans implÃ©mentation) ET des mÃ©thodes concrÃ¨tes (avec implÃ©mentation) Peut avoir des constructeurs (appelÃ©s par les classes dÃ©rivÃ©es) Peut avoir des attributs, propriÃ©tÃ©s, etc. Sert de modÃ¨le ou de base pour dâ€™autres classes Quand utiliser une classe abstraite ?\nQuand vous voulez dÃ©finir un comportement commun pour un groupe de classes Quand certaines mÃ©thodes doivent Ãªtre implÃ©mentÃ©es diffÃ©remment par chaque classe dÃ©rivÃ©e Quand vous voulez partager du code entre classes similaires Quand la classe reprÃ©sente un concept abstrait qui ne devrait pas exister seul 13.2 Anatomie ComplÃ¨te dâ€™une Classe Abstraite public abstract class Vehicule { // ========================================== // 1. ATTRIBUTS (comme une classe normale) // ========================================== protected string _marque; protected string _modele; private int _annee; protected double _kilometrage; // ========================================== // 2. PROPRIÃ‰TÃ‰S // ========================================== public string Marque { get { return _marque; } } public string Modele { get { return _modele; } } public int Annee { get { return _annee; } } public double Kilometrage { get { return _kilometrage; } } // ========================================== // 3. CONSTRUCTEUR (Oui, les classes abstraites peuvent en avoir!) // ========================================== protected Vehicule(string marque, string modele, int annee) { _marque = marque; _modele = modele; _annee = annee; _kilometrage = 0; Console.WriteLine($\"Constructeur de Vehicule appelÃ© pour {marque} {modele}\"); } // ========================================== // 4. MÃ‰THODES ABSTRAITES - ImplÃ©mentation obligatoire // ========================================== public abstract void Demarrer(); public abstract double CalculerConsommation(double distance); public abstract string ObtenirTypeCarburant(); // ========================================== // 5. MÃ‰THODES VIRTUELLES - RedÃ©finition optionnelle // ========================================== public virtual void Accelerer(int vitesse) { Console.WriteLine($\"Le vÃ©hicule accÃ©lÃ¨re Ã  {vitesse} km/h\"); } public virtual void Klaxonner() { Console.WriteLine(\"Beep beep!\"); } // ========================================== // 6. MÃ‰THODES CONCRÃˆTES - HÃ©ritÃ©es telles quelles // ========================================== public void Rouler(double distance) { _kilometrage += distance; double consommation = CalculerConsommation(distance); // Appelle la mÃ©thode abstraite Console.WriteLine($\"Parcouru {distance} km. Consommation: {consommation:F2}L\"); Console.WriteLine($\"KilomÃ©trage total: {_kilometrage} km\"); } public void AfficherInfos() { Console.WriteLine($\"\\n=== {_marque} {_modele} ({_annee}) ===\"); Console.WriteLine($\"Type de carburant: {ObtenirTypeCarburant()}\"); Console.WriteLine($\"KilomÃ©trage: {_kilometrage} km\"); } // ========================================== // 7. PROPRIÃ‰TÃ‰S ABSTRAITES // ========================================== public abstract int NombreRoues { get; } } 13.3 ImplÃ©mentation de la Classe Abstraite // ========================================== // CLASSE CONCRÃˆTE 1 : Voiture // ========================================== public class Voiture : Vehicule { private string _typeCarburant; private double _consommationAu100; private int _nombrePortes; public Voiture(string marque, string modele, int annee, int portes, string carburant, double consommation) : base(marque, modele, annee) // Appelle le constructeur abstrait { _nombrePortes = portes; _typeCarburant = carburant; _consommationAu100 = consommation; } // ImplÃ©mentation obligatoire des mÃ©thodes abstraites public override void Demarrer() { Console.WriteLine($\"La voiture {_marque} {_modele} dÃ©marre avec la clÃ©.\"); } public override double CalculerConsommation(double distance) { return (distance / 100) * _consommationAu100; } public override string ObtenirTypeCarburant() { return _typeCarburant; } // ImplÃ©mentation de la propriÃ©tÃ© abstraite public override int NombreRoues { get { return 4; } } // RedÃ©finition optionnelle d'une mÃ©thode virtuelle public override void Klaxonner() { Console.WriteLine(\"La voiture klaxonne: BEEP BEEP!\"); } // Nouvelle mÃ©thode spÃ©cifique public void OuvrirCoffre() { Console.WriteLine(\"Coffre ouvert\"); } } // ========================================== // CLASSE CONCRÃˆTE 2 : Moto // ========================================== public class Moto : Vehicule { private bool _aSidecar; private double _consommationAu100; public Moto(string marque, string modele, int annee, bool sidecar, double consommation) : base(marque, modele, annee) { _aSidecar = sidecar; _consommationAu100 = consommation; } public override void Demarrer() { Console.WriteLine($\"La moto {_marque} {_modele} dÃ©marre avec le bouton start.\"); } public override double CalculerConsommation(double distance) { double consommation = (distance / 100) * _consommationAu100; if (_aSidecar) consommation *= 1.2; // 20% de plus avec sidecar return consommation; } public override string ObtenirTypeCarburant() { return \"Essence\"; } public override int NombreRoues { get { return _aSidecar ? 3 : 2; } } // Utilise la mÃ©thode virtuelle hÃ©ritÃ©e (pas de redÃ©finition) // Donc Klaxonner() sera \"Beep beep!\" de la classe de base } // ========================================== // CLASSE CONCRÃˆTE 3 : Camion // ========================================== public class Camion : Vehicule { private double _capaciteChargeTonnes; private double _consommationAu100; private double _chargeActuelle; public Camion(string marque, string modele, int annee, double capacite, double consommation) : base(marque, modele, annee) { _capaciteChargeTonnes = capacite; _consommationAu100 = consommation; _chargeActuelle = 0; } public override void Demarrer() { Console.WriteLine($\"Le camion {_marque} {_modele} dÃ©marre avec un vrombissement.\"); } public override double CalculerConsommation(double distance) { double baseConsommation = (distance / 100) * _consommationAu100; // Consommation augmente avec la charge double facteurCharge = 1 + (_chargeActuelle / _capaciteChargeTonnes) * 0.5; return baseConsommation * facteurCharge; } public override string ObtenirTypeCarburant() { return \"Diesel\"; } public override int NombreRoues { get { return 18; } } public void Charger(double poids) { if (_chargeActuelle + poids \u003c= _capaciteChargeTonnes) { _chargeActuelle += poids; Console.WriteLine($\"Chargement de {poids}t. Charge totale: {_chargeActuelle}t\"); } else { Console.WriteLine($\"Impossible! CapacitÃ© dÃ©passÃ©e.\"); } } } 13.4 Utilisation Polymorphe class Program { static void Main() { // âŒ IMPOSSIBLE - Classe abstraite // Vehicule v = new Vehicule(\"Test\", \"Test\", 2020); // âœ… OK - Classes concrÃ¨tes Vehicule voiture = new Voiture(\"Toyota\", \"Camry\", 2023, 4, \"Essence\", 7.5); Vehicule moto = new Moto(\"Harley\", \"Davidson\", 2022, false, 4.5); Vehicule camion = new Camion(\"Volvo\", \"FH16\", 2021, 25, 30); // ========================================== // POLYMORPHISME EN ACTION // ========================================== List\u003cVehicule\u003e parc = new List\u003cVehicule\u003e { voiture, moto, camion }; Console.WriteLine(\"=== DÃ‰MARRAGE DE TOUS LES VÃ‰HICULES ===\\n\"); foreach (Vehicule vehicule in parc) { vehicule.Demarrer(); // Appelle la bonne version } Console.WriteLine(\"\\n=== TRAJET DE 100 KM ===\\n\"); foreach (Vehicule vehicule in parc) { vehicule.Rouler(100); vehicule.AfficherInfos(); } // ========================================== // UTILISATION SPÃ‰CIFIQUE // ========================================== if (camion is Camion c) { c.Charger(10); c.Rouler(50); // Consommation affectÃ©e par la charge } } } 13.5 Exemple Complet : SystÃ¨me de Paiement // ========================================== // CLASSE ABSTRAITE : Moyen de Paiement // ========================================== public abstract class MoyenPaiement { protected string _titulaire; protected DateTime _dateTransaction; public string Titulaire { get { return _titulaire; } } public DateTime DateTransaction { get { return _dateTransaction; } } protected MoyenPaiement(string titulaire) { _titulaire = titulaire; } // MÃ©thodes abstraites public abstract bool Payer(decimal montant); public abstract bool Verifier(); public abstract string ObtenirType(); // MÃ©thode virtuelle public virtual void AfficherRecu(decimal montant) { Console.WriteLine($\"\\n====== REÃ‡U DE PAIEMENT ======\"); Console.WriteLine($\"Titulaire: {_titulaire}\"); Console.WriteLine($\"Type: {ObtenirType()}\"); Console.WriteLine($\"Montant: {montant:C}\"); Console.WriteLine($\"Date: {_dateTransaction:F}\"); Console.WriteLine($\"==============================\\n\"); } // MÃ©thode concrÃ¨te protected void EnregistrerTransaction() { _dateTransaction = DateTime.Now; Console.WriteLine($\"[LOG] Transaction enregistrÃ©e pour {_titulaire}\"); } } // Classes concrÃ¨tes... // (voir continuation dans le message suivant) public class CarteCredit : MoyenPaiement { private string _numero; private DateTime _dateExpiration; private decimal _limiteCredit; private decimal _soldeUtilise; public CarteCredit(string titulaire, string numero, DateTime expiration, decimal limite) : base(titulaire) { _numero = numero; _dateExpiration = expiration; _limiteCredit = limite; _soldeUtilise = 0; } public override bool Verifier() { if (_dateExpiration \u003c DateTime.Now) { Console.WriteLine(\"âŒ Carte expirÃ©e\"); return false; } return true; } public override bool Payer(decimal montant) { if (!Verifier()) return false; if (_soldeUtilise + montant \u003e _limiteCredit) { Console.WriteLine($\"âŒ Limite de crÃ©dit dÃ©passÃ©e ({_limiteCredit:C})\"); return false; } _soldeUtilise += montant; EnregistrerTransaction(); Console.WriteLine($\"âœ… Paiement de {montant:C} effectuÃ© par carte de crÃ©dit\"); Console.WriteLine($\" Solde disponible: {_limiteCredit - _soldeUtilise:C}\"); return true; } public override string ObtenirType() { return \"Carte de CrÃ©dit\"; } } public class CompteBancaire : MoyenPaiement { private string _numeroCompte; private decimal _solde; public CompteBancaire(string titulaire, string numero, decimal soldeInitial) : base(titulaire) { _numeroCompte = numero; _solde = soldeInitial; } public override bool Verifier() { return true; // Toujours valide } public override bool Payer(decimal montant) { if (_solde \u003c montant) { Console.WriteLine($\"âŒ Solde insuffisant (Disponible: {_solde:C})\"); return false; } _solde -= montant; EnregistrerTransaction(); Console.WriteLine($\"âœ… Paiement de {montant:C} effectuÃ© par compte bancaire\"); Console.WriteLine($\" Nouveau solde: {_solde:C}\"); return true; } public override string ObtenirType() { return \"Compte Bancaire\"; } } // Utilisation List\u003cMoyenPaiement\u003e moyensPaiement = new List\u003cMoyenPaiement\u003e { new CarteCredit(\"Alice Martin\", \"1234-5678-9012-3456\", DateTime.Now.AddYears(2), 5000), new CompteBancaire(\"Bob Gagnon\", \"CA123456\", 2000) }; foreach (var moyen in moyensPaiement) { if (moyen.Payer(150)) { moyen.AfficherRecu(150); } } 14. Les Interfaces 14.1 DÃ©finition Approfondie Une interface est un contrat qui dÃ©finit un ensemble de membres (mÃ©thodes, propriÃ©tÃ©s, Ã©vÃ©nements) que les classes doivent implÃ©menter, sans fournir dâ€™implÃ©mentation.\nDiffÃ©rences clÃ©s : Interface vs Classe Abstraite\nAspect Interface Classe Abstraite ImplÃ©mentation Aucune (contrat pur) Peut contenir du code HÃ©ritage multiple âœ… Oui âŒ Non Constructeurs âŒ Non âœ… Oui Champs âŒ Non âœ… Oui Modificateurs dâ€™accÃ¨s Tous public VariÃ©s (private, protected, etc.) But DÃ©finir un comportement Partager du code commun Quand utiliser une interface ?\nDÃ©finir un comportement commun Ã  des classes sans relation hiÃ©rarchique Permettre lâ€™hÃ©ritage multiple de comportements CrÃ©er des contrats que diffÃ©rentes classes doivent respecter Favoriser le couplage faible dans votre architecture Analogie : Une interface est comme un certificat de compÃ©tence :\nUn pilote peut avoir : certificat voiture, certificat moto, certificat avion Chaque certificat garantit certaines compÃ©tences DiffÃ©rentes personnes peuvent avoir diffÃ©rentes combinaisons de certificats 14.2 DÃ©claration dâ€™une Interface // ========================================== // CONVENTION : PrÃ©fixe 'I' pour les interfaces // ========================================== public interface IVolant { // ========================================== // MÃ‰THODES (pas d'implÃ©mentation) // ========================================== void Voler(); void Atterrir(); // ========================================== // PROPRIÃ‰TÃ‰S (seulement les signatures) // ========================================== double AltitudeMaximale { get; } double Vitesse { get; set; } // ========================================== // TOUS les membres sont PUBLIC par dÃ©faut // Pas besoin de spÃ©cifier 'public' // ========================================== } public interface INageant { void Nager(); void Plonger(double profondeur); double ProfondeurMaximale { get; } } public interface IMarchant { void Marcher(); void Courir(); int VitesseMarche { get; } } 14.3 ImplÃ©mentation dâ€™Interfaces // ========================================== // Une classe peut implÃ©menter PLUSIEURS interfaces // ========================================== public class Canard : IVolant, INageant, IMarchant { private double _altitudeActuelle; private double _profondeurActuelle; // ========================================== // ImplÃ©mentation de IVolant // ========================================== public double AltitudeMaximale { get { return 1000; } } public double Vitesse { get; set; } public void Voler() { _altitudeActuelle = 100; Console.WriteLine($\"Le canard vole Ã  {_altitudeActuelle}m\"); } public void Atterrir() { _altitudeActuelle = 0; Console.WriteLine(\"Le canard atterrit\"); } // ========================================== // ImplÃ©mentation de INageant // ========================================== public double ProfondeurMaximale { get { return 5; } } public void Nager() { Console.WriteLine(\"Le canard nage Ã  la surface\"); } public void Plonger(double profondeur) { if (profondeur \u003c= ProfondeurMaximale) { _profondeurActuelle = profondeur; Console.WriteLine($\"Le canard plonge Ã  {profondeur}m\"); } else { Console.WriteLine(\"Trop profond!\"); } } // ========================================== // ImplÃ©mentation de IMarchant // ========================================== public int VitesseMarche { get { return 5; } } public void Marcher() { Console.WriteLine(\"Le canard se dandine\"); } public void Courir() { Console.WriteLine(\"Le canard court maladroitement\"); } } // ========================================== // Autre classe avec un sous-ensemble d'interfaces // ========================================== public class Avion : IVolant { public double AltitudeMaximale { get { return 12000; } } public double Vitesse { get; set; } public void Voler() { Console.WriteLine($\"L'avion vole Ã  {Vitesse} km/h\"); } public void Atterrir() { Console.WriteLine(\"L'avion atterrit sur la piste\"); } } public class Poisson : INageant { public double ProfondeurMaximale { get { return 500; } } public void Nager() { Console.WriteLine(\"Le poisson nage gracieusement\"); } public void Plonger(double profondeur) { Console.WriteLine($\"Le poisson plonge Ã  {profondeur}m\"); } } 14.4 Polymorphisme avec Interfaces class Program { static void Main() { // ========================================== // Collections polymorphes basÃ©es sur les interfaces // ========================================== // Tous les Ãªtres volants List\u003cIVolant\u003e volants = new List\u003cIVolant\u003e { new Canard(), new Avion { Vitesse = 800 }, new Canard() }; Console.WriteLine(\"=== DÃ‰COLLAGE ===\"); foreach (IVolant volant in volants) { volant.Voler(); // Polymorphisme! } // Tous les Ãªtres nageants List\u003cINageant\u003e nageants = new List\u003cINageant\u003e { new Canard(), new Poisson() }; Console.WriteLine(\"\\n=== PLONGÃ‰E ===\"); foreach (INageant nageant in nageants) { nageant.Nager(); nageant.Plonger(3); } // ========================================== // Le canard peut Ãªtre utilisÃ© comme 3 types diffÃ©rents // ========================================== Canard donald = new Canard(); IVolant v = donald; // RÃ©fÃ©rence comme IVolant INageant n = donald; // RÃ©fÃ©rence comme INageant IMarchant m = donald; // RÃ©fÃ©rence comme IMarchant v.Voler(); n.Nager(); m.Marcher(); } } 14.5 VÃ©rification de Type avec Interfaces public void TraiterAnimal(object animal) { // ========================================== // Test avec 'is' // ========================================== if (animal is IVolant) { Console.WriteLine(\"Cet animal peut voler!\"); } if (animal is INageant) { Console.WriteLine(\"Cet animal peut nager!\"); } // ========================================== // Cast avec 'as' // ========================================== IVolant volant = animal as IVolant; if (volant != null) { volant.Voler(); } // ========================================== // Pattern matching (C# 7+) // ========================================== if (animal is IVolant v) { Console.WriteLine($\"Altitude max: {v.AltitudeMaximale}m\"); v.Voler(); } } 14.6 ImplÃ©mentation Explicite dâ€™Interface UtilisÃ©e pour rÃ©soudre les conflits quand deux interfaces ont des membres avec le mÃªme nom.\npublic interface IAnimal { void Manger(); string Nom { get; } } public interface IRobot { void Manger(); // MÃªme nom! string Nom { get; } } public class CyberChien : IAnimal, IRobot { private string _nom; public CyberChien(string nom) { _nom = nom; } // ========================================== // IMPLÃ‰MENTATION EXPLICITE pour IAnimal // ========================================== void IAnimal.Manger() { Console.WriteLine($\"{_nom} mange de la nourriture organique\"); } string IAnimal.Nom { get { return $\"{_nom} (animal)\"; } } // ========================================== // IMPLÃ‰MENTATION EXPLICITE pour IRobot // ========================================== void IRobot.Manger() { Console.WriteLine($\"{_nom} recharge ses batteries\"); } string IRobot.Nom { get { return $\"{_nom} (robot)\"; } } // ========================================== // MÃ©thode publique normale // ========================================== public void SeReposer() { Console.WriteLine($\"{_nom} se met en veille\"); } } // Utilisation CyberChien cyber = new CyberChien(\"RoboDog\"); // âŒ ERREUR - AmbiguÃ¯tÃ© // cyber.Manger(); // âœ… OK - Cast explicite IAnimal animal = cyber; animal.Manger(); // Nourriture organique Console.WriteLine(animal.Nom); IRobot robot = cyber; robot.Manger(); // Recharge batteries Console.WriteLine(robot.Nom); cyber.SeReposer(); // âœ… OK - MÃ©thode publique 14.7 Exemple Complet : SystÃ¨me de Notifications // ========================================== // INTERFACES // ========================================== public interface INotifiable { void EnvoyerNotification(string message); bool EstActif { get; set; } } public interface IConfigurable { void Configurer(Dictionary\u003cstring, string\u003e parametres); Dictionary\u003cstring, string\u003e ObtenirConfiguration(); } public interface IPrioritaire { int Priorite { get; set; } } // ========================================== // CLASSES D'IMPLÃ‰MENTATION // ========================================== public class NotificationEmail : INotifiable, IConfigurable { public bool EstActif { get; set; } = true; public string AdresseEmail { get; private set; } public string ServeurSMTP { get; private set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"ğŸ“§ [EMAIL] Ã€: {AdresseEmail}\"); Console.WriteLine($\" Message: {message}\"); Console.WriteLine($\" Via: {ServeurSMTP}\\n\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"email\")) AdresseEmail = parametres[\"email\"]; if (parametres.ContainsKey(\"smtp\")) ServeurSMTP = parametres[\"smtp\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"email\", AdresseEmail }, { \"smtp\", ServeurSMTP } }; } } public class NotificationSMS : INotifiable, IConfigurable, IPrioritaire { public bool EstActif { get; set; } = true; public int Priorite { get; set; } = 1; public string NumeroTelephone { get; private set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"ğŸ“± [SMS] Au: {NumeroTelephone}\"); Console.WriteLine($\" Message: {message}\"); Console.WriteLine($\" PrioritÃ©: {Priorite}\\n\"); } } public void Configurer(Dictionary\u003cstring, string\u003e parametres) { if (parametres.ContainsKey(\"telephone\")) NumeroTelephone = parametres[\"telephone\"]; } public Dictionary\u003cstring, string\u003e ObtenirConfiguration() { return new Dictionary\u003cstring, string\u003e { { \"telephone\", NumeroTelephone } }; } } public class NotificationPush : INotifiable, IPrioritaire { public bool EstActif { get; set; } = true; public int Priorite { get; set; } = 2; public string DeviceId { get; set; } public void EnvoyerNotification(string message) { if (EstActif) { Console.WriteLine($\"ğŸ”” [PUSH] Device: {DeviceId}\"); Console.WriteLine($\" Message: {message}\"); Console.WriteLine($\" PrioritÃ©: {Priorite}\\n\"); } } } // ========================================== // GESTIONNAIRE // ========================================== public class GestionnaireNotifications { private List\u003cINotifiable\u003e _canaux = new List\u003cINotifiable\u003e(); public void AjouterCanal(INotifiable canal) { _canaux.Add(canal); Console.WriteLine($\"âœ… Canal ajoutÃ©: {canal.GetType().Name}\"); } public void EnvoyerATous(string message) { Console.WriteLine($\"\\n{'='.ToString().PadLeft(50, '=')}\"); Console.WriteLine($\"ENVOI Ã€ TOUS LES CANAUX\"); Console.WriteLine($\"{'='.ToString().PadLeft(50, '=')}\\n\"); foreach (INotifiable canal in _canaux) { canal.EnvoyerNotification(message); } } public void EnvoyerParPriorite(string message, int prioriteMin) { Console.WriteLine($\"\\n{'='.ToString().PadLeft(50, '=')}\"); Console.WriteLine($\"ENVOI PRIORITAIRE (\u003e= {prioriteMin})\"); Console.WriteLine($\"{'='.ToString().PadLeft(50, '=')}\\n\"); foreach (INotifiable canal in _canaux) { // VÃ©rifie si le canal supporte IPrioritaire if (canal is IPrioritaire prioritaire) { if (prioritaire.Priorite \u003e= prioriteMin) { canal.EnvoyerNotification(message); } } } } public void ConfigurerCanaux() { foreach (INotifiable canal in _canaux) { if (canal is IConfigurable configurable) { Console.WriteLine($\"\\nConfiguration de {canal.GetType().Name}:\"); var config = configurable.ObtenirConfiguration(); foreach (var param in config) { Console.WriteLine($\" {param.Key}: {param.Value}\"); } } } } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { GestionnaireNotifications gestionnaire = new GestionnaireNotifications(); // CrÃ©ation et configuration des canaux var email = new NotificationEmail(); email.Configurer(new Dictionary\u003cstring, string\u003e { { \"email\", \"user@example.com\" }, { \"smtp\", \"smtp.example.com\" } }); var sms = new NotificationSMS { Priorite = 3 }; sms.Configurer(new Dictionary\u003cstring, string\u003e { { \"telephone\", \"+1-514-555-0123\" } }); var push = new NotificationPush { DeviceId = \"ABC123\", Priorite = 2 }; // Ajout des canaux gestionnaire.AjouterCanal(email); gestionnaire.AjouterCanal(sms); gestionnaire.AjouterCanal(push); // Envoi de notifications gestionnaire.EnvoyerATous(\"Bienvenue dans le systÃ¨me!\"); gestionnaire.EnvoyerParPriorite(\"ALERTE: ActivitÃ© suspecte dÃ©tectÃ©e!\", 2); // Affichage de la configuration gestionnaire.ConfigurerCanaux(); } } 14.8 Interfaces vs Classes Abstraites : Quand Utiliser Quoi ? Utilisez une INTERFACE quand :\nVous dÃ©finissez un comportement que des classes sans relation peuvent partager Vous voulez permettre lâ€™hÃ©ritage multiple de comportements Vous crÃ©ez un plugin system ou une architecture dÃ©couplÃ©e Les implÃ©mentations seront trÃ¨s diffÃ©rentes Exemples dâ€™interfaces : IComparable, IDisposable, IEnumerable\nUtilisez une CLASSE ABSTRAITE quand :\nVous voulez partager du code entre classes liÃ©es Vous avez une hiÃ©rarchie â€œest-unâ€ claire Vous voulez fournir une implÃ©mentation par dÃ©faut Les classes dÃ©rivÃ©es ont beaucoup en commun Exemples : Stream, DbConnection, Control (UI)\nExemple combinÃ© :\n// Interface pour le comportement public interface IPayable { bool EffectuerPaiement(decimal montant); } // Classe abstraite pour le code commun public abstract class MoyenPaiement : IPayable { protected string _titulaire; protected MoyenPaiement(string titulaire) { _titulaire = titulaire; } // ImplÃ©mentation commune public void AfficherTitulaire() { Console.WriteLine($\"Titulaire: {_titulaire}\"); } // ImplÃ©mentation de l'interface (peut Ãªtre virtual ou abstract) public abstract bool EffectuerPaiement(decimal montant); } public class CarteCredit : MoyenPaiement { public CarteCredit(string titulaire) : base(titulaire) { } public override bool EffectuerPaiement(decimal montant) { Console.WriteLine($\"Paiement de {montant:C} par carte\"); return true; } } 15. Membres Statiques 15.1 DÃ©finition Les membres statiques (attributs, mÃ©thodes, propriÃ©tÃ©s) appartiennent Ã  la classe elle-mÃªme plutÃ´t quâ€™aux instances individuelles de la classe.\nAnalogie :\nMembres dâ€™instance = CaractÃ©ristiques personnelles (votre Ã¢ge, votre nom) Membres statiques = CaractÃ©ristiques partagÃ©es (le nombre total dâ€™Ãªtres humains sur Terre) CaractÃ©ristiques :\nUn seul exemplaire existe pour toute la classe PartagÃ© entre toutes les instances Accessible via le nom de la classe (pas via une instance) Existe mÃªme sans aucune instance crÃ©Ã©e 15.2 Attributs Statiques public class Compteur { // ========================================== // ATTRIBUT STATIQUE - PartagÃ© par toutes les instances // ========================================== private static int _nombreInstances = 0; // ========================================== // ATTRIBUT D'INSTANCE - Unique pour chaque objet // ========================================== private int _id; public int Id { get { return _id; } } // ========================================== // PROPRIÃ‰TÃ‰ STATIQUE // ========================================== public static int NombreInstances { get { return _nombreInstances; } } // ========================================== // CONSTRUCTEUR // ========================================== public Compteur() { _nombreInstances++; // Modifie la variable STATIQUE _id = _nombreInstances; // Assigne un ID unique basÃ© sur le compteur Console.WriteLine($\"Instance #{_id} crÃ©Ã©e. Total: {_nombreInstances}\"); } } // ========================================== // UTILISATION // ========================================== class Program { static void Main() { Console.WriteLine($\"Instances au dÃ©part: {Compteur.NombreInstances}\"); // 0 Compteur c1 = new Compteur(); // Instance #1 crÃ©Ã©e. Total: 1 Compteur c2 = new Compteur(); // Instance #2 crÃ©Ã©e. Total: 2 Compteur c3 = new Compteur(); // Instance #3 crÃ©Ã©e. Total: 3 Console.WriteLine($\"\\nTotal d'instances: {Compteur.NombreInstances}\"); // 3 Console.WriteLine($\"ID de c1: {c1.Id}\"); // 1 Console.WriteLine($\"ID de c2: {c2.Id}\"); // 2 Console.WriteLine($\"ID de c3: {c3.Id}\"); // 3 // ========================================== // Le compteur est PARTAGÃ‰ // ========================================== Compteur c4 = new Compteur(); // Instance #4 crÃ©Ã©e. Total: 4 Console.WriteLine($\"\\nTotal aprÃ¨s c4: {Compteur.NombreInstances}\"); // 4 } } 15.3 MÃ©thodes Statiques public class CalculatriceMath { // ========================================== // MÃ‰THODES STATIQUES - Pas besoin d'instance // ========================================== public static double CalculerAireRectangle(double longueur, double largeur) { return longueur * largeur; } public static double CalculerAireCercle(double rayon) { return Math.PI * rayon * rayon; } public static int CalculerFactorielle(int n) { if (n \u003c= 1) return 1; return n * CalculerFactorielle(n - 1); } public static bool EstPremier(int nombre) { if (nombre \u003c 2) return false; for (int i = 2; i \u003c= Math.Sqrt(nombre); i++) { if (nombre % i == 0) return false; } return true; } } // Utilisation - SANS crÃ©er d'objet double aire = CalculatriceMath.CalculerAireRectangle(5, 3); // 15 double cercle = CalculatriceMath.CalculerAireCercle(4); // ~50.27 int fact = CalculatriceMath.CalculerFactorielle(5); // 120 bool premier = CalculatriceMath.EstPremier(17); // true 15.4 Classes Statiques Une classe entiÃ¨rement statique ne peut contenir que des membres statiques et ne peut pas Ãªtre instanciÃ©e.\n// ========================================== // CLASSE STATIQUE - Ne peut pas Ãªtre instanciÃ©e // ========================================== public static class Convertisseur { // Toutes les mÃ©thodes doivent Ãªtre statiques public static double CelsiusVersFahrenheit(double celsius) { return (celsius * 9 / 5) + 32; } public static double FahrenheitVersCelsius(double fahrenheit) { return (fahrenheit - 32) * 5 / 9; } public static double KilometresVersMiles(double km) { return km * 0.621371; } public static double MilesVersKilometres(double miles) { return miles / 0.621371; } } // Utilisation double fahrenheit = Convertisseur.CelsiusVersFahrenheit(25); // 77 double miles = Convertisseur.KilometresVersMiles(100); // 62.14 // âŒ ERREUR - Impossible d'instancier // Convertisseur conv = new Convertisseur(); Exemples de classes statiques dans .NET :\nConsole Math File Directory Environment 15.5 Constructeur Statique Un constructeur statique est exÃ©cutÃ© une seule fois, avant la premiÃ¨re utilisation de la classe.\npublic class Configuration { public static string CheminFichier { get; private set; } public static DateTime DateInitialisation { get; private set; } public static Dictionary\u003cstring, string\u003e Parametres { get; private set; } // ========================================== // CONSTRUCTEUR STATIQUE // AppelÃ© automatiquement avant la premiÃ¨re utilisation // ========================================== static Configuration() { Console.WriteLine(\"Initialisation de la configuration...\"); CheminFichier = \"config.json\"; DateInitialisation = DateTime.Now; Parametres = new Dictionary\u003cstring, string\u003e { { \"version\", \"1.0\" }, { \"langue\", \"fr\" } }; Console.WriteLine($\"Configuration initialisÃ©e Ã  {DateInitialisation}\"); } public static void AfficherConfiguration() { Console.WriteLine($\"\\nConfiguration:\"); Console.WriteLine($\" Fichier: {CheminFichier}\"); Console.WriteLine($\" InitialisÃ©e: {DateInitialisation}\"); foreach (var param in Parametres) { Console.WriteLine($\" {param.Key}: {param.Value}\"); } } } // Utilisation class Program { static void Main() { Console.WriteLine(\"DÃ©but du programme\\n\"); // Le constructeur statique est appelÃ© ici (premiÃ¨re utilisation) Configuration.AfficherConfiguration(); // DeuxiÃ¨me utilisation - constructeur statique PAS rappelÃ© Configuration.AfficherConfiguration(); } } Affichage :\nDÃ©but du programme\rInitialisation de la configuration...\rConfiguration initialisÃ©e Ã  01/02/2026 10:30:00\rConfiguration:\rFichier: config.json\rInitialisÃ©e: 01/02/2026 10:30:00\rversion: 1.0\rlangue: fr\rConfiguration:\rFichier: config.json\rInitialisÃ©e: 01/02/2026 10:30:00\rversion: 1.0\rlangue: fr 15.6 Exemple Complet : Gestionnaire de Base de DonnÃ©es public class GestionnaireDB { // ========================================== // MEMBRES STATIQUES - PartagÃ©s // ========================================== private static string _chaine Connexion; private static int _nombreConnexionsActives = 0; private static int _nombreConnexionsTotales = 0; public static int NombreConnexionsActives { get { return _nombreConnexionsActives; } } public static int NombreConnexionsTotales { get { return _nombreConnexionsTotales; } } // ========================================== // MEMBRES D'INSTANCE - Uniques Ã  chaque connexion // ========================================== private int _id; private bool _estConnecte; private DateTime _dateConnexion; public int Id { get { return _id; } } public bool EstConnecte { get { return _estConnecte; } } // ========================================== // CONSTRUCTEUR STATIQUE // ========================================== static GestionnaireDB() { Console.WriteLine(\"[STATIC] Initialisation du gestionnaire DB\"); _chaineConnexion = \"Server=localhost;Database=test;\"; } // ========================================== // CONSTRUCTEUR D'INSTANCE // ========================================== public GestionnaireDB() { _nombreConnexionsTotales++; _id = _nombreConnexionsTotales; Console.WriteLine($\"[INSTANCE #{_id}] CrÃ©Ã©e\"); } // ========================================== // MÃ‰THODE D'INSTANCE // ========================================== public void Connecter() { if (!_estConnecte) { _estConnecte = true; _dateConnexion = DateTime.Now; _nombreConnexionsActives++; Console.WriteLine($\"[INSTANCE #{_id}] ConnectÃ©e. Actives: {_nombreConnexionsActives}\"); } } public void Deconnecter() { if (_estConnecte) { _estConnecte = false; _nombreConnexionsActives--; Console.WriteLine($\"[INSTANCE #{_id}] DÃ©connectÃ©e. Actives: {_nombreConnexionsActives}\"); } } // ========================================== // MÃ‰THODE STATIQUE // ========================================== public static void AfficherStatistiques() { Console.WriteLine($\"\\n=== STATISTIQUES DB ===\"); Console.WriteLine($\"ChaÃ®ne de connexion: {_chaineConnexion}\"); Console.WriteLine($\"Connexions actives: {_nombreConnexionsActives}\"); Console.WriteLine($\"Total crÃ©Ã©es: {_nombreConnexionsTotales}\"); Console.WriteLine($\"=======================\\n\"); } } // Utilisation class Program { static void Main() { GestionnaireDB.AfficherStatistiques(); // DÃ©clenche le constructeur statique GestionnaireDB db1 = new GestionnaireDB(); GestionnaireDB db2 = new GestionnaireDB(); GestionnaireDB db3 = new GestionnaireDB(); db1.Connecter(); db2.Connecter(); db3.Connecter(); GestionnaireDB.AfficherStatistiques(); db1.Deconnecter(); db2.Deconnecter(); GestionnaireDB.AfficherStatistiques(); } } 15.7 RÃ¨gles Importantes public class Exemple { private static int _compteurStatique = 0; private int _compteurInstance = 0; // ========================================== // MÃ‰THODE STATIQUE // ========================================== public static void MethodeStatique() { // âœ… OK - AccÃ¨s Ã  membre statique _compteurStatique++; // âŒ ERREUR - Pas d'accÃ¨s aux membres d'instance // _compteurInstance++; // ERREUR! // this._compteurInstance++; // ERREUR! // âœ… OK - Appel d'autre mÃ©thode statique AutreMethodeStatique(); // âŒ ERREUR - Pas d'appel de mÃ©thode d'instance // MethodeInstance(); // ERREUR! } // ========================================== // MÃ‰THODE D'INSTANCE // ========================================== public void MethodeInstance() { // âœ… OK - AccÃ¨s aux membres d'instance _compteurInstance++; // âœ… OK - AccÃ¨s aux membres statiques aussi _compteurStatique++; // âœ… OK - Appel de mÃ©thodes statiques MethodeStatique(); AutreMethodeStatique(); } private static void AutreMethodeStatique() { } } RÃ©sumÃ© Final Tableau RÃ©capitulatif des Concepts Concept DÃ©finition Exemple dâ€™Usage virtual MÃ©thode avec implÃ©mentation, redÃ©finition optionnelle Comportement par dÃ©faut modifiable abstract MÃ©thode sans implÃ©mentation, redÃ©finition obligatoire Forcer les dÃ©rivÃ©es Ã  implÃ©menter sealed EmpÃªche lâ€™hÃ©ritage ou la redÃ©finition Classe/mÃ©thode finale override RedÃ©finit une mÃ©thode virtual ou abstract Polymorphisme new Masque un membre de la classe de base Ã‰viter, prÃ©fÃ©rer override base AccÃ¨de aux membres de la classe parent Appeler la version parente this RÃ©fÃ©rence Ã  lâ€™instance actuelle Distinguer attributs/paramÃ¨tres static Membre appartenant Ã  la classe Utilitaires, compteurs partagÃ©s interface Contrat sans implÃ©mentation DÃ©finir comportements multiples abstract class Classe incomplÃ¨te avec code partagÃ© Base commune avec implÃ©mentation HiÃ©rarchie ComplÃ¨te dâ€™Exemple // Interface public interface IVolant { void Voler(); } // Classe abstraite public abstract class Animal { protected string _nom; public Animal(string nom) { _nom = nom; } // MÃ©thode abstraite public abstract void EmettreSound(); // MÃ©thode virtuelle public virtual void Dormir() { Console.WriteLine($\"{_nom} dort\"); } // MÃ©thode concrÃ¨te public void Respirer() { Console.WriteLine($\"{_nom} respire\"); } } // Classe concrÃ¨te public class Oiseau : Animal, IVolant { public Oiseau(string nom) : base(nom) { } // ImplÃ©mentation obligatoire (abstract) public override void EmettreSound() { Console.WriteLine($\"{_nom} chante\"); } // RedÃ©finition optionnelle (virtual) public override void Dormir() { Console.WriteLine($\"{_nom} dort dans un nid\"); } // ImplÃ©mentation d'interface public void Voler() { Console.WriteLine($\"{_nom} vole\"); } } // Classe sealed public sealed class Pingouin : Oiseau { public Pingouin(string nom) : base(nom) { } // Sealed override public sealed override void Dormir() { Console.WriteLine($\"{_nom} dort en groupe\"); } // Les pingouins ne volent pas, mais implÃ©mentent quand mÃªme IVolant public new void Voler() { Console.WriteLine($\"{_nom} ne peut pas voler!\"); } } // âŒ Impossible d'hÃ©riter de Pingouin (sealed) // public class SuperPingouin : Pingouin { }",
    "description": "Table des matiÃ¨res Le mot-clÃ© Virtual Le mot-clÃ© Abstract Le mot-clÃ© Sealed Les Classes Abstraites Les Interfaces Membres Statiques Cours POO C# - Partie 2 : Concepts AvancÃ©s 10. Le mot-clÃ© Virtual 10.1 DÃ©finition Le mot-clÃ© virtual permet de dÃ©clarer une mÃ©thode qui peut Ãªtre redÃ©finie (override) dans les classes dÃ©rivÃ©es. Câ€™est la base du polymorphisme dâ€™exÃ©cution en C#.",
    "tags": [],
    "title": "Programmation orientÃ©e objet - partie 2",
    "uri": "/420-413/poo_2/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Mini-Projets : Programmation OrientÃ©e Objet en C# Progression recommandÃ©e Niveau Projets DÃ©butant Projet 8 (Formes), Projet 5 (TÃ¢ches) IntermÃ©diaire Projet 1 (Banque), Projet 2 (BibliothÃ¨que), Projet 6 (Zoo) AvancÃ© Projet 3 (RPG), Projet 4 (Restaurant), Projet 7 (HÃ´tel) Table des matiÃ¨res Projet 1 : SystÃ¨me de Gestion Bancaire Projet 2 : Gestion dâ€™une BibliothÃ¨que Projet 3 : Jeu de Combat RPG Projet 4 : SystÃ¨me de Commandes Restaurant Projet 5 : Gestionnaire de TÃ¢ches Projet 6 : Simulateur de Zoo Projet 7 : SystÃ¨me de RÃ©servation HÃ´tel Projet 8 : Calculatrice de Formes GÃ©omÃ©triques Projet 1 : SystÃ¨me de Gestion Bancaire ğŸ“‹ Objectif CrÃ©er un systÃ¨me de gestion de comptes bancaires avec diffÃ©rents types de comptes et opÃ©rations.\nğŸ¯ Concepts utilisÃ©s HÃ©ritage Encapsulation Polymorphisme Classes abstraites ğŸ“ SpÃ©cifications CrÃ©er :\nUne classe abstraite CompteBancaire avec :\nPropriÃ©tÃ©s : NumeroCompte, Titulaire, Solde, DateOuverture MÃ©thodes abstraites : CalculerInterets() MÃ©thodes concrÃ¨tes : Deposer(), Retirer(), AfficherReleve() Classe CompteEpargne hÃ©ritant de CompteBancaire :\nPropriÃ©tÃ© : TauxInteret (ex: 2.5%) Minimum de retrait : 10$ ImplÃ©mente CalculerInterets() Classe CompteCourant hÃ©ritant de CompteBancaire :\nPropriÃ©tÃ© : DecouvertAutorise (ex: -500$) Frais mensuels : 5$ Peut retirer jusquâ€™Ã  atteindre le dÃ©couvert Classe CompteJeune hÃ©ritant de CompteEpargne :\nPour les moins de 18 ans Bonus annuel de 50$ si solde \u003e 500$ Limite de retrait : 200$ par transaction ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; namespace GestionBancaire { // Classe abstraite de base public abstract class CompteBancaire { // TODO: Ajouter les propriÃ©tÃ©s // TODO: Ajouter le constructeur public virtual bool Deposer(decimal montant) { // TODO: ImplÃ©menter return false; } public abstract bool Retirer(decimal montant); public abstract decimal CalculerInterets(); public virtual void AfficherReleve() { // TODO: ImplÃ©menter } } // TODO: CrÃ©er la classe CompteEpargne // TODO: CrÃ©er la classe CompteCourant // TODO: CrÃ©er la classe CompteJeune // Classe de gestion public class Banque { private List\u003cCompteBancaire\u003e _comptes = new List\u003cCompteBancaire\u003e(); public void AjouterCompte(CompteBancaire compte) { // TODO: ImplÃ©menter } public void AppliquerIntÃ©rets() { // TODO: Parcourir tous les comptes et appliquer les intÃ©rÃªts } public void AfficherTousLesComptes() { // TODO: ImplÃ©menter } } class Program { static void Main(string[] args) { // TODO: CrÃ©er des comptes et tester Console.WriteLine(\"=== SystÃ¨me Bancaire ===\"); // CrÃ©er une banque Banque banque = new Banque(); // CrÃ©er diffÃ©rents types de comptes // ... // Effectuer des opÃ©rations // ... // Appliquer les intÃ©rÃªts // ... // Afficher tous les comptes // ... } } } âœ… CritÃ¨res de rÃ©ussite Impossible de retirer plus que le solde (sauf compte courant avec dÃ©couvert) Les intÃ©rÃªts sont correctement calculÃ©s Le polymorphisme fonctionne (mÃªme mÃ©thode, comportements diffÃ©rents) Les encapsulations protÃ¨gent les donnÃ©es sensibles Projet 2 : Gestion dâ€™une BibliothÃ¨que ğŸ“‹ Objectif CrÃ©er un systÃ¨me de gestion de bibliothÃ¨que avec emprunts et rÃ©servations.\nğŸ¯ Concepts utilisÃ©s Interfaces HÃ©ritage Collections Ã‰numÃ©rations ğŸ“ SpÃ©cifications CrÃ©er :\nInterface IEmpruntable :\nMÃ©thodes : Emprunter(string emprunteur), Retourner() PropriÃ©tÃ© : EstDisponible Interface IReservable :\nMÃ©thodes : Reserver(string utilisateur), AnnulerReservation() Classe abstraite Document :\nPropriÃ©tÃ©s : Titre, Auteur, AnneePublication, Cote MÃ©thode abstraite : AfficherDetails() Classe Livre hÃ©ritant de Document et implÃ©mentant IEmpruntable, IReservable :\nPropriÃ©tÃ©s supplÃ©mentaires : ISBN, NombrePages, Genre DurÃ©e dâ€™emprunt : 21 jours Classe DVD hÃ©ritant de Document et implÃ©mentant IEmpruntable :\nPropriÃ©tÃ©s supplÃ©mentaires : Duree (en minutes), Genre DurÃ©e dâ€™emprunt : 7 jours Classe Magazine hÃ©ritant de Document et implÃ©mentant IEmpruntable :\nPropriÃ©tÃ©s supplÃ©mentaires : NumeroEdition, Mois DurÃ©e dâ€™emprunt : 14 jours Ne peut pas Ãªtre rÃ©servÃ© Ã‰numÃ©ration GenreLivre : Fiction, NonFiction, ScienceFiction, Romance, Thriller, etc.\nClasse Bibliotheque :\nCollection de documents MÃ©thodes : AjouterDocument(), RechercherParTitre(), RechercherParAuteur(), ListerDocumentsDisponibles() ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; using System.Linq; namespace GestionBibliotheque { public interface IEmpruntable { // TODO: DÃ©finir l'interface } public interface IReservable { // TODO: DÃ©finir l'interface } public enum GenreLivre { Fiction, NonFiction, ScienceFiction, Romance, Thriller, Biographie, Histoire } public abstract class Document { // TODO: PropriÃ©tÃ©s communes public abstract void AfficherDetails(); } public class Livre : Document, IEmpruntable, IReservable { // TODO: ImplÃ©menter } public class DVD : Document, IEmpruntable { // TODO: ImplÃ©menter } public class Magazine : Document, IEmpruntable { // TODO: ImplÃ©menter } public class Bibliotheque { private List\u003cDocument\u003e _documents = new List\u003cDocument\u003e(); public void AjouterDocument(Document document) { // TODO: ImplÃ©menter } public List\u003cDocument\u003e RechercherParTitre(string titre) { // TODO: ImplÃ©menter return null; } public void ListerDocumentsDisponibles() { // TODO: ImplÃ©menter } public void ListerEmprunts() { // TODO: Afficher tous les documents empruntÃ©s } } class Program { static void Main(string[] args) { Bibliotheque biblio = new Bibliotheque(); // TODO: Ajouter des documents // TODO: Tester les emprunts // TODO: Tester les rÃ©servations // TODO: Tester les recherches } } } âœ… CritÃ¨res de rÃ©ussite Impossible dâ€™emprunter un document dÃ©jÃ  empruntÃ© Les rÃ©servations fonctionnent uniquement pour les livres La recherche fonctionne correctement Lâ€™affichage des dÃ©tails est polymorphe Projet 3 : Jeu de Combat RPG ğŸ“‹ Objectif CrÃ©er un mini-jeu de combat avec diffÃ©rentes classes de personnages.\nğŸ¯ Concepts utilisÃ©s HÃ©ritage Polymorphisme Classes abstraites Interfaces ğŸ“ SpÃ©cifications CrÃ©er :\nClasse abstraite Personnage :\nPropriÃ©tÃ©s : Nom, PointsDeVie, PointsDeVieMax, Force, Defense, Niveau MÃ©thode abstraite : AttaqueSpeciale() MÃ©thodes concrÃ¨tes : Attaquer(Personnage cible), RecevoirDegats(int degats), EstVivant(), Guerir(int points) Classe Guerrier hÃ©ritant de Personnage :\nCompÃ©tence : Coup Puissant (2x la force, mais perd 10 PV) Bonus : +5 dÃ©fense Classe Mage hÃ©ritant de Personnage :\nPropriÃ©tÃ© supplÃ©mentaire : Mana CompÃ©tence : Boule de Feu (3x la force, coÃ»te 30 mana) Peut se rÃ©gÃ©nÃ©rer (rÃ©cupÃ¨re 20 mana par tour) Classe Archer hÃ©ritant de Personnage :\nPropriÃ©tÃ© supplÃ©mentaire : Precision (%) CompÃ©tence : Tir Critique (chance de critique basÃ©e sur prÃ©cision) Attaque Ã  distance (peut Ã©viter les contre-attaques) Classe Paladin hÃ©ritant de Personnage :\nPeut se soigner (50% de la force en soins) CompÃ©tence : Bouclier SacrÃ© (augmente dÃ©fense de 50% pour 3 tours) Bonus : RÃ©gÃ©nÃ©ration passive (5 PV par tour) Interface IInventaire :\nMÃ©thodes : AjouterObjet(), UtiliserObjet(), AfficherInventaire() Classe Objet :\nTypes : Potion (restore PV), PotionMana, ElixirForce (augmente force temporairement) ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; namespace JeuCombatRPG { public abstract class Personnage { public string Nom { get; set; } public int PointsDeVie { get; protected set; } public int PointsDeVieMax { get; protected set; } public int Force { get; protected set; } public int Defense { get; protected set; } public int Niveau { get; protected set; } protected Personnage(string nom, int pv, int force, int defense) { // TODO: Initialiser } public virtual int Attaquer(Personnage cible) { // TODO: Calculer les dÃ©gÃ¢ts (Force - Defense de la cible) // Minimum 1 dÃ©gÃ¢t return 0; } public void RecevoirDegats(int degats) { // TODO: RÃ©duire les PV } public abstract void AttaqueSpeciale(Personnage cible); public bool EstVivant() { return PointsDeVie \u003e 0; } public void AfficherStats() { // TODO: Afficher nom, PV, Force, DÃ©fense } } public class Guerrier : Personnage { public Guerrier(string nom) : base(nom, 150, 25, 15) { } public override void AttaqueSpeciale(Personnage cible) { // TODO: Coup Puissant } } // TODO: CrÃ©er les autres classes (Mage, Archer, Paladin) public class Combat { public void Duel(Personnage p1, Personnage p2) { Console.WriteLine($\"=== COMBAT: {p1.Nom} VS {p2.Nom} ===\\n\"); int tour = 1; while (p1.EstVivant() \u0026\u0026 p2.EstVivant()) { Console.WriteLine($\"--- Tour {tour} ---\"); // TODO: p1 attaque p2 if (!p2.EstVivant()) { Console.WriteLine($\"\\nğŸ† {p1.Nom} remporte le combat!\"); break; } // TODO: p2 attaque p1 if (!p1.EstVivant()) { Console.WriteLine($\"\\nğŸ† {p2.Nom} remporte le combat!\"); break; } tour++; Console.WriteLine(); } } } class Program { static void Main(string[] args) { // TODO: CrÃ©er des personnages // TODO: Lancer des combats // TODO: Tester les attaques spÃ©ciales } } } âœ… CritÃ¨res de rÃ©ussite Chaque classe a une attaque spÃ©ciale unique Le systÃ¨me de combat est Ã©quilibrÃ© Les statistiques sont correctement affichÃ©es Le polymorphisme permet des combats entre diffÃ©rents types ğŸ® Extensions possibles Ajouter un systÃ¨me dâ€™expÃ©rience et de montÃ©e de niveau ImplÃ©menter un inventaire dâ€™objets CrÃ©er un mode tournoi avec plusieurs combattants Ajouter des effets de statut (poison, paralysie, etc.) Projet 4 : SystÃ¨me de Commandes Restaurant ğŸ“‹ Objectif CrÃ©er un systÃ¨me de gestion de commandes pour un restaurant.\nğŸ¯ Concepts utilisÃ©s HÃ©ritage Interfaces Collections Ã‰numÃ©rations ğŸ“ SpÃ©cifications CrÃ©er :\nÃ‰numÃ©ration CategoriePlat : Entree, PlatPrincipal, Dessert, Boisson\nClasse abstraite Article :\nPropriÃ©tÃ©s : Nom, Prix, Description, Categorie MÃ©thode abstraite : CalculerPrix() (pour gÃ©rer les options/supplÃ©ments) Classe Plat hÃ©ritant de Article :\nPropriÃ©tÃ©s : Ingredients (liste), TempsPreparation, EstVegetarien Peut avoir des supplÃ©ments (fromage +2$, bacon +3$) Classe Boisson hÃ©ritant de Article :\nPropriÃ©tÃ©s : Taille (Petit, Moyen, Grand), EstGazeuse Prix varie selon la taille Interface IPersonnalisable :\nMÃ©thodes : AjouterOption(string option, decimal prix), RetirerIngredient(string ingredient) Classe Menu :\nContient une entrÃ©e, un plat principal, un dessert et une boisson Prix rÃ©duit de 15% par rapport aux articles sÃ©parÃ©s Classe Commande :\nPropriÃ©tÃ©s : NumeroCommande, Client, Articles, DateHeure, Statut MÃ©thodes : AjouterArticle(), RetirerArticle(), CalculerTotal(), CalculerTaxes(), AfficherFacture() Ã‰numÃ©ration StatutCommande : EnAttente, EnPreparation, Prete, Livree, Annulee\nğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; using System.Linq; namespace SystemeRestaurant { public enum CategoriePlat { Entree, PlatPrincipal, Dessert, Boisson } public enum StatutCommande { EnAttente, EnPreparation, Prete, Livree, Annulee } public enum TailleBoisson { Petit, Moyen, Grand } public interface IPersonnalisable { void AjouterOption(string option, decimal prix); void RetirerIngredient(string ingredient); } public abstract class Article { public string Nom { get; set; } public decimal PrixBase { get; set; } public string Description { get; set; } public CategoriePlat Categorie { get; set; } public abstract decimal CalculerPrix(); public virtual void AfficherDetails() { Console.WriteLine($\"{Nom} - {PrixBase:C}\"); Console.WriteLine($\" {Description}\"); } } public class Plat : Article, IPersonnalisable { public List\u003cstring\u003e Ingredients { get; set; } public int TempsPreparation { get; set; } // en minutes public bool EstVegetarien { get; set; } private Dictionary\u003cstring, decimal\u003e _options = new Dictionary\u003cstring, decimal\u003e(); public Plat() { Ingredients = new List\u003cstring\u003e(); } public void AjouterOption(string option, decimal prix) { // TODO: ImplÃ©menter } public void RetirerIngredient(string ingredient) { // TODO: ImplÃ©menter } public override decimal CalculerPrix() { // TODO: Prix de base + options return 0; } public override void AfficherDetails() { base.AfficherDetails(); Console.WriteLine($\" Temps de prÃ©paration: {TempsPreparation} min\"); Console.WriteLine($\" VÃ©gÃ©tarien: {(EstVegetarien ? \"Oui\" : \"Non\")}\"); Console.WriteLine($\" IngrÃ©dients: {string.Join(\", \", Ingredients)}\"); } } public class Boisson : Article { public TailleBoisson Taille { get; set; } public bool EstGazeuse { get; set; } public override decimal CalculerPrix() { // TODO: Ajuster le prix selon la taille // Petit: 100%, Moyen: 130%, Grand: 160% return 0; } } public class Menu { public Plat Entree { get; set; } public Plat PlatPrincipal { get; set; } public Article Dessert { get; set; } public Boisson Boisson { get; set; } public decimal CalculerPrix() { // TODO: Calculer avec rÃ©duction de 15% return 0; } public void AfficherMenu() { // TODO: Afficher tous les Ã©lÃ©ments du menu } } public class Commande { private static int _compteurCommandes = 0; public int NumeroCommande { get; private set; } public string Client { get; set; } public List\u003cArticle\u003e Articles { get; private set; } public DateTime DateHeure { get; private set; } public StatutCommande Statut { get; set; } public Commande(string client) { NumeroCommande = ++_compteurCommandes; Client = client; Articles = new List\u003cArticle\u003e(); DateHeure = DateTime.Now; Statut = StatutCommande.EnAttente; } public void AjouterArticle(Article article) { // TODO: ImplÃ©menter } public decimal CalculerSousTotal() { // TODO: Sommer tous les articles return 0; } public decimal CalculerTaxes() { // TODO: Calculer TPS (5%) + TVQ (9.975%) return 0; } public decimal CalculerTotal() { return CalculerSousTotal() + CalculerTaxes(); } public void AfficherFacture() { // TODO: Afficher facture dÃ©taillÃ©e } } public class Restaurant { public string Nom { get; set; } private List\u003cArticle\u003e _carte = new List\u003cArticle\u003e(); private List\u003cCommande\u003e _commandes = new List\u003cCommande\u003e(); public void AjouterAuMenu(Article article) { _carte.Add(article); } public void AfficherCarte() { // TODO: Afficher par catÃ©gorie } public Commande CreerCommande(string client) { var commande = new Commande(client); _commandes.Add(commande); return commande; } public void AfficherCommandesEnCours() { // TODO: Afficher commandes non terminÃ©es } } class Program { static void Main(string[] args) { Restaurant resto = new Restaurant { Nom = \"Chez Claude\" }; // TODO: CrÃ©er des plats et les ajouter au menu // TODO: CrÃ©er une commande // TODO: Personnaliser des plats // TODO: Afficher la facture Console.WriteLine(\"\\n=== BIENVENUE CHEZ CLAUDE ===\\n\"); // Exemple de crÃ©ation de plats var poutine = new Plat { Nom = \"Poutine Classique\", PrixBase = 12.99m, Description = \"Frites, sauce brune et fromage en grains\", Categorie = CategoriePlat.PlatPrincipal, Ingredients = new List\u003cstring\u003e { \"Frites\", \"Sauce brune\", \"Fromage en grains\" }, TempsPreparation = 15, EstVegetarien = true }; // ... crÃ©er d'autres plats } } } âœ… CritÃ¨res de rÃ©ussite Les prix sont calculÃ©s correctement avec les options Les taxes sont appliquÃ©es correctement La facture sâ€™affiche proprement Les menus offrent une rÃ©duction Projet 5 : Gestionnaire de TÃ¢ches ğŸ“‹ Objectif CrÃ©er une application de gestion de tÃ¢ches avec diffÃ©rents types de tÃ¢ches et prioritÃ©s.\nğŸ¯ Concepts utilisÃ©s HÃ©ritage Interfaces DÃ©lÃ©guÃ©s et Ã©vÃ©nements PropriÃ©tÃ©s ğŸ“ SpÃ©cifications CrÃ©er :\nÃ‰numÃ©ration Priorite : Basse, Normale, Haute, Critique\nÃ‰numÃ©ration StatutTache : AFaire, EnCours, Terminee, Annulee\nInterface INotifiable :\nÃ‰vÃ©nement : TacheModifiee MÃ©thode : NotifierChangement() Classe abstraite Tache :\nPropriÃ©tÃ©s : Id, Titre, Description, DateCreation, DateEcheance, Priorite, Statut MÃ©thodes abstraites : Executer(), EstEnRetard() Classe TacheSimple hÃ©ritant de Tache\nClasse TacheRecurrente hÃ©ritant de Tache :\nPropriÃ©tÃ© : Frequence (Quotidien, Hebdomadaire, Mensuel) MÃ©thode : CreerProchaineTache() Classe TacheAvecSousTaches hÃ©ritant de Tache :\nListe de sous-tÃ¢ches Calcul de progression (%) Classe ProjetTaches :\nCollection de tÃ¢ches MÃ©thodes : AjouterTache(), SupprimerTache(), ObtenirTachesParPriorite(), ObtenirTachesEnRetard() ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; using System.Linq; namespace GestionnaireTaches { public enum Priorite { Basse, Normale, Haute, Critique } public enum StatutTache { AFaire, EnCours, Terminee, Annulee } public enum FrequenceRecurrence { Quotidien, Hebdomadaire, Mensuel } public interface INotifiable { event EventHandler\u003cstring\u003e TacheModifiee; void NotifierChangement(string message); } public abstract class Tache : INotifiable { private static int _compteur = 0; public int Id { get; private set; } public string Titre { get; set; } public string Description { get; set; } public DateTime DateCreation { get; private set; } public DateTime? DateEcheance { get; set; } public Priorite Priorite { get; set; } public StatutTache Statut { get; set; } public event EventHandler\u003cstring\u003e TacheModifiee; protected Tache(string titre) { Id = ++_compteur; Titre = titre; DateCreation = DateTime.Now; Statut = StatutTache.AFaire; Priorite = Priorite.Normale; } public abstract void Executer(); public virtual bool EstEnRetard() { // TODO: VÃ©rifier si la date d'Ã©chÃ©ance est dÃ©passÃ©e return false; } public void NotifierChangement(string message) { TacheModifiee?.Invoke(this, message); } public virtual void AfficherDetails() { // TODO: Afficher toutes les infos } } public class TacheSimple : Tache { public TacheSimple(string titre) : base(titre) { } public override void Executer() { // TODO: Marquer comme terminÃ©e } } public class TacheRecurrente : Tache { public FrequenceRecurrence Frequence { get; set; } public TacheRecurrente(string titre, FrequenceRecurrence frequence) : base(titre) { Frequence = frequence; } public override void Executer() { // TODO: Marquer comme terminÃ©e et crÃ©er la prochaine occurrence } public TacheRecurrente CreerProchaineTache() { // TODO: CrÃ©er une nouvelle tÃ¢che avec date d'Ã©chÃ©ance ajustÃ©e return null; } } public class TacheAvecSousTaches : Tache { public List\u003cTache\u003e SousTaches { get; private set; } public TacheAvecSousTaches(string titre) : base(titre) { SousTaches = new List\u003cTache\u003e(); } public void AjouterSousTache(Tache tache) { // TODO: ImplÃ©menter } public double CalculerProgression() { // TODO: Calculer % de sous-tÃ¢ches terminÃ©es return 0; } public override void Executer() { // TODO: Marquer toutes les sous-tÃ¢ches comme terminÃ©es } public override void AfficherDetails() { base.AfficherDetails(); Console.WriteLine($\"Progression: {CalculerProgression():P0}\"); Console.WriteLine(\"Sous-tÃ¢ches:\"); // TODO: Afficher les sous-tÃ¢ches } } public class ProjetTaches { public string Nom { get; set; } private List\u003cTache\u003e _taches = new List\u003cTache\u003e(); public ProjetTaches(string nom) { Nom = nom; } public void AjouterTache(Tache tache) { _taches.Add(tache); tache.TacheModifiee += OnTacheModifiee; } private void OnTacheModifiee(object sender, string message) { Console.WriteLine($\"[NOTIFICATION] {message}\"); } public List\u003cTache\u003e ObtenirTachesParPriorite(Priorite priorite) { // TODO: Filtrer par prioritÃ© return null; } public List\u003cTache\u003e ObtenirTachesEnRetard() { // TODO: Retourner les tÃ¢ches en retard return null; } public void AfficherResume() { // TODO: Afficher statistiques (nombre total, terminÃ©es, en retard, etc.) } public void AfficherTachesParStatut() { // TODO: Grouper et afficher par statut } } class Program { static void Main(string[] args) { ProjetTaches projet = new ProjetTaches(\"DÃ©veloppement Application\"); // TODO: CrÃ©er diffÃ©rents types de tÃ¢ches // TODO: Afficher les tÃ¢ches // TODO: Marquer des tÃ¢ches comme terminÃ©es // TODO: Afficher les statistiques } } } âœ… CritÃ¨res de rÃ©ussite Les Ã©vÃ©nements notifient correctement les changements Les tÃ¢ches rÃ©currentes crÃ©ent de nouvelles instances La progression des tÃ¢ches avec sous-tÃ¢ches est correcte Les filtres fonctionnent correctement Projet 6 : Simulateur de Zoo ğŸ“‹ Objectif CrÃ©er un simulateur de zoo avec diffÃ©rents types dâ€™animaux et comportements.\nğŸ¯ Concepts utilisÃ©s HÃ©ritage multiple (interfaces) Polymorphisme Classes abstraites Collections ğŸ“ SpÃ©cifications CrÃ©er :\nInterfaces de comportements :\nIVolant : Voler(), AltitudeMaximale INageant : Nager(), ProfondeurMaximale IGrimpant : Grimper(), Agilite ICarnivore : Chasser(Animal proie) IHerbivore : Brouter() Classe abstraite Animal :\nPropriÃ©tÃ©s : Nom, Espece, Age, Poids, Sante, Faim MÃ©thodes : Manger(), Dormir(), SeReproduire(), AfficherInfos() Classes dâ€™animaux implÃ©mentant les bonnes interfaces :\nLion : ICarnivore Aigle : IVolant, ICarnivore Dauphin : INageant, ICarnivore Singe : IGrimpant, IHerbivore Elephant : IHerbivore Pingouin : INageant (ne vole pas!) Canard : IVolant, INageant Classe Enclos :\nType (Terrestre, Aquatique, Aerien, Mixte) Capacite maximale Liste dâ€™animaux MÃ©thode : AjouterAnimal(), RetirerAnimal(), NourririAnimaux() Classe Zoo :\nNom du zoo Collection dâ€™enclos MÃ©thodes : AjouterEnclos(), FaireVisiter(), RapportJournalier(), NourrirTousLesAnimaux() ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; using System.Linq; namespace SimulateurZoo { public interface IVolant { void Voler(); double AltitudeMaximale { get; } } public interface INageant { void Nager(); double ProfondeurMaximale { get; } } public interface IGrimpant { void Grimper(); int Agilite { get; } // Sur 10 } public interface ICarnivore { void Chasser(Animal proie); string RegimeAlimentaire { get; } } public interface IHerbivore { void Brouter(); string VegetationPreferee { get; } } public enum TypeEnclos { Terrestre, Aquatique, Aerien, Mixte } public abstract class Animal { public string Nom { get; set; } public string Espece { get; protected set; } public int Age { get; set; } public double Poids { get; set; } public int Sante { get; protected set; } // 0-100 public int Faim { get; protected set; } // 0-100 protected Animal(string nom, int age, double poids) { Nom = nom; Age = age; Poids = poids; Sante = 100; Faim = 50; } public virtual void Manger() { Faim = Math.Max(0, Faim - 30); Console.WriteLine($\"{Nom} mange. Faim: {Faim}%\"); } public void Dormir() { Sante = Math.Min(100, Sante + 10); Console.WriteLine($\"{Nom} dort. SantÃ©: {Sante}%\"); } public abstract void EmettreSon(); public virtual void AfficherInfos() { Console.WriteLine($\"=== {Nom} ===\"); Console.WriteLine($\"EspÃ¨ce: {Espece}\"); Console.WriteLine($\"Ã‚ge: {Age} ans\"); Console.WriteLine($\"Poids: {Poids} kg\"); Console.WriteLine($\"SantÃ©: {Sante}%\"); Console.WriteLine($\"Faim: {Faim}%\"); } } // TODO: CrÃ©er la classe Lion public class Lion : Animal, ICarnivore { public string RegimeAlimentaire { get; } = \"Carnivore strict\"; public Lion(string nom, int age, double poids) : base(nom, age, poids) { Espece = \"Lion\"; } public void Chasser(Animal proie) { // TODO: ImplÃ©menter } public override void EmettreSon() { Console.WriteLine($\"{Nom} rugit: ROARRR!\"); } } // TODO: CrÃ©er les autres classes d'animaux public class Enclos { private static int _compteur = 0; public int Numero { get; private set; } public string Nom { get; set; } public TypeEnclos Type { get; set; } public int CapaciteMax { get; set; } public List\u003cAnimal\u003e Animaux { get; private set; } public Enclos(string nom, TypeEnclos type, int capacite) { Numero = ++_compteur; Nom = nom; Type = type; CapaciteMax = capacite; Animaux = new List\u003cAnimal\u003e(); } public bool AjouterAnimal(Animal animal) { // TODO: VÃ©rifier capacitÃ© et compatibilitÃ© return false; } public void NourrirAnimaux() { // TODO: Nourrir tous les animaux } public void AfficherContenu() { // TODO: Afficher infos de l'enclos } } public class Zoo { public string Nom { get; set; } public string Ville { get; set; } private List\u003cEnclos\u003e _enclos = new List\u003cEnclos\u003e(); public Zoo(string nom, string ville) { Nom = nom; Ville = ville; } public void AjouterEnclos(Enclos enclos) { _enclos.Add(enclos); } public void NourrirTousLesAnimaux() { // TODO: Parcourir tous les enclos } public void FaireVisiter() { // TODO: Afficher tous les enclos } public void RapportJournalier() { // TODO: Statistiques (nombre animaux, par type, santÃ© moyenne, etc.) } public List\u003cAnimal\u003e RechercherAnimauxParCapacite(Type interfaceType) { // TODO: Trouver tous les animaux qui implÃ©mentent une interface donnÃ©e // Ex: tous les IVolant return null; } } class Program { static void Main(string[] args) { Zoo zoo = new Zoo(\"Zoo de MontrÃ©al\", \"MontrÃ©al\"); // TODO: CrÃ©er des enclos // TODO: CrÃ©er des animaux // TODO: Placer les animaux dans les enclos // TODO: Faire une visite // TODO: Nourrir les animaux // TODO: GÃ©nÃ©rer un rapport } } } âœ… CritÃ¨res de rÃ©ussite Les animaux ont les bonnes capacitÃ©s (nager, voler, etc.) Les enclos acceptent seulement les animaux compatibles Le polymorphisme fonctionne pour les comportements Les statistiques sont correctes Projet 7 : SystÃ¨me de RÃ©servation HÃ´tel ğŸ“‹ Objectif CrÃ©er un systÃ¨me de rÃ©servation pour un hÃ´tel avec diffÃ©rents types de chambres.\nğŸ¯ Concepts utilisÃ©s HÃ©ritage Interfaces PropriÃ©tÃ©s calculÃ©es Ã‰numÃ©rations ğŸ“ SpÃ©cifications CrÃ©er :\nÃ‰numÃ©rations :\nTypeChambre : Simple, Double, Suite, Penthouse StatutReservation : Confirmee, EnAttente, Annulee, Terminee Interface IAnnulable :\nMÃ©thode : Annuler(), ObtenirFraisAnnulation() Classe abstraite Chambre :\nPropriÃ©tÃ©s : Numero, Type, PrixParNuit, NombrePersonnesMax, Superficie, EstDisponible MÃ©thode abstraite : CalculerPrix(int nuits) Classes de chambres :\nChambreSimple : 1 personne, prix de base ChambreDouble : 2 personnes, prix + 30% Suite : 4 personnes, prix + 80%, inclut petit-dÃ©jeuner Penthouse : 6 personnes, prix + 150%, tous services inclus Classe Service :\nTypes : PetitDejeuner, Spa, Parking, RoomService Prix par service Classe Reservation implÃ©mentant IAnnulable :\nPropriÃ©tÃ©s : NumeroReservation, Client, Chambre, DateArrivee, DateDepart, Services, Statut MÃ©thodes : AjouterService(), CalculerCoutTotal(), CalculerDuree() Classe Hotel :\nGestion des chambres et rÃ©servations MÃ©thodes : RechercherChambresDisponibles(), CreerReservation(), AfficherOccupation() ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; using System.Linq; namespace SystemeHotel { public enum TypeChambre { Simple, Double, Suite, Penthouse } public enum StatutReservation { Confirmee, EnAttente, Annulee, Terminee } public enum TypeService { PetitDejeuner, Spa, Parking, RoomService, Wifi } public interface IAnnulable { bool Annuler(); decimal ObtenirFraisAnnulation(); } public abstract class Chambre { public int Numero { get; set; } public TypeChambre Type { get; protected set; } public decimal PrixParNuit { get; set; } public int NombrePersonnesMax { get; protected set; } public double Superficie { get; set; } public bool EstDisponible { get; set; } public List\u003cstring\u003e Equipements { get; protected set; } protected Chambre(int numero, decimal prixParNuit) { Numero = numero; PrixParNuit = prixParNuit; EstDisponible = true; Equipements = new List\u003cstring\u003e(); } public abstract decimal CalculerPrix(int nuits); public virtual void AfficherDetails() { Console.WriteLine($\"Chambre #{Numero} - {Type}\"); Console.WriteLine($\"Prix par nuit: {PrixParNuit:C}\"); Console.WriteLine($\"CapacitÃ©: {NombrePersonnesMax} personne(s)\"); Console.WriteLine($\"Superficie: {Superficie}mÂ²\"); Console.WriteLine($\"Disponible: {(EstDisponible ? \"Oui\" : \"Non\")}\"); } } // TODO: CrÃ©er ChambreSimple // TODO: CrÃ©er ChambreDouble // TODO: CrÃ©er Suite // TODO: CrÃ©er Penthouse public class Service { public TypeService Type { get; set; } public string Description { get; set; } public decimal Prix { get; set; } public Service(TypeService type, string description, decimal prix) { Type = type; Description = description; Prix = prix; } } public class Reservation : IAnnulable { private static int _compteur = 0; public int NumeroReservation { get; private set; } public string NomClient { get; set; } public string EmailClient { get; set; } public Chambre Chambre { get; set; } public DateTime DateArrivee { get; set; } public DateTime DateDepart { get; set; } public List\u003cService\u003e Services { get; private set; } public StatutReservation Statut { get; set; } public DateTime DateReservation { get; private set; } public Reservation(string nomClient, string email, Chambre chambre, DateTime arrivee, DateTime depart) { NumeroReservation = ++_compteur; NomClient = nomClient; EmailClient = email; Chambre = chambre; DateArrivee = arrivee; DateDepart = depart; Services = new List\u003cService\u003e(); Statut = StatutReservation.Confirmee; DateReservation = DateTime.Now; } public int CalculerDuree() { // TODO: Calculer nombre de nuits return 0; } public void AjouterService(Service service) { // TODO: ImplÃ©menter } public decimal CalculerCoutTotal() { // TODO: Chambre + services return 0; } public bool Annuler() { // TODO: VÃ©rifier si annulation possible et appliquer frais return false; } public decimal ObtenirFraisAnnulation() { // TODO: Calculer frais selon date d'annulation // Moins de 48h avant: 100% // Moins d'une semaine: 50% // Plus d'une semaine: 25% return 0; } public void AfficherDetails() { // TODO: Afficher tous les dÃ©tails } } public class Hotel { public string Nom { get; set; } public string Adresse { get; set; } private List\u003cChambre\u003e _chambres = new List\u003cChambre\u003e(); private List\u003cReservation\u003e _reservations = new List\u003cReservation\u003e(); public Hotel(string nom, string adresse) { Nom = nom; Adresse = adresse; } public void AjouterChambre(Chambre chambre) { _chambres.Add(chambre); } public List\u003cChambre\u003e RechercherChambresDisponibles(DateTime arrivee, DateTime depart) { // TODO: Filtrer les chambres disponibles pour ces dates return null; } public List\u003cChambre\u003e RechercherParType(TypeChambre type) { // TODO: Filtrer par type return null; } public Reservation CreerReservation(string client, string email, int numeroChambre, DateTime arrivee, DateTime depart) { // TODO: CrÃ©er et ajouter la rÃ©servation return null; } public void AfficherOccupation() { // TODO: Statistiques d'occupation } public decimal CalculerRevenuTotal() { // TODO: Sommer toutes les rÃ©servations confirmÃ©es return 0; } } class Program { static void Main(string[] args) { Hotel hotel = new Hotel(\"Grand HÃ´tel\", \"123 Rue Principale, MontrÃ©al\"); // TODO: Ajouter des chambres // TODO: CrÃ©er des rÃ©servations // TODO: Ajouter des services // TODO: Afficher l'occupation // TODO: Tester les annulations } } } âœ… CritÃ¨res de rÃ©ussite Les prix varient selon le type de chambre et les services Les frais dâ€™annulation sont calculÃ©s correctement Impossible de rÃ©server une chambre dÃ©jÃ  rÃ©servÃ©e Les statistiques sont exactes Projet 8 : Calculatrice de Formes GÃ©omÃ©triques ğŸ“‹ Objectif CrÃ©er un systÃ¨me pour calculer lâ€™aire, le pÃ©rimÃ¨tre et dâ€™autres propriÃ©tÃ©s de formes gÃ©omÃ©triques.\nğŸ¯ Concepts utilisÃ©s Classes abstraites Polymorphisme MÃ©thodes virtuelles Interfaces ğŸ“ SpÃ©cifications CrÃ©er :\nInterface IDessinable :\nMÃ©thode : Dessiner() Classe abstraite Forme :\nPropriÃ©tÃ©s : Nom, Couleur MÃ©thodes abstraites : CalculerAire(), CalculerPerimetre() MÃ©thode virtuelle : AfficherInfos() Classes de formes 2D :\nCercle : rayon Rectangle : longueur, largeur Carre : cÃ´tÃ© Triangle : base, hauteur Polygone : nombre de cÃ´tÃ©s, longueur des cÃ´tÃ©s Classe abstraite Forme3D hÃ©ritant de Forme :\nMÃ©thode abstraite supplÃ©mentaire : CalculerVolume() Classes de formes 3D :\nSphere : rayon Cube : cÃ´tÃ© Cylindre : rayon, hauteur Cone : rayon base, hauteur Classe Calculateur :\nMÃ©thodes statiques pour comparer des formes, trier par aire, etc. ğŸ’¡ Code de dÃ©marrage using System; using System.Collections.Generic; using System.Linq; namespace CalculatriceFormes { public interface IDessinable { void Dessiner(); } public abstract class Forme { public string Nom { get; set; } public string Couleur { get; set; } public abstract double CalculerAire(); public abstract double CalculerPerimetre(); public virtual void AfficherInfos() { Console.WriteLine($\"=== {Nom} ===\"); Console.WriteLine($\"Couleur: {Couleur}\"); Console.WriteLine($\"Aire: {CalculerAire():F2}\"); Console.WriteLine($\"PÃ©rimÃ¨tre: {CalculerPerimetre():F2}\"); } } public class Cercle : Forme, IDessinable { public double Rayon { get; set; } public Cercle(double rayon, string couleur = \"Noir\") { Rayon = rayon; Couleur = couleur; Nom = \"Cercle\"; } public override double CalculerAire() { // TODO: Ï€ Ã— rÂ² return 0; } public override double CalculerPerimetre() { // TODO: 2 Ã— Ï€ Ã— r return 0; } public void Dessiner() { Console.WriteLine($\"Dessin d'un cercle de rayon {Rayon} en {Couleur}\"); Console.WriteLine(\" *** \"); Console.WriteLine(\" * * \"); Console.WriteLine(\" * * \"); Console.WriteLine(\" * * \"); Console.WriteLine(\" *** \"); } } // TODO: CrÃ©er Rectangle // TODO: CrÃ©er Carre // TODO: CrÃ©er Triangle public abstract class Forme3D : Forme { public abstract double CalculerVolume(); public override void AfficherInfos() { base.AfficherInfos(); Console.WriteLine($\"Volume: {CalculerVolume():F2}\"); } } // TODO: CrÃ©er Sphere // TODO: CrÃ©er Cube // TODO: CrÃ©er Cylindre public static class Calculateur { public static Forme TrouverPlusGrandeAire(List\u003cForme\u003e formes) { // TODO: Retourner la forme avec la plus grande aire return null; } public static double CalculerAireTotale(List\u003cForme\u003e formes) { // TODO: Sommer toutes les aires return 0; } public static List\u003cForme\u003e TrierParAire(List\u003cForme\u003e formes) { // TODO: Trier par aire croissante return null; } public static void ComparerFormes(Forme f1, Forme f2) { // TODO: Comparer aires et pÃ©rimÃ¨tres } } class Program { static void Main(string[] args) { List\u003cForme\u003e formes = new List\u003cForme\u003e(); // TODO: CrÃ©er diffÃ©rentes formes // TODO: Afficher les infos // TODO: Utiliser le calculateur // TODO: Dessiner les formes qui sont IDessinable } } } Conseils pour rÃ©ussir les projets ğŸ¯ MÃ©thodologie Lire attentivement les spÃ©cifications Planifier la structure avant de coder Tester frÃ©quemment chaque nouvelle fonctionnalitÃ© Refactoriser le code pour amÃ©liorer la qualitÃ© Documenter avec des commentaires clairs ğŸ” Points de contrÃ´le Pour chaque projet, vÃ©rifiez :\nâœ… Respect de lâ€™encapsulation (propriÃ©tÃ©s privÃ©es/publiques appropriÃ©es) âœ… Utilisation correcte de lâ€™hÃ©ritage âœ… Polymorphisme fonctionnel âœ… Interfaces bien implÃ©mentÃ©es âœ… Gestion des cas dâ€™erreur âœ… Code lisible et bien organisÃ©",
    "description": "Mini-Projets : Programmation OrientÃ©e Objet en C# Progression recommandÃ©e Niveau Projets DÃ©butant Projet 8 (Formes), Projet 5 (TÃ¢ches) IntermÃ©diaire Projet 1 (Banque), Projet 2 (BibliothÃ¨que), Projet 6 (Zoo) AvancÃ© Projet 3 (RPG), Projet 4 (Restaurant), Projet 7 (HÃ´tel) Table des matiÃ¨res Projet 1 : SystÃ¨me de Gestion Bancaire Projet 2 : Gestion dâ€™une BibliothÃ¨que Projet 3 : Jeu de Combat RPG Projet 4 : SystÃ¨me de Commandes Restaurant Projet 5 : Gestionnaire de TÃ¢ches Projet 6 : Simulateur de Zoo Projet 7 : SystÃ¨me de RÃ©servation HÃ´tel Projet 8 : Calculatrice de Formes GÃ©omÃ©triques Projet 1 : SystÃ¨me de Gestion Bancaire ğŸ“‹ Objectif CrÃ©er un systÃ¨me de gestion de comptes bancaires avec diffÃ©rents types de comptes et opÃ©rations.",
    "tags": [],
    "title": "Exercices - POO",
    "uri": "/420-413/poo_exos/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "ğŸ“˜ LINQ en C# Language Integrated Query ğŸ“‹ Table des matiÃ¨res Introduction Ã  LINQ Pourquoi utiliser LINQ ? Les Bases de LINQ Les Deux Syntaxes LINQ OpÃ©rations de Filtrage OpÃ©rations de Projection OpÃ©rations de Tri OpÃ©rations dâ€™AgrÃ©gation OpÃ©rations de Regroupement OpÃ©rations de Jointure OpÃ©rations dâ€™Ensemble OpÃ©rations de Quantification OpÃ©rations de Partition LINQ avec Objets Complexes Cas Pratiques RÃ©els Bonnes Pratiques et PiÃ¨ges 1. Introduction Ã  LINQ 1.1 Quâ€™est-ce que LINQ ? LINQ (Language Integrated Query) est une fonctionnalitÃ© de C# qui permet dâ€™interroger des collections de donnÃ©es directement dans le code, avec une syntaxe Ã©lÃ©gante et lisible.\nAnalogie : Imaginez que vous avez une bibliothÃ¨que remplie de livres. PlutÃ´t que de parcourir manuellement chaque Ã©tagÃ¨re pour trouver â€œtous les romans de science-fiction publiÃ©s aprÃ¨s 2020â€, LINQ vous permet de poser cette question directement et dâ€™obtenir la rÃ©ponse instantanÃ©ment.\n1.2 Les sources de donnÃ©es LINQ LINQ peut interroger diffÃ©rents types de donnÃ©es :\n// LINQ to Objects - Collections en mÃ©moire List\u003cint\u003e nombres = new List\u003cint\u003e { 1, 2, 3, 4, 5 }; var pairs = from n in nombres where n % 2 == 0 select n; // LINQ to XML - Documents XML XDocument doc = XDocument.Load(\"data.xml\"); var elements = from e in doc.Descendants(\"item\") select e; // LINQ to SQL / Entity Framework - Bases de donnÃ©es var clients = from c in dbContext.Clients where c.Ville == \"MontrÃ©al\" select c; Dans ce cours, nous nous concentrerons sur LINQ to Objects (collections en mÃ©moire).\n1.3 Mise en contexte : ProblÃ¨me sans LINQ // ========================================== // SCÃ‰NARIO : Trouver tous les Ã©tudiants avec une moyenne \u003e= 75 // ========================================== public class Etudiant { public string Nom { get; set; } public int Age { get; set; } public double Moyenne { get; set; } public string Programme { get; set; } } // DonnÃ©es List\u003cEtudiant\u003e etudiants = new List\u003cEtudiant\u003e { new Etudiant { Nom = \"Alice\", Age = 20, Moyenne = 85.5, Programme = \"Informatique\" }, new Etudiant { Nom = \"Bob\", Age = 22, Moyenne = 72.0, Programme = \"GÃ©nie\" }, new Etudiant { Nom = \"Charlie\", Age = 21, Moyenne = 90.0, Programme = \"Informatique\" }, new Etudiant { Nom = \"Diana\", Age = 19, Moyenne = 68.5, Programme = \"Math\" }, new Etudiant { Nom = \"Eve\", Age = 23, Moyenne = 78.0, Programme = \"Informatique\" } }; // ========================================== // SANS LINQ - Approche traditionnelle (boucles) // ========================================== List\u003cEtudiant\u003e etudiantsAvecBonneMoyenne = new List\u003cEtudiant\u003e(); foreach (var etudiant in etudiants) { if (etudiant.Moyenne \u003e= 75) { etudiantsAvecBonneMoyenne.Add(etudiant); } } Console.WriteLine(\"Ã‰tudiants avec moyenne \u003e= 75:\"); foreach (var etudiant in etudiantsAvecBonneMoyenne) { Console.WriteLine($\"{etudiant.Nom}: {etudiant.Moyenne}\"); } // Affiche: // Alice: 85.5 // Charlie: 90 // Eve: 78 ProblÃ¨mes avec cette approche :\nCode verbeux (beaucoup de lignes pour une tÃ¢che simple) LisibilitÃ© rÃ©duite Variables temporaires nÃ©cessaires Difficile Ã  combiner plusieurs opÃ©rations 2. Pourquoi utiliser LINQ ? 2.1 Avantages de LINQ // ========================================== // AVEC LINQ - Ã‰lÃ©gant et concis // ========================================== var etudiantsAvecBonneMoyenne = etudiants.Where(e =\u003e e.Moyenne \u003e= 75); foreach (var etudiant in etudiantsAvecBonneMoyenne) { Console.WriteLine($\"{etudiant.Nom}: {etudiant.Moyenne}\"); } // MÃªme rÃ©sultat, mais en UNE SEULE LIGNE ! ğŸ¯ Avantages :\nConcision : Moins de code pour le mÃªme rÃ©sultat LisibilitÃ© : Le code se lit comme une phrase en anglais ComposabilitÃ© : Facile dâ€™enchaÃ®ner plusieurs opÃ©rations Type-safe : Erreurs dÃ©tectÃ©es Ã  la compilation IntelliSense : Auto-complÃ©tion dans Visual Studio RÃ©utilisabilitÃ© : RequÃªtes rÃ©utilisables 2.2 Comparaison avant/aprÃ¨s LINQ // ========================================== // SCÃ‰NARIO : Trouver les noms des Ã©tudiants en informatique, // triÃ©s par moyenne dÃ©croissante, avec moyenne \u003e= 80 // ========================================== // SANS LINQ - 15+ lignes List\u003cEtudiant\u003e etudiantsInfo = new List\u003cEtudiant\u003e(); foreach (var e in etudiants) { if (e.Programme == \"Informatique\" \u0026\u0026 e.Moyenne \u003e= 80) { etudiantsInfo.Add(e); } } // Tri manuel etudiantsInfo.Sort((a, b) =\u003e b.Moyenne.CompareTo(a.Moyenne)); List\u003cstring\u003e noms = new List\u003cstring\u003e(); foreach (var e in etudiantsInfo) { noms.Add(e.Nom); } // AVEC LINQ - 3 lignes (ou mÃªme 1 ligne!) var nomsInfo = etudiants .Where(e =\u003e e.Programme == \"Informatique\" \u0026\u0026 e.Moyenne \u003e= 80) .OrderByDescending(e =\u003e e.Moyenne) .Select(e =\u003e e.Nom); // Affichage foreach (var nom in nomsInfo) { Console.WriteLine(nom); } // Affiche: // Charlie // Alice 3. Les bases de LINQ 3.1 Importer le namespace using System.Linq; // âš ï¸ OBLIGATOIRE pour utiliser LINQ using System.Collections.Generic; 3.2 Les collections et IEnumerable LINQ fonctionne avec tout ce qui implÃ©mente IEnumerable\u003cT\u003e :\n// Listes List\u003cint\u003e nombres = new List\u003cint\u003e { 1, 2, 3, 4, 5 }; // Tableaux int[] tableauNombres = { 1, 2, 3, 4, 5 }; // Dictionnaires Dictionary\u003cstring, int\u003e ages = new Dictionary\u003cstring, int\u003e { { \"Alice\", 25 }, { \"Bob\", 30 } }; // Tous peuvent Ãªtre interrogÃ©s avec LINQ ! var resultats1 = nombres.Where(n =\u003e n \u003e 3); var resultats2 = tableauNombres.Where(n =\u003e n \u003e 3); var resultats3 = ages.Where(kvp =\u003e kvp.Value \u003e 25); 3.3 Lâ€™exÃ©cution diffÃ©rÃ©e (deferred execution) Concept important : LINQ utilise lâ€™exÃ©cution diffÃ©rÃ©e - la requÃªte nâ€™est exÃ©cutÃ©e que lorsquâ€™on Ã©numÃ¨re les rÃ©sultats.\nList\u003cint\u003e nombres = new List\u003cint\u003e { 1, 2, 3, 4, 5 }; // âš ï¸ La requÃªte est DÃ‰FINIE mais PAS EXÃ‰CUTÃ‰E var nombresPairs = nombres.Where(n =\u003e n % 2 == 0); Console.WriteLine(\"RequÃªte dÃ©finie\"); // Ajout d'un nouvel Ã©lÃ©ment APRÃˆS la dÃ©finition de la requÃªte nombres.Add(6); // âœ… La requÃªte est EXÃ‰CUTÃ‰E maintenant (lors du foreach) foreach (var n in nombresPairs) { Console.WriteLine(n); // Affiche: 2, 4, 6 (6 est inclus!) } Forcer lâ€™exÃ©cution immÃ©diate :\n// ExÃ©cution diffÃ©rÃ©e (par dÃ©faut) var requete = nombres.Where(n =\u003e n % 2 == 0); // IEnumerable\u003cint\u003e // ExÃ©cution immÃ©diate avec ToList() var liste = nombres.Where(n =\u003e n % 2 == 0).ToList(); // List\u003cint\u003e // ExÃ©cution immÃ©diate avec ToArray() var tableau = nombres.Where(n =\u003e n % 2 == 0).ToArray(); // int[] // ExÃ©cution immÃ©diate avec Count() int compte = nombres.Where(n =\u003e n % 2 == 0).Count(); // int 4. Les deux syntaxes LINQ LINQ offre deux syntaxes pour Ã©crire les requÃªtes :\n4.1 Syntaxe de mÃ©thode (method syntax) Utilise des mÃ©thodes dâ€™extension avec des expressions lambda.\nvar resultat = etudiants .Where(e =\u003e e.Moyenne \u003e= 75) .OrderBy(e =\u003e e.Nom) .Select(e =\u003e e.Nom); Avantages :\nPlus concise Plus flexible (accÃ¨s Ã  toutes les mÃ©thodes LINQ) PrÃ©fÃ©rÃ©e par la plupart des dÃ©veloppeurs RecommandÃ©e pour ce cours 4.2 Syntaxe de requÃªte (query syntax) Ressemble au SQL, utilise des mots-clÃ©s comme from, where, select.\nvar resultat = from e in etudiants where e.Moyenne \u003e= 75 orderby e.Nom select e.Nom; Avantages :\nFamiliÃ¨re pour ceux qui connaissent SQL Parfois plus lisible pour des requÃªtes complexes 4.3 Comparaison des deux syntaxes // ========================================== // SCÃ‰NARIO : Ã‰tudiants en informatique avec moyenne \u003e= 80 // ========================================== // SYNTAXE DE MÃ‰THODE (recommandÃ©e) var resultat1 = etudiants .Where(e =\u003e e.Programme == \"Informatique\") .Where(e =\u003e e.Moyenne \u003e= 80) .Select(e =\u003e e.Nom); // SYNTAXE DE REQUÃŠTE var resultat2 = from e in etudiants where e.Programme == \"Informatique\" where e.Moyenne \u003e= 80 select e.Nom; // Les DEUX produisent le mÃªme rÃ©sultat ! ğŸ’¡ Dans ce cours, nous utiliserons principalement la syntaxe de mÃ©thode car elle est :\nPlus courante dans lâ€™industrie Plus flexible Mieux supportÃ©e par IntelliSense 5. OpÃ©rations de filtrage 5.1 Where - Filtrer selon une condition Where() retourne tous les Ã©lÃ©ments qui satisfont une condition.\n// ========================================== // MISE EN CONTEXTE : Gestion d'un magasin // ========================================== public class Produit { public int Id { get; set; } public string Nom { get; set; } public decimal Prix { get; set; } public string Categorie { get; set; } public int Stock { get; set; } public bool EstEnPromotion { get; set; } } List\u003cProduit\u003e produits = new List\u003cProduit\u003e { new Produit { Id = 1, Nom = \"Laptop\", Prix = 1200, Categorie = \"Ã‰lectronique\", Stock = 5, EstEnPromotion = true }, new Produit { Id = 2, Nom = \"Souris\", Prix = 25, Categorie = \"Ã‰lectronique\", Stock = 50, EstEnPromotion = false }, new Produit { Id = 3, Nom = \"Clavier\", Prix = 80, Categorie = \"Ã‰lectronique\", Stock = 30, EstEnPromotion = true }, new Produit { Id = 4, Nom = \"Chaise\", Prix = 150, Categorie = \"Mobilier\", Stock = 10, EstEnPromotion = false }, new Produit { Id = 5, Nom = \"Bureau\", Prix = 400, Categorie = \"Mobilier\", Stock = 3, EstEnPromotion = true }, new Produit { Id = 6, Nom = \"Lampe\", Prix = 45, Categorie = \"Mobilier\", Stock = 20, EstEnPromotion = false } }; // ========================================== // EXEMPLE 1 : Produits en promotion // ========================================== var produitsEnPromotion = produits.Where(p =\u003e p.EstEnPromotion); Console.WriteLine(\"Produits en promotion:\"); foreach (var p in produitsEnPromotion) { Console.WriteLine($\"- {p.Nom} ({p.Prix:C})\"); } // Affiche: // - Laptop (1 200,00 $) // - Clavier (80,00 $) // - Bureau (400,00 $) // ========================================== // EXEMPLE 2 : Produits chers (\u003e 100$) // ========================================== var produitsChe rs = produits.Where(p =\u003e p.Prix \u003e 100); // ========================================== // EXEMPLE 3 : Ã‰lectronique PAS en promotion // ========================================== var electroniqueNormale = produits.Where(p =\u003e p.Categorie == \"Ã‰lectronique\" \u0026\u0026 !p.EstEnPromotion ); // ========================================== // EXEMPLE 4 : Stock faible (\u003c 10 unitÃ©s) // ========================================== var stockFaible = produits.Where(p =\u003e p.Stock \u003c 10); Console.WriteLine(\"\\nâš ï¸ ALERTE Stock faible:\"); foreach (var p in stockFaible) { Console.WriteLine($\"- {p.Nom}: seulement {p.Stock} unitÃ©s\"); } // Affiche: // - Laptop: seulement 5 unitÃ©s // - Bureau: seulement 3 unitÃ©s // ========================================== // EXEMPLE 5 : Conditions multiples // ========================================== var produitsSpeciaux = produits.Where(p =\u003e p.Prix \u003e= 50 \u0026\u0026 p.Prix \u003c= 200 \u0026\u0026 p.Stock \u003e 5 \u0026\u0026 p.Categorie == \"Ã‰lectronique\" ); ğŸ’¡ Astuce : Vous pouvez chaÃ®ner plusieurs Where() :\n// Ces deux requÃªtes sont Ã©quivalentes: // Version 1 : Une seule condition complexe var resultat1 = produits.Where(p =\u003e p.Prix \u003e 50 \u0026\u0026 p.Stock \u003e 10); // Version 2 : Deux Where() sÃ©parÃ©s, mais moins efficace que la premiÃ¨re version var resultat2 = produits .Where(p =\u003e p.Prix \u003e 50) .Where(p =\u003e p.Stock \u003e 10); 5.2 OfType - Filtrer par type Utile quand vous avez une collection dâ€™objets de types diffÃ©rents.\n// ========================================== // MISE EN CONTEXTE : Gestion de formes gÃ©omÃ©triques // ========================================== public abstract class Forme { public string Couleur { get; set; } } public class Cercle : Forme { public double Rayon { get; set; } } public class Rectangle : Forme { public double Longueur { get; set; } public double Largeur { get; set; } } public class Triangle : Forme { public double Base { get; set; } public double Hauteur { get; set; } } // Collection mixte List\u003cForme\u003e formes = new List\u003cForme\u003e { new Cercle { Couleur = \"Rouge\", Rayon = 5 }, new Rectangle { Couleur = \"Bleu\", Longueur = 10, Largeur = 5 }, new Cercle { Couleur = \"Vert\", Rayon = 3 }, new Triangle { Couleur = \"Jaune\", Base = 4, Hauteur = 6 }, new Rectangle { Couleur = \"Orange\", Longueur = 8, Largeur = 4 } }; // ========================================== // Obtenir seulement les cercles // ========================================== var cercles = formes.OfType\u003cCercle\u003e(); Console.WriteLine(\"Cercles:\"); foreach (var c in cercles) { Console.WriteLine($\"- Cercle {c.Couleur}, rayon = {c.Rayon}\"); } // Affiche: // - Cercle Rouge, rayon = 5 // - Cercle Vert, rayon = 3 // ========================================== // Obtenir seulement les rectangles // ========================================== var rectangles = formes.OfType\u003cRectangle\u003e(); // ========================================== // Calcul d'aire pour tous les cercles // ========================================== var airesDesCercles = formes .OfType\u003cCercle\u003e() .Select(c =\u003e Math.PI * c.Rayon * c.Rayon); 6. OpÃ©rations de projection La projection transforme les Ã©lÃ©ments dâ€™une collection en un autre format.\n6.1 Select - Transformer chaque Ã©lÃ©ment // ========================================== // MISE EN CONTEXTE : SystÃ¨me de gestion d'employÃ©s // ========================================== public class Employe { public int Id { get; set; } public string Prenom { get; set; } public string Nom { get; set; } public string Departement { get; set; } public decimal Salaire { get; set; } public DateTime DateEmbauche { get; set; } } List\u003cEmploye\u003e employes = new List\u003cEmploye\u003e { new Employe { Id = 1, Prenom = \"Alice\", Nom = \"Tremblay\", Departement = \"IT\", Salaire = 75000, DateEmbauche = new DateTime(2020, 5, 15) }, new Employe { Id = 2, Prenom = \"Bob\", Nom = \"Gagnon\", Departement = \"RH\", Salaire = 65000, DateEmbauche = new DateTime(2019, 3, 10) }, new Employe { Id = 3, Prenom = \"Charlie\", Nom = \"Roy\", Departement = \"IT\", Salaire = 85000, DateEmbauche = new DateTime(2018, 1, 20) }, new Employe { Id = 4, Prenom = \"Diana\", Nom = \"Martin\", Departement = \"Ventes\", Salaire = 70000, DateEmbauche = new DateTime(2021, 7, 5) } }; // ========================================== // EXEMPLE 1 : Extraire seulement les noms complets // ========================================== var nomsComplets = employes.Select(e =\u003e $\"{e.Prenom} {e.Nom}\"); Console.WriteLine(\"Liste des employÃ©s:\"); foreach (var nom in nomsComplets) { Console.WriteLine($\"- {nom}\"); } // Affiche: // - Alice Tremblay // - Bob Gagnon // - Charlie Roy // - Diana Martin // ========================================== // EXEMPLE 2 : Extraire seulement les salaires // ========================================== var salaires = employes.Select(e =\u003e e.Salaire); // ========================================== // EXEMPLE 3 : Augmenter tous les salaires de 10% // ========================================== var salairesAugmentes = employes.Select(e =\u003e e.Salaire * 1.10m); Console.WriteLine(\"\\nSalaires aprÃ¨s augmentation de 10%:\"); foreach (var salaire in salairesAugmentes) { Console.WriteLine($\"{salaire:C}\"); } // ========================================== // EXEMPLE 4 : Projection vers un type anonyme // ========================================== var resumeEmployes = employes.Select(e =\u003e new { NomComplet = $\"{e.Prenom} {e.Nom}\", Dept = e.Departement, SalaireAnnuel = e.Salaire, SalaireMensuel = e.Salaire / 12, Anciennete = DateTime.Now.Year - e.DateEmbauche.Year }); Console.WriteLine(\"\\nRÃ©sumÃ© des employÃ©s:\"); foreach (var e in resumeEmployes) { Console.WriteLine($\"{e.NomComplet} ({e.Dept}) - {e.SalaireAnnuel:C}/an - {e.Anciennete} ans d'anciennetÃ©\"); } // ========================================== // EXEMPLE 5 : Projection vers une nouvelle classe // ========================================== public class EmployeDTO // DTO = Data Transfer Object { public string NomComplet { get; set; } public string Departement { get; set; } public string InformationSalaire { get; set; } } var employesDTO = employes.Select(e =\u003e new EmployeDTO { NomComplet = $\"{e.Prenom} {e.Nom}\", Departement = e.Departement, InformationSalaire = $\"{e.Salaire:C} par annÃ©e\" }); 6.2 SelectMany - Aplatir des collections imbriquÃ©es UtilisÃ© pour â€œaplatirâ€ des collections de collections en une seule collection.\n// ========================================== // MISE EN CONTEXTE : UniversitÃ© avec Ã©tudiants et cours // ========================================== public class Cours { public string Code { get; set; } public string Nom { get; set; } public int Credits { get; set; } } public class EtudiantAvecCours { public string Nom { get; set; } public List\u003cCours\u003e CoursInscrits { get; set; } } List\u003cEtudiantAvecCours\u003e etudiants = new List\u003cEtudiantAvecCours\u003e { new EtudiantAvecCours { Nom = \"Alice\", CoursInscrits = new List\u003cCours\u003e { new Cours { Code = \"INF101\", Nom = \"Programmation I\", Credits = 3 }, new Cours { Code = \"MAT201\", Nom = \"Calcul I\", Credits = 4 } } }, new EtudiantAvecCours { Nom = \"Bob\", CoursInscrits = new List\u003cCours\u003e { new Cours { Code = \"INF101\", Nom = \"Programmation I\", Credits = 3 }, new Cours { Code = \"INF202\", Nom = \"Structures de donnÃ©es\", Credits = 3 } } }, new EtudiantAvecCours { Nom = \"Charlie\", CoursInscrits = new List\u003cCours\u003e { new Cours { Code = \"MAT201\", Nom = \"Calcul I\", Credits = 4 }, new Cours { Code = \"PHY101\", Nom = \"Physique I\", Credits = 4 } } } }; // ========================================== // PROBLÃˆME : Obtenir TOUS les cours (de tous les Ã©tudiants) // ========================================== // âŒ MAUVAISE approche avec Select (ne fonctionne pas comme voulu) var tentative = etudiants.Select(e =\u003e e.CoursInscrits); // Retourne : IEnumerable\u003cList\u003cCours\u003e\u003e - Une liste de listes ! // âœ… BONNE approche avec SelectMany var tousLesCours = etudiants.SelectMany(e =\u003e e.CoursInscrits); // Retourne : IEnumerable\u003cCours\u003e - Une liste plate ! Console.WriteLine(\"Tous les cours (avec doublons):\"); foreach (var cours in tousLesCours) { Console.WriteLine($\"- {cours.Code}: {cours.Nom}\"); } // Affiche: // - INF101: Programmation I // - MAT201: Calcul I // - INF101: Programmation I (doublon) // - INF202: Structures de donnÃ©es // - MAT201: Calcul I (doublon) // - PHY101: Physique I // ========================================== // Obtenir les cours uniques // ========================================== var coursUniques = etudiants .SelectMany(e =\u003e e.CoursInscrits) .Distinct() // Ã‰limine les doublons .Select(c =\u003e c.Code); Console.WriteLine(\"\\nCours uniques:\"); foreach (var code in coursUniques) { Console.WriteLine($\"- {code}\"); } // ========================================== // Compter le nombre total de crÃ©dits de tous les Ã©tudiants // ========================================== int totalCredits = etudiants .SelectMany(e =\u003e e.CoursInscrits) .Sum(c =\u003e c.Credits); Console.WriteLine($\"\\nTotal de crÃ©dits inscrits: {totalCredits}\"); Visualisation Select vs SelectMany :\nDonnÃ©es:\rÃ‰tudiant 1 â†’ [Cours A, Cours B]\rÃ‰tudiant 2 â†’ [Cours C, Cours D]\rÃ‰tudiant 3 â†’ [Cours E]\rSelect() :\r[[Cours A, Cours B], [Cours C, Cours D], [Cours E]]\râ†‘ Liste de listes\rSelectMany() :\r[Cours A, Cours B, Cours C, Cours D, Cours E]\râ†‘ Liste plate 7. OpÃ©rations de tri 7.1 OrderBy et OrderByDescending // ========================================== // MISE EN CONTEXTE : Classement d'athlÃ¨tes // ========================================== public class Athlete { public string Nom { get; set; } public string Pays { get; set; } public int Age { get; set; } public double TempsCourse { get; set; } // En secondes public int MedaillesOr { get; set; } } List\u003cAthlete\u003e athletes = new List\u003cAthlete\u003e { new Athlete { Nom = \"Usain Bolt\", Pays = \"JamaÃ¯que\", Age = 36, TempsCourse = 9.58, MedaillesOr = 8 }, new Athlete { Nom = \"Carl Lewis\", Pays = \"USA\", Age = 61, TempsCourse = 9.86, MedaillesOr = 9 }, new Athlete { Nom = \"Andre De Grasse\", Pays = \"Canada\", Age = 28, TempsCourse = 9.89, MedaillesOr = 1 }, new Athlete { Nom = \"Yohan Blake\", Pays = \"JamaÃ¯que\", Age = 33, TempsCourse = 9.69, MedaillesOr = 1 }, new Athlete { Nom = \"Justin Gatlin\", Pays = \"USA\", Age = 41, TempsCourse = 9.74, MedaillesOr = 1 } }; // ========================================== // EXEMPLE 1 : Trier par temps (du plus rapide au plus lent) // ========================================== var classementParTemps = athletes.OrderBy(a =\u003e a.TempsCourse); Console.WriteLine(\"Classement par temps de course:\"); int position = 1; foreach (var athlete in classementParTemps) { Console.WriteLine($\"{position}. {athlete.Nom} - {athlete.TempsCourse}s\"); position++; } // Affiche: // 1. Usain Bolt - 9.58s // 2. Yohan Blake - 9.69s // 3. Justin Gatlin - 9.74s // 4. Carl Lewis - 9.86s // 5. Andre De Grasse - 9.89s // ========================================== // EXEMPLE 2 : Trier par mÃ©dailles (du plus au moins) // ========================================== var classementParMedailles = athletes.OrderByDescending(a =\u003e a.MedaillesOr); Console.WriteLine(\"\\nClassement par mÃ©dailles d'or:\"); foreach (var athlete in classementParMedailles) { Console.WriteLine($\"{athlete.Nom}: {athlete.MedaillesOr} mÃ©daille(s)\"); } // ========================================== // EXEMPLE 3 : Trier par nom (ordre alphabÃ©tique) // ========================================== var classementAlphabetique = athletes.OrderBy(a =\u003e a.Nom); // ========================================== // EXEMPLE 4 : Trier par Ã¢ge (du plus jeune au plus vieux) // ========================================== var classementParAge = athletes.OrderBy(a =\u003e a.Age); 7.2 ThenBy et ThenByDescending - Tris secondaires UtilisÃ©s pour trier selon plusieurs critÃ¨res.\n// ========================================== // EXEMPLE : Trier par pays, puis par temps // ========================================== var classementPaysEtTemps = athletes .OrderBy(a =\u003e a.Pays) // D'abord par pays .ThenBy(a =\u003e a.TempsCourse); // Ensuite par temps Console.WriteLine(\"Classement par pays puis temps:\"); foreach (var athlete in classementPaysEtTemps) { Console.WriteLine($\"{athlete.Pays} - {athlete.Nom} ({athlete.TempsCourse}s)\"); } // Affiche: // Canada - Andre De Grasse (9.89s) // JamaÃ¯que - Usain Bolt (9.58s) // JamaÃ¯que - Yohan Blake (9.69s) // USA - Justin Gatlin (9.74s) // USA - Carl Lewis (9.86s) // ========================================== // EXEMPLE : Trier par mÃ©dailles (desc), puis par temps (asc) // ========================================== var classementComplet = athletes .OrderByDescending(a =\u003e a.MedaillesOr) // Plus de mÃ©dailles en premier .ThenBy(a =\u003e a.TempsCourse); // Si Ã©galitÃ©, plus rapide en premier Console.WriteLine(\"\\nClassement final:\"); foreach (var athlete in classementComplet) { Console.WriteLine($\"{athlete.Nom}: {athlete.MedaillesOr} mÃ©daille(s), {athlete.TempsCourse}s\"); } 7.3 Reverse - Inverser lâ€™ordre // Liste de nombres List\u003cint\u003e nombres = new List\u003cint\u003e { 1, 2, 3, 4, 5 }; // Inverser l'ordre var nombresInverses = nombres.AsEnumerable().Reverse(); foreach (var n in nombresInverses) { Console.Write($\"{n} \"); // Affiche: 5 4 3 2 1 } 8. OpÃ©rations dâ€™AgrÃ©gation Les opÃ©rations dâ€™agrÃ©gation calculent une valeur unique Ã  partir dâ€™une collection.\n8.1 Count - Compter les Ã©lÃ©ments // ========================================== // MISE EN CONTEXTE : SystÃ¨me de gestion de bibliothÃ¨que // ========================================== public class Livre { public string Titre { get; set; } public string Auteur { get; set; } public int AnneePublication { get; set; } public string Genre { get; set; } public int NombrePages { get; set; } public bool EstDisponible { get; set; } public double Note { get; set; } // Sur 5 } List\u003cLivre\u003e bibliotheque = new List\u003cLivre\u003e { new Livre { Titre = \"1984\", Auteur = \"George Orwell\", AnneePublication = 1949, Genre = \"Science-Fiction\", NombrePages = 328, EstDisponible = true, Note = 4.7 }, new Livre { Titre = \"Le Petit Prince\", Auteur = \"Antoine de Saint-ExupÃ©ry\", AnneePublication = 1943, Genre = \"Fiction\", NombrePages = 96, EstDisponible = false, Note = 4.8 }, new Livre { Titre = \"Harry Potter Ã  l'Ã©cole des sorciers\", Auteur = \"J.K. Rowling\", AnneePublication = 1997, Genre = \"Fantasy\", NombrePages = 309, EstDisponible = true, Note = 4.9 }, new Livre { Titre = \"Le Seigneur des Anneaux\", Auteur = \"J.R.R. Tolkien\", AnneePublication = 1954, Genre = \"Fantasy\", NombrePages = 1178, EstDisponible = true, Note = 4.9 }, new Livre { Titre = \"Dune\", Auteur = \"Frank Herbert\", AnneePublication = 1965, Genre = \"Science-Fiction\", NombrePages = 688, EstDisponible = false, Note = 4.6 }, new Livre { Titre = \"Les MisÃ©rables\", Auteur = \"Victor Hugo\", AnneePublication = 1862, Genre = \"Classique\", NombrePages = 1463, EstDisponible = true, Note = 4.5 } }; // ========================================== // EXEMPLE 1 : Compter tous les livres // ========================================== int totalLivres = bibliotheque.Count(); Console.WriteLine($\"Total de livres: {totalLivres}\"); // 6 // ========================================== // EXEMPLE 2 : Compter les livres disponibles // ========================================== int livresDisponibles = bibliotheque.Count(l =\u003e l.EstDisponible); Console.WriteLine($\"Livres disponibles: {livresDisponibles}\"); // 4 // ========================================== // EXEMPLE 3 : Compter par genre // ========================================== int livresSciFi = bibliotheque.Count(l =\u003e l.Genre == \"Science-Fiction\"); int livresFantasy = bibliotheque.Count(l =\u003e l.Genre == \"Fantasy\"); Console.WriteLine($\"Science-Fiction: {livresSciFi}\"); // 2 Console.WriteLine($\"Fantasy: {livresFantasy}\"); // 2 // ========================================== // EXEMPLE 4 : Compter les livres rÃ©cents (aprÃ¨s 1990) // ========================================== int livresRecents = bibliotheque.Count(l =\u003e l.AnneePublication \u003e= 1990); Console.WriteLine($\"Livres publiÃ©s aprÃ¨s 1990: {livresRecents}\"); // 1 8.2 Sum - Calculer la somme // ========================================== // EXEMPLE 1 : Nombre total de pages dans la bibliothÃ¨que // ========================================== int totalPages = bibliotheque.Sum(l =\u003e l.NombrePages); Console.WriteLine($\"Total de pages: {totalPages:N0}\"); // 4 062 // ========================================== // EXEMPLE 2 : Pages des livres disponibles // ========================================== int pagesDisponibles = bibliotheque .Where(l =\u003e l.EstDisponible) .Sum(l =\u003e l.NombrePages); Console.WriteLine($\"Pages disponibles: {pagesDisponibles:N0}\"); // 3 178 // ========================================== // EXEMPLE 3 : Somme simple (liste de nombres) // ========================================== List\u003cint\u003e ventes = new List\u003cint\u003e { 100, 250, 175, 320, 95 }; int totalVentes = ventes.Sum(); Console.WriteLine($\"Total des ventes: {totalVentes}\"); // 940 8.3 Average - Calculer la moyenne // ========================================== // EXEMPLE 1 : Note moyenne de tous les livres // ========================================== double noteMoyenne = bibliotheque.Average(l =\u003e l.Note); Console.WriteLine($\"Note moyenne: {noteMoyenne:F2}/5\"); // 4.73/5 // ========================================== // EXEMPLE 2 : Nombre moyen de pages // ========================================== double moyennePages = bibliotheque.Average(l =\u003e l.NombrePages); Console.WriteLine($\"Moyenne de pages: {moyennePages:F0}\"); // 677 // ========================================== // EXEMPLE 3 : Note moyenne des livres Fantasy // ========================================== double noteMoyenneFantasy = bibliotheque .Where(l =\u003e l.Genre == \"Fantasy\") .Average(l =\u003e l.Note); Console.WriteLine($\"Note moyenne Fantasy: {noteMoyenneFantasy:F2}/5\"); // 4.90/5 8.4 Min et Max - Trouver minimum et maximum // ========================================== // EXEMPLE 1 : Plus vieux et plus rÃ©cent livre // ========================================== int anneeMin = bibliotheque.Min(l =\u003e l.AnneePublication); int anneeMax = bibliotheque.Max(l =\u003e l.AnneePublication); Console.WriteLine($\"Plus vieux livre: {anneeMin}\"); // 1862 Console.WriteLine($\"Plus rÃ©cent livre: {anneeMax}\"); // 1997 // ========================================== // EXEMPLE 2 : Livre le plus court et le plus long // ========================================== int pagesMin = bibliotheque.Min(l =\u003e l.NombrePages); int pagesMax = bibliotheque.Max(l =\u003e l.NombrePages); Console.WriteLine($\"Livre le plus court: {pagesMin} pages\"); // 96 Console.WriteLine($\"Livre le plus long: {pagesMax} pages\"); // 1463 // ========================================== // EXEMPLE 3 : Meilleure et pire note // ========================================== double meilleureNote = bibliotheque.Max(l =\u003e l.Note); double pireNote = bibliotheque.Min(l =\u003e l.Note); Console.WriteLine($\"Meilleure note: {meilleureNote}/5\"); // 4.9/5 Console.WriteLine($\"Pire note: {pireNote}/5\"); // 4.5/5 // ========================================== // EXEMPLE 4 : Obtenir LE livre avec la meilleure note (pas juste la note) // ========================================== var meilleurLivre = bibliotheque.OrderByDescending(l =\u003e l.Note).First(); Console.WriteLine($\"Meilleur livre: {meilleurLivre.Titre} ({meilleurLivre.Note}/5)\"); // Harry Potter Ã  l'Ã©cole des sorciers (4.9/5) 8.5 Aggregate - AgrÃ©gation personnalisÃ©e Pour des calculs plus complexes.\n// ========================================== // EXEMPLE 1 : ConcatÃ©ner tous les titres // ========================================== string tousTitres = bibliotheque .Select(l =\u003e l.Titre) .Aggregate((titre1, titre2) =\u003e titre1 + \", \" + titre2); Console.WriteLine($\"Tous les titres: {tousTitres}\"); // ========================================== // EXEMPLE 2 : Calculer un produit (multiplication) // ========================================== List\u003cint\u003e nombres = new List\u003cint\u003e { 2, 3, 4, 5 }; int produit = nombres.Aggregate((a, b) =\u003e a * b); Console.WriteLine($\"Produit: {produit}\"); // 2 Ã— 3 Ã— 4 Ã— 5 = 120 // ========================================== // EXEMPLE 3 : Calculer un total avec valeur initiale // ========================================== int sommeAvecInitial = nombres.Aggregate(100, (total, nombre) =\u003e total + nombre); Console.WriteLine($\"Somme avec initial: {sommeAvecInitial}\"); // 100 + 2 + 3 + 4 + 5 = 114 9. OpÃ©rations de Regroupement 9.1 GroupBy - Regrouper par clÃ© // ========================================== // MISE EN CONTEXTE : Analyse des ventes d'un magasin // ========================================== public class Vente { public int Id { get; set; } public string Produit { get; set; } public string Categorie { get; set; } public decimal Montant { get; set; } public DateTime Date { get; set; } public string Vendeur { get; set; } } List\u003cVente\u003e ventes = new List\u003cVente\u003e { new Vente { Id = 1, Produit = \"Laptop\", Categorie = \"Ã‰lectronique\", Montant = 1200, Date = new DateTime(2024, 1, 15), Vendeur = \"Alice\" }, new Vente { Id = 2, Produit = \"Souris\", Categorie = \"Ã‰lectronique\", Montant = 25, Date = new DateTime(2024, 1, 16), Vendeur = \"Bob\" }, new Vente { Id = 3, Produit = \"Bureau\", Categorie = \"Mobilier\", Montant = 400, Date = new DateTime(2024, 1, 17), Vendeur = \"Alice\" }, new Vente { Id = 4, Produit = \"Chaise\", Categorie = \"Mobilier\", Montant = 150, Date = new DateTime(2024, 1, 18), Vendeur = \"Charlie\" }, new Vente { Id = 5, Produit = \"Clavier\", Categorie = \"Ã‰lectronique\", Montant = 80, Date = new DateTime(2024, 1, 19), Vendeur = \"Bob\" }, new Vente { Id = 6, Produit = \"Lampe\", Categorie = \"Mobilier\", Montant = 45, Date = new DateTime(2024, 1, 20), Vendeur = \"Alice\" }, new Vente { Id = 7, Produit = \"Ã‰cran\", Categorie = \"Ã‰lectronique\", Montant = 350, Date = new DateTime(2024, 1, 21), Vendeur = \"Charlie\" } }; // ========================================== // EXEMPLE 1 : Regrouper par catÃ©gorie // ========================================== var ventesParCategorie = ventes.GroupBy(v =\u003e v.Categorie); Console.WriteLine(\"Ventes par catÃ©gorie:\"); foreach (var groupe in ventesParCategorie) { Console.WriteLine($\"\\n{groupe.Key}:\"); // Key = la catÃ©gorie foreach (var vente in groupe) { Console.WriteLine($\" - {vente.Produit}: {vente.Montant:C}\"); } } // Affiche: // Ã‰lectronique: // - Laptop: 1 200,00 $ // - Souris: 25,00 $ // - Clavier: 80,00 $ // - Ã‰cran: 350,00 $ // Mobilier: // - Bureau: 400,00 $ // - Chaise: 150,00 $ // - Lampe: 45,00 $ // ========================================== // EXEMPLE 2 : Calculer le total par catÃ©gorie // ========================================== var totauxParCategorie = ventes .GroupBy(v =\u003e v.Categorie) .Select(groupe =\u003e new { Categorie = groupe.Key, NombreVentes = groupe.Count(), MontantTotal = groupe.Sum(v =\u003e v.Montant), MontantMoyen = groupe.Average(v =\u003e v.Montant) }); Console.WriteLine(\"\\nğŸ“Š Statistiques par catÃ©gorie:\"); foreach (var stat in totauxParCategorie) { Console.WriteLine($\"{stat.Categorie}:\"); Console.WriteLine($\" Nombre de ventes: {stat.NombreVentes}\"); Console.WriteLine($\" Total: {stat.MontantTotal:C}\"); Console.WriteLine($\" Moyenne: {stat.MontantMoyen:C}\"); } // Affiche: // Ã‰lectronique: // Nombre de ventes: 4 // Total: 1 655,00 $ // Moyenne: 413,75 $ // Mobilier: // Nombre de ventes: 3 // Total: 595,00 $ // Moyenne: 198,33 $ // ========================================== // EXEMPLE 3 : Regrouper par vendeur // ========================================== var ventesParVendeur = ventes .GroupBy(v =\u003e v.Vendeur) .Select(groupe =\u003e new { Vendeur = groupe.Key, NombreVentes = groupe.Count(), TotalVentes = groupe.Sum(v =\u003e v.Montant), MeilleureVente = groupe.Max(v =\u003e v.Montant) }) .OrderByDescending(x =\u003e x.TotalVentes); Console.WriteLine(\"\\nğŸ† Performance des vendeurs:\"); foreach (var vendeur in ventesParVendeur) { Console.WriteLine($\"{vendeur.Vendeur}:\"); Console.WriteLine($\" {vendeur.NombreVentes} vente(s)\"); Console.WriteLine($\" Total: {vendeur.TotalVentes:C}\"); Console.WriteLine($\" Meilleure vente: {vendeur.MeilleureVente:C}\"); } // ========================================== // EXEMPLE 4 : Regrouper par mois // ========================================== var ventesParMois = ventes .GroupBy(v =\u003e v.Date.Month) .Select(groupe =\u003e new { Mois = groupe.Key, Total = groupe.Sum(v =\u003e v.Montant) }); 10. OpÃ©rations de Jointure Les jointures combinent des donnÃ©es de deux collections basÃ©es sur une clÃ© commune.\n10.1 Join - Jointure interne // ========================================== // MISE EN CONTEXTE : SystÃ¨me de commandes en ligne // ========================================== public class Client { public int Id { get; set; } public string Nom { get; set; } public string Email { get; set; } public string Ville { get; set; } } public class Commande { public int Id { get; set; } public int ClientId { get; set; } public DateTime DateCommande { get; set; } public decimal Montant { get; set; } public string Statut { get; set; } } List\u003cClient\u003e clients = new List\u003cClient\u003e { new Client { Id = 1, Nom = \"Alice Tremblay\", Email = \"alice@email.com\", Ville = \"MontrÃ©al\" }, new Client { Id = 2, Nom = \"Bob Gagnon\", Email = \"bob@email.com\", Ville = \"QuÃ©bec\" }, new Client { Id = 3, Nom = \"Charlie Roy\", Email = \"charlie@email.com\", Ville = \"MontrÃ©al\" }, new Client { Id = 4, Nom = \"Diana Martin\", Email = \"diana@email.com\", Ville = \"Laval\" } }; List\u003cCommande\u003e commandes = new List\u003cCommande\u003e { new Commande { Id = 101, ClientId = 1, DateCommande = new DateTime(2024, 1, 15), Montant = 150.00m, Statut = \"LivrÃ©e\" }, new Commande { Id = 102, ClientId = 1, DateCommande = new DateTime(2024, 1, 20), Montant = 75.50m, Statut = \"En cours\" }, new Commande { Id = 103, ClientId = 2, DateCommande = new DateTime(2024, 1, 18), Montant = 200.00m, Statut = \"LivrÃ©e\" }, new Commande { Id = 104, ClientId = 3, DateCommande = new DateTime(2024, 1, 22), Montant = 95.00m, Statut = \"LivrÃ©e\" }, new Commande { Id = 105, ClientId = 1, DateCommande = new DateTime(2024, 1, 25), Montant = 120.00m, Statut = \"En cours\" } // Note: Aucune commande pour Diana (Id = 4) }; // ========================================== // EXEMPLE 1 : Joindre clients et commandes // ========================================== var commandesAvecClient = commandes.Join( clients, // Collection Ã  joindre commande =\u003e commande.ClientId, // ClÃ© de la premiÃ¨re collection client =\u003e client.Id, // ClÃ© de la deuxiÃ¨me collection (commande, client) =\u003e new // RÃ©sultat de la jointure { NumeroCommande = commande.Id, NomClient = client.Nom, VilleClient = client.Ville, Montant = commande.Montant, Date = commande.DateCommande, Statut = commande.Statut } ); Console.WriteLine(\"ğŸ“¦ Commandes avec informations clients:\"); foreach (var cmd in commandesAvecClient) { Console.WriteLine($\"Commande #{cmd.NumeroCommande} - {cmd.NomClient} ({cmd.VilleClient}) - {cmd.Montant:C} - {cmd.Statut}\"); } // Affiche: // Commande #101 - Alice Tremblay (MontrÃ©al) - 150,00 $ - LivrÃ©e // Commande #102 - Alice Tremblay (MontrÃ©al) - 75,50 $ - En cours // Commande #103 - Bob Gagnon (QuÃ©bec) - 200,00 $ - LivrÃ©e // Commande #104 - Charlie Roy (MontrÃ©al) - 95,00 $ - LivrÃ©e // Commande #105 - Alice Tremblay (MontrÃ©al) - 120,00 $ - En cours // âš ï¸ Note: Diana n'apparaÃ®t pas (elle n'a aucune commande) // ========================================== // EXEMPLE 2 : Total des commandes par client // ========================================== var totauxParClient = commandes .Join(clients, cmd =\u003e cmd.ClientId, cli =\u003e cli.Id, (cmd, cli) =\u003e new { Client = cli.Nom, Montant = cmd.Montant }) .GroupBy(x =\u003e x.Client) .Select(groupe =\u003e new { Client = groupe.Key, NombreCommandes = groupe.Count(), TotalAchats = groupe.Sum(x =\u003e x.Montant) }) .OrderByDescending(x =\u003e x.TotalAchats); Console.WriteLine(\"\\nğŸ’° Total des achats par client:\"); foreach (var total in totauxParClient) { Console.WriteLine($\"{total.Client}: {total.NombreCommandes} commande(s) - Total: {total.TotalAchats:C}\"); } // Affiche: // Alice Tremblay: 3 commande(s) - Total: 345,50 $ // Bob Gagnon: 1 commande(s) - Total: 200,00 $ // Charlie Roy: 1 commande(s) - Total: 95,00 $ 10.2 GroupJoin - Jointure de groupe Similaire Ã  un LEFT JOIN en SQL - inclut tous les Ã©lÃ©ments de la premiÃ¨re collection mÃªme sâ€™ils nâ€™ont pas de correspondance.\n// ========================================== // EXEMPLE : Tous les clients avec leurs commandes (mÃªme ceux sans commande) // ========================================== var clientsAvecCommandes = clients.GroupJoin( commandes, client =\u003e client.Id, commande =\u003e commande.ClientId, (client, commandesClient) =\u003e new { NomClient = client.Nom, Ville = client.Ville, NombreCommandes = commandesClient.Count(), TotalAchats = commandesClient.Sum(c =\u003e (decimal?)c.Montant) ?? 0, Commandes = commandesClient.ToList() } ); Console.WriteLine(\"\\nğŸ‘¥ Tous les clients:\"); foreach (var client in clientsAvecCommandes) { Console.WriteLine($\"\\n{client.NomClient} ({client.Ville}):\"); Console.WriteLine($\" Nombre de commandes: {client.NombreCommandes}\"); Console.WriteLine($\" Total des achats: {client.TotalAchats:C}\"); if (client.Commandes.Any()) { Console.WriteLine(\" Commandes:\"); foreach (var cmd in client.Commandes) { Console.WriteLine($\" - #{cmd.Id}: {cmd.Montant:C} ({cmd.Statut})\"); } } else { Console.WriteLine(\" âš ï¸ Aucune commande\"); } } // Affiche maintenant TOUS les clients, y compris Diana qui n'a aucune commande! 11. OpÃ©rations dâ€™Ensemble 11.1 Distinct - Ã‰liminer les doublons // ========================================== // MISE EN CONTEXTE : Tags d'articles de blog // ========================================== List\u003cstring\u003e tagsArticle1 = new List\u003cstring\u003e { \"C#\", \"LINQ\", \"Programming\", \"Tutorial\" }; List\u003cstring\u003e tagsArticle2 = new List\u003cstring\u003e { \"C#\", \"ASP.NET\", \"Web\", \"Programming\" }; List\u003cstring\u003e tagsArticle3 = new List\u003cstring\u003e { \"Python\", \"Programming\", \"Data Science\" }; // Combiner tous les tags List\u003cstring\u003e tousTags = new List\u003cstring\u003e(); tousTags.AddRange(tagsArticle1); tousTags.AddRange(tagsArticle2); tousTags.AddRange(tagsArticle3); Console.WriteLine(\"Tous les tags (avec doublons):\"); Console.WriteLine(string.Join(\", \", tousTags)); // C#, LINQ, Programming, Tutorial, C#, ASP.NET, Web, Programming, Python, Programming, Data Science // Obtenir les tags uniques var tagsUniques = tousTags.Distinct(); Console.WriteLine(\"\\nTags uniques:\"); Console.WriteLine(string.Join(\", \", tagsUniques)); // C#, LINQ, Programming, Tutorial, ASP.NET, Web, Python, Data Science // ========================================== // Distinct avec objets personnalisÃ©s // ========================================== public class Ville { public string Nom { get; set; } public string Province { get; set; } } List\u003cVille\u003e villes = new List\u003cVille\u003e { new Ville { Nom = \"MontrÃ©al\", Province = \"QuÃ©bec\" }, new Ville { Nom = \"QuÃ©bec\", Province = \"QuÃ©bec\" }, new Ville { Nom = \"MontrÃ©al\", Province = \"QuÃ©bec\" }, // Doublon! new Ville { Nom = \"Toronto\", Province = \"Ontario\" } }; // Pour Distinct sur objets, il faut implÃ©menter IEquatable ou utiliser DistinctBy var villesUniques = villes.DistinctBy(v =\u003e v.Nom); Console.WriteLine(\"\\nVilles uniques:\"); foreach (var ville in villesUniques) { Console.WriteLine($\"{ville.Nom}, {ville.Province}\"); } 11.2 Union - Union de deux collections Combine deux collections et Ã©limine les doublons.\nList\u003cint\u003e liste1 = new List\u003cint\u003e { 1, 2, 3, 4, 5 }; List\u003cint\u003e liste2 = new List\u003cint\u003e { 4, 5, 6, 7, 8 }; var union = liste1.Union(liste2); Console.WriteLine(\"Union:\"); Console.WriteLine(string.Join(\", \", union)); // 1, 2, 3, 4, 5, 6, 7, 8 11.3 Intersect - Intersection Retourne uniquement les Ã©lÃ©ments prÃ©sents dans LES DEUX collections.\nvar intersection = liste1.Intersect(liste2); Console.WriteLine(\"Intersection:\"); Console.WriteLine(string.Join(\", \", intersection)); // 4, 5 11.4 Except - DiffÃ©rence Retourne les Ã©lÃ©ments de la premiÃ¨re collection qui ne sont PAS dans la deuxiÃ¨me.\nvar difference = liste1.Except(liste2); Console.WriteLine(\"DiffÃ©rence (liste1 - liste2):\"); Console.WriteLine(string.Join(\", \", difference)); // 1, 2, 3 11.5 Exemple Pratique : Gestion dâ€™abonnements // ========================================== // MISE EN CONTEXTE : AbonnÃ©s Ã  des newsletters // ========================================== List\u003cstring\u003e abonnesNewsletter = new List\u003cstring\u003e { \"alice@email.com\", \"bob@email.com\", \"charlie@email.com\", \"diana@email.com\" }; List\u003cstring\u003e abonnesBlog = new List\u003cstring\u003e { \"bob@email.com\", \"charlie@email.com\", \"eve@email.com\", \"frank@email.com\" }; // Qui est abonnÃ© aux DEUX? var abonnesDeuxServices = abonnesNewsletter.Intersect(abonnesBlog); Console.WriteLine(\"ğŸ“§ AbonnÃ©s aux deux services:\"); foreach (var email in abonnesDeuxServices) { Console.WriteLine($\" - {email}\"); } // bob@email.com // charlie@email.com // Qui est abonnÃ© Ã  la newsletter mais PAS au blog? var uniquementNewsletter = abonnesNewsletter.Except(abonnesBlog); Console.WriteLine(\"\\nğŸ“° Uniquement Ã  la newsletter:\"); foreach (var email in uniquementNewsletter) { Console.WriteLine($\" - {email}\"); } // alice@email.com // diana@email.com // Tous les abonnÃ©s (peu importe le service) var tousLesAbonnes = abonnesNewsletter.Union(abonnesBlog); Console.WriteLine($\"\\nğŸ‘¥ Total d'abonnÃ©s uniques: {tousLesAbonnes.Count()}\"); // 6 12. OpÃ©rations de Quantification Ces opÃ©rations retournent un boolÃ©en (true/false).\n12.1 Any - Au moins un Ã©lÃ©ment satisfait la condition // ========================================== // MISE EN CONTEXTE : Validation de stock // ========================================== List\u003cProduit\u003e produits = new List\u003cProduit\u003e { new Produit { Nom = \"Laptop\", Stock = 5 }, new Produit { Nom = \"Souris\", Stock = 50 }, new Produit { Nom = \"Clavier\", Stock = 0 }, // Rupture de stock! new Produit { Nom = \"Ã‰cran\", Stock = 10 } }; // Y a-t-il au moins un produit en rupture de stock? bool ruptureStock = produits.Any(p =\u003e p.Stock == 0); Console.WriteLine($\"Rupture de stock: {ruptureStock}\"); // True // Y a-t-il au moins un produit avec beaucoup de stock? bool stockAbondant = produits.Any(p =\u003e p.Stock \u003e 30); Console.WriteLine($\"Stock abondant: {stockAbondant}\"); // True // Y a-t-il des produits? bool existeProduits = produits.Any(); Console.WriteLine($\"Existe des produits: {existeProduits}\"); // True // ========================================== // EXEMPLE PRATIQUE : Validation de formulaire // ========================================== public class Formulaire { public string Nom { get; set; } public string Email { get; set; } public string Telephone { get; set; } } bool FormulaireEstValide(Formulaire form) { // Au moins un champ doit Ãªtre vide pour que le formulaire soit invalide bool champVide = new[] { form.Nom, form.Email, form.Telephone } .Any(champ =\u003e string.IsNullOrWhiteSpace(champ)); return !champVide; } 12.2 All - Tous les Ã©lÃ©ments satisfont la condition // Tous les produits ont-ils un stock positif? bool tousEnStock = produits.All(p =\u003e p.Stock \u003e 0); Console.WriteLine($\"Tous en stock: {tousEnStock}\"); // False (Ã  cause du Clavier) // Tous les produits ont-ils un stock \u003e= 0? bool stockValide = produits.All(p =\u003e p.Stock \u003e= 0); Console.WriteLine($\"Stock valide: {stockValide}\"); // True // ========================================== // EXEMPLE : Validation d'Ã¢ge pour un groupe // ========================================== List\u003cEtudiant\u003e groupe = new List\u003cEtudiant\u003e { new Etudiant { Nom = \"Alice\", Age = 20 }, new Etudiant { Nom = \"Bob\", Age = 22 }, new Etudiant { Nom = \"Charlie\", Age = 21 } }; // Tous les Ã©tudiants sont-ils majeurs? bool tousMajeurs = groupe.All(e =\u003e e.Age \u003e= 18); Console.WriteLine($\"Tous majeurs: {tousMajeurs}\"); // True // Tous les Ã©tudiants ont-ils plus de 21 ans? bool tousPlus21 = groupe.All(e =\u003e e.Age \u003e 21); Console.WriteLine($\"Tous plus de 21 ans: {tousPlus21}\"); // False 12.3 Contains - VÃ©rifie si un Ã©lÃ©ment existe List\u003cstring\u003e fruits = new List\u003cstring\u003e { \"Pomme\", \"Banane\", \"Orange\", \"Kiwi\" }; bool aPomme = fruits.Contains(\"Pomme\"); Console.WriteLine($\"Contient Pomme: {aPomme}\"); // True bool aRaisin = fruits.Contains(\"Raisin\"); Console.WriteLine($\"Contient Raisin: {aRaisin}\"); // False // ========================================== // EXEMPLE : VÃ©rifier si un utilisateur existe // ========================================== List\u003cstring\u003e utilisateursAutorises = new List\u003cstring\u003e { \"admin@site.com\", \"moderateur@site.com\", \"editeur@site.com\" }; string emailUtilisateur = \"admin@site.com\"; bool estAutorise = utilisateursAutorises.Contains(emailUtilisateur); if (estAutorise) { Console.WriteLine(\"âœ… AccÃ¨s autorisÃ©\"); } else { Console.WriteLine(\"âŒ AccÃ¨s refusÃ©\"); } 13. OpÃ©rations de Partition 13.1 Take - Prendre les N premiers Ã©lÃ©ments // ========================================== // MISE EN CONTEXTE : Affichage de rÃ©sultats paginÃ©s // ========================================== List\u003cstring\u003e resultatsRecherche = new List\u003cstring\u003e { \"RÃ©sultat 1\", \"RÃ©sultat 2\", \"RÃ©sultat 3\", \"RÃ©sultat 4\", \"RÃ©sultat 5\", \"RÃ©sultat 6\", \"RÃ©sultat 7\", \"RÃ©sultat 8\", \"RÃ©sultat 9\", \"RÃ©sultat 10\" }; // Afficher les 3 premiers rÃ©sultats var top3 = resultatsRecherche.Take(3); Console.WriteLine(\"Top 3 rÃ©sultats:\"); foreach (var resultat in top3) { Console.WriteLine($\" - {resultat}\"); } // RÃ©sultat 1 // RÃ©sultat 2 // RÃ©sultat 3 // ========================================== // EXEMPLE : Top 5 des meilleurs Ã©tudiants // ========================================== var top5Etudiants = etudiants .OrderByDescending(e =\u003e e.Moyenne) .Take(5) .Select(e =\u003e new { e.Nom, e.Moyenne }); Console.WriteLine(\"\\nğŸ† Top 5 des Ã©tudiants:\"); int rang = 1; foreach (var etudiant in top5Etudiants) { Console.WriteLine($\"{rang}. {etudiant.Nom}: {etudiant.Moyenne}\"); rang++; } 13.2 Skip - Ignorer les N premiers Ã©lÃ©ments // Ignorer les 3 premiers rÃ©sultats var apres3 = resultatsRecherche.Skip(3); Console.WriteLine(\"AprÃ¨s les 3 premiers:\"); foreach (var resultat in apres3) { Console.WriteLine($\" - {resultat}\"); } // RÃ©sultat 4 // RÃ©sultat 5 // ... // RÃ©sultat 10 13.3 Pagination avec Take et Skip // ========================================== // EXEMPLE PRATIQUE : Pagination // ========================================== int pageSize = 3; // 3 rÃ©sultats par page int pageNumber = 2; // Page 2 var resultatsPagines = resultatsRecherche .Skip((pageNumber - 1) * pageSize) // Ignorer les pages prÃ©cÃ©dentes .Take(pageSize); // Prendre uniquement cette page Console.WriteLine($\"Page {pageNumber}:\"); foreach (var resultat in resultatsPagines) { Console.WriteLine($\" - {resultat}\"); } // Page 2: // - RÃ©sultat 4 // - RÃ©sultat 5 // - RÃ©sultat 6 // ========================================== // Fonction de pagination rÃ©utilisable // ========================================== public static IEnumerable\u003cT\u003e ObtenirPage\u003cT\u003e(IEnumerable\u003cT\u003e source, int numeroPage, int taillePage) { return source .Skip((numeroPage - 1) * taillePage) .Take(taillePage); } // Utilisation var page1 = ObtenirPage(resultatsRecherche, 1, 3); var page2 = ObtenirPage(resultatsRecherche, 2, 3); var page3 = ObtenirPage(resultatsRecherche, 3, 3); 13.4 TakeWhile et SkipWhile - Selon une condition List\u003cint\u003e nombres = new List\u003cint\u003e { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; // Prendre tant que la condition est vraie var inferieursA6 = nombres.TakeWhile(n =\u003e n \u003c 6); Console.WriteLine(\"TakeWhile (\u003c 6):\"); Console.WriteLine(string.Join(\", \", inferieursA6)); // 1, 2, 3, 4, 5 // Ignorer tant que la condition est vraie var depuis6 = nombres.SkipWhile(n =\u003e n \u003c 6); Console.WriteLine(\"SkipWhile (\u003c 6):\"); Console.WriteLine(string.Join(\", \", depuis6)); // 6, 7, 8, 9, 10 14. LINQ avec Objets Complexes 14.1 Exemple Complet : SystÃ¨me Universitaire public class Universite { public string Nom { get; set; } public List\u003cDepartement\u003e Departements { get; set; } } public class Departement { public string Nom { get; set; } public List\u003cProfesseur\u003e Professeurs { get; set; } public List\u003cCours\u003e Cours { get; set; } } public class Professeur { public string Nom { get; set; } public string Specialite { get; set; } public int AnneesExperience { get; set; } } public class Cours { public string Code { get; set; } public string Titre { get; set; } public int Credits { get; set; } public string ProfesseurNom { get; set; } public List\u003cEtudiant\u003e EtudiantsInscrits { get; set; } } // DonnÃ©es var universite = new Universite { Nom = \"UniversitÃ© du QuÃ©bec\", Departements = new List\u003cDepartement\u003e { new Departement { Nom = \"Informatique\", Professeurs = new List\u003cProfesseur\u003e { new Professeur { Nom = \"Dr. Smith\", Specialite = \"Intelligence Artificielle\", AnneesExperience = 15 }, new Professeur { Nom = \"Dr. Johnson\", Specialite = \"Bases de donnÃ©es\", AnneesExperience = 10 } }, Cours = new List\u003cCours\u003e { new Cours { Code = \"INF101\", Titre = \"Programmation I\", Credits = 3, ProfesseurNom = \"Dr. Smith\", EtudiantsInscrits = new List\u003cEtudiant\u003e { new Etudiant { Nom = \"Alice\", Moyenne = 85 }, new Etudiant { Nom = \"Bob\", Moyenne = 78 } } }, new Cours { Code = \"INF202\", Titre = \"Structures de donnÃ©es\", Credits = 4, ProfesseurNom = \"Dr. Johnson\", EtudiantsInscrits = new List\u003cEtudiant\u003e { new Etudiant { Nom = \"Charlie\", Moyenne = 90 }, new Etudiant { Nom = \"Diana\", Moyenne = 82 } } } } }, new Departement { Nom = \"MathÃ©matiques\", Professeurs = new List\u003cProfesseur\u003e { new Professeur { Nom = \"Dr. Williams\", Specialite = \"AlgÃ¨bre\", AnneesExperience = 20 } }, Cours = new List\u003cCours\u003e { new Cours { Code = \"MAT101\", Titre = \"Calcul I\", Credits = 4, ProfesseurNom = \"Dr. Williams\", EtudiantsInscrits = new List\u003cEtudiant\u003e { new Etudiant { Nom = \"Eve\", Moyenne = 88 } } } } } } }; // ========================================== // REQUÃŠTE 1 : Tous les professeurs de l'universitÃ© // ========================================== var tousProfesseurs = universite.Departements .SelectMany(d =\u003e d.Professeurs) .Select(p =\u003e new { p.Nom, p.Specialite, p.AnneesExperience }); Console.WriteLine(\"ğŸ‘¨â€ğŸ« Tous les professeurs:\"); foreach (var prof in tousProfesseurs) { Console.WriteLine($\" - {prof.Nom} ({prof.Specialite}) - {prof.AnneesExperience} ans\"); } // ========================================== // REQUÃŠTE 2 : Tous les cours avec plus de 3 crÃ©dits // ========================================== var coursAvances = universite.Departements .SelectMany(d =\u003e d.Cours) .Where(c =\u003e c.Credits \u003e 3) .Select(c =\u003e new { c.Code, c.Titre, c.Credits }); Console.WriteLine(\"\\nğŸ“š Cours avancÃ©s (\u003e3 crÃ©dits):\"); foreach (var cours in coursAvances) { Console.WriteLine($\" - {cours.Code}: {cours.Titre} ({cours.Credits} crÃ©dits)\"); } // ========================================== // REQUÃŠTE 3 : Nombre total d'Ã©tudiants dans l'universitÃ© // ========================================== int totalEtudiants = universite.Departements .SelectMany(d =\u003e d.Cours) .SelectMany(c =\u003e c.EtudiantsInscrits) .Distinct() // Au cas oÃ¹ un Ã©tudiant est dans plusieurs cours .Count(); Console.WriteLine($\"\\nğŸ‘¥ Total d'Ã©tudiants: {totalEtudiants}\"); // ========================================== // REQUÃŠTE 4 : Moyenne gÃ©nÃ©rale de l'universitÃ© // ========================================== double moyenneGenerale = universite.Departements .SelectMany(d =\u003e d.Cours) .SelectMany(c =\u003e c.EtudiantsInscrits) .Average(e =\u003e e.Moyenne); Console.WriteLine($\"ğŸ“Š Moyenne gÃ©nÃ©rale: {moyenneGenerale:F2}\"); // ========================================== // REQUÃŠTE 5 : Statistiques par dÃ©partement // ========================================== var statsParDepartement = universite.Departements .Select(d =\u003e new { Departement = d.Nom, NombreProfesseurs = d.Professeurs.Count, NombreCours = d.Cours.Count, TotalEtudiants = d.Cours.SelectMany(c =\u003e c.EtudiantsInscrits).Count(), MoyenneDepartement = d.Cours.SelectMany(c =\u003e c.EtudiantsInscrits).Average(e =\u003e e.Moyenne) }); Console.WriteLine(\"\\nğŸ“ˆ Statistiques par dÃ©partement:\"); foreach (var stat in statsParDepartement) { Console.WriteLine($\"{stat.Departement}:\"); Console.WriteLine($\" Professeurs: {stat.NombreProfesseurs}\"); Console.WriteLine($\" Cours: {stat.NombreCours}\"); Console.WriteLine($\" Ã‰tudiants: {stat.TotalEtudiants}\"); Console.WriteLine($\" Moyenne: {stat.MoyenneDepartement:F2}\"); } // ========================================== // REQUÃŠTE 6 : Cours les plus populaires // ========================================== var coursPopulaires = universite.Departements .SelectMany(d =\u003e d.Cours) .OrderByDescending(c =\u003e c.EtudiantsInscrits.Count) .Take(3) .Select(c =\u003e new { c.Code, c.Titre, NombreEtudiants = c.EtudiantsInscrits.Count }); Console.WriteLine(\"\\nğŸ”¥ Cours les plus populaires:\"); foreach (var cours in coursPopulaires) { Console.WriteLine($\" - {cours.Code}: {cours.Titre} ({cours.NombreEtudiants} Ã©tudiants)\"); } 15. Cas Pratiques RÃ©els 15.1 Analyse de Logs dâ€™Application public class LogEntry { public DateTime Timestamp { get; set; } public string Level { get; set; } // INFO, WARNING, ERROR public string Message { get; set; } public string Module { get; set; } } List\u003cLogEntry\u003e logs = new List\u003cLogEntry\u003e { new LogEntry { Timestamp = DateTime.Now.AddHours(-5), Level = \"INFO\", Message = \"Application started\", Module = \"Startup\" }, new LogEntry { Timestamp = DateTime.Now.AddHours(-4), Level = \"ERROR\", Message = \"Database connection failed\", Module = \"Database\" }, new LogEntry { Timestamp = DateTime.Now.AddHours(-3), Level = \"WARNING\", Message = \"High memory usage\", Module = \"Performance\" }, new LogEntry { Timestamp = DateTime.Now.AddHours(-2), Level = \"ERROR\", Message = \"Null reference exception\", Module = \"UserService\" }, new LogEntry { Timestamp = DateTime.Now.AddHours(-1), Level = \"INFO\", Message = \"User logged in\", Module = \"Auth\" }, new LogEntry { Timestamp = DateTime.Now, Level = \"ERROR\", Message = \"Payment processing failed\", Module = \"Payment\" } }; // ========================================== // Rapport d'erreurs // ========================================== var erreurs = logs .Where(log =\u003e log.Level == \"ERROR\") .OrderByDescending(log =\u003e log.Timestamp) .Select(log =\u003e new { Heure = log.Timestamp.ToString(\"HH:mm\"), log.Module, log.Message }); Console.WriteLine(\"ğŸ”´ Erreurs rÃ©centes:\"); foreach (var erreur in erreurs) { Console.WriteLine($\"[{erreur.Heure}] {erreur.Module}: {erreur.Message}\"); } // ========================================== // Statistiques par module // ========================================== var statsParModule = logs .GroupBy(log =\u003e log.Module) .Select(groupe =\u003e new { Module = groupe.Key, Total = groupe.Count(), Erreurs = groupe.Count(log =\u003e log.Level == \"ERROR\"), Warnings = groupe.Count(log =\u003e log.Level == \"WARNING\") }) .OrderByDescending(stat =\u003e stat.Erreurs); Console.WriteLine(\"\\nğŸ“Š Statistiques par module:\"); foreach (var stat in statsParModule) { Console.WriteLine($\"{stat.Module}: {stat.Total} logs (dont {stat.Erreurs} erreurs)\"); } // ========================================== // Alertes critiques (plusieurs erreurs dans un module) // ========================================== var modulesCritiques = logs .Where(log =\u003e log.Level == \"ERROR\") .GroupBy(log =\u003e log.Module) .Where(groupe =\u003e groupe.Count() \u003e= 2) .Select(groupe =\u003e groupe.Key); if (modulesCritiques.Any()) { Console.WriteLine(\"\\nâš ï¸ ALERTE: Modules avec erreurs multiples:\"); foreach (var module in modulesCritiques) { Console.WriteLine($\" - {module}\"); } } 15.2 Analyse de DonnÃ©es de Ventes public class Transaction { public int Id { get; set; } public DateTime Date { get; set; } public string Produit { get; set; } public decimal Prix { get; set; } public int Quantite { get; set; } public string Categorie { get; set; } public string Region { get; set; } } List\u003cTransaction\u003e transactions = new List\u003cTransaction\u003e { new Transaction { Id = 1, Date = new DateTime(2024, 1, 15), Produit = \"Laptop\", Prix = 1200, Quantite = 2, Categorie = \"Ã‰lectronique\", Region = \"QuÃ©bec\" }, new Transaction { Id = 2, Date = new DateTime(2024, 1, 16), Produit = \"Souris\", Prix = 25, Quantite = 10, Categorie = \"Ã‰lectronique\", Region = \"MontrÃ©al\" }, new Transaction { Id = 3, Date = new DateTime(2024, 1, 17), Produit = \"Bureau\", Prix = 400, Quantite = 1, Categorie = \"Mobilier\", Region = \"QuÃ©bec\" }, new Transaction { Id = 4, Date = new DateTime(2024, 1, 18), Produit = \"Chaise\", Prix = 150, Quantite = 4, Categorie = \"Mobilier\", Region = \"Laval\" }, new Transaction { Id = 5, Date = new DateTime(2024, 1, 19), Produit = \"Clavier\", Prix = 80, Quantite = 5, Categorie = \"Ã‰lectronique\", Region = \"MontrÃ©al\" } }; // ========================================== // Chiffre d'affaires total // ========================================== decimal chiffreAffaires = transactions.Sum(t =\u003e t.Prix * t.Quantite); Console.WriteLine($\"ğŸ’° Chiffre d'affaires total: {chiffreAffaires:C}\"); // ========================================== // Top 3 des produits les plus vendus // ========================================== var top3Produits = transactions .GroupBy(t =\u003e t.Produit) .Select(groupe =\u003e new { Produit = groupe.Key, QuantiteTotale = groupe.Sum(t =\u003e t.Quantite), Revenu = groupe.Sum(t =\u003e t.Prix * t.Quantite) }) .OrderByDescending(x =\u003e x.Revenu) .Take(3); Console.WriteLine(\"\\nğŸ† Top 3 produits par revenu:\"); foreach (var produit in top3Produits) { Console.WriteLine($\" {produit.Produit}: {produit.QuantiteTotale} unitÃ©s - {produit.Revenu:C}\"); } // ========================================== // Performance par rÃ©gion // ========================================== var performanceRegions = transactions .GroupBy(t =\u003e t.Region) .Select(groupe =\u003e new { Region = groupe.Key, NombreTransactions = groupe.Count(), RevenuTotal = groupe.Sum(t =\u003e t.Prix * t.Quantite), PanierMoyen = groupe.Average(t =\u003e t.Prix * t.Quantite) }) .OrderByDescending(x =\u003e x.RevenuTotal); Console.WriteLine(\"\\nğŸ“ Performance par rÃ©gion:\"); foreach (var region in performanceRegions) { Console.WriteLine($\"{region.Region}:\"); Console.WriteLine($\" Transactions: {region.NombreTransactions}\"); Console.WriteLine($\" Revenu: {region.RevenuTotal:C}\"); Console.WriteLine($\" Panier moyen: {region.PanierMoyen:C}\"); } // ========================================== // Tendance quotidienne // ========================================== var ventesParJour = transactions .GroupBy(t =\u003e t.Date.Date) .Select(groupe =\u003e new { Date = groupe.Key.ToString(\"dd/MM/yyyy\"), Revenu = groupe.Sum(t =\u003e t.Prix * t.Quantite) }) .OrderBy(x =\u003e x.Date); Console.WriteLine(\"\\nğŸ“ˆ Ventes quotidiennes:\"); foreach (var jour in ventesParJour) { Console.WriteLine($\" {jour.Date}: {jour.Revenu:C}\"); } 16. Bonnes Pratiques et PiÃ¨ges 16.1 Ã‰viter lâ€™ExÃ©cution Multiple // âŒ MAUVAIS - La requÃªte est exÃ©cutÃ©e 3 fois! var requete = produits.Where(p =\u003e p.Prix \u003e 100); int count = requete.Count(); // ExÃ©cution 1 decimal total = requete.Sum(p =\u003e p.Prix); // ExÃ©cution 2 var liste = requete.ToList(); // ExÃ©cution 3 // âœ… BON - ExÃ©cuter une seule fois avec ToList() var resultats = produits.Where(p =\u003e p.Prix \u003e 100).ToList(); int count = resultats.Count; // Pas d'exÃ©cution (dÃ©jÃ  en mÃ©moire) decimal total = resultats.Sum(p =\u003e p.Prix); // Pas d'exÃ©cution 16.2 Attention aux Null References // âŒ RISQUE - NullReferenceException si un produit est null var produitsChers = produits.Where(p =\u003e p.Prix \u003e 100); // âœ… MIEUX - Filtrer les nulls d'abord var produitsChers = produits .Where(p =\u003e p != null) .Where(p =\u003e p.Prix \u003e 100); // âœ… OU utiliser l'opÃ©rateur ?. var prixMax = produits .Where(p =\u003e p != null) .Max(p =\u003e p.Prix); 16.3 Performance : Where avant Select // âŒ MOINS EFFICACE - Transforme tout puis filtre var resultats = produits .Select(p =\u003e new { p.Nom, p.Prix }) .Where(x =\u003e x.Prix \u003e 100); // âœ… PLUS EFFICACE - Filtre d'abord, puis transforme var resultats = produits .Where(p =\u003e p.Prix \u003e 100) .Select(p =\u003e new { p.Nom, p.Prix }); 16.4 Utiliser Any() plutÃ´t que Count() // âŒ MOINS EFFICACE - Compte tous les Ã©lÃ©ments if (produits.Count() \u003e 0) { // ... } // âœ… PLUS EFFICACE - S'arrÃªte dÃ¨s qu'un Ã©lÃ©ment est trouvÃ© if (produits.Any()) { // ... } // âŒ MOINS EFFICACE if (produits.Where(p =\u003e p.Prix \u003e 1000).Count() \u003e 0) { // ... } // âœ… PLUS EFFICACE if (produits.Any(p =\u003e p.Prix \u003e 1000)) { // ... } 16.5 Ã‰viter les RequÃªtes Complexes dans les Boucles // âŒ TRÃˆS MAUVAIS - RequÃªte LINQ dans une boucle! foreach (var categorie in categories) { var count = produits.Count(p =\u003e p.Categorie == categorie); Console.WriteLine($\"{categorie}: {count}\"); } // âœ… BON - Une seule requÃªte avec GroupBy var comptesParCategorie = produits .GroupBy(p =\u003e p.Categorie) .Select(g =\u003e new { Categorie = g.Key, Count = g.Count() }); foreach (var groupe in comptesParCategorie) { Console.WriteLine($\"{groupe.Categorie}: {groupe.Count}\"); } 16.6 PrÃ©fÃ©rer FirstOrDefault() Ã  First() // âŒ RISQUE - LÃ¨ve une exception si aucun Ã©lÃ©ment trouvÃ© var produit = produits.First(p =\u003e p.Id == 999); // âœ… SÃ‰CURITAIRE - Retourne null si aucun Ã©lÃ©ment trouvÃ© var produit = produits.FirstOrDefault(p =\u003e p.Id == 999); if (produit != null) { Console.WriteLine(produit.Nom); } else { Console.WriteLine(\"Produit introuvable\"); } 16.7 Ordre des OpÃ©rations // L'ordre compte pour la performance! // âœ… BON - Filtre puis trie (trie moins d'Ã©lÃ©ments) var resultats = produits .Where(p =\u003e p.Prix \u003e 100) // RÃ©duit la collection .OrderBy(p =\u003e p.Nom); // Trie une petite collection // âŒ MOINS BON - Trie puis filtre (trie inutilement tout) var resultats = produits .OrderBy(p =\u003e p.Nom) // Trie TOUT .Where(p =\u003e p.Prix \u003e 100); // Puis filtre ğŸ“š RÃ©sumÃ© des OpÃ©rations LINQ CatÃ©gorie OpÃ©rations Description Filtrage Where, OfType SÃ©lectionner des Ã©lÃ©ments selon une condition Projection Select, SelectMany Transformer les Ã©lÃ©ments Tri OrderBy, OrderByDescending, ThenBy, Reverse Trier les Ã©lÃ©ments AgrÃ©gation Count, Sum, Average, Min, Max, Aggregate Calculer des valeurs Regroupement GroupBy Regrouper par clÃ© Jointure Join, GroupJoin Combiner deux collections Ensemble Distinct, Union, Intersect, Except OpÃ©rations dâ€™ensemble Quantification Any, All, Contains Tests boolÃ©ens Partition Take, Skip, TakeWhile, SkipWhile Pagination et dÃ©coupage Ã‰lÃ©ment First, FirstOrDefault, Last, Single Obtenir un Ã©lÃ©ment Conversion ToList, ToArray, ToDictionary Convertir en collection ğŸ¯ Checklist de MaÃ®trise LINQ Je comprends la diffÃ©rence entre exÃ©cution diffÃ©rÃ©e et immÃ©diate Je sais utiliser Where() pour filtrer Je sais utiliser Select() pour projeter/transformer Je maÃ®trise OrderBy() et ThenBy() pour trier Je sais utiliser GroupBy() pour regrouper Je comprends la diffÃ©rence entre First() et FirstOrDefault() Je sais utiliser Any() et All() pour tester Je maÃ®trise Sum(), Average(), Min(), Max() Je sais utiliser Take() et Skip() pour paginer Je comprends Join() et GroupJoin() Je sais Ã©viter les piÃ¨ges de performance Je peux Ã©crire des requÃªtes LINQ complexes ğŸ”— Ressources SupplÃ©mentaires Documentation Microsoft LINQ : https://docs.microsoft.com/fr-fr/dotnet/csharp/linq/ LINQ samples : https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b",
    "description": "ğŸ“˜ LINQ en C# Language Integrated Query ğŸ“‹ Table des matiÃ¨res Introduction Ã  LINQ Pourquoi utiliser LINQ ? Les Bases de LINQ Les Deux Syntaxes LINQ OpÃ©rations de Filtrage OpÃ©rations de Projection OpÃ©rations de Tri OpÃ©rations dâ€™AgrÃ©gation OpÃ©rations de Regroupement OpÃ©rations de Jointure OpÃ©rations dâ€™Ensemble OpÃ©rations de Quantification OpÃ©rations de Partition LINQ avec Objets Complexes Cas Pratiques RÃ©els Bonnes Pratiques et PiÃ¨ges 1. Introduction Ã  LINQ 1.1 Quâ€™est-ce que LINQ ? LINQ (Language Integrated Query) est une fonctionnalitÃ© de C# qui permet dâ€™interroger des collections de donnÃ©es directement dans le code, avec une syntaxe Ã©lÃ©gante et lisible.",
    "tags": [],
    "title": "LINQ",
    "uri": "/420-413/linq/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "ğŸ“ EXERCICE DE PRÃ‰PARATION Ã€ Lâ€™EXAMEN SystÃ¨me de Gestion dâ€™une BibliothÃ¨que Municipale POO AvancÃ©e + LINQ ğŸ¯ CONTEXTE Vous travaillez pour la Ville de MontrÃ©al et devez crÃ©er un systÃ¨me de gestion pour la bibliothÃ¨que municipale. Le systÃ¨me doit gÃ©rer diffÃ©rents types de documents (livres, magazines, DVD), les membres, les emprunts et gÃ©nÃ©rer des statistiques.\nTechnologies: Application Console C# (.NET), POO avancÃ©e (hÃ©ritage, interfaces, polymorphisme), LINQ obligatoire pour toutes les requÃªtes\nğŸ“‹ PARTIE 1: MODÃˆLE DE DONNÃ‰ES 1.1 Ã‰numÃ©rations Ã  crÃ©er Enum GenreLivre\nRoman ScienceFiction Policier Biographie Histoire Science Jeunesse BD Enum StatutEmprunt\nEnCours Retourne EnRetard Perdu Enum TypeMembre\nRegulier Etudiant Senior 1.2 Interface IEmpruntable CrÃ©ez une interface qui dÃ©finit le comportement des Ã©lÃ©ments empruntables.\nInterface IEmpruntable\nMÃ©thodes:\nbool PeutEtreEmprunte() - Retourne true si lâ€™item peut Ãªtre empruntÃ© bool Emprunter() - Tente dâ€™emprunter, retourne true si succÃ¨s void Retourner() - Retourne lâ€™item int ObtenirDureeEmprunt(TypeMembre typeMembre) - Retourne la durÃ©e dâ€™emprunt selon le type de membre 1.3 Classe abstraite Document CrÃ©ez une classe abstraite qui servira de base pour tous les types de documents.\nClasse abstraite Document\nChamp statique:\nprivate static int prochainId = 1 - Compteur pour gÃ©nÃ©rer des ID uniques PropriÃ©tÃ©s:\nint Id - Identifiant unique auto-gÃ©nÃ©rÃ© string Titre - Titre du document int AnneePublication - AnnÃ©e de publication bool EstDisponible - DisponibilitÃ© PropriÃ©tÃ©s calculÃ©es:\nint Age - Retourne lâ€™Ã¢ge du document (annÃ©e actuelle - annÃ©e publication) bool EstRecent - Retourne true si publiÃ© dans les 5 derniÃ¨res annÃ©es PropriÃ©tÃ©s abstraites Ã  implÃ©menter dans les classes dÃ©rivÃ©es:\nabstract string TypeDocument - Retourne le type de document (â€œLivreâ€, â€œMagazineâ€, â€œDVDâ€) Constructeur:\nprotected Document() { Id = prochainId++; EstDisponible = true; } MÃ©thodes virtuelles:\nvirtual string ObtenirDescription() - Retourne â€œ{Titre} ({AnneePublication})â€ virtual void AfficherInfos() - Affiche les informations de base du document MÃ©thodes abstraites:\nabstract int ObtenirDureeEmpruntDefaut() - DurÃ©e dâ€™emprunt par dÃ©faut selon le type de document Override obligatoire:\noverride string ToString() - Format: â€œTypeDocument: Titreâ€ 1.4 Classe Livre (hÃ©rite de Document et implÃ©mente IEmpruntable) Classe Livre : Document, IEmpruntable\nPropriÃ©tÃ©s spÃ©cifiques:\nstring Auteur - Nom de lâ€™auteur string ISBN - NumÃ©ro ISBN GenreLivre Genre - Genre du livre int NombrePages - Nombre de pages int NombreExemplaires - Nombre total dâ€™exemplaires int NombreDisponibles - Nombre dâ€™exemplaires disponibles ImplÃ©mentation propriÃ©tÃ© abstraite:\noverride string TypeDocument - Retourne â€œLivreâ€ Override mÃ©thodes virtuelles:\noverride string ObtenirDescription() - Retourne â€œ{Titre} par {Auteur} ({AnneePublication})â€ override void AfficherInfos() - Affiche toutes les infos du livre incluant auteur, genre, pages ImplÃ©mentation mÃ©thode abstraite:\noverride int ObtenirDureeEmpruntDefaut() - Retourne 14 jours ImplÃ©mentation interface IEmpruntable:\nbool PeutEtreEmprunte() - Retourne true si NombreDisponibles \u003e 0 bool Emprunter() - Diminue NombreDisponibles si possible, met Ã  jour EstDisponible void Retourner() - Augmente NombreDisponibles, met Ã  jour EstDisponible int ObtenirDureeEmprunt(TypeMembre typeMembre) - Retourne durÃ©e selon type: Regulier: 14 jours Etudiant: 21 jours Senior: 21 jours Constructeur:\npublic Livre() : base() { NombreExemplaires = 1; NombreDisponibles = 1; } 1.5 Classe Magazine (hÃ©rite de Document et implÃ©mente IEmpruntable) Classe Magazine : Document, IEmpruntable\nPropriÃ©tÃ©s spÃ©cifiques:\nint NumeroEdition - NumÃ©ro de lâ€™Ã©dition string Editeur - Nom de lâ€™Ã©diteur int Periodicite - PÃ©riodicitÃ© en jours (7 pour hebdo, 30 pour mensuel) ImplÃ©mentation propriÃ©tÃ© abstraite:\noverride string TypeDocument - Retourne â€œMagazineâ€ Override mÃ©thodes virtuelles:\noverride string ObtenirDescription() - Retourne â€œ{Titre} #{NumeroEdition} - {Editeur}â€ override void AfficherInfos() - Affiche infos du magazine incluant Ã©diteur, numÃ©ro ImplÃ©mentation mÃ©thode abstraite:\noverride int ObtenirDureeEmpruntDefaut() - Retourne 7 jours (magazines = emprunts courts) ImplÃ©mentation interface IEmpruntable:\nbool PeutEtreEmprunte() - Retourne EstDisponible bool Emprunter() - Met EstDisponible Ã  false void Retourner() - Met EstDisponible Ã  true int ObtenirDureeEmprunt(TypeMembre typeMembre) - Retourne toujours 7 jours (mÃªme durÃ©e pour tous) 1.6 Classe Membre PropriÃ©tÃ©s:\nint Id - Identifiant unique auto-gÃ©nÃ©rÃ© string Nom - Nom complet string NumeroMembre - Format: MEM-XXXXX string Courriel - Adresse courriel TypeMembre Type - Type de membre DateTime DateInscription - Date dâ€™inscription List\u003cEmprunt\u003e Emprunts - Liste de tous les emprunts Champ statique:\nprivate static int prochainId = 1; PropriÃ©tÃ©s calculÃ©es:\nint NombreEmpruntsActuels - Compte les emprunts avec Statut == EnCours int NombreEmpruntsTotal - Total dâ€™emprunts dans lâ€™historique bool PeutEmprunter - true si NombreEmpruntsActuels \u003c LimiteEmprunts int LimiteEmprunts - Selon le type: Regulier: 5 Etudiant: 10 Senior: 8 int JoursMembre - Jours depuis lâ€™inscription Constructeur:\npublic Membre() { Id = prochainId++; Emprunts = new List\u003cEmprunt\u003e(); DateInscription = DateTime.Now; } MÃ©thodes:\nvoid AjouterEmprunt(Emprunt emprunt) - Ajoute un emprunt override string ToString() - Format: â€œNumeroMembre - Nom (Type)â€ 1.7 Classe Emprunt PropriÃ©tÃ©s:\nint Id { get; private set; } - ID unique auto-gÃ©nÃ©rÃ© IEmpruntable Document { get; set; } - Le document empruntÃ© (interface!) Membre Membre { get; set; } - Le membre qui emprunte DateTime DateEmprunt { get; set; } - Date de lâ€™emprunt DateTime DateRetourPrevue { get; set; } - Date de retour prÃ©vue DateTime? DateRetourReelle { get; set; } - Date de retour effective (nullable) StatutEmprunt Statut { get; set; } - Statut actuel Champ statique:\nprivate static int prochainId = 1; PropriÃ©tÃ©s calculÃ©es:\nint DureeEmprunt - Obtenue via Document.ObtenirDureeEmprunt(Membre.Type) int JoursEmprunt - Jours depuis DateEmprunt bool EstEnRetard - true si maintenant \u003e DateRetourPrevue ET Statut == EnCours int JoursRetard - Jours de retard (0 si pas en retard) decimal Penalite - JoursRetard Ã— 0.50$ Constructeur:\npublic Emprunt(IEmpruntable document, Membre membre) { Id = prochainId++; Document = document; Membre = membre; DateEmprunt = DateTime.Now; int duree = document.ObtenirDureeEmprunt(membre.Type); DateRetourPrevue = DateEmprunt.AddDays(duree); Statut = StatutEmprunt.EnCours; } MÃ©thodes:\nvoid Retourner() - Met DateRetourReelle, change Statut override string ToString() - Format: â€œDocument.Titre - Membre.Nom - Statutâ€ ğŸ“‹ PARTIE 2: CLASSE GESTIONNAIRE AVEC POLYMORPHISME Classe GestionnaireBibliotheque PropriÃ©tÃ©s:\nList\u003cDocument\u003e Documents { get; set; } - Tous les documents (polymorphisme!) List\u003cMembre\u003e Membres { get; set; } - Tous les membres List\u003cEmprunt\u003e Emprunts { get; set; } - Tous les emprunts Constructeur:\nInitialise les 3 listes vides MÃ‰THODES Ã€ IMPLÃ‰MENTER AVEC LINQ 2.1 Gestion de base avec polymorphisme void AjouterDocument(Document document)\nAjoute un document (peut Ãªtre Livre ou Magazine) Valide que lâ€™ID nâ€™existe pas dÃ©jÃ  (LINQ) void AjouterMembre(Membre membre)\nAjoute un membre Valide que le courriel nâ€™existe pas dÃ©jÃ  (LINQ) bool CreerEmprunt(int documentId, int membreId)\nTrouve le document avec LINQ (FirstOrDefault) Cast vers IEmpruntable si le document implÃ©mente lâ€™interface Trouve le membre avec LINQ VÃ©rifie PeutEmprunter du membre VÃ©rifie PeutEtreEmprunte() du document CrÃ©e lâ€™Emprunt et lâ€™ajoute aux listes Appelle document.Emprunter() Retourne true si succÃ¨s bool RetournerDocument(int empruntId)\nTrouve lâ€™emprunt avec LINQ Appelle Emprunt.Retourner() Appelle Document.Retourner() Retourne true si succÃ¨s 2.2 Recherches LINQ avec polymorphisme List\u003cDocument\u003e ObtenirDocumentsDisponibles()\nRetourne tous les documents disponibles TriÃ©s par Titre List\u003cLivre\u003e ObtenirLivresParGenre(GenreLivre genre)\nFiltre les documents qui sont des Livre (utilisez is ou OfType\u003cLivre\u003e()) Filtre par genre TriÃ©s par AnneePublication dÃ©croissant List\u003cMagazine\u003e ObtenirMagazinesRecents()\nFiltre les documents qui sont des Magazine OÃ¹ EstRecent == true TriÃ©s par NumeroEdition dÃ©croissant List\u003cDocument\u003e ObtenirDocumentsParAuteur(string auteur)\nFiltre les documents qui sont des Livre Dont lâ€™auteur contient la chaÃ®ne (ignore casse) Retourne comme List (polymorphisme!) TriÃ©s par Titre List\u003cEmprunt\u003e ObtenirEmpruntsEnRetard()\nTous les emprunts oÃ¹ EstEnRetard == true TriÃ©s par JoursRetard dÃ©croissant 2.3 Statistiques LINQ int CompterDocumentsParType(string typeDocument)\nCompte les documents oÃ¹ TypeDocument == paramÃ¨tre Exemple: CompterDocumentsParType(â€œLivreâ€) int CompterLivresParGenre(GenreLivre genre)\nFiltre les Livre du genre donnÃ© Compte le total decimal CalculerPenalitesTotales()\nSomme toutes les pÃ©nalitÃ©s double CalculerMoyenneEmpruntsParMembre()\nMoyenne dâ€™emprunts par membre Document ObtenirDocumentLePlusEmprunte()\nGroupBy sur Document OrderByDescending par Count Retourne le premier 2.4 RequÃªtes avancÃ©es avec polymorphisme Dictionary\u003cstring, int\u003e ObtenirStatistiquesParTypeDocument()\nGroupBy sur TypeDocument Retourne: â€œLivreâ€ â†’ 25, â€œMagazineâ€ â†’ 15 TriÃ© par nombre dÃ©croissant var ObtenirStatistiquesCompletes()\nPour chaque type de document, retourne (type anonyme): new { TypeDocument = \"Livre\", Nombre = ..., NombreDisponibles = ..., TauxDisponibilite = ... } List\u003cIEmpruntable\u003e ObtenirDocumentsEmpruntables()\nRetourne tous les documents qui sont IEmpruntable OÃ¹ PeutEtreEmprunte() == true Important: retour polymorphe comme IEmpruntable Dictionary\u003cTypeMembre, List\u003cMembre\u003e\u003e GrouperMembresParType()\nGroupBy par type Retourne dictionnaire var ObtenirTop5MembresActifs()\nTop 5 par nombre dâ€™emprunts totaux Type anonyme avec Nom et NombreEmprunts List\u003cEmprunt\u003e ObtenirHistoriqueMembreParType(int membreId, string typeDocument)\nEmprunts dâ€™un membre Filtre par TypeDocument du Document TriÃ©s par DateEmprunt dÃ©croissant 2.5 MÃ©thodes utilisant le polymorphisme (IMPORTANT!) void AfficherTousLesDocuments()\nParcourt la liste Documents Pour chaque document, appelle document.AfficherInfos() (polymorphisme!) La bonne mÃ©thode est appelÃ©e selon le type rÃ©el List\u003cstring\u003e ObtenirDescriptionsTousDocuments()\nSelect sur Documents Appelle document.ObtenirDescription() pour chacun (polymorphisme!) Retourne la liste des descriptions Dictionary\u003cstring, int\u003e CalculerDureeMoyenneParType()\nGroupBy par TypeDocument Pour chaque groupe, calcule la durÃ©e moyenne dâ€™emprunt Retourne: â€œLivreâ€ â†’ 18, â€œMagazineâ€ â†’ 7 ğŸ“‹ PARTIE 3: PROGRAMME PRINCIPAL Dans Program.cs:\nCrÃ©ez un GestionnaireBibliotheque\nAjoutez des donnÃ©es de test:\nAu moins 8 Livres (diffÃ©rents genres) Au moins 4 Magazines Au moins 5 Membres (diffÃ©rents types) Au moins 10 Emprunts (certains en retard, certains de livres, certains de magazines) DÃ©montrez le polymorphisme:\n// Ajout polymorphe Document doc1 = new Livre { Titre = \"1984\", Auteur = \"Orwell\" }; Document doc2 = new Magazine { Titre = \"Science et Vie\", NumeroEdition = 125 }; gestionnaire.AjouterDocument(doc1); gestionnaire.AjouterDocument(doc2); // Affichage polymorphe gestionnaire.AfficherTousLesDocuments(); Testez et affichez:\nStatistiques par type de document Documents disponibles (livres ET magazines) Emprunts en retard avec pÃ©nalitÃ©s Top 5 membres actifs Descriptions de tous les documents (polymorphisme!) Format dâ€™affichage suggÃ©rÃ©:\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\rSYSTÃˆME DE GESTION - BIBLIOTHÃˆQUE\râ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\rğŸ“Š STATISTIQUES PAR TYPE:\râ€¢ Livre: 8 documents (5 disponibles) - 62.5%\râ€¢ Magazine: 4 documents (3 disponibles) - 75.0%\rğŸ“š TOUS LES DOCUMENTS DISPONIBLES:\râ€¢ Livre: 1984 par George Orwell (1949)\râ€¢ Magazine: Science et Vie #125 - Editeur XYZ\râ€¢ Livre: Le Petit Prince par Saint-ExupÃ©ry (1943)\râ° EMPRUNTS EN RETARD:\râ€¢ 1984 - Alice Tremblay - 5 jours - 2.50$\râ€¢ Science et Vie #120 - Bob Gagnon - 2 jours - 1.00$\rğŸ’° PÃ‰NALITÃ‰S TOTALES: 3.50$\rğŸ† TOP 5 MEMBRES ACTIFS:\r1. Alice Tremblay - 8 emprunts\r2. Bob Gagnon - 6 emprunts\r3. Charlie Roy - 4 emprunts âœ… CRITÃˆRES Dâ€™Ã‰VALUATION POO AvancÃ©e (40%) Interface IEmpruntable correctement dÃ©finie et implÃ©mentÃ©e Classe abstraite Document avec propriÃ©tÃ©s/mÃ©thodes abstraites et virtuelles HÃ©ritage correct: Livre et Magazine hÃ©ritent de Document ImplÃ©mentation correcte de lâ€™interface dans les deux classes Utilisation de override pour les mÃ©thodes virtuelles/abstraites Utilisation de base dans les constructeurs Polymorphisme dÃ©montrÃ© (Document peut rÃ©fÃ©rer Livre ou Magazine) PropriÃ©tÃ© protÃ©gÃ©e (protected) utilisÃ©e correctement LINQ (40%) Utilisation de OfType\u003cT\u003e() ou is pour filtrer par type Toutes les mÃ©thodes utilisent LINQ (pas de boucles) Where, OrderBy, Select correctement utilisÃ©s GroupBy, Count, Sum, Average correctement utilisÃ©s FirstOrDefault avec gestion du null Types anonymes utilisÃ©s QualitÃ© du code (20%) Code compile sans erreurs Noms significatifs Gestion des cas null Polymorphisme bien exploitÃ© Programme principal dÃ©montre bien les concepts ğŸ“ CONCEPTS POO Ã€ MAÃTRISER Classe abstraite vs Interface Classe abstraite (Document):\nPeut avoir des propriÃ©tÃ©s concrÃ¨tes ET abstraites Peut avoir des mÃ©thodes implÃ©mentÃ©es ET abstraites Peut avoir un constructeur HÃ©ritage simple uniquement (une classe ne peut hÃ©riter que dâ€™une classe abstraite) Interface (IEmpruntable):\nDÃ©finit uniquement un contrat (signatures) Pas dâ€™implÃ©mentation Pas de constructeur Une classe peut implÃ©menter plusieurs interfaces Mots-clÃ©s importants abstract - Classe ou membre qui DOIT Ãªtre implÃ©mentÃ©\npublic abstract string TypeDocument { get; } public abstract int ObtenirDureeEmpruntDefaut(); virtual - Membre qui PEUT Ãªtre surchargÃ©\npublic virtual string ObtenirDescription() { ... } override - Surcharge un membre virtual ou abstract\npublic override string ObtenirDescription() { ... } protected - Accessible dans la classe et les classes dÃ©rivÃ©es\nprotected set { ... } base - Appelle le constructeur/mÃ©thode de la classe parent\npublic Livre() : base() { } Pattern matching avec is et as // VÃ©rifier le type if (document is Livre livre) { Console.WriteLine(livre.Auteur); } // Cast sÃ©curitaire IEmpruntable empruntable = document as IEmpruntable; if (empruntable != null) { empruntable.Emprunter(); } // Avec LINQ var livres = Documents.OfType\u003cLivre\u003e(); ğŸ“š RAPPELS LINQ SPÃ‰CIFIQUES AU POLYMORPHISME // Filtrer par type avec OfType var livres = Documents.OfType\u003cLivre\u003e(); // Filtrer par type avec Where et is var magazines = Documents.Where(d =\u003e d is Magazine); // Cast aprÃ¨s filtrage var livresSciFi = Documents .OfType\u003cLivre\u003e() .Where(l =\u003e l.Genre == GenreLivre.ScienceFiction); // GroupBy sur propriÃ©tÃ© polymorphe var stats = Documents .GroupBy(d =\u003e d.TypeDocument) .Select(g =\u003e new { Type = g.Key, Count = g.Count() }); // Utiliser l'interface var disponibles = Documents .OfType\u003cIEmpruntable\u003e() .Where(e =\u003e e.PeutEtreEmprunte()); Focus: HÃ©ritage, Interfaces, Polymorphisme et LINQ!",
    "description": "ğŸ“ EXERCICE DE PRÃ‰PARATION Ã€ Lâ€™EXAMEN SystÃ¨me de Gestion dâ€™une BibliothÃ¨que Municipale POO AvancÃ©e + LINQ ğŸ¯ CONTEXTE Vous travaillez pour la Ville de MontrÃ©al et devez crÃ©er un systÃ¨me de gestion pour la bibliothÃ¨que municipale. Le systÃ¨me doit gÃ©rer diffÃ©rents types de documents (livres, magazines, DVD), les membres, les emprunts et gÃ©nÃ©rer des statistiques.",
    "tags": [],
    "title": "Pratique - Exam 1",
    "uri": "/420-413/pratique_exam1/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "DÃ©veloppement dâ€™applications WPF avec C# Partie 1 : Installation de .NET Desktop Development 1.1 Pourquoi Visual Studio 2022 ? Visual Studio 2022 est lâ€™IDE (environnement de dÃ©veloppement intÃ©grÃ©) officiel de Microsoft pour crÃ©er des applications .NET.\nAvantages :\nDesigner visuel pour WPF (glisser-dÃ©poser de contrÃ´les) IntelliSense (auto-complÃ©tion intelligente) DÃ©bogueur puissant Gratuit dans la version Community 1.2 Ã‰tapes dâ€™installation Ã‰tape 1 : TÃ©lÃ©charger Visual Studio 2022 Allez sur : https://visualstudio.microsoft.com/fr/ TÃ©lÃ©chargez Visual Studio 2022 Community (gratuit) Lancez le programme dâ€™installation tÃ©lÃ©chargÃ© Ã‰tape 2 : Installer la charge de travail .NET Desktop Quand le Visual Studio Installer sâ€™ouvre :\nDans lâ€™onglet â€œCharges de travailâ€, cochez :\nâœ… DÃ©veloppement .NET Desktop (en franÃ§ais) âœ… \".NET desktop development\" (en anglais) Cette charge de travail installe automatiquement :\n.NET SDK (kit de dÃ©veloppement) Windows Forms WPF (Windows Presentation Foundation) Templates de projets pour applications de bureau Cliquez sur â€œInstallerâ€ ou â€œModifierâ€ (si VS est dÃ©jÃ  installÃ©)\nÃ‰tape 3 : VÃ©rifier lâ€™installation Une fois lâ€™installation terminÃ©e :\nLancez Visual Studio 2022 Cliquez sur â€œCrÃ©er un projetâ€ Dans la barre de recherche, tapez â€œWPFâ€ Vous devriez voir : â€œApplication WPF (.NET)â€ Si vous voyez ce template, lâ€™installation a rÃ©ussi ! âœ…\n1.3 CrÃ©er votre premier projet WPF ProcÃ©dure complÃ¨te :\nFichier â†’ Nouveau â†’ Projet Recherchez â€œWPFâ€ SÃ©lectionnez â€œApplication WPFâ€ (assurez-vous que câ€™est bien .NET et pas .NET Framework) Cliquez sur â€œSuivantâ€ Donnez un nom au projet : MonPremierWPF Choisissez un emplacement sur votre disque Cliquez sur â€œSuivantâ€ SÃ©lectionnez \".NET 8.0\" ou \".NET 7.0\" (la version la plus rÃ©cente) Cliquez sur â€œCrÃ©erâ€ Visual Studio va crÃ©er :\nUn fichier MainWindow.xaml (lâ€™interface) Un fichier MainWindow.xaml.cs (le code C#) Un fichier App.xaml (configuration de lâ€™application) Appuyez sur F5 pour lancer lâ€™application. Une fenÃªtre vide sâ€™ouvrira â€” câ€™est votre premiÃ¨re app WPF ! ğŸ‰\nPartie 2 : Introduction Ã  la programmation de bureau 2.1 Quâ€™est-ce quâ€™une application de bureau ? Jusquâ€™Ã  prÃ©sent, vous avez probablement Ã©crit des applications console (avec Console.WriteLine).\nApplication console :\n\u003e Entrez votre nom: Alice\r\u003e Bonjour Alice! Application de bureau (WPF) :\nFenÃªtres avec boutons, champs de texte, images Interface graphique (GUI) Interaction Ã  la souris Exemple : Microsoft Word, Excel, calculatrice Windows 2.2 DiffÃ©rence entre Console et WPF Aspect Application Console Application WPF Interface Texte uniquement Graphique (boutons, images, etc.) Interaction Clavier (input/output) Souris + clavier Apparence Noire et blanche Couleurs, polices, animations ComplexitÃ© Simple Plus complexe mais plus puissante Utilisation Scripts, outils admin Logiciels utilisateur final 2.3 Les 3 technologies de bureau en .NET Technologie AnnÃ©e Utilisation Windows Forms 2002 Ancienne, simple mais limitÃ©e WPF 2006 Moderne, puissante, flexible WinUI 3 2021 TrÃ¨s rÃ©cente, encore en dÃ©veloppement Dans ce cours, on se concentre sur WPF car câ€™est le standard de lâ€™industrie.\n2.4 Architecture dâ€™une application WPF MonProjet/\râ”œâ”€â”€ App.xaml â† Configuration de l'application\râ”œâ”€â”€ App.xaml.cs â† Code-behind de App\râ”œâ”€â”€ MainWindow.xaml â† Interface de la fenÃªtre principale\râ”œâ”€â”€ MainWindow.xaml.cs â† Logique de la fenÃªtre principale\râ””â”€â”€ (Autres fenÃªtres, classes, ressources...) Principe fondamental : WPF sÃ©pare lâ€™interface (XAML) de la logique (C#).\nPartie 3 : Premiers pas avec WPF 3.1 Structure dâ€™un projet WPF Quand vous crÃ©ez un projet WPF, Visual Studio gÃ©nÃ¨re automatiquement :\nApp.xaml\n\u003cApplication x:Class=\"MonPremierWPF.App\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" StartupUri=\"MainWindow.xaml\"\u003e \u003cApplication.Resources\u003e \u003c/Application.Resources\u003e \u003c/Application\u003e StartupUri=\"MainWindow.xaml\" â†’ Quelle fenÃªtre sâ€™ouvre au dÃ©marrage MainWindow.xaml\n\u003cWindow x:Class=\"MonPremierWPF.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"MainWindow\" Height=\"450\" Width=\"800\"\u003e \u003cGrid\u003e \u003c/Grid\u003e \u003c/Window\u003e Title â†’ Titre de la fenÃªtre Height et Width â†’ Dimensions en pixels \u003cGrid\u003e â†’ Conteneur pour placer les contrÃ´les MainWindow.xaml.cs\nusing System.Windows; namespace MonPremierWPF { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } } } InitializeComponent() â†’ Charge le XAML et construit lâ€™interface 3.2 Le Designer visuel Dans Visual Studio, quand vous ouvrez MainWindow.xaml, vous voyez deux panneaux :\nEn haut : Le Designer (aperÃ§u visuel) En bas : Le code XAML Vous pouvez :\nGlisser-dÃ©poser des contrÃ´les depuis la BoÃ®te Ã  outils (View â†’ Toolbox) Modifier le XAML directement Les deux sont synchronisÃ©s ! 3.3 Votre premier bouton Modifiez MainWindow.xaml :\n\u003cWindow x:Class=\"MonPremierWPF.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"Ma premiÃ¨re application\" Height=\"300\" Width=\"400\"\u003e \u003cGrid\u003e \u003cButton Content=\"Cliquez-moi !\" Width=\"150\" Height=\"50\" Click=\"Button_Click\" /\u003e \u003c/Grid\u003e \u003c/Window\u003e Dans MainWindow.xaml.cs, ajoutez la mÃ©thode :\nusing System.Windows; namespace MonPremierWPF { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); } private void Button_Click(object sender, RoutedEventArgs e) { MessageBox.Show(\"Bonjour du monde WPF !\"); } } } Appuyez sur F5 et cliquez sur le bouton. Un message apparaÃ®t ! ğŸ‰\nExplications :\nClick=\"Button_Click\" dans le XAML crÃ©e un lien vers la mÃ©thode C# Visual Studio peut crÃ©er cette mÃ©thode automatiquement : double-cliquez sur le bouton dans le Designer MessageBox.Show() affiche une boÃ®te de dialogue Partie 4 : XAML â€” Le langage de lâ€™interface 4.1 Quâ€™est-ce que XAML ? XAML (prononcez â€œzamelâ€) = eXtensible Application Markup Language\nCâ€™est un langage basÃ© sur XML pour dÃ©crire des interfaces graphiques.\nAnalogie :\nXAML est Ã  WPF ce que HTML est aux sites web C# est Ã  WPF ce que JavaScript est aux sites web 4.2 Syntaxe de base XAML Les balises (Ã©lÃ©ments) \u003cButton /\u003e \u003c!-- Balise auto-fermante --\u003e \u003cButton\u003e \u003c!-- Balise avec contenu --\u003e Texte du bouton \u003c/Button\u003e Les attributs (propriÃ©tÃ©s) \u003cButton Content=\"Mon bouton\" Width=\"100\" Height=\"40\" Background=\"Blue\" /\u003e Chaque attribut configure une propriÃ©tÃ© de lâ€™objet C#.\nÃ‰quivalent en C# pur :\nButton monBouton = new Button(); monBouton.Content = \"Mon bouton\"; monBouton.Width = 100; monBouton.Height = 40; monBouton.Background = Brushes.Blue; 4.3 Les namespaces XML En haut de chaque fichier XAML :\nxmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Premier namespace (par dÃ©faut) : Contient tous les contrÃ´les WPF (Button, TextBox, Grid, etc.) Namespace x: : Contient les Ã©lÃ©ments spÃ©ciaux XAML (x:Name, x:Class, etc.) 4.4 Lâ€™attribut x:Name Pour accÃ©der Ã  un contrÃ´le depuis le code C#, donnez-lui un nom :\n\u003cTextBox x:Name=\"txtNom\" Width=\"200\" Height=\"30\" /\u003e Ensuite, dans le C# :\nprivate void Button_Click(object sender, RoutedEventArgs e) { string nom = txtNom.Text; // AccÃ¨s direct ! MessageBox.Show($\"Bonjour {nom}\"); } Convention de nommage :\nTextBox â†’ txt prefix (ex: txtNom, txtCourriel) Button â†’ btn prefix (ex: btnEnvoyer, btnAnnuler) Label â†’ lbl prefix ListBox â†’ lst prefix 4.5 PropriÃ©tÃ©s complexes Certaines propriÃ©tÃ©s sont trop complexes pour un simple attribut.\nSyntaxe avec attribut (simple) :\n\u003cButton Background=\"Blue\" /\u003e Syntaxe avec balise (complexe) :\n\u003cButton\u003e \u003cButton.Background\u003e \u003cLinearGradientBrush\u003e \u003cGradientStop Color=\"LightBlue\" Offset=\"0\" /\u003e \u003cGradientStop Color=\"DarkBlue\" Offset=\"1\" /\u003e \u003c/LinearGradientBrush\u003e \u003c/Button.Background\u003e \u003cButton.Content\u003e Mon bouton avec dÃ©gradÃ© \u003c/Button.Content\u003e \u003c/Button\u003e 4.6 Les Ã©vÃ©nements Les Ã©vÃ©nements relient lâ€™interface au code C#.\nÃ‰vÃ©nements courants :\n\u003cButton Click=\"MonBouton_Click\" /\u003e \u003cTextBox TextChanged=\"MonTexte_Changed\" /\u003e \u003cCheckBox Checked=\"MaCase_Checked\" /\u003e \u003cListBox SelectionChanged=\"MaListe_SelectionChanged\" /\u003e Dans le C# :\nprivate void MonBouton_Click(object sender, RoutedEventArgs e) { // Code exÃ©cutÃ© quand on clique } private void MonTexte_Changed(object sender, TextChangedEventArgs e) { // Code exÃ©cutÃ© quand le texte change } Partie 5 : Les Layouts (mise en page) Les Layouts sont des conteneurs qui organisent les contrÃ´les Ã  lâ€™Ã©cran.\n5.1 Grid â€” Le layout principal Le Grid divise lâ€™espace en lignes et colonnes, comme un tableau Excel.\nExemple de base \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"Auto\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003cRowDefinition Height=\"50\" /\u003e \u003c/Grid.RowDefinitions\u003e \u003cGrid.ColumnDefinitions\u003e \u003cColumnDefinition Width=\"200\" /\u003e \u003cColumnDefinition Width=\"*\" /\u003e \u003c/Grid.ColumnDefinitions\u003e \u003c!-- Placer les contrÃ´les --\u003e \u003cButton Grid.Row=\"0\" Grid.Column=\"0\" Content=\"Haut gauche\" /\u003e \u003cButton Grid.Row=\"0\" Grid.Column=\"1\" Content=\"Haut droite\" /\u003e \u003cTextBox Grid.Row=\"1\" Grid.Column=\"0\" Grid.ColumnSpan=\"2\" /\u003e \u003c/Grid\u003e Types de dimensions Valeur Signification Exemple 100 Pixels fixes Height=\"100\" Auto Sâ€™adapte au contenu Height=\"Auto\" * Prend lâ€™espace restant Height=\"*\" 2* Prend 2 fois plus dâ€™espace Height=\"2*\" Exemple avec proportions :\n\u003cGrid.ColumnDefinitions\u003e \u003cColumnDefinition Width=\"*\" /\u003e \u003c!-- 1/3 de l'espace --\u003e \u003cColumnDefinition Width=\"2*\" /\u003e \u003c!-- 2/3 de l'espace --\u003e \u003c/Grid.ColumnDefinitions\u003e Si la fenÃªtre fait 900 pixels de large :\nColonne 0 : 300 pixels Colonne 1 : 600 pixels Fusionner des cellules \u003c!-- Prendre 2 colonnes --\u003e \u003cButton Grid.Row=\"0\" Grid.Column=\"0\" Grid.ColumnSpan=\"2\" Content=\"Large\" /\u003e \u003c!-- Prendre 2 rangÃ©es --\u003e \u003cButton Grid.Row=\"0\" Grid.Column=\"0\" Grid.RowSpan=\"2\" Content=\"Haut\" /\u003e 5.2 StackPanel â€” Empilement Le StackPanel empile les Ã©lÃ©ments verticalement (dÃ©faut) ou horizontalement.\nVertical (dÃ©faut) \u003cStackPanel\u003e \u003cButton Content=\"Bouton 1\" Height=\"40\" /\u003e \u003cButton Content=\"Bouton 2\" Height=\"40\" /\u003e \u003cButton Content=\"Bouton 3\" Height=\"40\" /\u003e \u003c/StackPanel\u003e Les boutons sont empilÃ©s du haut vers le bas.\nHorizontal \u003cStackPanel Orientation=\"Horizontal\"\u003e \u003cButton Content=\"Bouton 1\" Width=\"100\" /\u003e \u003cButton Content=\"Bouton 2\" Width=\"100\" /\u003e \u003cButton Content=\"Bouton 3\" Width=\"100\" /\u003e \u003c/StackPanel\u003e Les boutons sont cÃ´te Ã  cÃ´te.\nAvec Margin (espacement) \u003cStackPanel Margin=\"20\"\u003e \u003cTextBlock Text=\"Nom :\" FontWeight=\"Bold\" /\u003e \u003cTextBox Height=\"30\" Margin=\"0,5,0,10\" /\u003e \u003cTextBlock Text=\"Courriel :\" FontWeight=\"Bold\" /\u003e \u003cTextBox Height=\"30\" Margin=\"0,5,0,10\" /\u003e \u003cButton Content=\"Envoyer\" Height=\"40\" /\u003e \u003c/StackPanel\u003e Margin : Left, Top, Right, Bottom\nMargin=\"10\" â†’ 10 pixels de tous les cÃ´tÃ©s Margin=\"10,20\" â†’ 10 gauche/droite, 20 haut/bas Margin=\"10,20,30,40\" â†’ Gauche, Haut, Droite, Bas 5.3 WrapPanel â€” Empilement avec retour automatique Comme StackPanel, mais retourne Ã  la ligne si pas assez dâ€™espace.\n\u003cWrapPanel\u003e \u003cButton Content=\"1\" Width=\"100\" Height=\"40\" Margin=\"5\" /\u003e \u003cButton Content=\"2\" Width=\"100\" Height=\"40\" Margin=\"5\" /\u003e \u003cButton Content=\"3\" Width=\"100\" Height=\"40\" Margin=\"5\" /\u003e \u003cButton Content=\"4\" Width=\"100\" Height=\"40\" Margin=\"5\" /\u003e \u003cButton Content=\"5\" Width=\"100\" Height=\"40\" Margin=\"5\" /\u003e \u003c/WrapPanel\u003e Si la fenÃªtre est Ã©troite, les boutons passent Ã  la ligne suivante.\n5.4 DockPanel â€” Ancrage sur les bords \u003cDockPanel\u003e \u003cMenu DockPanel.Dock=\"Top\" Height=\"30\" Background=\"LightGray\"\u003e \u003cMenuItem Header=\"Fichier\" /\u003e \u003cMenuItem Header=\"Edition\" /\u003e \u003c/Menu\u003e \u003cStatusBar DockPanel.Dock=\"Bottom\" Height=\"25\" Background=\"LightGray\"\u003e \u003cTextBlock Text=\"PrÃªt\" /\u003e \u003c/StatusBar\u003e \u003cTreeView DockPanel.Dock=\"Left\" Width=\"200\" /\u003e \u003cTextBox /\u003e \u003c!-- Remplit le centre --\u003e \u003c/DockPanel\u003e RÃ©sultat : Interface classique avec menu en haut, barre de statut en bas, arbre Ã  gauche, et zone centrale.\n5.5 Canvas â€” Positionnement absolu \u003cCanvas\u003e \u003cButton Content=\"Bouton 1\" Canvas.Left=\"50\" Canvas.Top=\"100\" Width=\"100\" Height=\"40\" /\u003e \u003cEllipse Fill=\"Red\" Canvas.Left=\"200\" Canvas.Top=\"150\" Width=\"80\" Height=\"80\" /\u003e \u003c/Canvas\u003e Rarement utilisÃ© car pas responsive.\n5.6 Exemple : Interface complÃ¨te Application de calculatrice simple :\nğŸ’¡ Solution\r\u003cWindow x:Class=\"Calculatrice.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"Calculatrice\" Height=\"400\" Width=\"350\"\u003e \u003cGrid Margin=\"10\"\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"80\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003c/Grid.RowDefinitions\u003e \u003c!-- Affichage --\u003e \u003cBorder Grid.Row=\"0\" BorderBrush=\"Black\" BorderThickness=\"2\" Background=\"White\" Padding=\"10\"\u003e \u003cTextBlock x:Name=\"txtAffichage\" Text=\"0\" FontSize=\"36\" HorizontalAlignment=\"Right\" VerticalAlignment=\"Center\" /\u003e \u003c/Border\u003e \u003c!-- Boutons --\u003e \u003cGrid Grid.Row=\"1\" Margin=\"0,10,0,0\"\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003c/Grid.RowDefinitions\u003e \u003cGrid.ColumnDefinitions\u003e \u003cColumnDefinition Width=\"*\" /\u003e \u003cColumnDefinition Width=\"*\" /\u003e \u003cColumnDefinition Width=\"*\" /\u003e \u003cColumnDefinition Width=\"*\" /\u003e \u003c/Grid.ColumnDefinitions\u003e \u003c!-- Ligne 0 --\u003e \u003cButton Grid.Row=\"0\" Grid.Column=\"0\" Content=\"7\" FontSize=\"24\" Margin=\"2\" /\u003e \u003cButton Grid.Row=\"0\" Grid.Column=\"1\" Content=\"8\" FontSize=\"24\" Margin=\"2\" /\u003e \u003cButton Grid.Row=\"0\" Grid.Column=\"2\" Content=\"9\" FontSize=\"24\" Margin=\"2\" /\u003e \u003cButton Grid.Row=\"0\" Grid.Column=\"3\" Content=\"Ã·\" FontSize=\"24\" Margin=\"2\" Background=\"LightBlue\" /\u003e \u003c!-- Ligne 1 --\u003e \u003cButton Grid.Row=\"1\" Grid.Column=\"0\" Content=\"4\" FontSize=\"24\" Margin=\"2\" /\u003e \u003cButton Grid.Row=\"1\" Grid.Column=\"1\" Content=\"5\" FontSize=\"24\" Margin=\"2\" /\u003e \u003cButton Grid.Row=\"1\" Grid.Column=\"2\" Content=\"6\" FontSize=\"24\" Margin=\"2\" /\u003e \u003cButton Grid.Row=\"1\" Grid.Column=\"3\" Content=\"Ã—\" FontSize=\"24\" Margin=\"2\" Background=\"LightBlue\" /\u003e \u003c!-- Ligne 2 --\u003e \u003cButton Grid.Row=\"2\" Grid.Column=\"0\" Content=\"1\" FontSize=\"24\" Margin=\"2\" /\u003e \u003cButton Grid.Row=\"2\" Grid.Column=\"1\" Content=\"2\" FontSize=\"24\" Margin=\"2\" /\u003e \u003cButton Grid.Row=\"2\" Grid.Column=\"2\" Content=\"3\" FontSize=\"24\" Margin=\"2\" /\u003e \u003cButton Grid.Row=\"2\" Grid.Column=\"3\" Content=\"-\" FontSize=\"24\" Margin=\"2\" Background=\"LightBlue\" /\u003e \u003c!-- Ligne 3 --\u003e \u003cButton Grid.Row=\"3\" Grid.Column=\"0\" Content=\"0\" FontSize=\"24\" Margin=\"2\" Grid.ColumnSpan=\"2\" /\u003e \u003cButton Grid.Row=\"3\" Grid.Column=\"2\" Content=\"=\" FontSize=\"24\" Margin=\"2\" Background=\"Orange\" /\u003e \u003cButton Grid.Row=\"3\" Grid.Column=\"3\" Content=\"+\" FontSize=\"24\" Margin=\"2\" Background=\"LightBlue\" /\u003e \u003c/Grid\u003e \u003c/Grid\u003e \u003c/Window\u003e Partie 6 : Les contrÃ´les de base 6.1 TextBox â€” Saisie de texte \u003cTextBox x:Name=\"txtNom\" Width=\"200\" Height=\"30\" Text=\"Valeur par dÃ©faut\" /\u003e PropriÃ©tÃ©s importantes :\nText : Le contenu MaxLength : Limite de caractÃ¨res IsReadOnly : Lecture seule AcceptsReturn : Multi-lignes AccÃ¨s en C# :\nstring texte = txtNom.Text; txtNom.Text = \"Nouveau texte\"; 6.2 TextBlock â€” Texte non modifiable \u003cTextBlock Text=\"Ceci est un texte\" FontSize=\"16\" FontWeight=\"Bold\" Foreground=\"DarkBlue\" /\u003e DiffÃ©rence avec TextBox :\nTextBlock : Affichage seulement (comme un label HTML) TextBox : Saisie utilisateur (comme un input HTML) 6.3 Button â€” Bouton \u003cButton Content=\"Cliquer ici\" Width=\"120\" Height=\"40\" Click=\"MonBouton_Click\" /\u003e PropriÃ©tÃ©s :\nContent : Texte ou contenu IsEnabled : Actif/dÃ©sactivÃ© Background : Couleur de fond 6.4 CheckBox â€” Case Ã  cocher \u003cCheckBox Content=\"J'accepte les conditions\" IsChecked=\"True\" Checked=\"Case_Checked\" /\u003e AccÃ¨s en C# :\nbool estCoche = maCaseACocher.IsChecked == true; 6.5 RadioButton â€” Bouton radio \u003cStackPanel\u003e \u003cRadioButton Content=\"Option 1\" GroupName=\"Options\" IsChecked=\"True\" /\u003e \u003cRadioButton Content=\"Option 2\" GroupName=\"Options\" /\u003e \u003cRadioButton Content=\"Option 3\" GroupName=\"Options\" /\u003e \u003c/StackPanel\u003e GroupName : Regroupe les RadioButtons (un seul sÃ©lectionnable par groupe)\n6.6 ComboBox â€” Liste dÃ©roulante \u003cComboBox x:Name=\"cbVilles\" Width=\"200\" Height=\"30\"\u003e \u003cComboBoxItem Content=\"MontrÃ©al\" /\u003e \u003cComboBoxItem Content=\"QuÃ©bec\" /\u003e \u003cComboBoxItem Content=\"Laval\" /\u003e \u003c/ComboBox\u003e AccÃ¨s en C# :\nComboBoxItem item = (ComboBoxItem)cbVilles.SelectedItem; string ville = item.Content.ToString(); 6.7 ListBox â€” Liste \u003cListBox x:Name=\"lstNoms\" Height=\"200\"\u003e \u003cListBoxItem Content=\"Alice\" /\u003e \u003cListBoxItem Content=\"Bob\" /\u003e \u003cListBoxItem Content=\"Charlie\" /\u003e \u003c/ListBox\u003e Ajouter des Ã©lÃ©ments en C# :\nlstNoms.Items.Add(\"David\"); 6.8 Image â€” Afficher une image \u003cImage Source=\"logo.png\" Width=\"100\" Height=\"100\" /\u003e Note : Lâ€™image doit Ãªtre dans le dossier du projet et configurÃ©e en â€œCopy to Output Directoryâ€.\n6.9 ProgressBar â€” Barre de progression \u003cProgressBar x:Name=\"barreProgression\" Height=\"20\" Minimum=\"0\" Maximum=\"100\" Value=\"50\" /\u003e 6.10 Slider â€” Curseur \u003cSlider x:Name=\"sliderVolume\" Minimum=\"0\" Maximum=\"100\" Value=\"50\" TickFrequency=\"10\" IsSnapToTickEnabled=\"True\" /\u003e Partie 7 : Data Binding (Liaison de donnÃ©es) Le Data Binding est la fonctionnalitÃ© qui rend WPF vraiment puissant. Il synchronise automatiquement lâ€™interface avec les donnÃ©es.\n7.1 Pourquoi le Data Binding ? Sans Data Binding (approche manuelle) :\nprivate string nom = \"Alice\"; private void ChangerNom() { nom = \"Bob\"; txtAffichage.Text = nom; // Mise Ã  jour manuelle ! } ProblÃ¨me : Ã€ chaque changement, il faut manuellement mettre Ã  jour lâ€™interface.\nAvec Data Binding :\n\u003cTextBox Text=\"{Binding Nom}\" /\u003e Maintenant, quand Nom change, le TextBox se met Ã  jour automatiquement !\n7.2 Le DataContext Le DataContext est lâ€™objet source auquel les contrÃ´les se lient.\nExemple simple :\nClasse Personne.cs :\npublic class Personne { public string Nom { get; set; } public int Age { get; set; } } MainWindow.xaml :\n\u003cWindow x:Class=\"BindingDemo.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"Data Binding Demo\" Height=\"200\" Width=\"350\"\u003e \u003cStackPanel Margin=\"20\"\u003e \u003cTextBlock Text=\"Nom :\" FontWeight=\"Bold\" /\u003e \u003cTextBox Text=\"{Binding Nom}\" Height=\"30\" Margin=\"0,5,0,10\" /\u003e \u003cTextBlock Text=\"Ã‚ge :\" FontWeight=\"Bold\" /\u003e \u003cTextBox Text=\"{Binding Age}\" Height=\"30\" Margin=\"0,5,0,10\" /\u003e \u003cTextBlock Text=\"{Binding Nom}\" FontSize=\"16\" /\u003e \u003c/StackPanel\u003e \u003c/Window\u003e MainWindow.xaml.cs :\nusing System.Windows; namespace BindingDemo { public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); // CrÃ©er une personne Personne p = new Personne { Nom = \"Alice\", Age = 25 }; // DÃ©finir le DataContext this.DataContext = p; } } } RÃ©sultat : Les TextBox affichent â€œAliceâ€ et â€œ25â€.\n7.3 Les modes de Binding Mode Direction Usage OneWay Source â†’ UI Affichage (lecture seule) TwoWay Source â†” UI Ã‰dition (bidirectionnel) OneTime Source â†’ UI (une seule fois) Valeurs constantes OneWayToSource UI â†’ Source Rare Exemples :\n\u003c!-- TwoWay : modifications dans les deux sens --\u003e \u003cTextBox Text=\"{Binding Nom, Mode=TwoWay}\" /\u003e \u003c!-- OneWay : lecture seule --\u003e \u003cTextBlock Text=\"{Binding Nom, Mode=OneWay}\" /\u003e Par dÃ©faut :\nTextBox : TwoWay TextBlock : OneWay",
    "description": "DÃ©veloppement dâ€™applications WPF avec C# Partie 1 : Installation de .NET Desktop Development 1.1 Pourquoi Visual Studio 2022 ? Visual Studio 2022 est lâ€™IDE (environnement de dÃ©veloppement intÃ©grÃ©) officiel de Microsoft pour crÃ©er des applications .NET.",
    "tags": [],
    "title": "WPF - intro",
    "uri": "/420-413/wpf/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Partie 1 : Le patron Observateur (Contexte gÃ©nÃ©ral) Quâ€™est-ce quâ€™un patron de conception ? DÃ©finition simple : Un patron de conception est une solution Ã©prouvÃ©e Ã  un problÃ¨me rÃ©current en programmation.\nAnalogie : Câ€™est comme une recette de cuisine. Si vous voulez faire un gÃ¢teau, vous nâ€™inventez pas la mÃ©thode Ã  chaque fois â€” vous suivez une recette qui a fait ses preuves.\nLes patrons de conception ne sont pas :\nâŒ Du code Ã  copier-coller âŒ Une bibliothÃ¨que ou un framework âŒ SpÃ©cifiques Ã  un langage Les patrons de conception sont :\nâœ… Des principes dâ€™organisation du code âœ… Des solutions conceptuelles âœ… Applicables dans nâ€™importe quel langage orientÃ© objet Le patron Observateur â€” Le problÃ¨me quâ€™il rÃ©sout Mise en situation rÃ©elle :\nImaginez une station mÃ©tÃ©o. Elle mesure :\nLa tempÃ©rature Lâ€™humiditÃ© La pression Plusieurs appareils doivent afficher ces donnÃ©es :\nUn thermomÃ¨tre digital Une application mobile Un site web Un systÃ¨me dâ€™alerte ProblÃ¨me : Comment faire en sorte que tous ces appareils soient notifiÃ©s automatiquement quand les donnÃ©es changent ?\nâŒ Mauvaise solution (couplage fort) :\npublic class StationMeteo { private double temperature; public void SetTemperature(double temp) { temperature = temp; // Mettre Ã  jour chaque appareil manuellement thermometre.Afficher(temp); appMobile.MettreAJour(temp); siteWeb.Actualiser(temp); systemeAlerte.Verifier(temp); // ProblÃ¨me : Si on ajoute un nouvel appareil, // il faut modifier cette mÃ©thode ! } } ProblÃ¨mes de cette approche :\nLa station mÃ©tÃ©o connaÃ®t tous les appareils (couplage fort) Pour ajouter un nouvel appareil, il faut modifier la station Impossible de dÃ©sactiver un appareil sans modifier le code Code rigide et difficile Ã  maintenir Le patron Observateur â€” La solution Principe fondamental : Inverser la dÃ©pendance.\nAu lieu que la station connaisse tous les appareils, les appareils sâ€™abonnent Ã  la station.\nAnalogie : Câ€™est comme une newsletter par email :\nLe site web (sujet) publie du contenu Les lecteurs (observateurs) sâ€™abonnent Quand un nouvel article sort, tous les abonnÃ©s reÃ§oivent un email Les lecteurs peuvent se dÃ©sabonner Ã  tout moment Le site web ne connaÃ®t pas les lecteurs individuellement Diagramme conceptuel :\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ SUJET (Observable) â”‚\râ”‚ - Liste d'observateurs â”‚\râ”‚ + Attacher(observateur) â”‚\râ”‚ + DÃ©tacher(observateur) â”‚\râ”‚ + Notifier() â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\râ”‚\râ”‚ notifie\râ†“\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ OBSERVATEUR â”‚\râ”‚ (Interface) â”‚\râ”‚ + Actualiser() â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\râ–³\râ”‚ implÃ©mente\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ â”‚ â”‚\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚Thermo- â”‚ â”‚App â”‚ â”‚Site â”‚\râ”‚mÃ¨tre â”‚ â”‚Mobile â”‚ â”‚Web â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ImplÃ©mentation complÃ¨te Ã‰tape 1 : Lâ€™interface Observateur\n// Ce que TOUS les observateurs doivent implÃ©menter public interface IObservateur { void Actualiser(double temperature, double humidite, double pression); } Ã‰tape 2 : Le Sujet (Observable)\npublic class StationMeteo { // Liste des observateurs abonnÃ©s private List\u003cIObservateur\u003e observateurs = new List\u003cIObservateur\u003e(); // DonnÃ©es private double temperature; private double humidite; private double pression; // MÃ©thodes d'abonnement public void Abonner(IObservateur observateur) { observateurs.Add(observateur); Console.WriteLine($\"{observateur.GetType().Name} s'est abonnÃ©\"); } public void Desabonner(IObservateur observateur) { observateurs.Remove(observateur); Console.WriteLine($\"{observateur.GetType().Name} s'est dÃ©sabonnÃ©\"); } // Notifier tous les observateurs private void Notifier() { Console.WriteLine(\"=== Notification des observateurs ===\"); foreach (var observateur in observateurs) { observateur.Actualiser(temperature, humidite, pression); } } // Quand les donnÃ©es changent public void SetMesures(double temp, double hum, double press) { Console.WriteLine($\"\\nğŸ“¡ Nouvelles mesures reÃ§ues\"); temperature = temp; humidite = hum; pression = press; // Notifier automatiquement Notifier(); } } Ã‰tape 3 : Les observateurs concrets\n// Observateur 1 : ThermomÃ¨tre digital public class ThermometreDigital : IObservateur { public void Actualiser(double temperature, double humidite, double pression) { Console.WriteLine($\"ğŸŒ¡ï¸ ThermomÃ¨tre : {temperature}Â°C\"); } } // Observateur 2 : Application mobile public class ApplicationMobile : IObservateur { public void Actualiser(double temperature, double humidite, double pression) { Console.WriteLine($\"ğŸ“± App Mobile : Temp={temperature}Â°C, \" + $\"HumiditÃ©={humidite}%, Pression={pression}hPa\"); } } // Observateur 3 : SystÃ¨me d'alerte public class SystemeAlerte : IObservateur { private const double SEUIL_CANICULE = 35; private const double SEUIL_GEL = 0; public void Actualiser(double temperature, double humidite, double pression) { if (temperature \u003e= SEUIL_CANICULE) Console.WriteLine(\"âš ï¸ ALERTE : Canicule dÃ©tectÃ©e !\"); else if (temperature \u003c= SEUIL_GEL) Console.WriteLine(\"âš ï¸ ALERTE : Risque de gel !\"); else Console.WriteLine(\"âœ… SystÃ¨me d'alerte : Conditions normales\"); } } // Observateur 4 : Site web public class SiteWeb : IObservateur { public void Actualiser(double temperature, double humidite, double pression) { Console.WriteLine($\"ğŸŒ Site Web actualisÃ© : {temperature}Â°C\"); } } Ã‰tape 4 : Utilisation\nclass Program { static void Main(string[] args) { // CrÃ©er la station mÃ©tÃ©o StationMeteo station = new StationMeteo(); // CrÃ©er les observateurs ThermometreDigital thermo = new ThermometreDigital(); ApplicationMobile appMobile = new ApplicationMobile(); SystemeAlerte alerte = new SystemeAlerte(); SiteWeb siteWeb = new SiteWeb(); // Abonnement Console.WriteLine(\"=== Phase d'abonnement ===\"); station.Abonner(thermo); station.Abonner(appMobile); station.Abonner(alerte); station.Abonner(siteWeb); // PremiÃ¨re mise Ã  jour station.SetMesures(22.5, 65, 1013); // DeuxiÃ¨me mise Ã  jour station.SetMesures(38, 45, 1010); // Le site web se dÃ©sabonne Console.WriteLine(\"\\n=== Site web se dÃ©sabonne ===\"); station.Desabonner(siteWeb); // TroisiÃ¨me mise Ã  jour (le site web ne reÃ§oit plus de notification) station.SetMesures(-2, 80, 1020); } } Sortie :\n=== Phase d'abonnement ===\rThermometreDigital s'est abonnÃ©\rApplicationMobile s'est abonnÃ©\rSystemeAlerte s'est abonnÃ©\rSiteWeb s'est abonnÃ©\rğŸ“¡ Nouvelles mesures reÃ§ues\r=== Notification des observateurs ===\rğŸŒ¡ï¸ ThermomÃ¨tre : 22.5Â°C\rğŸ“± App Mobile : Temp=22.5Â°C, HumiditÃ©=65%, Pression=1013hPa\râœ… SystÃ¨me d'alerte : Conditions normales\rğŸŒ Site Web actualisÃ© : 22.5Â°C\rğŸ“¡ Nouvelles mesures reÃ§ues\r=== Notification des observateurs ===\rğŸŒ¡ï¸ ThermomÃ¨tre : 38Â°C\rğŸ“± App Mobile : Temp=38Â°C, HumiditÃ©=45%, Pression=1010hPa\râš ï¸ ALERTE : Canicule dÃ©tectÃ©e !\rğŸŒ Site Web actualisÃ© : 38Â°C\r=== Site web se dÃ©sabonne ===\rSiteWeb s'est dÃ©sabonnÃ©\rğŸ“¡ Nouvelles mesures reÃ§ues\r=== Notification des observateurs ===\rğŸŒ¡ï¸ ThermomÃ¨tre : -2Â°C\rğŸ“± App Mobile : Temp=-2Â°C, HumiditÃ©=80%, Pression=1020hPa\râš ï¸ ALERTE : Risque de gel ! Avantages du patron Observateur 1. DÃ©couplage (Low Coupling)\n// La station ne connaÃ®t PAS les observateurs concrets // Elle connaÃ®t seulement l'interface IObservateur // On peut ajouter 100 nouveaux observateurs sans modifier la station 2. Ouvert/FermÃ© (Open/Closed Principle)\nOuvert Ã  lâ€™extension : On peut ajouter de nouveaux observateurs FermÃ© Ã  la modification : Pas besoin de modifier le sujet 3. FlexibilitÃ©\n// Abonnement/dÃ©sabonnement dynamique Ã  l'exÃ©cution station.Abonner(nouvelObservateur); station.Desabonner(ancienObservateur); 4. Diffusion un-Ã -plusieurs\n// Une seule mise Ã  jour â†’ Tous les observateurs notifiÃ©s station.SetMesures(25, 60, 1015); // Un appel // â†’ Notifie automatiquement tous les abonnÃ©s Quand utiliser le patron Observateur ? âœ… Utilisez-le quand :\nUn changement dâ€™Ã©tat dans un objet nÃ©cessite de mettre Ã  jour dâ€™autres objets Vous ne savez pas Ã  lâ€™avance combien dâ€™objets doivent Ãªtre notifiÃ©s Vous voulez dÃ©coupler le sujet des observateurs Vous voulez permettre lâ€™ajout/suppression dâ€™observateurs dynamiquement âŒ Nâ€™utilisez pas si :\nIl nâ€™y a quâ€™un seul observateur (pas besoin de ce patron) Les observateurs sont trÃ¨s peu nombreux et fixes (une simple mÃ©thode suffit) Performance critique (chaque notification a un coÃ»t) Variantes du patron Observateur 1. Push vs Pull\nPush (ce quâ€™on a fait) : Le sujet envoie les donnÃ©es\nvoid Actualiser(double temp, double hum, double press) { // Toutes les donnÃ©es sont poussÃ©es } Pull : Lâ€™observateur rÃ©cupÃ¨re ce dont il a besoin\npublic interface IObservateur { void Actualiser(StationMeteo station); } public class ThermometreDigital : IObservateur { public void Actualiser(StationMeteo station) { // Je rÃ©cupÃ¨re seulement ce qui m'intÃ©resse double temp = station.GetTemperature(); Console.WriteLine($\"Temp: {temp}Â°C\"); } } 2. Ã‰vÃ©nements C# (version .NET du patron)\nC# implÃ©mente le patron Observateur avec les Ã©vÃ©nements :\npublic class StationMeteo { // DÃ©finir un Ã©vÃ©nement public event EventHandler\u003cMesuresEventArgs\u003e MesuresChangees; private double temperature; public void SetTemperature(double temp) { temperature = temp; // DÃ©clencher l'Ã©vÃ©nement MesuresChangees?.Invoke(this, new MesuresEventArgs { Temperature = temp }); } } // Classe pour passer les donnÃ©es public class MesuresEventArgs : EventArgs { public double Temperature { get; set; } public double Humidite { get; set; } public double Pression { get; set; } } // Utilisation StationMeteo station = new StationMeteo(); // S'abonner avec += station.MesuresChangees += (sender, e) =\u003e { Console.WriteLine($\"TempÃ©rature : {e.Temperature}Â°C\"); }; // DÃ©clencher station.SetTemperature(25); Partie 2 : Le patron Observateur (INotifyPropertyChanged) Le problÃ¨me Avec le code prÃ©cÃ©dent, si on modifie une propriÃ©tÃ© en C#, lâ€™interface ne se met PAS Ã  jour :\nPersonne p = new Personne { Nom = \"Alice\" }; this.DataContext = p; // Plus tard... p.Nom = \"Bob\"; // L'interface ne change pas ! âŒ Pourquoi ? WPF ne sait pas que Nom a changÃ©.\nLa solution : INotifyPropertyChanged Pour que WPF dÃ©tecte les changements, la classe doit implÃ©menter lâ€™interface INotifyPropertyChanged.\nClasse Personne amÃ©liorÃ©e :\nusing System.ComponentModel; public class Personne : INotifyPropertyChanged { private string nom; private int age; public string Nom { get { return nom; } set { nom = value; OnPropertyChanged(\"Nom\"); // Notifier le changement } } public int Age { get { return age; } set { age = value; OnPropertyChanged(\"Age\"); } } // Ã‰vÃ©nement requis par l'interface public event PropertyChangedEventHandler PropertyChanged; // MÃ©thode pour dÃ©clencher l'Ã©vÃ©nement protected void OnPropertyChanged(string propertyName) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } Maintenant, Ã§a fonctionne :\nPersonne p = new Personne { Nom = \"Alice\" }; this.DataContext = p; // Plus tard... p.Nom = \"Bob\"; // L'interface se met Ã  jour automatiquement ! âœ… Explication dÃ©taillÃ©e Le patron Observateur (Observer Pattern) :\nUn objet (la source) notifie ses observateurs quand son Ã©tat change Les observateurs (ici, les contrÃ´les WPF) Ã©coutent ces notifications Quand notifiÃ©s, ils se mettent Ã  jour Dans notre exemple :\nSource : La classe Personne Observateurs : Les TextBox et TextBlock Notification : PropertyChanged?.Invoke(...) Le ? (opÃ©rateur null-conditional) :\nPropertyChanged?.Invoke(...) = Si PropertyChanged nâ€™est pas null, alors invoke Ã‰vite une exception si personne nâ€™Ã©coute Version moderne avec CallerMemberName Pour Ã©viter dâ€™Ã©crire le nom de la propriÃ©tÃ© en string, on peut utiliser CallerMemberName :\nusing System.ComponentModel; using System.Runtime.CompilerServices; public class Personne : INotifyPropertyChanged { private string nom; private int age; public string Nom { get { return nom; } set { nom = value; OnPropertyChanged(); // Pas besoin de spÃ©cifier \"Nom\" } } public int Age { get { return age; } set { age = value; OnPropertyChanged(); } } public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = \"\") { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } Avantage : Plus sÃ»r (pas de risque de typo dans le nom de propriÃ©tÃ©).\nClasse de base rÃ©utilisable Pour Ã©viter de rÃ©Ã©crire le code dans chaque classe, crÃ©ez une classe de base :\nBaseViewModel.cs :\nusing System.ComponentModel; using System.Runtime.CompilerServices; public class BaseViewModel : INotifyPropertyChanged { public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = \"\") { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } Utilisation :\npublic class Personne : BaseViewModel { private string nom; public string Nom { get { return nom; } set { nom = value; OnPropertyChanged(); } } }",
    "description": "Partie 1 : Le patron Observateur (Contexte gÃ©nÃ©ral) Quâ€™est-ce quâ€™un patron de conception ? DÃ©finition simple : Un patron de conception est une solution Ã©prouvÃ©e Ã  un problÃ¨me rÃ©current en programmation.\nAnalogie : Câ€™est comme une recette de cuisine. Si vous voulez faire un gÃ¢teau, vous nâ€™inventez pas la mÃ©thode Ã  chaque fois â€” vous suivez une recette qui a fait ses preuves.",
    "tags": [],
    "title": "Patron observateur",
    "uri": "/420-413/patron_observateur/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Le patron Commande (Contexte gÃ©nÃ©ral) Le problÃ¨me quâ€™il rÃ©sout Mise en situation : Un Ã©diteur de texte\nVous dÃ©veloppez un Ã©diteur de texte (comme Notepad). Lâ€™utilisateur peut :\nCouper du texte Copier du texte Coller du texte Annuler la derniÃ¨re action Refaire une action annulÃ©e Question : Comment organiser tout Ã§a ?\nâŒ Approche naÃ¯ve (code spaghetti) :\nprivate void btnCouper_Click(object sender, EventArgs e) { // Code pour couper string texteSelectionne = txtEditeur.SelectedText; presse-papiers = texteSelectionne; txtEditeur.SelectedText = \"\"; // Ajouter Ã  l'historique pour annuler historique.Add(new ActionCouper { Texte = texteSelectionne, Position = ... }); } private void btnCopier_Click(object sender, EventArgs e) { // Code pour copier presse-papiers = txtEditeur.SelectedText; // Ajouter Ã  l'historique historique.Add(new ActionCopier { Texte = ... }); } private void btnColler_Click(object sender, EventArgs e) { // Code pour coller txtEditeur.SelectedText = presse-papiers; // Ajouter Ã  l'historique historique.Add(new ActionColler { Texte = presse-papiers, Position = ... }); } private void btnAnnuler_Click(object sender, EventArgs e) { var derniere = historique.Last(); // ğŸ˜± Comment annuler selon le type d'action ? if (derniere is ActionCouper) { // Code pour dÃ©faire une coupe } else if (derniere is ActionCopier) { // Code pour dÃ©faire une copie } else if (derniere is ActionColler) { // Code pour dÃ©faire un collage } // ... et ainsi de suite pour chaque type d'action ! } ProblÃ¨mes :\nCode dupliquÃ© : La logique dâ€™annulation est Ã©parpillÃ©e partout Difficile Ã  tester : Impossible de tester une action sans lâ€™interface Pas rÃ©utilisable : Si on ajoute un raccourci clavier, il faut dupliquer le code Couplage fort : Les boutons sont directement couplÃ©s Ã  la logique mÃ©tier Difficile Ã  Ã©tendre : Ajouter une nouvelle action nÃ©cessite de modifier plein dâ€™endroits Le patron Commande â€” La solution Principe central : Encapsuler une action dans un objet.\nAnalogie : Pensez Ã  une tÃ©lÃ©commande TV :\nChaque bouton est une commande (Volume+, Volume-, Chaine+, etc.) La tÃ©lÃ©commande ne sait pas comment augmenter le volume Elle envoie juste la commande â€œVolume+â€ Ã  la TV La TV exÃ©cute la commande On peut enregistrer les commandes (macro) On peut annuler des commandes Diagramme conceptuel :\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ INTERFACE COMMANDE â”‚\râ”‚ + Executer() â”‚\râ”‚ + Annuler() â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\râ–³\râ”‚ implÃ©mente\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ â”‚ â”‚\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚Commande â”‚ â”‚Commande â”‚ â”‚Commande â”‚\râ”‚Couper â”‚ â”‚Copier â”‚ â”‚Coller â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ INVOCATEUR â”‚\râ”‚ (Bouton, raccourci) â”‚\râ”‚ - commande: ICommande â”‚\râ”‚ + AppuiSurBouton() â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\râ”‚\râ”‚ utilise\râ†“\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ RÃ‰CEPTEUR â”‚\râ”‚ (EditeurTexte) â”‚\râ”‚ + Couper() â”‚\râ”‚ + Copier() â”‚\râ”‚ + Coller() â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ImplÃ©mentation complÃ¨te Ã‰tape 1 : Interface Commande\npublic interface ICommande { void Executer(); void Annuler(); } Ã‰tape 2 : Le RÃ©cepteur (celui qui fait le vrai travail)\npublic class EditeurTexte { private StringBuilder contenu = new StringBuilder(); private string presse_papiers = \"\"; public string Contenu =\u003e contenu.ToString(); public void Couper(int debut, int longueur) { presse_papiers = contenu.ToString(debut, longueur); contenu.Remove(debut, longueur); Console.WriteLine($\"âœ‚ï¸ Texte coupÃ© : '{presse_papiers}'\"); } public void Copier(int debut, int longueur) { presse_papiers = contenu.ToString(debut, longueur); Console.WriteLine($\"ğŸ“‹ Texte copiÃ© : '{presse_papiers}'\"); } public void Coller(int position) { contenu.Insert(position, presse_papiers); Console.WriteLine($\"ğŸ“Œ Texte collÃ© : '{presse_papiers}' Ã  la position {position}\"); } public void AjouterTexte(string texte) { contenu.Append(texte); } public void Afficher() { Console.WriteLine($\"ğŸ“„ Contenu : '{Contenu}'\"); } } Ã‰tape 3 : Les Commandes concrÃ¨tes\n// Commande Couper public class CommandeCouper : ICommande { private EditeurTexte editeur; private int debut; private int longueur; private string texteCoupe; // Pour pouvoir annuler public CommandeCouper(EditeurTexte editeur, int debut, int longueur) { this.editeur = editeur; this.debut = debut; this.longueur = longueur; } public void Executer() { texteCoupe = editeur.Contenu.Substring(debut, longueur); editeur.Couper(debut, longueur); } public void Annuler() { // Restaurer le texte coupÃ© editeur.AjouterTexte(texteCoupe); Console.WriteLine($\"â†©ï¸ Annulation : texte '{texteCoupe}' restaurÃ©\"); } } // Commande Copier public class CommandeCopier : ICommande { private EditeurTexte editeur; private int debut; private int longueur; public CommandeCopier(EditeurTexte editeur, int debut, int longueur) { this.editeur = editeur; this.debut = debut; this.longueur = longueur; } public void Executer() { editeur.Copier(debut, longueur); } public void Annuler() { // Copier ne modifie pas le texte, donc pas besoin d'annuler Console.WriteLine(\"â†©ï¸ Copier annulÃ© (aucun changement au texte)\"); } } // Commande Coller public class CommandeColler : ICommande { private EditeurTexte editeur; private int position; private int longueurCollee; public CommandeColler(EditeurTexte editeur, int position) { this.editeur = editeur; this.position = position; } public void Executer() { // On suppose qu'on connaÃ®t la longueur du presse-papiers editeur.Coller(position); } public void Annuler() { // Retirer le texte collÃ© Console.WriteLine($\"â†©ï¸ Annulation du collage\"); } } Ã‰tape 4 : Lâ€™Invocateur (gestionnaire de commandes)\npublic class GestionnaireCommandes { private Stack\u003cICommande\u003e historique = new Stack\u003cICommande\u003e(); private Stack\u003cICommande\u003e historiqueAnnule = new Stack\u003cICommande\u003e(); public void ExecuterCommande(ICommande commande) { commande.Executer(); historique.Push(commande); // Vider l'historique d'annulation (comme dans Word) historiqueAnnule.Clear(); } public void Annuler() { if (historique.Count == 0) { Console.WriteLine(\"âŒ Rien Ã  annuler\"); return; } ICommande commande = historique.Pop(); commande.Annuler(); historiqueAnnule.Push(commande); } public void Refaire() { if (historiqueAnnule.Count == 0) { Console.WriteLine(\"âŒ Rien Ã  refaire\"); return; } ICommande commande = historiqueAnnule.Pop(); commande.Executer(); historique.Push(commande); } } Ã‰tape 5 : Utilisation\nclass Program { static void Main(string[] args) { // CrÃ©er l'Ã©diteur et le gestionnaire EditeurTexte editeur = new EditeurTexte(); GestionnaireCommandes gestionnaire = new GestionnaireCommandes(); // Ajouter du texte initial Console.WriteLine(\"=== Initialisation ===\"); editeur.AjouterTexte(\"Bonjour le monde!\"); editeur.Afficher(); // CrÃ©er et exÃ©cuter des commandes Console.WriteLine(\"\\n=== Copier 'Bonjour' ===\"); ICommande copier = new CommandeCopier(editeur, 0, 7); gestionnaire.ExecuterCommande(copier); Console.WriteLine(\"\\n=== Coller Ã  la fin ===\"); ICommande coller = new CommandeColler(editeur, editeur.Contenu.Length); gestionnaire.ExecuterCommande(coller); editeur.Afficher(); Console.WriteLine(\"\\n=== Couper ' le monde' ===\"); ICommande couper = new CommandeCouper(editeur, 7, 9); gestionnaire.ExecuterCommande(couper); editeur.Afficher(); Console.WriteLine(\"\\n=== Annuler la derniÃ¨re action ===\"); gestionnaire.Annuler(); editeur.Afficher(); Console.WriteLine(\"\\n=== Refaire ===\"); gestionnaire.Refaire(); editeur.Afficher(); } } Avantages du patron Commande 1. DÃ©couplage\n// Le bouton ne connaÃ®t PAS l'Ã©diteur // Il connaÃ®t seulement l'interface ICommande Button btnCouper = new Button(); btnCouper.Command = new CommandeCouper(editeur, 0, 5); 2. Historique automatique\n// Toutes les commandes sont automatiquement historisÃ©es // Annuler/Refaire gratuit ! 3. TestabilitÃ©\n[TestMethod] public void Test_CommandeCouper() { EditeurTexte editeur = new EditeurTexte(); editeur.AjouterTexte(\"Test\"); CommandeCouper cmd = new CommandeCouper(editeur, 0, 2); cmd.Executer(); Assert.AreEqual(\"st\", editeur.Contenu); } 4. RÃ©utilisabilitÃ©\n// MÃªme commande utilisable de plusieurs faÃ§ons ICommande couper = new CommandeCouper(editeur, 0, 5); // Via un bouton button.Command = couper; // Via un raccourci clavier if (e.Key == Key.X \u0026\u0026 e.Control) gestionnaire.ExecuterCommande(couper); // Via un menu menuItem.Command = couper; 5. Macros et scripts\n// On peut crÃ©er des sÃ©quences de commandes List\u003cICommande\u003e macro = new List\u003cICommande\u003e { new CommandeCopier(editeur, 0, 5), new CommandeColler(editeur, 10), new CommandeCouper(editeur, 0, 5) }; // ExÃ©cuter la macro foreach (var cmd in macro) gestionnaire.ExecuterCommande(cmd); Variantes du patron Commande 1. Commandes paramÃ©trÃ©es\npublic interface ICommande\u003cT\u003e { void Executer(T parametre); void Annuler(); } public class CommandeRechercher : ICommande\u003cstring\u003e { public void Executer(string motCle) { // Rechercher le mot-clÃ© } public void Annuler() { // Annuler la recherche } } 2. Commandes asynchrones\npublic interface ICommandeAsync { Task ExecuterAsync(); Task AnnulerAsync(); } public class CommandeSauvegarder : ICommandeAsync { public async Task ExecuterAsync() { await SauvegarderDansFichierAsync(); } public async Task AnnulerAsync() { await RestaurerVersionPrecedenteAsync(); } } Le lien avec WPF ICommand (aperÃ§u) WPF utilise le patron Commande !\n// ICommand dans WPF public interface ICommand { bool CanExecute(object parameter); // Peut-on exÃ©cuter ? void Execute(object parameter); // ExÃ©cuter event EventHandler CanExecuteChanged; // Notifier changement d'Ã©tat } DiffÃ©rences avec notre version :\nWPF nâ€™a pas de mÃ©thode Annuler() (on peut lâ€™ajouter) WPF a CanExecute() pour activer/dÃ©sactiver les boutons WPF a un Ã©vÃ©nement pour notifier les changements dâ€™Ã©tat Utilisation en WPF :\n\u003cButton Content=\"Sauvegarder\" Command=\"{Binding SauvegarderCommand}\" /\u003e Quand le bouton est cliquÃ© :\nWPF vÃ©rifie CanExecute() â†’ Active/dÃ©sactive le bouton WPF appelle Execute() â†’ ExÃ©cute lâ€™action Câ€™est exactement le patron Commande appliquÃ© Ã  WPF !",
    "description": "Le patron Commande (Contexte gÃ©nÃ©ral) Le problÃ¨me quâ€™il rÃ©sout Mise en situation : Un Ã©diteur de texte\nVous dÃ©veloppez un Ã©diteur de texte (comme Notepad). Lâ€™utilisateur peut :\nCouper du texte Copier du texte Coller du texte Annuler la derniÃ¨re action Refaire une action annulÃ©e Question : Comment organiser tout Ã§a ?",
    "tags": [],
    "title": "Patron commande",
    "uri": "/420-413/patron_commande/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": ": Injection de dÃ©pendances (Contexte gÃ©nÃ©ral) Le problÃ¨me des dÃ©pendances Mise en situation : Un systÃ¨me de notification\nVous dÃ©veloppez une application qui doit envoyer des notifications :\nPar email Par SMS Par notification push âŒ Approche naÃ¯ve (dÃ©pendances cÃ¢blÃ©es en dur) :\npublic class ServiceUtilisateur { private EmailService emailService; private SMSService smsService; public ServiceUtilisateur() { // CrÃ©er les dÃ©pendances directement emailService = new EmailService(); smsService = new SMSService(); } public void EnregistrerUtilisateur(string nom, string email, string telephone) { // Logique d'enregistrement Console.WriteLine($\"Utilisateur {nom} enregistrÃ©\"); // Envoyer notifications emailService.Envoyer(email, \"Bienvenue !\"); smsService.Envoyer(telephone, \"Compte crÃ©Ã©\"); } } ProblÃ¨mes de cette approche :\nCouplage fort // ServiceUtilisateur DÃ‰PEND DIRECTEMENT de EmailService et SMSService // Si EmailService change, ServiceUtilisateur doit changer aussi Difficile Ã  tester // Pour tester ServiceUtilisateur, je DOIS avoir un serveur email fonctionnel // Les emails seront vraiment envoyÃ©s pendant les tests ! Pas flexible // Et si je veux utiliser un autre service email ? // Je dois modifier ServiceUtilisateur Pas rÃ©utilisable // ServiceUtilisateur est liÃ© Ã  des implÃ©mentations spÃ©cifiques // Impossible de le rÃ©utiliser avec d'autres services Le principe dâ€™inversion de dÃ©pendance (DIP) Principe fondamental : DÃ©pendre dâ€™abstractions, pas de concrÃ©tions.\nAnalogie : Les prises Ã©lectriques\nTous vos appareils utilisent une prise standard (abstraction) Vous ne cÃ¢blez pas directement les appareils Ã  lâ€™alimentation Ã©lectrique Vous pouvez brancher nâ€™importe quel appareil (machine Ã  cafÃ©, ordinateur, lampe) Lâ€™appareil ne sait pas dâ€™oÃ¹ vient lâ€™Ã©lectricitÃ© (centrale nuclÃ©aire, solaire, etc.) Diagramme :\nâŒ AVANT (dÃ©pendance directe)\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ ServiceUtilisateurâ”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\râ”‚\râ”‚ dÃ©pend de\râ†“\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ EmailService â”‚ â† Classe concrÃ¨te\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\râœ… APRÃˆS (inversion de dÃ©pendance)\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ ServiceUtilisateurâ”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\râ”‚\râ”‚ dÃ©pend de\râ†“\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ INotification â”‚ â† Interface (abstraction)\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\râ–³\râ”‚ implÃ©mente\râ”Œâ”€â”€â”€â”´â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚Email â”‚ â”‚ â”‚SMS â”‚\râ”‚Service â”‚ â”‚ â”‚Service â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜\râ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚Push â”‚\râ”‚Service â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ImplÃ©mentation complÃ¨te Ã‰tape 1 : DÃ©finir lâ€™abstraction (interface)\npublic interface INotificationService { void Envoyer(string destinataire, string message); } Ã‰tape 2 : CrÃ©er les implÃ©mentations concrÃ¨tes\n// Service Email public class EmailService : INotificationService { public void Envoyer(string destinataire, string message) { Console.WriteLine($\"ğŸ“§ Email envoyÃ© Ã  {destinataire}: {message}\"); // Code rÃ©el pour envoyer un email } } // Service SMS public class SMSService : INotificationService { public void Envoyer(string destinataire, string message) { Console.WriteLine($\"ğŸ“± SMS envoyÃ© Ã  {destinataire}: {message}\"); // Code rÃ©el pour envoyer un SMS } } // Service Push public class PushNotificationService : INotificationService { public void Envoyer(string destinataire, string message) { Console.WriteLine($\"ğŸ”” Notification push Ã  {destinataire}: {message}\"); // Code rÃ©el pour envoyer une notification push } } // Faux service pour les tests public class FakeNotificationService : INotificationService { public List\u003cstring\u003e MessagesEnvoyes = new List\u003cstring\u003e(); public void Envoyer(string destinataire, string message) { MessagesEnvoyes.Add($\"{destinataire}: {message}\"); Console.WriteLine($\"ğŸ§ª [TEST] Message enregistrÃ© (non envoyÃ©)\"); } } Ã‰tape 3 : Injection de dÃ©pendances\nIl existe 3 types dâ€™injection :\nType 1 : Injection par constructeur (recommandÃ©e)\npublic class ServiceUtilisateur { private readonly INotificationService notificationService; // La dÃ©pendance est INJECTÃ‰E via le constructeur public ServiceUtilisateur(INotificationService notificationService) { this.notificationService = notificationService; } public void EnregistrerUtilisateur(string nom, string contact) { Console.WriteLine($\"âœ“ Utilisateur {nom} enregistrÃ©\"); notificationService.Envoyer(contact, \"Bienvenue !\"); } } Utilisation :\n// En production : Email INotificationService emailService = new EmailService(); ServiceUtilisateur service = new ServiceUtilisateur(emailService); service.EnregistrerUtilisateur(\"Alice\", \"alice@email.com\"); // En test : Fake INotificationService fakeService = new FakeNotificationService(); ServiceUtilisateur serviceTest = new ServiceUtilisateur(fakeService); serviceTest.EnregistrerUtilisateur(\"Bob\", \"bob@test.com\"); Type 2 : Injection par propriÃ©tÃ©\npublic class ServiceUtilisateur { // PropriÃ©tÃ© publique public INotificationService NotificationService { get; set; } public void EnregistrerUtilisateur(string nom, string contact) { Console.WriteLine($\"âœ“ Utilisateur {nom} enregistrÃ©\"); NotificationService.Envoyer(contact, \"Bienvenue !\"); } } Utilisation :\nServiceUtilisateur service = new ServiceUtilisateur(); service.NotificationService = new EmailService(); // Injection service.EnregistrerUtilisateur(\"Alice\", \"alice@email.com\"); Type 3 : Injection par mÃ©thode\npublic class ServiceUtilisateur { public void EnregistrerUtilisateur(string nom, string contact, INotificationService notificationService) { Console.WriteLine($\"âœ“ Utilisateur {nom} enregistrÃ©\"); notificationService.Envoyer(contact, \"Bienvenue !\"); } } Utilisation :\nServiceUtilisateur service = new ServiceUtilisateur(); service.EnregistrerUtilisateur(\"Alice\", \"alice@email.com\", new EmailService()); Comparaison des types dâ€™injection Type Avantages InconvÃ©nients Quand utiliser Constructeur - DÃ©pendances obligatoires\n- ImmutabilitÃ© (readonly)\n- DÃ©pendances claires - Constructeur peut devenir long Par dÃ©faut (99% des cas) PropriÃ©tÃ© - DÃ©pendances optionnelles\n- Flexible - Risque dâ€™oubli\n- Mutable DÃ©pendances optionnelles MÃ©thode - DÃ©pendance ponctuelle - RÃ©pÃ©titif\n- Pas de contrÃ´le DÃ©pendance change souvent Conteneur dâ€™injection de dÃ©pendances (IoC Container) ProblÃ¨me : CrÃ©er toutes les dÃ©pendances manuellement devient fastidieux.\nSolution : Un conteneur IoC (Inversion of Control) gÃ¨re la crÃ©ation des objets.\nExemple avec Microsoft.Extensions.DependencyInjection :\nusing Microsoft.Extensions.DependencyInjection; class Program { static void Main(string[] args) { // 1. CrÃ©er le conteneur var services = new ServiceCollection(); // 2. Enregistrer les dÃ©pendances services.AddTransient\u003cINotificationService, EmailService\u003e(); services.AddTransient\u003cServiceUtilisateur\u003e(); // 3. Construire le provider var serviceProvider = services.BuildServiceProvider(); // 4. RÃ©soudre automatiquement les dÃ©pendances var service = serviceProvider.GetService\u003cServiceUtilisateur\u003e(); // â†‘ Le conteneur crÃ©e automatiquement EmailService et l'injecte // 5. Utiliser service.EnregistrerUtilisateur(\"Alice\", \"alice@email.com\"); } } DurÃ©es de vie :\n// Transient : Nouvelle instance Ã  chaque demande services.AddTransient\u003cINotificationService, EmailService\u003e(); // Scoped : Une instance par \"scope\" (requÃªte web par exemple) services.AddScoped\u003cINotificationService, EmailService\u003e(); // Singleton : UNE SEULE instance pour toute l'application services.AddSingleton\u003cINotificationService, EmailService\u003e(); Avantages de lâ€™injection de dÃ©pendances 1. TestabilitÃ©\n[TestMethod] public void Test_EnregistrerUtilisateur() { // Utiliser un faux service var fakeService = new FakeNotificationService(); var service = new ServiceUtilisateur(fakeService); service.EnregistrerUtilisateur(\"Bob\", \"bob@test.com\"); // VÃ©rifier qu'un message a Ã©tÃ© \"envoyÃ©\" Assert.AreEqual(1, fakeService.MessagesEnvoyes.Count); Assert.IsTrue(fakeService.MessagesEnvoyes[0].Contains(\"Bienvenue\")); } 2. FlexibilitÃ©\n// Basculer facilement entre implÃ©mentations // En production services.AddTransient\u003cINotificationService, EmailService\u003e(); // En dÃ©veloppement services.AddTransient\u003cINotificationService, FakeNotificationService\u003e(); // Pas besoin de changer ServiceUtilisateur ! 3. DÃ©couplage\n// ServiceUtilisateur ne sait PAS quelle implÃ©mentation il utilise // Il dÃ©pend seulement de l'interface INotificationService 4. MaintenabilitÃ©\n// Ajouter une nouvelle implÃ©mentation ne nÃ©cessite PAS de modifier les classes existantes public class SlackService : INotificationService { ... } // Juste changer l'enregistrement services.AddTransient\u003cINotificationService, SlackService\u003e(); Le lien avec MVVM (aperÃ§u) En MVVM, on injecte souvent des services dans les ViewModels :\npublic class ProduitViewModel { private readonly IProduitRepository repository; private readonly INotificationService notificationService; // Injection par constructeur public ProduitViewModel(IProduitRepository repository, INotificationService notificationService) { this.repository = repository; this.notificationService = notificationService; } public void AjouterProduit(Produit produit) { repository.Ajouter(produit); notificationService.Envoyer(\"admin@app.com\", \"Nouveau produit ajoutÃ©\"); } } Avantages en MVVM :\nâœ… ViewModel testable sans interface graphique âœ… RÃ©utilisable avec diffÃ©rents services âœ… DÃ©couplÃ© de lâ€™implÃ©mentation des services",
    "description": ": Injection de dÃ©pendances (Contexte gÃ©nÃ©ral) Le problÃ¨me des dÃ©pendances Mise en situation : Un systÃ¨me de notification\nVous dÃ©veloppez une application qui doit envoyer des notifications :\nPar email Par SMS Par notification push âŒ Approche naÃ¯ve (dÃ©pendances cÃ¢blÃ©es en dur) :",
    "tags": [],
    "title": "Injection de dÃ©pendance",
    "uri": "/420-413/injection_dependance/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Le patron MVVM (Model-View-ViewModel) Quâ€™est-ce que MVVM ? MVVM = Model-View-ViewModel\nCâ€™est un patron de conception (design pattern) qui organise le code dâ€™une application WPF en 3 couches :\nCouche ResponsabilitÃ© Fichier Model Les donnÃ©es brutes (classes mÃ©tier) Personne.cs, Produit.cs View Lâ€™interface graphique (XAML) MainWindow.xaml ViewModel Logique de prÃ©sentation, data binding MainViewModel.cs Pourquoi MVVM ? ProblÃ¨me avec le code-behind (approche traditionnelle) :\n// MainWindow.xaml.cs public partial class MainWindow : Window { private void Button_Click(object sender, RoutedEventArgs e) { // Logique mÃ©tier mÃ©langÃ©e avec l'UI string nom = txtNom.Text; double prix = double.Parse(txtPrix.Text); // Calculs... // AccÃ¨s base de donnÃ©es... // Mise Ã  jour de l'interface... } } ProblÃ¨mes :\nLogique mÃ©langÃ©e avec lâ€™interface Difficile Ã  tester Difficile Ã  rÃ©utiliser Code-behind devient Ã©norme Avec MVVM :\nâœ… SÃ©paration claire des responsabilitÃ©s âœ… Code testable (ViewModel peut Ãªtre testÃ© sans UI) âœ… RÃ©utilisable âœ… Code-behind quasi vide Architecture MVVM View (XAML)\râ†• Data Binding\rViewModel (Logique de prÃ©sentation)\râ†• Model (DonnÃ©es) RÃ¨gles :\nLa View ne contient QUE du XAML (et un code-behind minimal) Le ViewModel ne connaÃ®t PAS la View (pas de MessageBox, pas de txtNom.Text) Le Model ne connaÃ®t ni View ni ViewModel Exemple complet MVVM : Gestion de produits Ã‰tape 1 : Le Model Produit.cs\npublic class Produit { public int Id { get; set; } public string Nom { get; set; } public double Prix { get; set; } public int Stock { get; set; } } Câ€™est juste une classe de donnÃ©es, rien de spÃ©cial.\nÃ‰tape 2 : Le ViewModel ProduitViewModel.cs\nusing System.Collections.ObjectModel; using System.ComponentModel; using System.Runtime.CompilerServices; public class ProduitViewModel : INotifyPropertyChanged { // Collection observable pour la liste public ObservableCollection\u003cProduit\u003e Produits { get; set; } // Produit sÃ©lectionnÃ© dans la liste private Produit produitSelectionne; public Produit ProduitSelectionne { get { return produitSelectionne; } set { produitSelectionne = value; OnPropertyChanged(); } } // Champs pour le nouveau produit private string nouveauNom; public string NouveauNom { get { return nouveauNom; } set { nouveauNom = value; OnPropertyChanged(); } } private double nouveauPrix; public double NouveauPrix { get { return nouveauPrix; } set { nouveauPrix = value; OnPropertyChanged(); } } private int nouveauStock; public int NouveauStock { get { return nouveauStock; } set { nouveauStock = value; OnPropertyChanged(); } } // Constructeur public ProduitViewModel() { Produits = new ObservableCollection\u003cProduit\u003e { new Produit { Id = 1, Nom = \"Clavier\", Prix = 49.99, Stock = 15 }, new Produit { Id = 2, Nom = \"Souris\", Prix = 29.99, Stock = 25 }, new Produit { Id = 3, Nom = \"Ã‰cran\", Prix = 299.99, Stock = 8 } }; } // MÃ©thodes publiques (appelÃ©es par les boutons via Commands) public void AjouterProduit() { var nouveau = new Produit { Id = Produits.Count + 1, Nom = NouveauNom, Prix = NouveauPrix, Stock = NouveauStock }; Produits.Add(nouveau); // RÃ©initialiser les champs NouveauNom = \"\"; NouveauPrix = 0; NouveauStock = 0; } public void SupprimerProduit() { if (ProduitSelectionne != null) { Produits.Remove(ProduitSelectionne); } } // INotifyPropertyChanged public event PropertyChangedEventHandler PropertyChanged; protected void OnPropertyChanged([CallerMemberName] string propertyName = \"\") { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName)); } } Ã‰tape 3 : La View MainWindow.xaml\n\u003cWindow x:Class=\"GestionProduits.MainWindow\" xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\" xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\" Title=\"Gestion de Produits - MVVM\" Height=\"500\" Width=\"700\"\u003e \u003cGrid Margin=\"15\"\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"50\" /\u003e \u003cRowDefinition Height=\"*\" /\u003e \u003c/Grid.RowDefinitions\u003e \u003c!-- Titre --\u003e \u003cTextBlock Grid.Row=\"0\" Text=\"ğŸ“¦ Gestion de Produits\" FontSize=\"24\" FontWeight=\"Bold\" VerticalAlignment=\"Center\" /\u003e \u003c!-- Contenu --\u003e \u003cGrid Grid.Row=\"1\" Margin=\"0,10,0,0\"\u003e \u003cGrid.ColumnDefinitions\u003e \u003cColumnDefinition Width=\"2*\" /\u003e \u003cColumnDefinition Width=\"*\" /\u003e \u003c/Grid.ColumnDefinitions\u003e \u003c!-- Liste des produits (gauche) --\u003e \u003cDataGrid Grid.Column=\"0\" ItemsSource=\"{Binding Produits}\" SelectedItem=\"{Binding ProduitSelectionne}\" AutoGenerateColumns=\"False\" Margin=\"0,0,10,0\"\u003e \u003cDataGrid.Columns\u003e \u003cDataGridTextColumn Header=\"ID\" Binding=\"{Binding Id}\" Width=\"50\" /\u003e \u003cDataGridTextColumn Header=\"Nom\" Binding=\"{Binding Nom}\" Width=\"*\" /\u003e \u003cDataGridTextColumn Header=\"Prix\" Binding=\"{Binding Prix, StringFormat={}{0:C}}\" Width=\"100\" /\u003e \u003cDataGridTextColumn Header=\"Stock\" Binding=\"{Binding Stock}\" Width=\"80\" /\u003e \u003c/DataGrid.Columns\u003e \u003c/DataGrid\u003e \u003c!-- Panneau de contrÃ´le (droite) --\u003e \u003cBorder Grid.Column=\"1\" BorderBrush=\"LightGray\" BorderThickness=\"1\" Padding=\"10\"\u003e \u003cStackPanel\u003e \u003cTextBlock Text=\"Ajouter un produit\" FontWeight=\"Bold\" FontSize=\"16\" Margin=\"0,0,0,15\" /\u003e \u003cLabel Content=\"Nom :\" /\u003e \u003cTextBox Text=\"{Binding NouveauNom}\" Height=\"30\" Margin=\"0,0,0,10\" /\u003e \u003cLabel Content=\"Prix :\" /\u003e \u003cTextBox Text=\"{Binding NouveauPrix}\" Height=\"30\" Margin=\"0,0,0,10\" /\u003e \u003cLabel Content=\"Stock :\" /\u003e \u003cTextBox Text=\"{Binding NouveauStock}\" Height=\"30\" Margin=\"0,0,0,20\" /\u003e \u003cButton Content=\"Ajouter\" Height=\"40\" Background=\"Green\" Foreground=\"White\" Click=\"BtnAjouter_Click\" Margin=\"0,0,0,10\" /\u003e \u003cButton Content=\"Supprimer\" Height=\"40\" Background=\"Red\" Foreground=\"White\" Click=\"BtnSupprimer_Click\" /\u003e \u003c/StackPanel\u003e \u003c/Border\u003e \u003c/Grid\u003e \u003c/Grid\u003e \u003c/Window\u003e Ã‰tape 4 : Code-behind (minimal) MainWindow.xaml.cs\nusing System.Windows; namespace GestionProduits { public partial class MainWindow : Window { private ProduitViewModel viewModel; public MainWindow() { InitializeComponent(); // CrÃ©er et assigner le ViewModel viewModel = new ProduitViewModel(); this.DataContext = viewModel; } private void BtnAjouter_Click(object sender, RoutedEventArgs e) { viewModel.AjouterProduit(); } private void BtnSupprimer_Click(object sender, RoutedEventArgs e) { viewModel.SupprimerProduit(); } } } ObservableCollection vs List Pourquoi ObservableCollection et pas List ?\n// âŒ Avec List - l'interface ne se met pas Ã  jour public List\u003cProduit\u003e Produits { get; set; } // âœ… Avec ObservableCollection - l'interface se met Ã  jour automatiquement public ObservableCollection\u003cProduit\u003e Produits { get; set; } ObservableCollection\u003cT\u003e implÃ©mente automatiquement INotifyCollectionChanged :\nQuand on ajoute un Ã©lÃ©ment : lâ€™interface se met Ã  jour Quand on supprime un Ã©lÃ©ment : lâ€™interface se met Ã  jour Commands (amÃ©lioration avancÃ©e) Dans un MVVM pur, on ne devrait pas avoir de Click=\"...\" dans le XAML. Ã€ la place, on utilise des Commands.\nRelayCommand.cs (classe utilitaire) :\nusing System; using System.Windows.Input; public class RelayCommand : ICommand { private Action execute; private Func\u003cbool\u003e canExecute; public RelayCommand(Action execute, Func\u003cbool\u003e canExecute = null) { this.execute = execute; this.canExecute = canExecute; } public event EventHandler CanExecuteChanged { add { CommandManager.RequerySuggested += value; } remove { CommandManager.RequerySuggested -= value; } } public bool CanExecute(object parameter) { return canExecute == null || canExecute(); } public void Execute(object parameter) { execute(); } } ProduitViewModel avec Commands :\npublic class ProduitViewModel : INotifyPropertyChanged { // ... propriÃ©tÃ©s ... public ICommand AjouterCommand { get; } public ICommand SupprimerCommand { get; } public ProduitViewModel() { // ... initialisation ... AjouterCommand = new RelayCommand(AjouterProduit); SupprimerCommand = new RelayCommand(SupprimerProduit, () =\u003e ProduitSelectionne != null); } // ... mÃ©thodes ... } XAML avec Commands :\n\u003cButton Content=\"Ajouter\" Command=\"{Binding AjouterCommand}\" /\u003e \u003cButton Content=\"Supprimer\" Command=\"{Binding SupprimerCommand}\" /\u003e Avantage : Aucun code-behind nÃ©cessaire !",
    "description": "Le patron MVVM (Model-View-ViewModel) Quâ€™est-ce que MVVM ? MVVM = Model-View-ViewModel\nCâ€™est un patron de conception (design pattern) qui organise le code dâ€™une application WPF en 3 couches :\nCouche ResponsabilitÃ© Fichier Model Les donnÃ©es brutes (classes mÃ©tier) Personne.cs, Produit.cs View Lâ€™interface graphique (XAML) MainWindow.xaml ViewModel Logique de prÃ©sentation, data binding MainViewModel.cs Pourquoi MVVM ? ProblÃ¨me avec le code-behind (approche traditionnelle) :",
    "tags": [],
    "title": "MVVM",
    "uri": "/420-413/mvvm/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Mini-projets progressifs Mini-projet 1 : Calculatrice avec historique Niveau : â­â­ IntermÃ©diaire\nObjectifs pÃ©dagogiques Patron Commande (annuler/refaire) INotifyPropertyChanged Data Binding de base SpÃ©cifications FonctionnalitÃ©s :\nOpÃ©rations : Addition, Soustraction, Multiplication, Division Historique des calculs Annuler/Refaire les opÃ©rations Effacer lâ€™historique Interface :\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ CALCULATRICE â”‚\râ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\râ”‚ RÃ©sultat: [0] â”‚\râ”‚ â”‚\râ”‚ [7] [8] [9] [Ã·] â”‚\râ”‚ [4] [5] [6] [Ã—] â”‚\râ”‚ [1] [2] [3] [-] â”‚\râ”‚ [0] [.] [=] [+] â”‚\râ”‚ â”‚\râ”‚ [â†© Annuler] [â†ª Refaire] [C] â”‚\râ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\râ”‚ HISTORIQUE â”‚\râ”‚ - 5 + 3 = 8 â”‚\râ”‚ - 8 Ã— 2 = 16 â”‚\râ”‚ - 16 Ã· 4 = 4 â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Structure du projet // Models/Operation.cs public class Operation { public double Operande1 { get; set; } public double Operande2 { get; set; } public string Operateur { get; set; } public double Resultat { get; set; } public override string ToString() { return $\"{Operande1} {Operateur} {Operande2} = {Resultat}\"; } } // Commands/ICommande.cs public interface ICommande { void Executer(); void Annuler(); } // Commands/CommandeCalculer.cs public class CommandeCalculer : ICommande { private CalculatriceViewModel viewModel; private Operation operation; private double resultatPrecedent; public CommandeCalculer(CalculatriceViewModel vm, Operation op) { viewModel = vm; operation = op; resultatPrecedent = vm.Resultat; } public void Executer() { // Calculer selon l'opÃ©rateur switch (operation.Operateur) { case \"+\": operation.Resultat = operation.Operande1 + operation.Operande2; break; // ... autres opÃ©rations } viewModel.Resultat = operation.Resultat; viewModel.Historique.Add(operation); } public void Annuler() { viewModel.Resultat = resultatPrecedent; viewModel.Historique.Remove(operation); } } // ViewModels/CalculatriceViewModel.cs public class CalculatriceViewModel : BaseViewModel { private double resultat; public double Resultat { get =\u003e resultat; set =\u003e SetProperty(ref resultat, value); } public ObservableCollection\u003cOperation\u003e Historique { get; set; } private Stack\u003cICommande\u003e historiqueCommandes = new Stack\u003cICommande\u003e(); private Stack\u003cICommande\u003e commandesAnnulees = new Stack\u003cICommande\u003e(); public ICommand CalculerCommand { get; } public ICommand AnnulerCommand { get; } public ICommand RefaireCommand { get; } // ... implÃ©mentation } CritÃ¨res de rÃ©ussite Les 4 opÃ©rations fonctionnent correctement Lâ€™historique se met Ã  jour automatiquement Annuler restaure le rÃ©sultat prÃ©cÃ©dent Refaire rÃ©applique lâ€™opÃ©ration annulÃ©e Gestion des erreurs (division par zÃ©ro) Mini-projet 2 : Gestionnaire de tÃ¢ches avec prioritÃ©s Niveau : â­â­â­ IntermÃ©diaire-AvancÃ©\nObjectifs pÃ©dagogiques MVVM complet ObservableCollection Filtrage et tri Sauvegarde/chargement (JSON) SpÃ©cifications FonctionnalitÃ©s :\nAjouter/modifier/supprimer des tÃ¢ches Marquer comme terminÃ© Assigner des prioritÃ©s (Haute, Moyenne, Basse) Filtrer par statut et prioritÃ© Trier par date, prioritÃ©, ou titre Recherche par mots-clÃ©s Statistiques (nombre de tÃ¢ches par statut/prioritÃ©) Sauvegarder/charger depuis un fichier Interface :\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\râ”‚ GESTIONNAIRE DE TÃ‚CHES â”‚\râ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\râ”‚ [ğŸ” Rechercher...] [Filtre: Tous â–¼] [Tri: Date â–¼]â”‚\râ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\râ”‚ â˜ Terminer le rapport [ğŸ”´ Haute] 2024-02-20 â”‚\râ”‚ â˜‘ RÃ©pondre aux emails [ğŸŸ¡ Moyenne] 2024-02-19 â”‚\râ”‚ â˜ RÃ©viser pour l'examen [ğŸ”´ Haute] 2024-02-25 â”‚\râ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\râ”‚ Nouvelle tÃ¢che: â”‚\râ”‚ Titre: [____________________] â”‚\râ”‚ PrioritÃ©: [Moyenne â–¼] â”‚\râ”‚ Date limite: [ğŸ“… 2024-02-20] â”‚\râ”‚ [â• Ajouter] [âœï¸ Modifier] [ğŸ—‘ï¸ Supprimer] â”‚\râ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\râ”‚ ğŸ“Š STATISTIQUES â”‚\râ”‚ Total: 3 | En cours: 2 | TerminÃ©es: 1 â”‚\râ”‚ ğŸ”´ Haute: 2 ğŸŸ¡ Moyenne: 1 ğŸŸ¢ Basse: 0 â”‚\râ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Structure du projet // Models/Tache.cs public class Tache : BaseViewModel { public int Id { get; set; } private string titre; public string Titre { get =\u003e titre; set =\u003e SetProperty(ref titre, value); } private bool estTerminee; public bool EstTerminee { get =\u003e estTerminee; set =\u003e SetProperty(ref estTerminee, value); } private Priorite priorite; public Priorite Priorite { get =\u003e priorite; set =\u003e SetProperty(ref priorite, value); } private DateTime dateLimite; public DateTime DateLimite { get =\u003e dateLimite; set =\u003e SetProperty(ref dateLimite, value); } public DateTime DateCreation { get; set; } } // Models/Priorite.cs (enum) public enum Priorite { Basse, Moyenne, Haute } // Services/ITacheRepository.cs public interface ITacheRepository { List\u003cTache\u003e ChargerTaches(); void SauvegarderTaches(List\u003cTache\u003e taches); } // Services/TacheRepository.cs public class TacheRepository : ITacheRepository { private readonly string cheminFichier = \"taches.json\"; public List\u003cTache\u003e ChargerTaches() { if (!File.Exists(cheminFichier)) return new List\u003cTache\u003e(); string json = File.ReadAllText(cheminFichier); return JsonSerializer.Deserialize\u003cList\u003cTache\u003e\u003e(json); } public void SauvegarderTaches(List\u003cTache\u003e taches) { string json = JsonSerializer.Serialize(taches, new JsonSerializerOptions { WriteIndented = true }); File.WriteAllText(cheminFichier, json); } } // ViewModels/TachesViewModel.cs public class TachesViewModel : BaseViewModel { private readonly ITacheRepository repository; private ObservableCollection\u003cTache\u003e toutesLesTaches; public ObservableCollection\u003cTache\u003e TachesAffichees { get; set; } // PropriÃ©tÃ©s de filtrage private string rechercheTexte; public string RechercheTexte { get =\u003e rechercheTexte; set { SetProperty(ref rechercheTexte, value); AppliquerFiltres(); } } private string filtreStatut = \"Tous\"; public string FiltreStatut { get =\u003e filtreStatut; set { SetProperty(ref filtreStatut, value); AppliquerFiltres(); } } // Statistiques public int NombreTotal =\u003e toutesLesTaches.Count; public int NombreEnCours =\u003e toutesLesTaches.Count(t =\u003e !t.EstTerminee); public int NombreTerminees =\u003e toutesLesTaches.Count(t =\u003e t.EstTerminee); public int NombreHaute =\u003e toutesLesTaches.Count(t =\u003e t.Priorite == Priorite.Haute); // Commandes public ICommand AjouterCommand { get; } public ICommand ModifierCommand { get; } public ICommand SupprimerCommand { get; } public ICommand SauvegarderCommand { get; } // Constructeur avec injection de dÃ©pendances public TachesViewModel(ITacheRepository repository) { this.repository = repository; TachesAffichees = new ObservableCollection\u003cTache\u003e(); toutesLesTaches = new ObservableCollection\u003cTache\u003e(); // S'abonner aux changements pour mettre Ã  jour les stats toutesLesTaches.CollectionChanged += (s, e) =\u003e MettreAJourStatistiques(); // Initialiser les commandes AjouterCommand = new RelayCommand(AjouterTache, PeutAjouter); SupprimerCommand = new RelayCommand(SupprimerTache, PeutSupprimer); SauvegarderCommand = new RelayCommand(Sauvegarder); // Charger les tÃ¢ches ChargerTaches(); } private void ChargerTaches() { var taches = repository.ChargerTaches(); toutesLesTaches.Clear(); foreach (var tache in taches) { toutesLesTaches.Add(tache); } AppliquerFiltres(); } private void AppliquerFiltres() { TachesAffichees.Clear(); var resultats = toutesLesTaches.AsEnumerable(); // Filtre de recherche if (!string.IsNullOrWhiteSpace(RechercheTexte)) { resultats = resultats.Where(t =\u003e t.Titre.Contains(RechercheTexte, StringComparison.OrdinalIgnoreCase)); } // Filtre de statut if (FiltreStatut == \"En cours\") resultats = resultats.Where(t =\u003e !t.EstTerminee); else if (FiltreStatut == \"TerminÃ©es\") resultats = resultats.Where(t =\u003e t.EstTerminee); foreach (var tache in resultats) { TachesAffichees.Add(tache); } } private void MettreAJourStatistiques() { OnPropertyChanged(nameof(NombreTotal)); OnPropertyChanged(nameof(NombreEnCours)); OnPropertyChanged(nameof(NombreTerminees)); OnPropertyChanged(nameof(NombreHaute)); } private void Sauvegarder() { repository.SauvegarderTaches(toutesLesTaches.ToList()); } } CritÃ¨res de rÃ©ussite CRUD complet (Create, Read, Update, Delete) Filtres et recherche fonctionnels Statistiques mises Ã  jour automatiquement Sauvegarde/chargement persistant Interface responsive Validation des donnÃ©es Mini-projet 3 : Application de chat avec patron Observateur Niveau : â­â­â­ AvancÃ©\nObjectifs pÃ©dagogiques Patron Observateur avancÃ© Services avec injection de dÃ©pendances Gestion dâ€™Ã©tat complexe Temps rÃ©el (simulation) SpÃ©cifications FonctionnalitÃ©s :\nSalons de discussion multiples Envoi/rÃ©ception de messages Notifications en temps rÃ©el Liste des utilisateurs connectÃ©s Indicateur â€œen train dâ€™Ã©crireâ€¦â€ Historique des messages Recherche dans les messages Architecture :\n- IChatService (abstraction)\r- ChatService (implÃ©mentation rÃ©elle)\r- FakeChatService (pour tests)\r- Observateurs:\r- IMessageObservateur\r- IUtilisateurObservateur\r- INotificationObservateur Structure du projet // Models/Message.cs public class Message { public int Id { get; set; } public string Expediteur { get; set; } public string Contenu { get; set; } public DateTime Horodatage { get; set; } public string SalonId { get; set; } } // Models/Salon.cs public class Salon { public string Id { get; set; } public string Nom { get; set; } public ObservableCollection\u003cMessage\u003e Messages { get; set; } public ObservableCollection\u003cstring\u003e UtilisateursConnectes { get; set; } } // Services/IChatService.cs public interface IChatService { void AbonnerMessages(IMessageObservateur observateur); void DesabonnerMessages(IMessageObservateur observateur); void EnvoyerMessage(string salonId, string expediteur, string contenu); List\u003cMessage\u003e ObtenirHistorique(string salonId); void RejoindreSalon(string salonId, string utilisateur); void QuitterSalon(string salonId, string utilisateur); } // Services/ChatService.cs public class ChatService : IChatService { private List\u003cIMessageObservateur\u003e observateursMessages = new List\u003cIMessageObservateur\u003e(); private Dictionary\u003cstring, Salon\u003e salons = new Dictionary\u003cstring, Salon\u003e(); public void AbonnerMessages(IMessageObservateur observateur) { observateursMessages.Add(observateur); } public void EnvoyerMessage(string salonId, string expediteur, string contenu) { var message = new Message { Id = GenererId(), SalonId = salonId, Expediteur = expediteur, Contenu = contenu, Horodatage = DateTime.Now }; if (!salons.ContainsKey(salonId)) salons[salonId] = new Salon { Id = salonId, Messages = new ObservableCollection\u003cMessage\u003e() }; salons[salonId].Messages.Add(message); // Notifier tous les observateurs foreach (var obs in observateursMessages) { obs.NouveauMessage(message); } } // Simulation de messages entrants (autre utilisateur) public void SimulerReception(string salonId) { var random = new Random(); var expediteurs = new[] { \"Alice\", \"Bob\", \"Charlie\" }; var messages = new[] { \"Salut!\", \"Comment Ã§a va?\", \"Avez-vous vu le dernier rapport?\" }; string expediteur = expediteurs[random.Next(expediteurs.Length)]; string contenu = messages[random.Next(messages.Length)]; EnvoyerMessage(salonId, expediteur, contenu); } } // Observateurs/IMessageObservateur.cs public interface IMessageObservateur { void NouveauMessage(Message message); } // ViewModels/ChatViewModel.cs public class ChatViewModel : BaseViewModel, IMessageObservateur { private readonly IChatService chatService; private Salon salonActuel; public Salon SalonActuel { get =\u003e salonActuel; set =\u003e SetProperty(ref salonActuel, value); } public ObservableCollection\u003cSalon\u003e Salons { get; set; } private string messageActuel; public string MessageActuel { get =\u003e messageActuel; set =\u003e SetProperty(ref messageActuel, value); } private string utilisateurActuel; public string UtilisateurActuel { get; set; } public ICommand EnvoyerMessageCommand { get; } public ICommand ChangerSalonCommand { get; } public ChatViewModel(IChatService chatService) { this.chatService = chatService; // S'abonner aux nouveaux messages chatService.AbonnerMessages(this); Salons = new ObservableCollection\u003cSalon\u003e(); EnvoyerMessageCommand = new RelayCommand(EnvoyerMessage, PeutEnvoyer); ChangerSalonCommand = new RelayCommand\u003cSalon\u003e(ChangerSalon); InitialiserSalons(); } private void InitialiserSalons() { Salons.Add(new Salon { Id = \"general\", Nom = \"GÃ©nÃ©ral\", Messages = new ObservableCollection\u003cMessage\u003e() }); Salons.Add(new Salon { Id = \"technique\", Nom = \"Technique\", Messages = new ObservableCollection\u003cMessage\u003e() }); SalonActuel = Salons[0]; } // ImplÃ©mentation de IMessageObservateur public void NouveauMessage(Message message) { // Trouver le salon correspondant var salon = Salons.FirstOrDefault(s =\u003e s.Id == message.SalonId); if (salon != null) { // WPF nÃ©cessite d'Ãªtre sur le thread UI Application.Current.Dispatcher.Invoke(() =\u003e { salon.Messages.Add(message); // Notification si ce n'est pas le salon actuel if (salon != SalonActuel) { // Afficher une notification } }); } } private void EnvoyerMessage() { chatService.EnvoyerMessage(SalonActuel.Id, UtilisateurActuel, MessageActuel); MessageActuel = \"\"; } private bool PeutEnvoyer() { return !string.IsNullOrWhiteSpace(MessageActuel); } } XAML suggÃ©rÃ© \u003cGrid\u003e \u003cGrid.ColumnDefinitions\u003e \u003cColumnDefinition Width=\"200\"/\u003e \u003cColumnDefinition Width=\"*\"/\u003e \u003c/Grid.ColumnDefinitions\u003e \u003c!-- Liste des salons --\u003e \u003cListBox Grid.Column=\"0\" ItemsSource=\"{Binding Salons}\" SelectedItem=\"{Binding SalonActuel}\" DisplayMemberPath=\"Nom\"/\u003e \u003c!-- Zone de chat --\u003e \u003cGrid Grid.Column=\"1\"\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"*\"/\u003e \u003cRowDefinition Height=\"Auto\"/\u003e \u003c/Grid.RowDefinitions\u003e \u003c!-- Messages --\u003e \u003cListBox Grid.Row=\"0\" ItemsSource=\"{Binding SalonActuel.Messages}\"\u003e \u003cListBox.ItemTemplate\u003e \u003cDataTemplate\u003e \u003cStackPanel Margin=\"5\"\u003e \u003cTextBlock Text=\"{Binding Expediteur}\" FontWeight=\"Bold\"/\u003e \u003cTextBlock Text=\"{Binding Contenu}\"/\u003e \u003cTextBlock Text=\"{Binding Horodatage}\" FontSize=\"10\" Foreground=\"Gray\"/\u003e \u003c/StackPanel\u003e \u003c/DataTemplate\u003e \u003c/ListBox.ItemTemplate\u003e \u003c/ListBox\u003e \u003c!-- Zone de saisie --\u003e \u003cStackPanel Grid.Row=\"1\" Orientation=\"Horizontal\" Margin=\"5\"\u003e \u003cTextBox Text=\"{Binding MessageActuel, UpdateSourceTrigger=PropertyChanged}\" Width=\"400\"/\u003e \u003cButton Content=\"Envoyer\" Command=\"{Binding EnvoyerMessageCommand}\" Width=\"80\" Margin=\"5,0,0,0\"/\u003e \u003c/StackPanel\u003e \u003c/Grid\u003e \u003c/Grid\u003e CritÃ¨res de rÃ©ussite Plusieurs salons fonctionnent indÃ©pendamment Messages apparaissent en temps rÃ©el Notification pour nouveau message Changement de salon fluide Historique conservÃ© Tests unitaires du ChatService Mini-projet 4 : Gestion dâ€™inventaire avec commandes et injection Niveau : â­â­â­â­ AvancÃ©\nObjectifs pÃ©dagogiques Architecture complÃ¨te MVVM Patron Commande complet Injection de dÃ©pendances avancÃ©e Repository pattern Validation Export/Import de donnÃ©es SpÃ©cifications FonctionnalitÃ©s :\nGestion complÃ¨te de produits (CRUD) CatÃ©gories de produits Gestion des stocks (entrÃ©es/sorties) Alertes de stock faible Historique des mouvements Recherche et filtres avancÃ©s Export Excel/CSV Rapports statistiques Architecture :\nServices/\r- IProduitRepository\r- ICategorieRepository - IExportService\r- IValidationService\rCommands/\r- CommandeAjouterProduit\r- CommandeModifierProduit\r- CommandeSupprimerProduit\r- CommandeAjusterStock\rViewModels/\r- MainViewModel (orchestrateur)\r- ProduitsViewModel\r- CategoriesViewModel\r- StockViewModel\r- RapportsViewModel Exemple de structure partielle // Models/Produit.cs public class Produit : BaseViewModel { public int Id { get; set; } private string nom; public string Nom { get =\u003e nom; set =\u003e SetProperty(ref nom, value); } private decimal prix; public decimal Prix { get =\u003e prix; set =\u003e SetProperty(ref prix, value); } private int quantiteStock; public int QuantiteStock { get =\u003e quantiteStock; set { SetProperty(ref quantiteStock, value); OnPropertyChanged(nameof(EstEnRupture)); OnPropertyChanged(nameof(EstStockFaible)); } } public int SeuilAlerte { get; set; } = 10; public bool EstEnRupture =\u003e QuantiteStock == 0; public bool EstStockFaible =\u003e QuantiteStock \u003e 0 \u0026\u0026 QuantiteStock \u003c= SeuilAlerte; private Categorie categorie; public Categorie Categorie { get =\u003e categorie; set =\u003e SetProperty(ref categorie, value); } } // Services/IProduitRepository.cs public interface IProduitRepository { Task\u003cList\u003cProduit\u003e\u003e ObtenirTousAsync(); Task\u003cProduit\u003e ObtenirParIdAsync(int id); Task\u003cProduit\u003e AjouterAsync(Produit produit); Task ModifierAsync(Produit produit); Task SupprimerAsync(int id); Task\u003cList\u003cProduit\u003e\u003e RechercherAsync(string critere); } // Services/IExportService.cs public interface IExportService { void ExporterCSV(List\u003cProduit\u003e produits, string cheminFichier); void ExporterExcel(List\u003cProduit\u003e produits, string cheminFichier); } // Commands/CommandeAjouterProduit.cs public class CommandeAjouterProduit : ICommande { private readonly IProduitRepository repository; private readonly ObservableCollection\u003cProduit\u003e collection; private Produit produit; private Produit produitAjoute; public CommandeAjouterProduit(IProduitRepository repository, ObservableCollection\u003cProduit\u003e collection, Produit produit) { this.repository = repository; this.collection = collection; this.produit = produit; } public async void Executer() { produitAjoute = await repository.AjouterAsync(produit); collection.Add(produitAjoute); } public async void Annuler() { await repository.SupprimerAsync(produitAjoute.Id); collection.Remove(produitAjoute); } } // ViewModels/ProduitsViewModel.cs public class ProduitsViewModel : BaseViewModel { private readonly IProduitRepository repository; private readonly IValidationService validationService; private readonly GestionnaireCommandes gestionnaireCommandes; public ObservableCollection\u003cProduit\u003e Produits { get; set; } public ObservableCollection\u003cProduit\u003e ProduitsAffichees { get; set; } public ObservableCollection\u003cCategorie\u003e Categories { get; set; } // PropriÃ©tÃ©s pour le formulaire private Produit produitSelectionne; public Produit ProduitSelectionne { get =\u003e produitSelectionne; set =\u003e SetProperty(ref produitSelectionne, value); } // Statistiques public int NombreProduits =\u003e Produits.Count; public int NombreRuptures =\u003e Produits.Count(p =\u003e p.EstEnRupture); public int NombreAlertes =\u003e Produits.Count(p =\u003e p.EstStockFaible); public decimal ValeurTotaleStock =\u003e Produits.Sum(p =\u003e p.Prix * p.QuantiteStock); // Commandes public ICommand AjouterCommand { get; } public ICommand ModifierCommand { get; } public ICommand SupprimerCommand { get; } public ICommand AnnulerCommand { get; } public ICommand RefaireCommand { get; } public ICommand ExporterCommand { get; } // Constructeur avec injection public ProduitsViewModel(IProduitRepository repository, IValidationService validationService) { this.repository = repository; this.validationService = validationService; this.gestionnaireCommandes = new GestionnaireCommandes(); Produits = new ObservableCollection\u003cProduit\u003e(); ProduitsAffichees = new ObservableCollection\u003cProduit\u003e(); AjouterCommand = new RelayCommand(AjouterProduit, PeutAjouter); AnnulerCommand = new RelayCommand(() =\u003e gestionnaireCommandes.Annuler()); ChargerProduitsAsync(); } private async void ChargerProduitsAsync() { var produits = await repository.ObtenirTousAsync(); Produits.Clear(); foreach (var p in produits) { Produits.Add(p); } AppliquerFiltres(); } private void AjouterProduit() { // Valider d'abord var erreurs = validationService.ValiderProduit(ProduitSelectionne); if (erreurs.Any()) { // Afficher les erreurs return; } // CrÃ©er et exÃ©cuter la commande var commande = new CommandeAjouterProduit(repository, Produits, ProduitSelectionne); gestionnaireCommandes.ExecuterCommande(commande); MettreAJourStatistiques(); } } CritÃ¨res de rÃ©ussite Architecture propre avec injection de dÃ©pendances Toutes les opÃ©rations CRUD avec annuler/refaire Validation complÃ¨te des donnÃ©es Export fonctionnel Statistiques en temps rÃ©el Tests unitaires complets Documentation du code Mini-projet 5 : Application de blog avec architecture complÃ¨te Niveau : â­â­â­â­â­ Expert\nObjectifs pÃ©dagogiques Architecture N-tiers complÃ¨te Tous les patrons intÃ©grÃ©s API REST simulÃ©e Navigation multi-vues Authentification Gestion des erreurs avancÃ©e SpÃ©cifications FonctionnalitÃ©s :\nAuthentification (login/logout) Gestion dâ€™articles (CRUD) Commentaires CatÃ©gories et tags Recherche full-text Draft/PubliÃ© RÃ´les (Admin, Ã‰diteur, Lecteur) Historique des modifications Upload dâ€™images Export PDF dâ€™article Architecture complÃ¨te :\nPresentation/\r- Views/\r- LoginView\r- ArticlesListView\r- ArticleDetailView\r- EditorView\r- ViewModels/\r- LoginViewModel\r- ArticlesViewModel\r- ArticleDetailViewModel\rBusiness/\r- Services/\r- IAuthenticationService\r- IArticleService\r- ICommentaireService\r- Commands/\r- Validators/\rData/\r- Repositories/\r- IArticleRepository\r- IUtilisateurRepository\r- Models/\rInfrastructure/\r- API/\r- ApiClient\r- Storage/\r- Logging/ Je vous fournis un squelette de dÃ©partâ€¦ // Models/Article.cs public class Article : BaseViewModel { public int Id { get; set; } private string titre; public string Titre { get =\u003e titre; set =\u003e SetProperty(ref titre, value); } private string contenu; public string Contenu { get =\u003e contenu; set =\u003e SetProperty(ref contenu, value); } private StatutArticle statut; public StatutArticle Statut { get =\u003e statut; set =\u003e SetProperty(ref statut, value); } public Utilisateur Auteur { get; set; } public DateTime DateCreation { get; set; } public DateTime? DatePublication { get; set; } public DateTime DateModification { get; set; } public ObservableCollection\u003cCommentaire\u003e Commentaires { get; set; } public ObservableCollection\u003cTag\u003e Tags { get; set; } public Categorie Categorie { get; set; } } public enum StatutArticle { Brouillon, EnRevision, Publie, Archive } // Services/IArticleService.cs public interface IArticleService { Task\u003cList\u003cArticle\u003e\u003e ObtenirArticlesAsync(FiltreBlog filtre); Task\u003cArticle\u003e ObtenirArticleAsync(int id); Task\u003cArticle\u003e CreerArticleAsync(Article article); Task ModifierArticleAsync(Article article); Task SupprimerArticleAsync(int id); Task\u003cbool\u003e PublierArticleAsync(int id); Task\u003cList\u003cArticle\u003e\u003e RechercherAsync(string termes); } // ViewModels/MainViewModel.cs public class MainViewModel : BaseViewModel { private readonly INavigationService navigationService; private readonly IAuthenticationService authService; private BaseViewModel vueActuelle; public BaseViewModel VueActuelle { get =\u003e vueActuelle; set =\u003e SetProperty(ref vueActuelle, value); } private Utilisateur utilisateurConnecte; public Utilisateur UtilisateurConnecte { get =\u003e utilisateurConnecte; set =\u003e SetProperty(ref utilisateurConnecte, value); } public ICommand NaviguerVersArticlesCommand { get; } public ICommand NaviguerVersNouvelArticleCommand { get; } public ICommand DeconnecterCommand { get; } public MainViewModel(INavigationService navigationService, IAuthenticationService authService) { this.navigationService = navigationService; this.authService = authService; NaviguerVersArticlesCommand = new RelayCommand(() =\u003e navigationService.NaviguerVers\u003cArticlesViewModel\u003e()); DeconnecterCommand = new RelayCommand(Deconnecter); // VÃ©rifier si l'utilisateur est dÃ©jÃ  connectÃ© UtilisateurConnecte = authService.ObtenirUtilisateurActuel(); if (UtilisateurConnecte == null) navigationService.NaviguerVers\u003cLoginViewModel\u003e(); else navigationService.NaviguerVers\u003cArticlesViewModel\u003e(); } } // Services/NavigationService.cs public interface INavigationService { void NaviguerVers\u003cTViewModel\u003e() where TViewModel : BaseViewModel; void NaviguerVers\u003cTViewModel\u003e(object parametre) where TViewModel : BaseViewModel; void NaviguerRetour(); } public class NavigationService : INavigationService { private readonly Func\u003cType, BaseViewModel\u003e viewModelFactory; private readonly MainViewModel mainViewModel; private Stack\u003cBaseViewModel\u003e historique = new Stack\u003cBaseViewModel\u003e(); public NavigationService(Func\u003cType, BaseViewModel\u003e viewModelFactory, MainViewModel mainViewModel) { this.viewModelFactory = viewModelFactory; this.mainViewModel = mainViewModel; } public void NaviguerVers\u003cTViewModel\u003e() where TViewModel : BaseViewModel { var viewModel = viewModelFactory(typeof(TViewModel)); if (mainViewModel.VueActuelle != null) historique.Push(mainViewModel.VueActuelle); mainViewModel.VueActuelle = viewModel; } public void NaviguerRetour() { if (historique.Count \u003e 0) mainViewModel.VueActuelle = historique.Pop(); } } XAML avec navigation \u003c!-- MainWindow.xaml --\u003e \u003cWindow\u003e \u003cGrid\u003e \u003cGrid.RowDefinitions\u003e \u003cRowDefinition Height=\"Auto\"/\u003e \u003cRowDefinition Height=\"*\"/\u003e \u003c/Grid.RowDefinitions\u003e \u003c!-- Barre de navigation --\u003e \u003cStackPanel Grid.Row=\"0\" Orientation=\"Horizontal\" Background=\"#2196F3\"\u003e \u003cButton Content=\"Articles\" Command=\"{Binding NaviguerVersArticlesCommand}\"/\u003e \u003cButton Content=\"Nouvel Article\" Command=\"{Binding NaviguerVersNouvelArticleCommand}\"/\u003e \u003cTextBlock Text=\"{Binding UtilisateurConnecte.Nom}\" Foreground=\"White\" VerticalAlignment=\"Center\" Margin=\"20,0\"/\u003e \u003cButton Content=\"DÃ©connexion\" Command=\"{Binding DeconnecterCommand}\"/\u003e \u003c/StackPanel\u003e \u003c!-- Zone de contenu dynamique --\u003e \u003cContentControl Grid.Row=\"1\" Content=\"{Binding VueActuelle}\"\u003e \u003cContentControl.Resources\u003e \u003c!-- Mapper les ViewModels aux Views --\u003e \u003cDataTemplate DataType=\"{x:Type vm:ArticlesViewModel}\"\u003e \u003cviews:ArticlesView /\u003e \u003c/DataTemplate\u003e \u003cDataTemplate DataType=\"{x:Type vm:ArticleDetailViewModel}\"\u003e \u003cviews:ArticleDetailView /\u003e \u003c/DataTemplate\u003e \u003cDataTemplate DataType=\"{x:Type vm:LoginViewModel}\"\u003e \u003cviews:LoginView /\u003e \u003c/DataTemplate\u003e \u003c/ContentControl.Resources\u003e \u003c/ContentControl\u003e \u003c/Grid\u003e \u003c/Window\u003e Configuration de lâ€™injection de dÃ©pendances // App.xaml.cs public partial class App : Application { private ServiceProvider serviceProvider; protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); var services = new ServiceCollection(); // Repositories services.AddSingleton\u003cIArticleRepository, ArticleRepository\u003e(); services.AddSingleton\u003cIUtilisateurRepository, UtilisateurRepository\u003e(); // Services services.AddSingleton\u003cIAuthenticationService, AuthenticationService\u003e(); services.AddTransient\u003cIArticleService, ArticleService\u003e(); services.AddTransient\u003cIExportService, ExportService\u003e(); // ViewModels services.AddSingleton\u003cMainViewModel\u003e(); services.AddTransient\u003cArticlesViewModel\u003e(); services.AddTransient\u003cArticleDetailViewModel\u003e(); services.AddTransient\u003cLoginViewModel\u003e(); // Navigation services.AddSingleton\u003cINavigationService\u003e(provider =\u003e { var mainVM = provider.GetRequiredService\u003cMainViewModel\u003e(); return new NavigationService( type =\u003e (BaseViewModel)provider.GetRequiredService(type), mainVM ); }); serviceProvider = services.BuildServiceProvider(); // Lancer la fenÃªtre principale var mainWindow = new MainWindow { DataContext = serviceProvider.GetRequiredService\u003cMainViewModel\u003e() }; mainWindow.Show(); } } CritÃ¨res de rÃ©ussite Architecture N-tiers complÃ¨te Navigation fluide entre vues Authentification fonctionnelle CRUD complet avec validation Gestion des rÃ´les Export PDF Gestion des erreurs Logging Tests unitaires complets Tests dâ€™intÃ©gration Conclusion des mini-projets Ces 5 mini-projets couvrent progressivement tous les concepts enseignÃ©s :\nCalculatrice : Introduction aux commandes et historique TÃ¢ches : MVVM complet avec sauvegarde Chat : Observateur en temps rÃ©el Inventaire : Architecture complÃ¨te avec injection Blog : Application professionnelle complÃ¨te Chaque projet construit sur les acquis du prÃ©cÃ©dent et introduit de nouveaux concepts.",
    "description": "Mini-projets progressifs Mini-projet 1 : Calculatrice avec historique Niveau : â­â­ IntermÃ©diaire\nObjectifs pÃ©dagogiques Patron Commande (annuler/refaire) INotifyPropertyChanged Data Binding de base SpÃ©cifications FonctionnalitÃ©s :",
    "tags": [],
    "title": "Mini-projets",
    "uri": "/420-413/mini_projets/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "Noms Significatifs et Fonctions Claires ğŸ“‹ Objectifs de cette semaine Apprendre Ã  :\nIdentifier et corriger les noms non significatifs ReconnaÃ®tre et rÃ©soudre les fonctions trop longues Ã‰liminer les commentaires inutiles en Ã©crivant du code auto-explicatif ğŸ’¡ Citation de la semaine â€œLe code est lu beaucoup plus souvent quâ€™il nâ€™est Ã©crit. Facilitez la lecture, pas lâ€™Ã©criture.â€\nâ€” Robert C. Martin (Uncle Bob), Clean Code\nğŸ”´ Code Smell #1 : Noms Non Significatifs Quâ€™est-ce quâ€™un nom non significatif ? Un nom non significatif est un nom de variable, mÃ©thode ou classe qui ne rÃ©vÃ¨le pas clairement son intention ou son rÃ´le. Il force le lecteur Ã  deviner ou Ã  chercher dans le contexte pour comprendre.\nâŒ Exemple de Code ProblÃ©matique public class Program { static void Main() { // Que reprÃ©sentent ces variables ??? var d = 30; var temp = new List\u003cint[]\u003e(); for (int i = 0; i \u003c 100; i++) { var x = new int[3]; x[0] = i; x[1] = i * 2; x[2] = i % d; if (x[2] == 0) { temp.Add(x); } } // Afficher les rÃ©sultats foreach (var t in temp) { Console.WriteLine($\"{t[0]} - {t[1]} - {t[2]}\"); } } } ğŸ¤” ProblÃ¨mes identifiÃ©s d : Que signifie â€œdâ€ ? Jour ? Distance ? Diviseur ? temp : Temporaire de quoi ? Quelle est sa vraie signification ? x : Quâ€™est-ce que ce tableau reprÃ©sente ? t : MÃªme problÃ¨me dans la boucle i : Dans ce contexte, que reprÃ©sente-t-il vraiment ? Indices magiques : Que signifient [0], [1], [2] ? âœ… Code CorrigÃ© (Version Clean Code) public class Program { static void Main() { // VERSION CLEAN CODE const int NombreJoursDansUnMois = 30; List\u003cCommande\u003e commandesDivisiblesParTrente = new List\u003cCommande\u003e(); for (int numeroCommande = 0; numeroCommande \u003c 100; numeroCommande++) { var commande = new Commande { Numero = numeroCommande, MontantDouble = numeroCommande * 2, ResteModulo = numeroCommande % NombreJoursDansUnMois }; if (commande.EstDivisibleParTrente()) { commandesDivisiblesParTrente.Add(commande); } } AfficherCommandes(commandesDivisiblesParTrente); } private static void AfficherCommandes(List\u003cCommande\u003e commandes) { foreach (var commande in commandes) { Console.WriteLine(commande.ObtenirDescription()); } } } public class Commande { public int Numero { get; set; } public int MontantDouble { get; set; } public int ResteModulo { get; set; } public bool EstDivisibleParTrente() { return ResteModulo == 0; } public string ObtenirDescription() { return $\"Commande #{Numero} - Montant: {MontantDouble} - Reste: {ResteModulo}\"; } } ğŸ“Š Comparaison Avant/AprÃ¨s Avant (ğŸ˜ Mauvais) AprÃ¨s (âœ… Bon) AmÃ©lioration d nombreDeJoursDansUnMois Intention claire temp commandesDivisiblesParTrente But explicite x commande (objet Commande) Type et rÃ´le clairs x[0], x[1], x[2] commande.Numero, commande.MontantDouble PropriÃ©tÃ©s nommÃ©es i numeroCommande Contexte prÃ©cis t commande Nom significatif ğŸ” Exercice Pratique #1 Corrigez ce code :\npublic void Process(int a, int b) { var r = 0; for (int i = a; i \u003c= b; i++) { if (i % 2 == 0) { r += i; } } Console.WriteLine(r); } Solution :\npublic void AfficherSommeNombresPairs(int nombreDebut, int nombreFin) { int sommePairs = 0; for (int nombre = nombreDebut; nombre \u003c= nombreFin; nombre++) { if (NombreEstPair(nombre)) { sommePairs += nombre; } } Console.WriteLine($\"Somme des nombres pairs : {sommePairs}\"); } private bool NombreEstPair(int nombre) { return nombre % 2 == 0; } ğŸ”´ Code Smell #2 : Fonctions Trop Longues Quâ€™est-ce quâ€™une fonction trop longue ? Une fonction qui fait trop de choses, contient trop de lignes de code, ou a trop de niveaux dâ€™indentation. RÃ¨gle gÃ©nÃ©rale : une fonction devrait tenir sur un Ã©cran sans dÃ©filement.\nRÃ¨gle dâ€™or : Une fonction = Une responsabilitÃ©\nâŒ Exemple de Code ProblÃ©matique public class GestionnaireCommandes { public void TraiterCommande(int idCommande) { // Cette fonction fait BEAUCOUP TROP de choses ! // 1. RÃ©cupÃ©ration des donnÃ©es var commande = new Commande(); using (var connection = new SqlConnection(\"connectionString\")) { connection.Open(); var cmd = new SqlCommand($\"SELECT * FROM Commandes WHERE Id = {idCommande}\", connection); var reader = cmd.ExecuteReader(); if (reader.Read()) { commande.Id = (int)reader[\"Id\"]; commande.ClientId = (int)reader[\"ClientId\"]; commande.MontantTotal = (decimal)reader[\"MontantTotal\"]; commande.DateCommande = (DateTime)reader[\"DateCommande\"]; } } // 2. Validation if (commande.MontantTotal \u003c= 0) { Console.WriteLine(\"Erreur: Montant invalide\"); return; } if (commande.DateCommande \u003e DateTime.Now) { Console.WriteLine(\"Erreur: Date future\"); return; } // 3. Calcul des taxes decimal tps = commande.MontantTotal * 0.05m; decimal tvq = commande.MontantTotal * 0.09975m; decimal total = commande.MontantTotal + tps + tvq; // 4. VÃ©rification du client var client = new Client(); using (var connection = new SqlConnection(\"connectionString\")) { connection.Open(); var cmd = new SqlCommand($\"SELECT * FROM Clients WHERE Id = {commande.ClientId}\", connection); var reader = cmd.ExecuteReader(); if (reader.Read()) { client.Nom = (string)reader[\"Nom\"]; client.Email = (string)reader[\"Email\"]; client.Actif = (bool)reader[\"Actif\"]; } } if (!client.Actif) { Console.WriteLine(\"Erreur: Client inactif\"); return; } // 5. Application de rabais decimal rabais = 0; if (commande.MontantTotal \u003e 1000) { rabais = total * 0.10m; } else if (commande.MontantTotal \u003e 500) { rabais = total * 0.05m; } total -= rabais; // 6. Enregistrement de la facture using (var connection = new SqlConnection(\"connectionString\")) { connection.Open(); var cmd = new SqlCommand( $\"INSERT INTO Factures (CommandeId, MontantHT, TPS, TVQ, Rabais, Total) \" + $\"VALUES ({commande.Id}, {commande.MontantTotal}, {tps}, {tvq}, {rabais}, {total})\", connection); cmd.ExecuteNonQuery(); } // 7. Envoi d'email var smtp = new SmtpClient(\"smtp.server.com\"); var message = new MailMessage(); message.To.Add(client.Email); message.Subject = \"Facture\"; message.Body = $\"Votre facture de {total:C} est prÃªte\"; smtp.Send(message); // 8. Logging Console.WriteLine($\"Commande {idCommande} traitÃ©e avec succÃ¨s\"); File.AppendAllText(\"log.txt\", $\"{DateTime.Now}: Commande {idCommande} OK\\n\"); } } ğŸ¤” ProblÃ¨mes identifiÃ©s 91 lignes dans une seule mÃ©thode ! 8 responsabilitÃ©s diffÃ©rentes dans une fonction Violation du principe SRP (Single Responsibility Principle) Difficile Ã  tester : comment tester juste une partie ? Difficile Ã  maintenir : modifier une partie risque de casser le reste Code dupliquÃ© : connexion DB rÃ©pÃ©tÃ©e 3 fois MÃ©lange de niveaux dâ€™abstraction : dÃ©tails DB + logique mÃ©tier âœ… Code CorrigÃ© (Version Clean Code) public class GestionnaireCommandes { private readonly ICommandeRepository _commandeRepository; private readonly IClientRepository _clientRepository; private readonly IFactureRepository _factureRepository; private readonly ICalculateurTaxes _calculateurTaxes; private readonly ICalculateurRabais _calculateurRabais; private readonly IServiceEmail _serviceEmail; private readonly ILogger _logger; public GestionnaireCommandes( ICommandeRepository commandeRepository, IClientRepository clientRepository, IFactureRepository factureRepository, ICalculateurTaxes calculateurTaxes, ICalculateurRabais calculateurRabais, IServiceEmail serviceEmail, ILogger logger) { _commandeRepository = commandeRepository; _clientRepository = clientRepository; _factureRepository = factureRepository; _calculateurTaxes = calculateurTaxes; _calculateurRabais = calculateurRabais; _serviceEmail = serviceEmail; _logger = logger; } // ========================================== // MÃ‰THODE PRINCIPALE - Claire et concise // ========================================== public void TraiterCommande(int idCommande) { var commande = RecupererCommande(idCommande); ValiderCommande(commande); var client = RecupererClient(commande.ClientId); ValiderClient(client); var facture = CreerFacture(commande); EnregistrerFacture(facture); EnvoyerEmailConfirmation(client, facture); LoggerTraitement(idCommande); } // ========================================== // MÃ‰THODES PRIVÃ‰ES - Une responsabilitÃ© chacune // ========================================== private Commande RecupererCommande(int idCommande) { var commande = _commandeRepository.ObtenirParId(idCommande); if (commande == null) { throw new CommandeIntrouvableException($\"Commande {idCommande} introuvable\"); } return commande; } private void ValiderCommande(Commande commande) { if (commande.MontantTotal \u003c= 0) { throw new CommandeInvalideException(\"Le montant doit Ãªtre positif\"); } if (commande.DateCommande \u003e DateTime.Now) { throw new CommandeInvalideException(\"La date ne peut Ãªtre future\"); } } private Client RecupererClient(int clientId) { var client = _clientRepository.ObtenirParId(clientId); if (client == null) { throw new ClientIntrouvableException($\"Client {clientId} introuvable\"); } return client; } private void ValiderClient(Client client) { if (!client.Actif) { throw new ClientInactifException($\"Le client {client.Nom} est inactif\"); } } private Facture CreerFacture(Commande commande) { var montantHT = commande.MontantTotal; var taxes = _calculateurTaxes.CalculerTaxes(montantHT); var montantAvecTaxes = montantHT + taxes.TPS + taxes.TVQ; var rabais = _calculateurRabais.CalculerRabais(montantAvecTaxes); var montantFinal = montantAvecTaxes - rabais; return new Facture { CommandeId = commande.Id, MontantHorsTaxes = montantHT, TPS = taxes.TPS, TVQ = taxes.TVQ, Rabais = rabais, MontantTotal = montantFinal }; } private void EnregistrerFacture(Facture facture) { _factureRepository.Enregistrer(facture); } private void EnvoyerEmailConfirmation(Client client, Facture facture) { var contenuEmail = new EmailFacture { Destinataire = client.Email, NomClient = client.Nom, MontantTotal = facture.MontantTotal }; _serviceEmail.EnvoyerEmailFacture(contenuEmail); } private void LoggerTraitement(int idCommande) { _logger.LogInformation($\"Commande {idCommande} traitÃ©e avec succÃ¨s\"); } } // ========================================== // CLASSES DE SUPPORT (extraites) // ========================================== public class CalculateurTaxes : ICalculateurTaxes { private const decimal TauxTPS = 0.05m; // Taxe fÃ©dÃ©rale (5%) private const decimal TauxTVQ = 0.09975m; // Taxe provinciale QuÃ©bec (9.975%) public TaxesCalculees CalculerTaxes(decimal montantHorsTaxes) { return new TaxesCalculees { TPS = montantHorsTaxes * TauxTPS, TVQ = montantHorsTaxes * TauxTVQ }; } } public class CalculateurRabais : ICalculateurRabais { private const decimal SeuilRabaisEleve = 1000m; private const decimal SeuilRabaisMoyen = 500m; private const decimal TauxRabaisEleve = 0.10m; private const decimal TauxRabaisMoyen = 0.05m; public decimal CalculerRabais(decimal montant) { if (montant \u003e SeuilRabaisEleve) { return montant * TauxRabaisEleve; } if (montant \u003e SeuilRabaisMoyen) { return montant * TauxRabaisMoyen; } return 0; } } ğŸ“Š Comparaison Avant/AprÃ¨s Aspect Avant (ğŸ˜) AprÃ¨s (âœ…) Lignes par mÃ©thode 91 lignes 5-15 lignes max ResponsabilitÃ©s 8 dans une mÃ©thode 1 par mÃ©thode TestabilitÃ© TrÃ¨s difficile Facile (chaque partie) LisibilitÃ© NÃ©cessite dÃ©filement Chaque mÃ©thode visible dâ€™un coup Maintenance RisquÃ© SÃ»r et ciblÃ© RÃ©utilisabilitÃ© Aucune Chaque mÃ©thode rÃ©utilisable ğŸ¯ RÃ¨gles pour les Fonctions Propres âœ… Principes Ã  suivre : Une fonction = Une responsabilitÃ© // âœ… BON - Fait une seule chose public decimal CalculerPrixAvecTaxes(decimal prixHT) { return prixHT * 1.14975m; // TPS + TVQ du QuÃ©bec } // âŒ MAUVAIS - Fait plusieurs choses public decimal CalculerEtEnregistrerPrixAvecTaxes(decimal prixHT) { var prixTTC = prixHT * 1.14975m; // Enregistrement en DB // Envoi d'email // Logging return prixTTC; } Petite taille : 5-20 lignes idÃ©alement // âœ… BON - Court et clair public bool UtilisateurEstEligibleAuRabais(Utilisateur user) { return user.EstMembre \u0026\u0026 user.AncienneteEnMois \u003e= 6 \u0026\u0026 user.MontantAchatsTotal \u003e 1000; } Un seul niveau dâ€™abstraction // âœ… BON - MÃªme niveau d'abstraction public void TraiterInscription(Utilisateur user) { ValiderDonneesUtilisateur(user); EnregistrerUtilisateur(user); EnvoyerEmailBienvenue(user); } // âŒ MAUVAIS - Niveaux d'abstraction mÃ©langÃ©s public void TraiterInscription(Utilisateur user) { // Haut niveau ValiderDonneesUtilisateur(user); // Bas niveau (dÃ©tails d'implÃ©mentation) using (var connection = new SqlConnection(\"...\")) { connection.Open(); var cmd = new SqlCommand(\"INSERT...\", connection); cmd.ExecuteNonQuery(); } // Haut niveau EnvoyerEmailBienvenue(user); } Peu de paramÃ¨tres : 0-3 idÃ©alement // âœ… BON - 2 paramÃ¨tres public decimal CalculerRemise(decimal montant, TypeClient typeClient) { // ... } // âš ï¸ ACCEPTABLE - 3 paramÃ¨tres public void CreerCommande(int clientId, List\u003cProduit\u003e produits, AdresseLivraison adresse) { // ... } // âŒ MAUVAIS - Trop de paramÃ¨tres public void CreerCommande(int clientId, string nom, string prenom, string email, string telephone, string rue, string ville, string codePostal, List\u003cProduit\u003e produits) { // Utilisez plutÃ´t un objet } // âœ… MIEUX - Objet de paramÃ¨tres public void CreerCommande(InformationsCommande infos) { // ... } Pas dâ€™effets de bord // âŒ MAUVAIS - Effet de bord cachÃ© private int compteur = 0; // Variable de classe public bool ValiderUtilisateur(Utilisateur user) { compteur++; // âš ï¸ Effet de bord : modifie l'Ã©tat return user.Email != null \u0026\u0026 user.Age \u003e= 18; } // âœ… BON - Fonction pure public bool ValiderUtilisateur(Utilisateur user) { return user.Email != null \u0026\u0026 user.Age \u003e= 18; } ğŸ” Exercice Pratique #2 DÃ©composez cette fonction :\npublic void ProcessOrder(int orderId) { var order = db.Orders.Find(orderId); if (order == null) return; var customer = db.Customers.Find(order.CustomerId); if (customer == null) return; var total = 0m; foreach (var item in order.Items) { total += item.Price * item.Quantity; } var tax = total * 0.15m; var finalTotal = total + tax; if (finalTotal \u003e 1000) { finalTotal *= 0.9m; } order.Total = finalTotal; db.SaveChanges(); SendEmail(customer.Email, $\"Your order total: {finalTotal:C}\"); } Solution :\npublic void TraiterCommande(int idCommande) { var commande = RecupererCommande(idCommande); var client = RecupererClient(commande.ClientId); var montantTotal = CalculerMontantTotal(commande); EnregistrerMontantCommande(commande, montantTotal); EnvoyerEmailConfirmation(client, montantTotal); } private Commande RecupererCommande(int idCommande) { var commande = db.Orders.Find(idCommande); if (commande == null) { throw new CommandeIntrouvableException($\"Commande {idCommande} introuvable\"); } return commande; } private Client RecupererClient(int clientId) { var client = db.Customers.Find(clientId); if (client == null) { throw new ClientIntrouvableException($\"Client {clientId} introuvable\"); } return client; } private decimal CalculerMontantTotal(Commande commande) { var sousTotal = CalculerSousTotal(commande.Items); var montantAvecTaxes = AjouterTaxes(sousTotal); var montantFinal = AppliquerRabaisSiEligible(montantAvecTaxes); return montantFinal; } private decimal CalculerSousTotal(List\u003cItem\u003e items) { return items.Sum(item =\u003e item.Price * item.Quantity); } private decimal AjouterTaxes(decimal montant) { const decimal TauxTaxe = 0.15m; return montant * (1 + TauxTaxe); } private decimal AppliquerRabaisSiEligible(decimal montant) { const decimal SeuilRabais = 1000m; const decimal TauxRabais = 0.10m; if (montant \u003e SeuilRabais) { return montant * (1 - TauxRabais); } return montant; } private void EnregistrerMontantCommande(Commande commande, decimal montant) { commande.Total = montant; db.SaveChanges(); } private void EnvoyerEmailConfirmation(Client client, decimal montant) { var message = $\"Votre commande : {montant:C}\"; SendEmail(client.Email, message); } ğŸ”´ Code Smell #3 : Commentaires Inutiles ou Mensongers Quâ€™est-ce quâ€™un commentaire inutile ? Un commentaire qui :\nDÃ©crit ce que le code fait dÃ©jÃ  clairement Est obsolÃ¨te ou faux Compense un code mal Ã©crit Pourrait Ãªtre remplacÃ© par un bon nom de variable/mÃ©thode RÃ¨gle dâ€™or : Le meilleur commentaire est celui que vous nâ€™avez pas besoin dâ€™Ã©crire\nâŒ Exemple de Code ProblÃ©matique public class GestionnaireUtilisateurs { // Cette mÃ©thode calcule l'Ã¢ge de l'utilisateur public int CalculerAge(DateTime dateNaissance) { // Obtenir la date d'aujourd'hui DateTime aujourd'hui = DateTime.Today; // Calculer l'Ã¢ge int age = aujourd'hui.Year - dateNaissance.Year; // VÃ©rifier si l'anniversaire est passÃ© cette annÃ©e if (dateNaissance.Date \u003e aujourd'hui.AddYears(-age)) { age--; // Soustraire 1 si anniversaire pas encore passÃ© } // Retourner l'Ã¢ge return age; } // TODO: Corriger ce bug (Ã©crit il y a 2 ans...) // HACK: Solution temporaire en attendant le refactoring // NOTE: Ne fonctionne pas pour les clients VIP public decimal CalculerPrix(Produit p, Client c) { decimal prix = p.PrixBase; // Appliquer le rabais if (c.Type == \"VIP\") { prix = prix * 0.8m; // 20% de rabais } else if (c.Type == \"Premium\") { prix = prix * 0.9m; // 10% de rabais } // Sinon, pas de rabais return prix; } // ========================================== // SECTION: Validation // ========================================== // Valide l'email public bool ValiderEmail(string email) { // VÃ©rifier si email est null if (email == null) { return false; // Retourner faux } // VÃ©rifier si email contient @ if (!email.Contains(\"@\")) { return false; // Retourner faux } // L'email est valide return true; // Retourner vrai } /** * Cette mÃ©thode envoie un email Ã  l'utilisateur * ParamÃ¨tres: * - destinataire: l'adresse email du destinataire * - sujet: le sujet de l'email * - corps: le corps du message * Retour: * - bool: true si envoyÃ©, false sinon * Auteur: Jean Dupont * Date: 15/01/2022 * ModifiÃ© par: Marie Martin * Date: 03/05/2023 */ public bool EnvoyerEmail(string destinataire, string sujet, string corps) { // Code d'envoi d'email return true; } // MÃ©thode obsolÃ¨te - NE PLUS UTILISER // Utiliser NouvelleMethode() Ã  la place public void AncienneMethode() { // Cette mÃ©thode ne devrait plus Ãªtre utilisÃ©e // mais on la garde pour compatibilitÃ© } } ğŸ¤” ProblÃ¨mes identifiÃ©s Commentaires redondants : â€œCette mÃ©thode calcule lâ€™Ã¢geâ€ â†’ Le nom le dit dÃ©jÃ  ! Commentaires Ã©vidents : â€œObtenir la date dâ€™aujourdâ€™huiâ€ â†’ Le code est clair TODO/HACK vieux : Jamais rÃ©solus, induisent en erreur Commentaires qui mentent : â€œNe fonctionne pas pour VIPâ€ mais le code le gÃ¨re ! Commentaires de sÃ©paration : Headers inutiles Documentation excessive : Javadoc inutile pour mÃ©thode simple Code commentÃ© : MÃ©thode obsolÃ¨te devrait Ãªtre supprimÃ©e Explications du â€œcommentâ€ : Au lieu du â€œpourquoiâ€ âœ… Code CorrigÃ© (Version Clean Code) public class GestionnaireUtilisateurs { // ========================================== // MÃ‰THODE 1 : Calcul d'Ã¢ge // Aucun commentaire nÃ©cessaire - le code parle de lui-mÃªme // ========================================== public int CalculerAge(DateTime dateNaissance) { var aujourdHui = DateTime.Today; var age = aujourdHui.Year - dateNaissance.Year; if (AnniversairePasEncorePasseCetteAnnee(dateNaissance, aujourdHui, age)) { age--; } return age; } private bool AnniversairePasEncorePasseCetteAnnee(DateTime dateNaissance, DateTime aujourdHui, int age) { return dateNaissance.Date \u003e aujourdHui.AddYears(-age); } // ========================================== // MÃ‰THODE 2 : Calcul de prix // Code auto-documentÃ© avec extraction de mÃ©thodes // ========================================== public decimal CalculerPrix(Produit produit, Client client) { var prixBase = produit.PrixBase; var tauxRabais = ObtenirTauxRabais(client.Type); return AppliquerRabais(prixBase, tauxRabais); } private decimal ObtenirTauxRabais(TypeClient typeClient) { return typeClient switch { TypeClient.VIP =\u003e 0.20m, // 20% pour VIP TypeClient.Premium =\u003e 0.10m, // 10% pour Premium _ =\u003e 0m // Pas de rabais par dÃ©faut }; } private decimal AppliquerRabais(decimal prixBase, decimal tauxRabais) { return prixBase * (1 - tauxRabais); } // ========================================== // MÃ‰THODE 3 : Validation email // Nom de mÃ©thode explicite + extraction de conditions // ========================================== public bool EmailEstValide(string email) { return email != null \u0026\u0026 email.Contains(\"@\"); } // OU version plus robuste public bool EmailEstValide_Version2(string email) { if (EstVideOuNull(email)) { return false; } return ContientArobase(email) \u0026\u0026 ContientPoint(email); } private bool EstVideOuNull(string texte) =\u003e string.IsNullOrWhiteSpace(texte); private bool ContientArobase(string email) =\u003e email.Contains(\"@\"); private bool ContientPoint(string email) =\u003e email.Contains(\".\"); // ========================================== // MÃ‰THODE 4 : Envoi email // Signature claire = documentation suffisante // ========================================== public bool EnvoyerEmail(string destinataire, string sujet, string corps) { // Code d'envoi return true; } // ========================================== // MÃ‰THODE OBSOLÃˆTE : MarquÃ©e avec attribut, pas commentaire // ========================================== [Obsolete(\"Utilisez NouvelleMethode() Ã  la place\", error: true)] public void AncienneMethode() { throw new NotSupportedException(\"Cette mÃ©thode est obsolÃ¨te\"); } public void NouvelleMethode() { // Nouvelle implÃ©mentation } } ğŸ¯ Quand les Commentaires SONT Utiles Certains commentaires sont prÃ©cieux et doivent Ãªtre gardÃ©s :\nâœ… 1. Explication du â€œPOURQUOIâ€ (pas du â€œQUOIâ€) // âœ… BON - Explique une dÃ©cision non-Ã©vidente public decimal CalculerFraisLivraison(decimal montantCommande) { // Nous offrons la livraison gratuite au-dessus de 50$ pour encourager // les achats plus importants et amÃ©liorer la satisfaction client // (dÃ©cision marketing du 15/01/2024) if (montantCommande \u003e= 50) { return 0; } return 5.99m; } // âŒ MAUVAIS - DÃ©crit ce que le code fait dÃ©jÃ  public decimal CalculerFraisLivraison(decimal montantCommande) { // VÃ©rifier si le montant est supÃ©rieur ou Ã©gal Ã  50 if (montantCommande \u003e= 50) { return 0; // Retourner 0 } return 5.99m; // Sinon retourner 5.99 } âœ… 2. Avertissements sur les ConsÃ©quences // âœ… BON - Avertit d'un comportement important public void SupprimerToutesLesDonnees() { // ATTENTION: Cette opÃ©ration est IRRÃ‰VERSIBLE et supprime // toutes les donnÃ©es de production. Ã€ utiliser uniquement // dans le cadre de la procÃ©dure de rÃ©initialisation annuelle. database.DeleteAll(); } âœ… 3. TODO LÃ©gitimes (avec date et contexte) // âœ… BON - TODO avec contexte et Ã©chÃ©ance public class ServicePaiement { // TODO (2024-02-15): Migrer vers la nouvelle API Stripe v3 // DÃ©pendance: Attente de la mise Ã  jour du SDK // Responsable: Ã©quipe-backend@example.com public bool ProcesserPaiement(CarteBancaire carte) { // Utilisation de l'ancienne API (v2) return StripeV2.Charge(carte); } } // âŒ MAUVAIS - TODO vague et sans contexte public bool ProcesserPaiement(CarteBancaire carte) { // TODO: amÃ©liorer return StripeV2.Charge(carte); } âœ… 4. Explication dâ€™un Algorithme Complexe // âœ… BON - Explique un algorithme non-trivial public int CalculerJourPaques(int annee) { // Algorithme de Gauss pour calculer la date de PÃ¢ques // Formule mathÃ©matique complexe basÃ©e sur les cycles lunaires // RÃ©fÃ©rence: https://fr.wikipedia.org/wiki/Calcul_de_la_date_de_PÃ¢ques int a = annee % 19; int b = annee / 100; int c = annee % 100; // ... suite de l'algorithme complexe } âœ… 5. Exigences LÃ©gales ou MÃ©tier // âœ… BON - RÃ©fÃ©rence lÃ©gale importante public decimal CalculerTaxes(decimal montant) { // ConformÃ©ment Ã  la loi C-45 (QuÃ©bec), les taux de taxes sont: // TPS fÃ©dÃ©rale: 5% (depuis 01/01/2008) // TVQ provinciale: 9.975% (depuis 01/01/2013) // Ces taux peuvent changer - voir: revenuquebec.ca const decimal TauxTPS = 0.05m; const decimal TauxTVQ = 0.09975m; return montant * (1 + TauxTPS + TauxTVQ); } ğŸ“Š Guide de DÃ©cision : Commentaire ou Refactoring ? Vous voulez Ã©crire un commentaire ?\râ”‚\râ”œâ”€ DÃ©crit-il ce que le code fait ?\râ”‚ â””â”€ OUI â†’ âŒ Ne commentez pas, amÃ©liorez le code\râ”‚ â””â”€ Renommez variables/mÃ©thodes pour Ãªtre auto-documentÃ©\râ”‚\râ”œâ”€ Explique-t-il POURQUOI (dÃ©cision mÃ©tier, contrainte) ?\râ”‚ â””â”€ OUI â†’ âœ… Commentaire utile, gardez-le\râ”‚\râ”œâ”€ Compense-t-il un code mal Ã©crit ?\râ”‚ â””â”€ OUI â†’ âŒ Ne commentez pas, refactorez\râ”‚\râ”œâ”€ Contient-il un TODO/FIXME ?\râ”‚ â”œâ”€ Avec date, contexte et responsable â†’ âœ… OK\râ”‚ â””â”€ Vague ou ancien â†’ âŒ Supprimez ou corrigez\râ”‚\râ””â”€ Explique-t-il un algorithme complexe ?\râ””â”€ OUI â†’ âœ… Commentaire utile avec rÃ©fÃ©rence ğŸ” Exercice Pratique #3 Nettoyez ce code :\n// Classe pour gÃ©rer les utilisateurs public class UserManager { // Constructeur public UserManager() { // Initialiser } // Cette mÃ©thode vÃ©rifie si l'utilisateur peut se connecter public bool CanLogin(User u) { // VÃ©rifier si l'utilisateur n'est pas null if (u == null) { return false; // Retourner faux } // VÃ©rifier si l'utilisateur est actif if (!u.IsActive) { return false; // Retourner faux } // VÃ©rifier le mot de passe // TODO: ajouter vÃ©rification 2FA if (u.Password == null || u.Password.Length \u003c 8) { return false; // Mot de passe trop court } // Tout est OK return true; // Retourner vrai } // HACK: Temporaire jusqu'Ã  refonte // Ne fonctionne pas pour admin public void DeleteUser(int id) { // Code de suppression } } Solution :\npublic class GestionnaireUtilisateurs { private const int LongueurMinimaleMotDePasse = 8; public bool UtilisateurPeutSeConnecter(Utilisateur utilisateur) { return UtilisateurExiste(utilisateur) \u0026\u0026 UtilisateurEstActif(utilisateur) \u0026\u0026 MotDePasseEstValide(utilisateur.MotDePasse); } private bool UtilisateurExiste(Utilisateur utilisateur) { return utilisateur != null; } private bool UtilisateurEstActif(Utilisateur utilisateur) { return utilisateur.EstActif; } private bool MotDePasseEstValide(string motDePasse) { return !string.IsNullOrEmpty(motDePasse) \u0026\u0026 motDePasse.Length \u003e= LongueurMinimaleMotDePasse; } // TODO (2024-02-15): Ajouter authentification Ã  deux facteurs (2FA) // Ticket: SECURITY-123 // Responsable: Ã©quipe-sÃ©curitÃ©@example.com public void SupprimerUtilisateur(int idUtilisateur) { // ImplÃ©mentation } } ğŸ“ RÃ©sumÃ© de la Semaine Les 3 Code Smells Ã‰tudiÃ©s Noms Non Significatifs\nâŒ Variables dâ€™une lettre, abrÃ©viations obscures âœ… Noms rÃ©vÃ©lant lâ€™intention, prononÃ§ables, cherchables Fonctions Trop Longues\nâŒ Fonction qui fait tout, 100+ lignes âœ… Petites fonctions (5-20 lignes), une responsabilitÃ©, un niveau dâ€™abstraction Commentaires Inutiles\nâŒ Commentaires redondants, obsolÃ¨tes, compensant du mauvais code âœ… Code auto-documentÃ©, commentaires expliquant le POURQUOI Citations Ã  Retenir â€œLe code propre est simple et direct. Il se lit comme une prose bien Ã©crite.â€ â€” Grady Booch\nâ€œUn commentaire mensonger est pire que pas de commentaire du tout.â€ â€” Robert C. Martin\nChecklist Avant de Commiter du Code Mes variables ont des noms significatifs et rÃ©vÃ¨lent leur intention Mes mÃ©thodes font UNE SEULE chose Mes mÃ©thodes ont moins de 20 lignes Mes mÃ©thodes ont 3 paramÃ¨tres ou moins Jâ€™ai Ã©liminÃ© les commentaires qui dÃ©crivent ce que le code fait Mes commentaires (sâ€™il y en a) expliquent le POURQUOI Mon code se lit comme une histoire claire ğŸ¯ DÃ©fi de la Semaine Trouvez dans votre propre code :\n3 variables avec des noms non significatifs â†’ Renommez-les 1 fonction longue (\u003e30 lignes) â†’ DÃ©composez-la 5 commentaires inutiles â†’ Supprimez-les en rendant le code auto-documentÃ© Partagez vos avant/aprÃ¨s avec la classe la semaine prochaine !\nğŸ”œ AperÃ§u Semaine Prochaine La semaine prochaine, nous aborderons :\nCode Duplication (DRY Principle) Classes trop grandes Couplage fort vs Couplage faible â€œLaissez le code plus propre que vous ne lâ€™avez trouvÃ©.â€ â€” RÃ¨gle du Boy Scout",
    "description": "Noms Significatifs et Fonctions Claires ğŸ“‹ Objectifs de cette semaine Apprendre Ã  :\nIdentifier et corriger les noms non significatifs ReconnaÃ®tre et rÃ©soudre les fonctions trop longues Ã‰liminer les commentaires inutiles en Ã©crivant du code auto-explicatif ğŸ’¡ Citation de la semaine â€œLe code est lu beaucoup plus souvent quâ€™il nâ€™est Ã©crit. Facilitez la lecture, pas lâ€™Ã©criture.â€",
    "tags": [],
    "title": "Rubrique  - Semaine 2",
    "uri": "/420-413/rubrique/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/420-413/categories/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Plans de cours ğŸ“‹ Samuel FostinÃ© : Plan de cours\nHoraire et disponibilitÃ©s des enseignants âœ”ï¸ Samuel FostinÃ© : Lien vers mon horaire et mes disponibilitÃ©s\nSamuel FostinÃ© Nom de lâ€™Ã©valuation PondÃ©ration Semaine de lâ€™Ã©valuation 10 quiz (8 meilleures notes) 15 % Semaine 2 Ã  14 Examen 1 20% Semaine 4 Examen 2 25 % Semaine 12 Projet remise 1 5 % Semaine 6 Projet remise 2 5 % Semaine 8 Projet remise 3 5 % Semaine 10 Projet remise 4 5 % Semaine 13 Projet remise final 20 % Semaine 15",
    "description": "Plans de cours ğŸ“‹ Samuel FostinÃ© : Plan de cours\nHoraire et disponibilitÃ©s des enseignants âœ”ï¸ Samuel FostinÃ© : Lien vers mon horaire et mes disponibilitÃ©s\nSamuel FostinÃ© Nom de lâ€™Ã©valuation PondÃ©ration Semaine de lâ€™Ã©valuation 10 quiz (8 meilleures notes) 15 % Semaine 2 Ã  14 Examen 1 20% Semaine 4 Examen 2 25 % Semaine 12 Projet remise 1 5 % Semaine 6 Projet remise 2 5 % Semaine 8 Projet remise 3 5 % Semaine 10 Projet remise 4 5 % Semaine 13 Projet remise final 20 % Semaine 15",
    "tags": [],
    "title": "DÃ©veloppement d'applications pour entreprise",
    "uri": "/420-413/index.html"
  },
  {
    "breadcrumb": "DÃ©veloppement d'applications pour entreprise",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/420-413/tags/index.html"
  }
]
